// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package twitch

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

// An action (and metadata about the action) which a user or session is performing.
type Activity interface {
	IsActivity()
}

// BitsOffer is a way to obtain more bits.
type BitsOffer interface {
	IsBitsOffer()
}

// Details of the effect.
type ChallengeEffectDetails interface {
	IsChallengeEffectDetails()
}

// Details of the effect settings.
type ChallengeEffectSettingsDetails interface {
	IsChallengeEffectSettingsDetails()
}

// A challenge to which users can contribute bits.
type ChannelChallenge interface {
	IsChannelChallenge()
}

// An entry of a moderation action performed on a channel.
type ChannelModerationActionEntry interface {
	IsChannelModerationActionEntry()
}

// An interface to represent a claimable thing.
type Claimable interface {
	IsClaimable()
}

// The types of objects that can be contained in a collection.
type CollectionItem interface {
	IsCollectionItem()
}

// A CompetitionParticipant is either a CompetitionPlayer who is playing solo or a CompetitionTeam who plays as a team.
type CompetitionParticipant interface {
	IsCompetitionParticipant()
}

// An action (and metadata about the action) which occurred for a channel's Dashboard Activity Feed.
type DashboardActivityFeedActivity interface {
	IsDashboardActivityFeedActivity()
}

// A Directory is a container of content – Streams, Videos, and Clips – on Twitch.
type Directory interface {
	IsDirectory()
}

// An interface to handle shared Drop data. The `Drop` type is already in use (although deprecated) so we can't use that name.
type DropType interface {
	IsDropType()
}

// ExtensionView is the interface which every anchor-specific extension view extends from.
type ExtensionView interface {
	IsExtensionView()
}

type FeaturedItemContent interface {
	IsFeaturedItemContent()
}

type FeedEmbed interface {
	IsFeedEmbed()
}

// FeedItemContent is the supported content types that may appear in a feed.
type FeedItemContent interface {
	IsFeedItemContent()
}

// The details of different formats. Currently there is only 1 detail type.
type FormatTypeDetails interface {
	IsFormatTypeDetails()
}

// FragmentContent contains the parse content of a fragment, and can be an emote or a mention.
// NOTE: should have been called RoomMessageFragmentContent.
type FragmentContent interface {
	IsFragmentContent()
}

// The friend-type relationship between the authenticated user and another user.
//
// If this field is a FriendEdge, the authenticated user and the other user are Friends.
//
// If it is an IncomingFriendRequestEdge, the other user has an open friend request with authenticated user.
//
// If it is an OutgoingFriendRequestEdge, the authenticated user has an open friend request with the other user.
type FriendRelationship interface {
	IsFriendRelationship()
}

// The hype train reward interface, which has to implement an identifier and the hype train reward type.
type HypeTrainReward interface {
	IsHypeTrainReward()
}

// InterruptScheduleError is a wrapper for error associated with the CreateScheduleSegment mutation.
type InterruptScheduleError interface {
	IsInterruptScheduleError()
}

// ModLogsMessageResult defines the types of entries that appear as mod log messages: Mod Logs (Chat) Messages and Targeted Mod Actions.
type ModLogsMessageResult interface {
	IsModLogsMessageResult()
}

// OEmbed is a universal spec converted to GraphQL from http://oembed.com/.
type OEmbed interface {
	IsOEmbed()
}

// Extra onsite notification content.
type OnsiteNotificationContent interface {
	IsOnsiteNotificationContent()
}

// Panel is information about a single info panel for a channel.
type Panel interface {
	IsPanel()
}

// Content metadata for either live stream or list of vod.
type PersonalSectionChannelContent interface {
	IsPersonalSectionChannelContent()
}

// The types of content(channel, category ...) that can be contained in a PersonalSectionItem.
type PersonalSectionItem interface {
	IsPersonalSectionItem()
}

// The content of a personal section title token.
type PersonalSectionTitleToken interface {
	IsPersonalSectionTitleToken()
}

// Stream Platform.
type Platform interface {
	IsPlatform()
}

// TODO: Add events.
type PostEmbed interface {
	IsPostEmbed()
}

// Someone or something that is capable of performing actions on a Prediction Event.
type PredictionEventActor interface {
	IsPredictionEventActor()
}

// DEPRECATED.
// The types of objects that can be contained in a premiere.
type PremiereItem interface {
	IsPremiereItem()
}

// A benefit the user receives when purchasing a product from the product catalog.
type ProductCatalogBenefit interface {
	IsProductCatalogBenefit()
}

// A product appearing in the product catalog.
type ProductCatalogItem interface {
	IsProductCatalogItem()
}

// Quick action items can be either a quick action or a folder of quick actions.
type QuickActionLayoutItem interface {
	IsQuickActionLayoutItem()
}

// The types of radio content that can be requested (e.g., playlists, stations, tracks, etc).
type RadioContentItem interface {
	IsRadioContentItem()
}

type ReactableContent interface {
	IsReactableContent()
}

// Feedback target.
type RecommendationFeedbackContent interface {
	IsRecommendationFeedbackContent()
}

type RecommendedStream interface {
	IsRecommendedStream()
}

type RoomMessageItem interface {
	IsRoomMessageItem()
}

// The types with additional content in a search suggestion.
type SearchSuggestionContent interface {
	IsSearchSuggestionContent()
}

// An interface to represent the logged in user's relationship to the claimable.
type SelfClaimEdge interface {
	IsSelfClaimEdge()
}

type ShareTarget interface {
	IsShareTarget()
}

// The content to render in a shelf.
type ShelfContent interface {
	IsShelfContent()
}

// Metadata used to render the shelf title.
type ShelfTitleContext interface {
	IsShelfTitleContext()
}

// All of the different content types that make up "short form video".
type ShortVideoContent interface {
	IsShortVideoContent()
}

// StreamKeyResult represents StreamKey or StreamKeyError.
type StreamKeyResult interface {
	IsStreamKeyResult()
}

// The set of results that can occur when resolving a subscription product.
type SubscriptionProductsResult interface {
	IsSubscriptionProductsResult()
}

// The content that are possibly return for tagging mutation payload.
type TaggedContent interface {
	IsTaggedContent()
}

// The content of a shelf title token.
type TitleTokenNode interface {
	IsTitleTokenNode()
}

// IDs used to determine the context(s) by which content was determined for a given VerticalSubDirectory.
type VerticalContentContext interface {
	IsVerticalContentContext()
}

// A union of the fields that are specific to individual moments, such as Game Mode
// inside Hearthstone VCA data.
type VideoMomentDetails interface {
	IsVideoMomentDetails()
}

// The item to render in a video shelf.
type VideoShelfItem interface {
	IsVideoShelfItem()
}

// Additional information about content.
type WatchPartyItemDetails interface {
	IsWatchPartyItemDetails()
}

// Amazon Digital Ad Service Properties.
type ADASProperties struct {
	// The media partner that should be used for the ad break.
	Partner *string `json:"partner"`
	// The id for selecting the amazon ad campaign or program.
	ProgramID *string `json:"programID"`
}

type AcceptFriendRequestInput struct {
	// The authenticated user will accept the friend request sent by the user with an ID equal to targetID.
	TargetID string `json:"targetID"`
}

type AcceptFriendRequestPayload struct {
	// The user whose friend request was just accepted.
	User *User `json:"user"`
}

// Error associated with mutation AcceptOrganizationInvite.
type AcceptOrganizationInviteError struct {
	// Error code.
	Code AcceptOrganizationInviteErrorCode `json:"code"`
}

// Input to the AcceptOrganiztaionInvite mutation.
type AcceptOrganizationInviteInput struct {
	// First name to the user accepting the invite.
	FirstName string `json:"firstName"`
	// Last name of the user accepting the invite.
	LastName string `json:"lastName"`
	// ID of the invite to accept.
	OrganizationInviteID string `json:"organizationInviteID"`
	// Job title the user has in the inviting organization.
	Title string `json:"title"`
}

// Output from the AcceptOrganizationInvite mutation.
type AcceptOrganizationInvitePayload struct {
	// The possible error returned from service.
	Error *AcceptOrganizationInviteError `json:"error"`
}

// AcceptProgramAgreementInput is the input required when accepting a program agreement.
type AcceptProgramAgreementInput struct {
	// TargetUserID is the ID of the user whose program agreement will be accepted.
	TargetUserID string `json:"targetUserID"`
	// Agreement type being accepted for payout onboarding.
	Type PayoutOnboardingCategory `json:"type"`
	// Version of agreement (e.g. "v1").
	Version string `json:"version"`
}

// AcceptProgramAgreementPayload is the payload returned after accepting a program agreement.
type AcceptProgramAgreementPayload struct {
	// Describes error that occured while accepting a program agreement.
	Error *AcceptProgramAgreementError `json:"error"`
	// New workflow state.
	Workflow *PayoutOnboardingWorkflow `json:"workflow"`
}

// Errors from acceptSquadStreamInvitation mutation.
type AcceptSquadStreamInvitationError struct {
	// Error from request to accept invitation.
	Code AcceptSquadStreamInvitationErrorCode `json:"code"`
}

// Inputs to the acceptSquadStreamInvitation mutation.
type AcceptSquadStreamInvitationInput struct {
	// ID of the invitation to be accepted.
	InvitationID string `json:"invitationID"`
}

// Outputs from the acceptSquadStreamInvitation mutation.
type AcceptSquadStreamInvitationPayload struct {
	// Error from mutation if exists.
	Error *AcceptSquadStreamInvitationError `json:"error"`
	// The accepted invitation.
	Invitation *SquadStreamInvitation `json:"invitation"`
}

// The information about all of a user's connected accounts.
type AccountConnectionSet struct {
	// Connection information about a user's Blizzard account.
	Blizzard *UserBlizzardConnectionLink `json:"blizzard"`
	// Connection infromation about a user's Facebook account.
	Facebook *UserFacebookConnectionLink `json:"facebook"`
	// Whether or not the user has a linked amazon account.
	HasConnectedAmazon *bool `json:"hasConnectedAmazon"`
	// Connection information about a user's Riot account.
	Riot *UserRiotConnectionLink `json:"riot"`
	// Connection information about a user's Steam account.
	Steam *UserSteamConnectionLink `json:"steam"`
	// Connection information about a user's Twitter account.
	Twitter *UserTwitterConnectionLink `json:"twitter"`
	// Connection information about a user's Youtube account.
	Youtube *UserYoutubeConnectionLink `json:"youtube"`
}

// An error returned from the acknowledgePredictionResult mutation.
type AcknowledgePredictionResultError struct {
	// Code describing the error.
	Code AcknowledgePredictionResultErrorCode `json:"code"`
}

// Acknowledge the results of a Prediction.
type AcknowledgePredictionResultInput struct {
	// The Prediction ID.
	ID string `json:"id"`
}

// Payload for acknowledging the results of a Prediction.
type AcknowledgePredictionResultPayload struct {
	// If present, there was an error with the request.
	Error *AcknowledgePredictionResultError `json:"error"`
	// The acknowledgged Prediction.
	Prediction *Prediction `json:"prediction"`
}

// AcknowledgeSubscriptionStateInput updates the state of the given subscription to aknowledged.
type AcknowledgeSubscriptionStateInput struct {
	// ID of the subscription being updated.
	SubscriptionID string `json:"subscriptionID"`
}

// AcknowledgeSubscriptionStatePayload returns the state of the subscription.
type AcknowledgeSubscriptionStatePayload struct {
	// The current state of the subscription. One of "active", "will_not_renew", or "canceled".
	State *UnacknowledgedSubscriptionEventState `json:"state"`
}

// Required input to acknowledge an unban request on a channel.
type AcknowledgeUnbanRequestInput struct {
	// ID of the unban request to be acknowledged.
	ID string `json:"id"`
}

// Result of acknowledging an unban request.
type AcknowledgeUnbanRequestPayload struct {
	// Used for errors arising from acknowledging the unban request.
	Error *UnbanRequestError `json:"error"`
	// The acknowledged unban request.
	UnbanRequest *UnbanRequest `json:"unbanRequest"`
}

// The input to be provided to the activateExtension mutation.
type ActivateExtensionInput struct {
	// The anchor the extension is getting activated into.
	Anchor ExtensionAnchor `json:"anchor"`
	// The composite ID of an extension installation <extensionID:version:channelID>.
	ExtensionInstallationID string `json:"extensionInstallationID"`
	// The slot the extension is getting activated into.
	Slot string `json:"slot"`
}

// The result of an activateExtension mutation.
type ActivateExtensionPayload struct {
	// The resulting list of installed extensions after the activation.
	InstalledExtensions []*ExtensionInstallation `json:"installedExtensions"`
}

// ActivityInput represents what the user is doing right now.
//
// If type is WATCHING, userID must be supplied.
//
// If type is PLAYING, gameID must be supplied.
type ActivityInput struct {
	GameID *string       `json:"gameID"`
	Type   *ActivityType `json:"type"`
	UserID *string       `json:"userID"`
}

// The context returned for the current ad request.
type AdContext struct {
	// The decline status for this ad request.
	DeclineState *AdContextDeclineState `json:"declineState"`
	// The id of the ad session this context applies to.
	ID string `json:"id"`
	// The RAd service token used to validate subsequent ad event mutations.
	RadToken string `json:"radToken"`
}

// The decline state for the context.
type AdContextDeclineState struct {
	// The reason the ad request was declined if it was declined.
	Reason *string `json:"reason"`
	// Whether or not the client will request an ad.
	ShouldDecline bool `json:"shouldDecline"`
}

// Advertising creative.
type AdCreative struct {
	// The AdCreative's unique identifier.
	ID string `json:"id"`
	// Integrated loudness value for this AdCreative.
	IntegratedLoudness *float64 `json:"integratedLoudness"`
}

// A vote an ad poll and associated information.
type AdPollVote struct {
	// Id of the choice that was voted for.
	ChoiceID string `json:"choiceID"`
	// id of the vote in the poll.
	ID string `json:"id"`
	// Id of the poll this voter voted in.
	PollID string `json:"pollID"`
	// Id of the voter in the poll.
	UserID string `json:"userID"`
}

// Ad Properties is an object that defines ad properties for a channel.
type AdProperties struct {
	// Deprecated.
	AdServer *string `json:"adServer"`
	// Which adserver to send requests to.
	AdServerDefault *string `json:"adServerDefault"`
	// Amazon Digital Ad Service (ADAS) specific Properties for this channel. Properties should only be nested if it is ADAS specific.
	AdasProperties *ADASProperties `json:"adasProperties"`
	// Which ids are costreamers for this channel.
	Costreamers []*User `json:"costreamers"`
	// Contains ad density information for channel ads management.
	Density *Density `json:"density"`
	// Contains properties used by channel's disable prerolls feature.
	DisablePrerollsAbility *DisablePrerollsAbility `json:"disablePrerollsAbility"`
	// Get the ad experiment treatment group for a specified experiment bucket.
	ExperimentTreatment *string `json:"experimentTreatment"`
	// How often ad breaks can be run on this channel.
	Frequency *int `json:"frequency"`
	// If postrolls are disabled on this channel.
	HasPostrollsDisabled *bool `json:"hasPostrollsDisabled"`
	// If prerolls are disabled on this channel.
	HasPrerollsDisabled *bool `json:"hasPrerollsDisabled"`
	// If Turbo benefit is disabled on this channel.
	HasTurboDisabled *bool `json:"hasTurboDisabled"`
	// If vod ads are enabled on this channel.
	HasVodAdsEnabled *bool `json:"hasVodAdsEnabled"`
	// If multiplayer ads are enabled for subscribers on this channel.
	IsMultiplayerAdsForSubsEnabled *bool `json:"isMultiplayerAdsForSubsEnabled"`
	// A bool that represents a streamer's eligibility to run a picture by picture ad.
	IsPictureByPictureAdEligible *bool `json:"isPictureByPictureAdEligible"`
	// Maximum length for an ad break on this channel.
	MaxAdBreakLength *int `json:"maxAdBreakLength"`
	// Current multiplayer ad offers on the channel.
	MultiplayerAdOffers []*MultiplayerAdOffer `json:"multiplayerAdOffers"`
	// The stream has the required age gate enabled if greater than 0.
	RequiredAge *int `json:"requiredAge"`
	// Tracking pixels that channel pages should fire at certain intervals.
	TrackingPixels []*TrackingPixel `json:"trackingPixels"`
	// Setting for vod archive midrolls on this channel. Can be 'broadcaster', 'inserted', or 'off'.
	VodArchiveMidrolls *string `json:"vodArchiveMidrolls"`
	// Ad break length for VOD archive midrolls on this channel.
	VodArchiveMidrollsBreakLength *int `json:"vodArchiveMidrollsBreakLength"`
	// Frequency for VOD archive midrolls on this channel.
	VodArchiveMidrollsFrequency *int `json:"vodArchiveMidrollsFrequency"`
}

// The context of the Client when the ad request is about to be made.
type AdRequestClientContext struct {
	// If the client is in audio only mode.
	IsAudioOnly bool `json:"isAudioOnly"`
	// If the client is in mini theater mode.
	IsMiniTheater bool `json:"isMiniTheater"`
	// If the client is in Picture in Picture mode.
	IsPip bool `json:"isPIP"`
	// If the client is broadcasting to an external device (i.e. Chromecast, Airplay).
	IsUsingExternalPlayback bool `json:"isUsingExternalPlayback"`
}

// The context of an upcoming ad request.
type AdRequestContext struct {
	// The ID generated for the ad Session.
	AdSessionID string `json:"adSessionID"`
	// The context of the client at the time the ad is requested.
	ClientContext *AdRequestClientContext `json:"clientContext"`
	// The commercial break ID of a channel wide midroll.
	CommercialID *string `json:"commercialID"`
	// The duration of the ad break in seconds.
	Duration int `json:"duration"`
	// If the requested ad is a viewer level midroll.
	IsVlm *bool `json:"isVLM"`
	// The context of the player at the time the ad is requested.
	PlayerContext *AdRequestPlayerContext `json:"playerContext"`
	// The type of ad request being made.
	RollType AdrollType `json:"rollType"`
}

// The context of the Player when the ad request is about to be made.
type AdRequestPlayerContext struct {
	// The type of content being watched.
	ContentType AdRequestContentType `json:"contentType"`
	// If the session was initiated by playing automatically.
	IsAutoPlay bool `json:"isAutoPlay"`
	// The signature for the access token for the current video session.
	NauthSig string `json:"nauthSig"`
	// The access token for the current video session.
	NauthToken string `json:"nauthToken"`
	// The ID for the current video session.
	VideoSessionID *string `json:"videoSessionID"`
}

// AdSession is the response object from an Ad Request.
type AdSession struct {
	// id is the id of the ad.
	ID string `json:"id"`
	// lengthSeconds is the length of the ad being requested in seconds.
	LengthSeconds int `json:"lengthSeconds"`
	// retryAfterSeconds is the amount of time in seconds remaining for a user to run another ad.
	RetryAfterSeconds int `json:"retryAfterSeconds"`
}

// Defines ads management attributes for channel.
type AdSlot struct {
	// Duration of Ads that will run.
	DurationSeconds int `json:"durationSeconds"`
	// Time when Ad will run.
	RunAtTime time.Time `json:"runAtTime"`
}

// AddAutohostChannelsInput append channelIDs to a user's list to autohost.
type AddAutohostChannelsInput struct {
	// ChannelIDs that will be added to the list to autohost.
	ChannelIDs []string `json:"channelIDs"`
	// UserID to update autohost list for.
	UserID string `json:"userID"`
}

// AddAutohostChannelsPayload returns the user whose autohostChannels field had been updated.
type AddAutohostChannelsPayload struct {
	// User whose autohostChannels field had been updated.
	User *User `json:"user"`
}

type AddBrowserPushSubscriptionInput struct {
	// An authentication secret. It must be a non-blank string.
	Auth string `json:"auth"`
	// A custom URL pointing to a push server, which can be used to send a push message to the
	// particular service worker instance that subscribed to the push service. It must be a
	// non-blank string.
	Endpoint string `json:"endpoint"`
	// An Elliptic curve Diffie–Hellman public key on the P-256 curve. It must be a non-blank string.
	P256dh string `json:"p256DH"`
}

type AddBrowserPushSubscriptionPayload struct {
	// The opaque ID of the push subscription. The entire push subscription is not returned because
	// there is no product use for it. Also, there is no existing query or mutation that can use this ID,
	// but it could be used for future functionality.
	BrowserPushSubscriptionID *string `json:"browserPushSubscriptionID"`
}

// AddChannelBlockedTermInput takes in the channel, phrases, and if the term should be editable by mods.
type AddChannelBlockedTermInput struct {
	// channelID is the channelID owner of terms.
	ChannelID string `json:"channelID"`
	// isModEditable is if the term is viewable or editable by mods.
	IsModEditable bool `json:"isModEditable"`
	// phrases is the strings that are blocked.
	Phrases []string `json:"phrases"`
}

// The returned data from the mutation.
type AddChannelBlockedTermPayload struct {
	// The time term was added.
	AddedAt *time.Time `json:"addedAt"`
	// Mutation error caused by the user input.
	Error *AddChannelBlockedTermError `json:"error"`
	// The phrases that were added.
	Phrases []string `json:"phrases"`
}

// AddChannelPermittedTermInput takes in the channel, phrases, and if the term should be editable by mods.
type AddChannelPermittedTermInput struct {
	// channelID is the owner of the permitted terms.
	ChannelID string `json:"channelID"`
	// phrases are the strings that are permitted in a channel.
	Phrases []string `json:"phrases"`
}

// The returned payload from the mutation.
type AddChannelPermittedTermPayload struct {
	// The time term was added.
	AddedAt *time.Time `json:"addedAt"`
	// Mutation error caused by the user input.
	Error *AddChannelPermittedTermError `json:"error"`
	// The phrases that were added.
	Phrases []string `json:"phrases"`
}

// AddCollectionItemInput accepts a collectionID and item ID and parameters to add the item to a collection.
type AddCollectionItemInput struct {
	// The id of the collection.
	CollectionID string `json:"collectionID"`
	// The id of the item of which will be added to the collection.
	ItemID string `json:"itemID"`
	// The type of item ie. video.
	ItemType string `json:"itemType"`
}

// The response from adding an item to a collection.
type AddCollectionItemPayload struct {
	// The newly updated collection.
	Collection *Collection `json:"collection"`
}

// Add a Phase to a Competition.
type AddCompetitionPhaseInput struct {
	// Unique Competition ID.
	CompetitionID string `json:"competitionID"`
}

// Data that was mutated after the Phase was created.
type AddCompetitionPhasePayload struct {
	// The competition is returned with any side effects adding a phase has caused.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// Add a User as a player to a Competition.
type AddCompetitionPlayerInput struct {
	// Unique Competition ID.
	CompetitionID string `json:"competitionID"`
	// The player's Discord username.
	DiscordUsername *string `json:"discordUsername"`
	// The player's in-game username.
	InGameUsername *string `json:"inGameUsername"`
	// The state the player in. Defaults to INVITED if not specified.
	State *CompetitionPlayerState `json:"state"`
	// Twitch user id of the player.
	UserID string `json:"userID"`
}

// Data that was mutated after the player was created.
type AddCompetitionPlayerPayload struct {
	// The new state of competition after adding a competition player to the competition.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// Inputs adding a competition team to a competition.
type AddCompetitionTeamInput struct {
	// ID of the competition team captain.
	CaptainID *string `json:"captainID"`
	// ID of the competition.
	CompetitionID string `json:"competitionID"`
	// The user ids of the team members.
	Members []string `json:"members"`
	// The name of the team.
	Name string `json:"name"`
}

// AddCompetitionTeamPayload is the success response adding a competition team to the competition.
type AddCompetitionTeamPayload struct {
	// The new state of competition after adding a competition team to the competition.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// AddDeviceTokenInput accepts a token and other parameters to add a device token to a given user.
type AddDeviceTokenInput struct {
	// App build number of the current device.
	AppBuild *string `json:"appBuild"`
	// Unique identifier of the current device.
	// Note: deprecated field -- the deviceID now comess of the X-Device-Id header...
	DeviceID *string `json:"deviceID"`
	// Arbitrary name associated with the device.
	DeviceName *string `json:"deviceName"`
	// The ID of the new token.
	DeviceToken string `json:"deviceToken"`
	// Notification capabilities of the current device.
	NotificationCapabilitiesTypes []string `json:"notificationCapabilitiesTypes"`
	// Onsite notification capabilities of the current device.
	OnsiteCapabilitiesTypes []string `json:"onsiteCapabilitiesTypes"`
	// The platform the token is associated with, i.e. 'android' or 'ios'.
	Platform string `json:"platform"`
	// ID for the user associated with the new device token.
	// Note: deprecated field -- the userID now comes off the authenticated user.
	UserID *string `json:"userID"`
}

// The response from adding a push notification token to a user.
type AddDeviceTokenPayload struct {
	// The ID of the new token.
	DeviceToken string `json:"deviceToken"`
}

// AddDropToCampaignInput has fields required to create a drop within a campaign.
type AddDropToCampaignInput struct {
	// The campaign this drop belongs to.
	CampaignID string `json:"campaignID"`
	// The type of rule defining what needs to happen to trigger this drop.
	DropRuleType DropRuleType `json:"dropRuleType"`
	// The date at which this drop can no longer occur. Default to campaign endDate if not provided.
	EndAt *time.Time `json:"endAt"`
	// The friendly name of this drop.
	Name string `json:"name"`
	// The date at which this drop can start to occur. Default to campaign startDate if not provided.
	StartAt *time.Time `json:"startAt"`
}

// AddDropToCampaignPayload returns the result of the creation.
type AddDropToCampaignPayload struct {
	// Returns the newly created drop.
	Drop DropType `json:"drop"`
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// AddEditorError contains details about a client error that occurred.
type AddEditorError struct {
	// The type of error that occurred when adding an editor.
	Code AddEditorErrorCode `json:"code"`
}

// AddEditorInput contains the parameters to add an editor.
type AddEditorInput struct {
	// The channel for which the target user will become an editor.
	ChannelID string `json:"channelID"`
	// The ID of the user who will become an editor.
	// Either targetUserID or targetUserLogin must be provided.
	TargetUserID *string `json:"targetUserID"`
	// The login of the user who will become an editor.
	// Either targetUserID or targetUserLogin must be provided.
	TargetUserLogin *string `json:"targetUserLogin"`
}

// AddEditorPayload is the response after attemping to add an editor.
type AddEditorPayload struct {
	// The channel for which the target user will become an editor.
	Channel *User `json:"channel"`
	// The client error that has occurred.
	// Null if the operation is successful.
	Error *AddEditorError `json:"error"`
	// The user who became an editor.
	TargetUser *User `json:"targetUser"`
}

// Error from a failed recent play mutation.
type AddRadioRecentlyPlayedError struct {
	// Mutation error code.
	Code AddRadioRecentlyPlayedErrorCode `json:"code"`
}

// AddRadioRecentlyPlayedInput contains the parameters to register a play start.
type AddRadioRecentlyPlayedInput struct {
	// The type of content the ID maps to.
	ContentType RadioRecentlyPlayedType `json:"contentType"`
	// The ID of the recently played item.
	ID string `json:"id"`
}

// Response from registering a recent play.
type AddRadioRecentlyPlayedPayload struct {
	// Error code.
	Error *AddRadioRecentlyPlayedError `json:"error"`
	// The added/updated recently played item.
	Recent *RadioRecentlyPlayed `json:"recent"`
}

type AddReactionInput struct {
	EmoteID  string `json:"emoteID"`
	EntityID string `json:"entityID"`
}

type AddReactionPayload struct {
	Content ReactableContent `json:"content"`
}

// Data required to add recommendation feedback.
type AddRecommendationFeedbackInput struct {
	// Reason for the feedback (ie. Not interested, offensive, etc).
	Category RecommendationFeedbackCategory `json:"category"`
	// The id of the item (channelID, gameID, etc).
	ItemID string `json:"itemID"`
	// One of CHANNEL, GAME, SHELF, VOD.
	ItemType RecommendationFeedbackType `json:"itemType"`
	// The page this event was fired from.
	SourceItemPage string `json:"sourceItemPage"`
	// The unique id given to this request.
	SourceItemRequestID string `json:"sourceItemRequestID"`
	// The tracking id of the shelf / shelf card.
	SourceItemTrackingID string `json:"sourceItemTrackingID"`
}

// Returns the created feedback item back to the client.
type AddRecommendationFeedbackPayload struct {
	// Feedback item.
	RecommendationFeedback *RecommendationFeedback `json:"recommendationFeedback"`
}

// Error that may be returned by the AddStreamAuthorizedUser mutation.
type AddStreamAuthorizedUserError struct {
	// Type of mutation error.
	Code AddStreamAuthorizedUserErrorCode `json:"code"`
}

// AddStreamAuthorizedUserInput contains the channelID for the broadcaster and the authorized userID.
type AddStreamAuthorizedUserInput struct {
	// authorizedUserID for an authorized user who is allow to stream on behalf of broadcaster.
	AuthorizedUserID string `json:"authorizedUserID"`
	// channelID of the broadcaster.
	ChannelID string `json:"channelID"`
}

// AddStreamAuthorizedUserPayload contains the VideoStreamSettings with updated authorized users.
type AddStreamAuthorizedUserPayload struct {
	// The updated channel of broadcaster.
	Channel *Channel `json:"channel"`
	// Error code.
	Error *AddStreamAuthorizedUserError `json:"error"`
}

// Grouping of referral sources with name and count -- e.g. ("UK", 1437).
type AggregatedReferrals struct {
	// Count of the referrals from the named source (1437).
	Count int `json:"count"`
	// Name of the referral source ("UK").
	Name string `json:"name"`
}

// Error from the mutation.
type AllocateKeysForBountyError struct {
	// Error code from the mutation.
	Code AllocateKeysForBountyErrorCode `json:"code"`
}

// Input required to allocate keys for the bounty.
type AllocateKeysForBountyInput struct {
	// Unique Identifier for the bounty.
	BountyID string `json:"bountyID"`
	// UserID that is allocating keys for the bounty.
	UserID string `json:"userID"`
}

// Payload from the mutation.
type AllocateKeysForBountyPayload struct {
	// The bounty with allocated keys.
	Bounty *Bounty `json:"bounty"`
	// The possible error returned from the service.
	Error *AllocateKeysForBountyError `json:"error"`
}

type AllowRejectedChatMessageInput struct {
	ID string `json:"id"`
}

type AllowRejectedChatMessagePayload struct {
	Message *RejectedChatMessage `json:"message"`
}

// Input to the allowRejectedCheer mutation.
type AllowRejectedCheerInput struct {
	// Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
	// The server will reject any request with an ID that has already been used.
	ID string `json:"id"`
	// ID of the user whose message is automodded.
	TargetUserID string `json:"targetUserID"`
}

// Payload from the allowRejectedCheer mutation.
type AllowRejectedCheerPayload struct {
	// Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
	// The server will reject any request with an ID that has already been used.
	ID string `json:"id"`
}

// A mapping of extension type to list of activation configs.
type ApplyExtensionActivationsInput struct {
	// A list of activations to apply to the given channelID.
	Activations []*ExtensionActivationInput `json:"activations"`
	// The ID of the channel the activations are being performed on.
	ChannelID string `json:"channelID"`
}

// A list of all installed extensions on the channel after an applyExtensionActivations mutation.
type ApplyExtensionActivationsPayload struct {
	// The list of all installed extensions on the channel after an applyExtensionActivations mutation
	// with their new activation state.
	InstalledExtensions []*ExtensionInstallation `json:"installedExtensions"`
}

// Required input to approve an unban request on a channel.
type ApproveUnbanRequestInput struct {
	// ID of the unban request to be resolved.
	ID string `json:"id"`
	// Optional message from the resolver to be shown to the unban requester.
	ResolverMessage *string `json:"resolverMessage"`
}

// Result of approving an unban request.
type ApproveUnbanRequestPayload struct {
	// Used for errors arising from resolving unban request.
	Error *UnbanRequestError `json:"error"`
	// The resolved unban request.
	UnbanRequest *UnbanRequest `json:"unbanRequest"`
}

// ArchiveChanletInput archives a chanlet by chanlet ID.
type ArchiveChanletInput struct {
	// The ID of the chanlet being archived.
	ChanletID string `json:"chanletID"`
}

// ArchiveChanletPayload returns the Chanlet that was archived.
type ArchiveChanletPayload struct {
	// The chanlet archived.
	Chanlet *Channel `json:"chanlet"`
}

// Archive community goal error.
type ArchiveCommunityPointsCommunityGoalError struct {
	// The error code.
	Code ArchiveCommunityPointsCommunityGoalErrorCode `json:"code"`
}

// Archive community goal input.
type ArchiveCommunityPointsCommunityGoalInput struct {
	// The channel.
	ChannelID string `json:"channelID"`
	// The community goal.
	GoalID string `json:"goalID"`
}

// Archive community goal payload.
type ArchiveCommunityPointsCommunityGoalPayload struct {
	// The error, if any.
	Error *ArchiveCommunityPointsCommunityGoalError `json:"error"`
	// The community goal that was archived.
	Goal *CommunityPointsCommunityGoal `json:"goal"`
}

// Inputs for archiving a poll.
type ArchivePollInChannelInput struct {
	// The id of the channel that contains the poll to archive.
	ChannelID string `json:"channelID"`
}

// Outputs from the archive poll mutation.
type ArchivePollInChannelPayload struct {
	// The archived poll.
	Poll *Poll `json:"poll"`
}

// Inputs for archiving a poll.
type ArchivePollInput struct {
	// The id of the poll to archive.
	PollID string `json:"pollID"`
}

// Outputs from the create poll mutation.
type ArchivePollPayload struct {
	// The created poll.
	Poll *Poll `json:"poll"`
}

// AssignExtensionBillingManagerError is the error associated with AssignExtensionBillingManager.
type AssignExtensionBillingManagerError struct {
	// The associated error code.
	Code AssignExtensionBillingManagerErrorCode `json:"code"`
}

// Inputs to the SetExtensionBillingManager mutation.
type AssignExtensionBillingManagerInput struct {
	// The ID of the extensions.
	ExtensionID string `json:"extensionID"`
	// The twitch ID of the organization member.
	UserID string `json:"userID"`
}

// Payload retuned from the mutation.
type AssignExtensionBillingManagerPayload struct {
	// The possible error returned from the service.
	Error *AssignExtensionBillingManagerError `json:"error"`
	// The updated extension.
	ExtensionClient *ExtensionClient `json:"extensionClient"`
}

// Information regarding an Amazon Associates store.
type AssociatesStore struct {
	ID string `json:"ID"`
	// Whether the owner of this store is enabled to recieve payments.
	IsPayoutEnabled *bool `json:"isPayoutEnabled"`
	// The store ID tag.
	StoreID *string `json:"storeID"`
}

// Authenticated Twitch session.
type AuthenticatedSession struct {
	// ID of the client the user authenticated from.
	ClientID string `json:"clientID"`
	// Creation date of the session.
	CreatedAt *time.Time `json:"createdAt"`
	// Date of invalidation of the session.
	// Can be null if the session hasn't been deleted.
	DeletedAt *time.Time `json:"deletedAt"`
	// Geolocation during authentication, determined by IP.
	Location *string `json:"location"`
	// User agent used during authentication.
	UserAgent *string `json:"userAgent"`
	// Twitch User ID.
	UserID string `json:"userID"`
}

// An automod fragment type, which is text that is flagged by AutoModeration.
// It contains a list of topics which contain reasons why AutoModeration flagged the text.
type AutoMod struct {
	// The topics that were flagged by AutoModeration.
	Topics []*AutoModTopic `json:"topics"`
}

func (AutoMod) IsFragmentContent() {}

// A message rejected by automod.
type AutoModCaughtMessage struct {
	// Reason why the message was flagged and/or rejected.
	Category AutoModCaughtMessageCategory `json:"category"`
	// id contains the UUID of the AutoModCaughtMessage.
	ID string `json:"id"`
	// The contents of the message itself, including its content, sender, sentAt timestamp, etc.
	ModLogsMessage *ModLogsMessage `json:"modLogsMessage"`
	// Time when a moderator allowed or denied a flagged message.
	ResolvedAt *time.Time `json:"resolvedAt"`
	// The user (mod) who approve/denied the flagged message.
	Resolver *User `json:"resolver"`
	// The approval status of the caught message.
	Status AutoModCaughtMessageStatus `json:"status"`
}

func (AutoModCaughtMessage) IsModLogsMessageResult() {}

type AutoModProperties struct {
	// These are integers between 0 and 4, inclusive.
	AggressiveLevel int `json:"aggressiveLevel"`
	IdentityLevel   int `json:"identityLevel"`
	ProfanityLevel  int `json:"profanityLevel"`
	SexualLevel     int `json:"sexualLevel"`
}

// An auto moderation topic with value.
type AutoModTopic struct {
	// The topic type, defined by Zuma.
	Type string `json:"type"`
	// The weight assigned to the topic.
	Weight int `json:"weight"`
}

// Contains all auto refill profiles, will have auto refill metadata in the future.
type AutoRefill struct {
	// Lists actions to execute during an auto refill setup session.
	Actions []CheckoutAction `json:"actions"`
	// The list of auto refill profiles.
	Profiles []*AutoRefillProfile `json:"profiles"`
	// A list of active xsolla payment methods that a user has available. This field is intended to be replaced by the User.PaymentMethods query.
	XsollaPaymentMethods []*PaymentMethod `json:"xsollaPaymentMethods"`
}

// Auto Refill profile information.
type AutoRefillProfile struct {
	// The charge instrument information for starting a purchase.
	ChargeInstrument *ChargeInstrument `json:"chargeInstrument"`
	// Unique ID assigned to this profile.
	ID string `json:"id"`
	// Indicates if this profile is active.
	IsEnabled bool `json:"isEnabled"`
	// The offerID that maps to the ability to purchase the intended product.
	OfferID *string `json:"offerID"`
	// The threshold amount a balance must go below to trigger a reload.
	Threshold int `json:"threshold"`
}

// A list of configured autohost channels
//
// A relay connection type that does not yet support pagination.
type AutohostChannelConnection struct {
	// The channels.
	Nodes []*User `json:"nodes"`
}

// A user's autohosting settings.
type AutohostSettings struct {
	// True if this channels prefers autohost over vodcast.
	DeprioritizeVodcast bool `json:"deprioritizeVodcast"`
	// True if this channel has the autohost feature turned on.
	Enabled bool `json:"enabled"`
	// Determines what other channels can raid this channel.
	IncomingRaidsPolicy AutohostSettingsIncomingRaidsPolicy `json:"incomingRaidsPolicy"`
	// The strategy to use when choosing channels to autohost.
	Strategy AutohostSettingsStrategy `json:"strategy"`
	// True if this user autohosts their team members.
	TeamHost bool `json:"teamHost"`
}

// A list of channels that are autohosting the channel
//
// A relay connection type that does not yet support pagination.
type AutohostedByChannelConnection struct {
	// The channels.
	Nodes []*User `json:"nodes"`
}

// AutomodContentResponse is the automod response for the text evaulated.
type AutomodContentResponse struct {
	// content are pieces of the content evaulated by automod.
	Content *RoomMessageContent `json:"content"`
	// text is the original raw string evaluated by automod.
	Text string `json:"text"`
}

// BackupIngestSession is session metadata related to broadcaster's backup session.
type BackupIngestSession struct {
	// The session where the current session was stitched from.
	StitchedFrom []*BackupStreamSession `json:"stitchedFrom"`
	// The session where the current session was stitched to.
	StitchedTo []*BackupStreamSession `json:"stitchedTo"`
}

// BackupStreamSession identifies the backup stream session.
type BackupStreamSession struct {
	// Type of live stream.
	BroadcastFormat BroadcastFormat `json:"broadcastFormat"`
	// The ID of backup session.
	ID string `json:"id"`
	// Time when the backup stream was stitched as primary session.
	StitchedTimeAt time.Time `json:"stitchedTimeAt"`
}

// Communicates a user's status in chat.
type Badge struct {
	// Identifies an action to trigger when this badge is clicked.
	ClickAction *BadgeClickAction `json:"clickAction"`
	// The URL to redirect to if the badge's onClickAction is VISIT_URL.
	ClickURL *string `json:"clickURL"`
	// A localized, human-friendly description of the badge.
	// Defaults to English if no translation exists for the requested locale.
	Description string `json:"description"`
	// The badge's unique identifier.
	ID string `json:"id"`
	// A URL to the badge's image.
	ImageURL string `json:"imageURL"`
	// Identifies an action to trigger when this badge is clicked.
	OnClickAction *BadgeClickAction `json:"onClickAction"`
	// The identifier of the set which this badge belongs (e.g. "subscriber").
	SetID string `json:"setID"`
	// A localized, human-friendly title for the badge.
	// Defaults to English if no translation exists for the requested locale.
	Title string `json:"title"`
	// The badge's associated broadcaster.
	// Returns null if this is a global badge.
	User *User `json:"user"`
	// The badge's version (e.g. "1mo").
	Version string `json:"version"`
}

// Balance for a Twitch User Account in a FIAT currency. Can be used to purchase
// product on the Twitch Platform.
type Balance struct {
	// Amount in the smallest unit of subcurrency.
	Amount int `json:"amount"`
	// ISO-4217 currency code of a user's balance.
	Currency Currency `json:"currency"`
	// When the credit amount will expire. Can be non-expirable (null).
	ExpiresAt *time.Time `json:"expiresAt"`
	// Number of digits after the decimal separator.
	Exponent int `json:"exponent"`
}

type BanUserFromChatRoomError struct {
	Code BanUserFromChatRoomErrorCode `json:"code"`
	// On DURATION_INVALID, maximum number of seconds a user can be timed out for.
	MaxTimeoutDurationSeconds *int `json:"maxTimeoutDurationSeconds"`
	// On DURATION_INVALID, minimum number of seconds a user can be timed out for.
	MinTimeoutDurationSeconds *int `json:"minTimeoutDurationSeconds"`
}

type BanUserFromChatRoomInput struct {
	BannedUserLogin string `json:"bannedUserLogin"`
	ChannelID       string `json:"channelID"`
	// This argument accepts a string specifying a duration.
	// It takes a succession of a number (positive integer) and a time unit, one of:
	// s[econd[s]], m[inute[s]], h[our[s]], d[ay[s]], w[eek[s]], mo[nth[s]].
	// Number/unit pairs can be contiguous or separated by spaces.
	// Valid examples: "3d4h" "11 minutes" "2month", "1s", "12 second"
	// If not provided, target is banned permanently.
	ExpiresIn *string `json:"expiresIn"`
	// The reason that the user has been banned or timed out.
	Reason *string `json:"reason"`
}

type BanUserFromChatRoomPayload struct {
	// The new ban status of this user regarding the specified channel.
	Ban *ChatRoomBanStatus `json:"ban"`
	// Mutation error caused by the user input.
	Error *BanUserFromChatRoomError `json:"error"`
}

type BanVideoCommenterInput struct {
	// The id of the channel from where to ban commenter from.
	ChannelID string `json:"channelID"`
	// The id of the commenter to ban.
	CommenterID string `json:"commenterID"`
}

type BanVideoCommenterPayload struct {
	User *User `json:"user"`
}

// The required input for an BeginUseBitsInExtension mutation.
type BeginUseBitsInExtensionInput struct {
	// Channel on which to use the bits.
	ChannelID string `json:"channelID"`
	// Extension client ID to spend bits in.
	ExtensionClientID string `json:"extensionClientID"`
	// The SKU of the item being bought.
	Sku string `json:"sku"`
}

// The result of a BeginUseBitsInExtension mutation.
type BeginUseBitsInExtensionPayload struct {
	// The user's balance.
	Balance *int `json:"balance"`
	// How many bits are required for this.
	BitsRequired *int `json:"bitsRequired"`
	// Does the front end need to prompt the user.
	IsPromptRequired *bool `json:"isPromptRequired"`
	// The new transaction ID for this spend.
	TransactionID *string `json:"transactionID"`
}

// BillingAuthInfo holds data to facilitate the Fraud analysis.
type BillingAuthInfo struct {
	// Fraud Session ID.
	RecurlyFraudSessionID *string `json:"recurlyFraudSessionID"`
	// Token generated after completing a 3-D Secure device fingerprinting or
	// authentication challenge.
	ThreeDSecureActionResultTokenID *string `json:"threeDSecureActionResultTokenID"`
}

// BitsAdOffer is an offer to earn bits by watching an ad or interacting with an engagement.
type BitsAdOffer struct {
	// bits is the minimum number of bits received from watching an ad.
	// Some ads may reward more, but this is the number displayed to the user before choosing to watch an ad for bits.
	Bits int    `json:"bits"`
	ID   string `json:"id"`
	// type is `BitsOfferType.AD`.
	Type BitsOfferType `json:"type"`
}

func (BitsAdOffer) IsBitsOffer() {}

// Bits Badges with their associated settings.
type BitsBadgeTier struct {
	// The badge for this tier.
	Badge *Badge `json:"badge"`
	// Whether the broadcaster can upload emoticons for this tier.
	CanUploadEmoticons bool `json:"canUploadEmoticons"`
	// The emoticon configurations for emoticons that are currently in the process of being uploaded for this tier.
	EmoticonUploadConfigurations []*EmoteUploadConfiguration `json:"emoticonUploadConfigurations"`
	// The emoticons that are associated with this tier.
	Emoticons []*Emote `json:"emoticons"`
	// Whether the badge is enabled for this threshold.
	IsEnabled bool `json:"isEnabled"`
	// Time when this badge tier was last updated.
	LastUpdated *time.Time `json:"lastUpdated"`
	// The amount of bits a user must cheer to achieve this tier.
	Threshold int `json:"threshold"`
	// The number of users who have unlocked this badge tier.
	UnlockedUsersCount int `json:"unlockedUsersCount"`
}

// BadgeTier Emoticon data to modify.
type BitsBadgeTierEmoticonSetting struct {
	// The text representation that will allow a user to invoke the emoticon in chat.
	// Usually consists of: a creator's emoticon prefix + a codeSuffix.
	Code string `json:"code"`
	// The creator-defined suffix that differentiates this emoticon from other emoticons in the channel.
	// Usually begins with either a capital letter or a number.
	CodeSuffix string `json:"codeSuffix"`
	// I'm going to make these new fields nullable and transition them to non-nullable after deprecate the existing flow
	// Image ID for the 28x28 emote asset.
	ImageID1x *string `json:"imageID1x"`
	// Image ID for the 56x56 emote asset.
	ImageID2x *string `json:"imageID2x"`
	// Image ID for the 112x112 emote asset.
	ImageID4x *string `json:"imageID4x"`
}

// BadgeTier metadata to modify.
type BitsBadgeTierInput struct {
	// Whether to reset the images to the default images.
	DeleteImage *bool `json:"deleteImage"`
	// Wether to reset the badge title to the default title.
	DeleteTitle *bool `json:"deleteTitle"`
	// A list of emoticons to modify.
	EmoticonSettings []*BitsBadgeTierEmoticonSetting `json:"emoticonSettings"`
	// Base64 encoded binary data of the 18x18px badge ("1x") image asset.
	ImageData1x *string `json:"imageData1x"`
	// Base64 encoded binary data of the 36x36px badge ("2x") image asset.
	ImageData2x *string `json:"imageData2x"`
	// Base64 encoded binary data of the 72x72px badge ("4x") image asset.
	ImageData4x *string `json:"imageData4x"`
	// Whether the badge is enabled for this threshold.
	IsEnabled *bool `json:"isEnabled"`
	// The threshold to modify.
	Threshold int `json:"threshold"`
	// Badge title as string.
	Title *string `json:"title"`
}

// A notification about achieving a new bits badge tier. Used to send a special message.
type BitsBadgeTierNotification struct {
	// Whether or not the notification can be shared with chat.
	CanShare bool `json:"canShare"`
	// UUID for notification.
	ID string `json:"id"`
	// Represents the badge tier threshold reached by the user on a channel (e.g. 100, 1000, etc).
	Threshold int `json:"threshold"`
	// The list of bits badge tier emoticons that were obtained as part of achieving this notification's bits badge tier.
	UnlockedEmoticons []*Emote `json:"unlockedEmoticons"`
}

// BitsBundleOffer is an offer to purchase a number of bits for a certain price.
type BitsBundleOffer struct {
	// amount is the numerical cost of this offer (ex: 20.00).
	Amount float64 `json:"amount"`
	// asin is the Amazon Standard Identification Number for this offer.
	Asin string `json:"asin"`
	// bits is the number of bits this offer provides.
	Bits int `json:"bits"`
	// Currency code that the price and amount are displayed in (USD, CAD, etc.).
	CurrencyCode string `json:"currencyCode"`
	// discount is the bulk discount this offer provides compared to the base offer [0.0-1.0).
	Discount float64 `json:"discount"`
	ID       string  `json:"id"`
	// includesVAT is a boolean flag to indicate that the Value Added Tax (VAT)
	// is included in the price of a Bits product. This is important for Bits prices
	// in EU.
	IncludesVat bool `json:"includesVAT"`
	// isPromo is a flag that signifies if the offer is a promotional offer. This is for clients that
	// need to display promotional offers differently.
	IsPromo bool `json:"isPromo"`
	// price is the formatted currency cost of this offer to be displayed to the user.
	Price string `json:"price"`
	// promotion contains information about this bits offer if it is a promotional offer. Is null if the offer is not promotional.
	Promotion *BitsPromotion `json:"promotion"`
	// type is `BitsOfferType.BUNDLE`.
	Type BitsOfferType `json:"type"`
	// url is the purchase URL to use for this offer.
	// The url contains a `{channelID}` token which should be replaced by the `User.id` of the channel bits are being purchased from.
	URL string `json:"url"`
}

func (BitsBundleOffer) IsBitsOffer() {}

// BitsChallengeConditionPoolRecipientWeightedShare represents the weighted share of the total bits pool
// that a recipient user is entitled to upon condition satisfaction.
type BitsChallengeConditionPoolRecipientWeightedShare struct {
	// TUID of the bits recipient.
	RecipientUserID string `json:"recipientUserID"`
	// The weight of the recipient's share from the total bits pool. The sum of all the recipients' weights
	// dictates the proportion that a particular recipient receives from the pool (shareWeight/totalShareWeight * totalBitsAmountInPool).
	Weight int `json:"weight"`
}

// An event that captures a single bits transaction.
type BitsEvent struct {
	// Amount of bits used.
	Amount int `json:"amount"`
	// Channel bits were used on.
	Channel *User `json:"channel"`
	// Event ID.
	ID string `json:"id"`
	// What type of event the bits were used on.
	Type BitsEventType `json:"type"`
	// Time the bits were used at.
	UsedAt time.Time `json:"usedAt"`
}

// A paginated list of bits events, and its metadata.
type BitsEventConnection struct {
	// The list of bits events on this page.
	Edges []*BitsEventEdge `json:"edges"`
	// Information about this page of bits.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of bits events in the overall collection.
	TotalCount int `json:"totalCount"`
}

// Filter and sorting options for querying all bits events for a Twitch user.
type BitsEventConnectionCriteriaInput struct {
	// Sort bits events by... defaults to date.
	SortBy *BitsEventSort `json:"sortBy"`
	// Sort bits events direction, defaults to descending.
	SortDirection *BitsEventSortDirection `json:"sortDirection"`
	// Only show bits events of a certain type, defaults to returning all types.
	Type *BitsEventType `json:"type"`
	// Only show bits events after this date.
	UsedAfter *time.Time `json:"usedAfter"`
	// Only show bits events before this date.
	UsedBefore *time.Time `json:"usedBefore"`
}

// An element in a paginated list of bits events, and its metadata.
type BitsEventEdge struct {
	// Offset acting as a cursor.
	Cursor string `json:"cursor"`
	// The element node.
	Node *BitsEvent `json:"node"`
}

// A list of hashtags to use in chat while using bits.
type BitsHashtagConnection struct {
	// The list of BitsHashtagEdges.
	Edges []*BitsHashtagEdge `json:"edges"`
}

// BitsHashtagEdge contains.
type BitsHashtagEdge struct {
	// The cursor of the record. This will be the BitsHashtagEdge ID.
	Cursor string `json:"cursor"`
	// The node of the edge contains all information about the hashtag.
	Node *BitsHashtagEntry `json:"node"`
}

// BitsHashtagEntry contains information about a hashtag, sucn as the description and image URL for display.
type BitsHashtagEntry struct {
	// description text.
	Description *string `json:"description"`
	// The ID, which would be the hashtag value.
	ID string `json:"id"`
	// An image to display in autocomplete.
	ImageURL *string `json:"imageURL"`
}

// The Bits Key Code that can be claimed to add bits to a user's account.
type BitsKeyCode struct {
	// A description of what is claimable for the bits key code.
	Description string `json:"description"`
	// The ID of the bits key code.
	ID string `json:"id"`
	// The field that gives us claim information for the logged in user.
	Self SelfClaimEdge `json:"self"`
	// The type is `ClaimableType.BITS_KEY_CODE`.
	Type ClaimableType `json:"type"`
}

func (BitsKeyCode) IsClaimable() {}

// User edge relating the key's status to the user.
type BitsKeyCodeSelfClaimEdge struct {
	// If the user is eligible to claim the key code.
	CanClaim bool `json:"canClaim"`
	// Nullable field for the country where the user redeemed the claimable.
	CountryOfResidence *string `json:"countryOfResidence"`
	// The user ID that is claiming the code.
	ID string `json:"id"`
	// Nullable status code for if the user cannot claim the key code.
	StatusCode *string `json:"statusCode"`
}

func (BitsKeyCodeSelfClaimEdge) IsSelfClaimEdge() {}

// BitsLeaderboard contains the leaderboard for a specified channel.
type BitsLeaderboard struct {
	// entries is the list of users in the leaderboard ordered by the number of bits cheered.
	Entries *BitsLeaderboardConnection `json:"entries"`
	// id is the id of this leaderboard.
	ID string `json:"id"`
	// items is the list of users in the leaderboard ordered by the number of bits cheered.
	Items *BitsLeaderboardItemConnection `json:"items"`
	// SecondsRemaining is the number of seconds left before the leaderboard expires (or zero for all-time).
	SecondsRemaining int `json:"secondsRemaining"`
}

// Bits leaderboard connection is used to show the various leaderboard entries.
type BitsLeaderboardConnection struct {
	Edges []*BitsLeaderboardEdge `json:"edges"`
}

// BitsLeaderboardEdge describes an edge in a bits leaderboard.
type BitsLeaderboardEdge struct {
	// The cursor for this leaderboard edge.
	Cursor string `json:"cursor"`
	// The leaderboard entry at this edge.
	Node *BitsLeaderboardEntry `json:"node"`
}

// Leaderboard entry at a specific node in a leaderboard connection.
type BitsLeaderboardEntry struct {
	// id the id of this leaderboard entry.
	ID string `json:"id"`
	// rank the ordinal rank of this leaderboard entry.
	Rank int `json:"rank"`
	// score the number of bits cheered by this leaderboard entry.
	Score int `json:"score"`
}

// Leaderboard item at a specific node in a leaderboard connection.
type BitsLeaderboardItem struct {
	// entryKey the key of this leaderboard item.
	EntryKey string `json:"entryKey"`
	// id the id of this leaderboard item.
	ID string `json:"id"`
	// rank the ordinal rank of this leaderboard item.
	Rank int `json:"rank"`
	// score the number of bits cheered by this leaderboard entry.
	Score int `json:"score"`
}

// Bits leaderboard connection is used to show the various leaderboard items.
type BitsLeaderboardItemConnection struct {
	// edges ...
	Edges []*BitsLeaderboardItemEdge `json:"edges"`
	// pageInfo ...
	PageInfo *PageInfo `json:"pageInfo"`
	// totalCount ...
	TotalCount *int `json:"totalCount"`
}

// BitsLeaderboardItemEdge describes an edge in a bits leaderboard.
type BitsLeaderboardItemEdge struct {
	// The cursor for this leaderboard edge.
	Cursor string `json:"cursor"`
	// The leaderboard entry at this edge.
	Node *BitsLeaderboardItem `json:"node"`
}

// BitsLeaderboardSettings are channel-specific settings related to Bits Leaderboards.
type BitsLeaderboardSettings struct {
	// isEnabled indicates if the Bits leaderboard is pinned in this channel.
	IsEnabled bool `json:"isEnabled"`
	// timePeriodType indicates whether the leaderboard type is of WEEKLY, ALL-TIME, etc.
	TimePeriodType *LeaderboardTimePeriodType `json:"timePeriodType"`
}

// The type used when checking which payment methods a user can use.
type BitsPaymentMethods struct {
	// A list of the valid bits payment methods for a user.
	PaymentMethods []BitsPaymentMethodType `json:"paymentMethods"`
}

// A product for bits that contains all information about a product, except for the pricing.
type BitsProduct struct {
	// The amount of bits the product is for.
	Amount int `json:"amount"`
	// The product ID.
	ID string `json:"id"`
	// The maximum quantity a user can purchase at once.
	MaxQuantity int `json:"maxQuantity"`
	// The offer id associated with this product's id (if available).
	OfferID *string `json:"offerID"`
	// A field that contains promotional information about the product.
	Promo *BitsProductPromotion `json:"promo"`
	// The relation of the product to the user.
	Self *BitsProductSelfEdge `json:"self"`
	// The product type, which right now is only "purchase".
	Type BitsProductType `json:"type"`
}

// The type used when checking bits product eligibility for a user.
type BitsProductEligibility struct {
	// A boolean that is true when the user is eligible for the product.
	CanPurchase bool `json:"canPurchase"`
	// If the user is ineligible for the product, then this code is set
	// as the reason why the user is ineligible for the product.
	ReasonCode *string `json:"reasonCode"`
}

// Promotional information about bits products.
type BitsProductPromotion struct {
	// The unique ID of the bits product promo.
	ID string `json:"id"`
	// The localized title of the promo product.
	Title string `json:"title"`
	// The type of promotion the product is associated with. This type is not enumerable since it is very dynamic.
	Type string `json:"type"`
}

// Contains the Bits product's preview price and tax info for a Bits purchase, and error if a preview cannot be created.
type BitsProductPurchaseInfo struct {
	// Lists any additional actions for a bits checkout session.
	Actions []CheckoutAction `json:"actions"`
	// The error is present if purchase info failed to be retrieved.
	Error *BitsProductPurchaseInfoError `json:"error"`
	// Gets the preview price and tax info for the Bits purchase.
	PreviewPriceInfo *PriceInfo `json:"previewPriceInfo"`
}

// Error information shown when priceInfo could not be retrieved for Bits Product.
type BitsProductPurchaseInfoError struct {
	// The descriptive error code.
	Code BitsProductPurchaseInfoErrorCode `json:"code"`
}

// The relation of a Bits product to a user.
type BitsProductSelfEdge struct {
	// Holds configuration necessary to start bits purchase checkout flow for this product for current user.
	CheckoutConfiguration *CheckoutConfiguration `json:"checkoutConfiguration"`
	// Is the user eligible to claim the product at the given quantity.
	Eligibility *BitsProductEligibility `json:"eligibility"`
	// Gets the preview price and tax info for the Bits purchase, or error if that failed.
	PurchaseInfo *BitsProductPurchaseInfo `json:"purchaseInfo"`
}

type BitsPromotion struct {
	// id indicates the particular promo that this offer is associated with.
	ID string `json:"id"`
	// PromoType indicates the type of promo that the offer represents i.e First time purchase, single purchase, etc...
	Type string `json:"type"`
}

// Settings tied to a bits user.
type BitsUserSettings struct {
	// Settings specific to the first cheer tutorial.
	FirstCheerTutorial *FirstCheerTutorial `json:"firstCheerTutorial"`
}

// Information regarding a Blizzard account that is linked to Twitch.
type BlizzardUser struct {
	// The BattleTag that is stored for the user.
	BattleTag string `json:"battleTag"`
	// The Blizzard ID that is stored for the user.
	ID string `json:"id"`
	// The region the Blizzard account is from.
	Region string `json:"region"`
}

type BlockUserInput struct {
	// Reason the user is being blocked.
	Reason *string `json:"reason"`
	// Feature from which the user is being blocked.
	SourceContext *BlockContext `json:"sourceContext"`
	// ID of user to block.
	TargetUserID string `json:"targetUserID"`
}

type BlockUserPayload struct {
	// User that was blocked.
	TargetUser *User `json:"targetUser"`
}

// A BoostSettings is a set of preferences set by a creator regarding Community Boosts for their channel.
type BoostSettings struct {
	// If Boosts earned through community challenges are enabled on this channel.
	IsEarnedEnabled *bool `json:"isEarnedEnabled"`
	// If the channel is eligible to recieve boosts.
	IsEligible bool `json:"isEligible"`
	// If Boosts are enabled on this channel.
	IsEnabled *bool `json:"isEnabled"`
	// If Boosts paid for by the community are enabled on this channel.
	IsPaidEnabled *bool `json:"isPaidEnabled"`
}

// A bounty is a task that a user can complete for a payout.
type Bounty struct {
	// The campaign that this bounty belongs to.
	Campaign *BountyCampaign `json:"campaign"`
	// The chat Call to Action that will be display during the bounty.
	ChatCta *BountyChatCta `json:"chatCTA"`
	// When the bounty was claimed by the user.
	ClaimTime *time.Time `json:"claimTime"`
	// When the bounty was claimed by the user.
	ClaimedAt *time.Time `json:"claimedAt"`
	// When the bounty expires.
	EndAt *time.Time `json:"endAt"`
	// When the the user stops tracking.
	EndTime *time.Time `json:"endTime"`
	// When the bounty expires.
	ExpiresAt *time.Time `json:"expiresAt"`
	// The bounty's unique identifier.
	ID string `json:"id"`
	// The product keys for the bounty.
	Keys []*BountyProductKey `json:"keys"`
	// When the bounty was last modified.
	LastModifiedAt *time.Time `json:"lastModifiedAt"`
	// The number of concurrent users (CCU) required to hit the maximum payout for the bounty.
	MaximumPayoutCcu *int `json:"maximumPayoutCCU"`
	// The maximum payout for completing this bounty in USD cents.
	MaximumPayoutCents int `json:"maximumPayoutCents"`
	// The number of concurrent users (CCU) required to earn a payout for the bounty.
	MinimumPayoutCcu *int `json:"minimumPayoutCCU"`
	// The node includes all bounty moderation metadata.
	ModerationMetadata *BountyModerationMetadata `json:"moderationMetadata"`
	// The moderation status of the bounty.
	ModerationStatus *BountyModerationStatus `json:"moderationStatus"`
	// The actual payout for completing this bounty in USD cents.
	PayoutCents *int `json:"payoutCents"`
	// The platform on which the user will play the game for this bounty (ie. PC).
	Platform *string `json:"platform"`
	// The region that the broadcaster has selected for this bounty (as defined by BountyCampaignKeyDescriptor).
	Region *string `json:"region"`
	// Restrictions for this bounty.
	Restriction *BountyRestriction `json:"restriction"`
	// When the bounty was claimed by the user.
	StartAt *time.Time `json:"startAt"`
	// When the bounty was started by the user.
	StartTime *time.Time `json:"startTime"`
	// The status of the bounty.
	Status BountyStatus `json:"status"`
	// When the user starts tracking the bounty.
	TrackingStartedAt *time.Time `json:"trackingStartedAt"`
	// When the user stops tracking the bounty.
	TrackingStoppedAt *time.Time `json:"trackingStoppedAt"`
	// The videos for this bounty.
	Videos []*BountyVideo `json:"videos"`
}

// Bounty board settings configure how a user can interact with the Bounty Boards feature.
type BountyBoardSettings struct {
	// This determines whether or not a user has a bounty board notification.
	HasNotification bool `json:"hasNotification"`
	// This determines whether the user has the Bounty Boards feature enabled.
	IsEnabled bool `json:"isEnabled"`
	// The user's status on Bounty Board.
	Status BountyBoardUserStatus `json:"status"`
}

// A campaign defines the requirements and parameters for a set of bounties.
type BountyCampaign struct {
	// The list of games that if isAllowAllGames is false, the bounty must use.
	AllowedGames []*Game `json:"allowedGames"`
	// The platforms on which users can play this campaign's game (ie. PC, PS4, Switch).
	AvailablePlatforms []string `json:"availablePlatforms"`
	// The length of this campaign's bounties (in days).
	BountyLengthDays int `json:"bountyLengthDays"`
	// Override Box Art URL only for campaign shown on Bounty Board Dashboard, unrelated to game.
	BoxArtURL *string `json:"boxArtURL"`
	// Details about the campaign that only the sponsoring brand should see.
	BrandDetails *BountyCampaignBrandDetails `json:"brandDetails"`
	// Override Cover URL only for campaign shown on Bounty Board Dashboard, unrelated to game.
	CoverURL *string `json:"coverURL"`
	// Details for this campaign.
	Details string `json:"details"`
	// Override Display name only for campaign shown on Bounty Board Dashboard, unrelated to game.
	DisplayName *string `json:"displayName"`
	// When the campaign expires.
	EndAt time.Time `json:"endAt"`
	// When the campaign expires.
	EndTime time.Time `json:"endTime"`
	// The game identifier that is related to this campaign.
	Game *Game `json:"game"`
	// The campaign's unique identifier.
	ID string `json:"id"`
	// If the campaing is a promotional campaign.
	IsPromotionEligible *bool `json:"isPromotionEligible"`
	// The information about keys for the campaigns.
	KeyDescriptors []*BountyCampaignKeyDescriptor `json:"keyDescriptors"`
	// Why the campaign was rejected.
	RejectionReason *string `json:"rejectionReason"`
	// If a campaign allows any game to be played.
	ShouldAllowAllGames *bool `json:"shouldAllowAllGames"`
	// The sponsor that is funding this campaign (ie. Amazon Game Studios).
	Sponsor string `json:"sponsor"`
	// When the campaign starts.
	StartAt time.Time `json:"startAt"`
	// When the campaign starts.
	StartTime time.Time `json:"startTime"`
	// The status of the campaign.
	Status *BountyCampaignStatus `json:"status"`
	// How many seconds a bounty for this campaign must be streamed to complete the bounty.
	StreamLengthSeconds *int `json:"streamLengthSeconds"`
	// The click target of the campaign if it is a promotional campaign.
	TargetPromotionalVideoClicks *int `json:"targetPromotionalVideoClicks"`
	// The URL for the terms and conditions page.
	TermsAndConditionsURL *string `json:"termsAndConditionsURL"`
	// The title of the campaign (ie. Stream Breakaway for 1 hour).
	Title string `json:"title"`
	// The tracking URLs for this campaign.
	TrackingPixels []*TrackingPixel `json:"trackingPixels"`
	// The type of the campaign (ie. PAY_TO_STREAM).
	Type BountyCampaignType `json:"type"`
	// The URL of the video for this campaign.
	VideoURL *string `json:"videoURL"`
	// The video URLS for the campaign.
	Videos []*BountyCampaignVideo `json:"videos"`
}

// Details about a bounty campaign that only the sponsoring brand should see.
type BountyCampaignBrandDetails struct {
	// The list of users (if any) blacklisted for the campaign.
	// Limited to 40 users - use totalBlockedBroadcasters for the total count.
	BlacklistedBroadcasters []*User `json:"blacklistedBroadcasters"`
	// The multiplier for the broadcaster payout rate.
	BroadcasterMultiplier *float64 `json:"broadcasterMultiplier"`
	// Reporting data for the campaign.
	CampaignReporting *BountyCampaignReporting `json:"campaignReporting"`
	// The chat Calls to Action for the campaign.
	ChatCTAs []*BountyChatCta `json:"chatCTAs"`
	// The total number of broadcasters who have claimed the bounty.
	ClaimedBountyCount *int `json:"claimedBountyCount"`
	// How much of the budget has been claimed (in cents).
	ClaimedBudgetCents *int `json:"claimedBudgetCents"`
	// The total number of broadcasters who have completed the bounty.
	CompletedBountyCount *int `json:"completedBountyCount"`
	// The total number of broadcasters who have expanded the bounty.
	ExpandedBountyCount *int `json:"expandedBountyCount"`
	// If all broadcasters are targeted for the campaign.
	IncludesAllBroadcasters *bool `json:"includesAllBroadcasters"`
	// If all countries are targeted for the campaign.
	IncludesAllCountries bool `json:"includesAllCountries"`
	// If all games are targeted for the campaign.
	IncludesAllGames bool `json:"includesAllGames"`
	// If variety broadcasters are targeted for the campaign.
	IncludesVarietyBroadcasters bool `json:"includesVarietyBroadcasters"`
	// Detailed performance metrics for this campaign.
	PerformanceMetrics []*BountyCampaignPerformanceMetric `json:"performanceMetrics"`
	// Why the campaign was rejected.
	RejectionReason *string `json:"rejectionReason"`
	// How much of the budget has been spent (completed bounties) (in cents).
	SpentBudgetCents *int `json:"spentBudgetCents"`
	// The status of the campaign.
	Status *BountyCampaignStatus `json:"status"`
	// Targeted countries for the campaign (represented by ISO 3166-1 alpha-2).
	TargetedCountries []string `json:"targetedCountries"`
	// Targeted Games for the campaign.
	TargetedGames []*Game `json:"targetedGames"`
	// The total length of the blacklistedBroadcasters list.
	TotalBlockedBroadcasters *int `json:"totalBlockedBroadcasters"`
	// The total budget for the campaign (in cents).
	TotalBudgetCents *int `json:"totalBudgetCents"`
	// The number of broadcasters who have viewed the bounty.
	ViewedBountyCount *int `json:"viewedBountyCount"`
}

// The chat Call to Action (CTA) that will be created as part of this campaign.
type BountyCampaignChatCTAInput struct {
	// The country that the chat CTA is targeted for (represented by ISO 3166-1 alpha-2).
	CountryCode string `json:"countryCode"`
	// The title for the chat CTA.
	Title string `json:"title"`
	// The URL for the chat CTA.
	URL string `json:"url"`
}

// A list of bounty campaigns related to the subject.
type BountyCampaignConnection struct {
	// The campaigns.
	Edges []*BountyCampaignEdge `json:"edges"`
	// Information about pagination in this connection.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Information about the relationship to the bounty campaign and the subject.
// Also includes the campaign itself.
type BountyCampaignEdge struct {
	// Uniquely identifies this campaign's position in a connection.
	Cursor string `json:"cursor"`
	// The campaign.
	Node *BountyCampaign `json:"node"`
}

// A descriptor for a product key.
type BountyCampaignKeyDescriptor struct {
	// The platform for the key.
	Platform string `json:"platform"`
	// The region for the key.
	Region string `json:"region"`
}

// Metric containing details about how a campaign performed over a time period.
type BountyCampaignPerformanceMetric struct {
	// The number of click-throughs from the Chat CTAs of the campaign.
	ChatCTAClickThroughCount *int `json:"chatCTAClickThroughCount"`
	// The total number of bounties that were completed.
	CompletedBountyCount int `json:"completedBountyCount"`
	// The end time of this metric.
	EndTime time.Time `json:"endTime"`
	// The total number of minutes watched.
	MinutesWatched int `json:"minutesWatched"`
	// The start time of this metric.
	StartTime time.Time `json:"startTime"`
	// The number of viewers that watched at least thirty seconds of the campaign's content.
	ThirtySecondViewerCount int `json:"thirtySecondViewerCount"`
	// The total number of viewers that watched the campaign's content.
	TotalViewerCount int `json:"totalViewerCount"`
	// The number of viewers that watched at least two minutes of the campaign's content.
	TwoMinuteViewerCount int `json:"twoMinuteViewerCount"`
}

// Details about a bounty campaign reporting that only the sponsoring brand should see.
type BountyCampaignReporting struct {
	// The total number of clicks from chat CTAs from every bounty.
	ChatCTAsClicks *int `json:"chatCTAsClicks"`
	// The total number of impressions from chat CTAs from every bounty.
	ChatCTAsImpressions *int `json:"chatCTAsImpressions"`
	// The total number of broadcasters who have claimed the bounty.
	ClaimedBountyCount *int `json:"claimedBountyCount"`
	// How much of the budget has been claimed (live bounties) (in cents).
	ClaimedBudgetCents *int `json:"claimedBudgetCents"`
	// The total number of broadcasters who have completed the bounty.
	CompletedBountyCount *int `json:"completedBountyCount"`
	// The total number of broadcasters who have expanded the bounty.
	ExpandedBountyCount *int `json:"expandedBountyCount"`
	// Detailed performance metrics for this campaign.
	PerformanceMetrics []*BountyCampaignPerformanceMetric `json:"performanceMetrics"`
	// How much of the budget has been spent (completed bounties) (in cents).
	SpentBudgetCents *int `json:"spentBudgetCents"`
	// The number of broadcasters who have viewed the bounty.
	ViewedBountyCount *int `json:"viewedBountyCount"`
}

// A video for a bounty board campaign.
type BountyCampaignVideo struct {
	// The country that the video is targeted for (represented by ISO 3166-1 alpha-2).
	Country string `json:"country"`
	// The title of the video.
	Title string `json:"title"`
	// The URL of the video.
	URL string `json:"url"`
}

// The video that will be created as part of this campaign.
type BountyCampaignVideoInput struct {
	// The country that the video is targeted for (represented by ISO 3166-1 alpha-2).
	Country string `json:"country"`
	// The title of the video.
	Title string `json:"title"`
	// The URL of the video.
	URL string `json:"url"`
}

// A chat Call to Action (CTA) that will be trigger in the broadcaster chat while doing the bounty.
type BountyChatCta struct {
	// The country targeted for the chat CTA (represented by ISO 3166-1 alpha-2).
	CountryCode string `json:"countryCode"`
	// The time (in seconds) between each appearance of the chat CTA.
	FrequencySeconds int `json:"frequencySeconds"`
	// The initial delay (in seconds) before the first chat CTA.
	InitialDelaySeconds int `json:"initialDelaySeconds"`
	// The title of the chat CTA.
	Title string `json:"title"`
	// The URL of the chat CTA.
	URL string `json:"url"`
}

// A list of bounty related to the subject.
type BountyConnection struct {
	// The bounties.
	Edges []*BountyEdge `json:"edges"`
	// Information about pagination in this connection.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Information about the relationship to the bounty and the subject.
// Also includes the bounty itself.
type BountyEdge struct {
	// Uniquely identifies this bounty's position in a connection.
	Cursor string `json:"cursor"`
	// The bounty.
	Node *Bounty `json:"node"`
}

// Bounty Moderation metadata includes moderation metadata for a specific bounty.
type BountyModerationMetadata struct {
	// The moderation fail reason of the bounty.
	Reason *BountyModerationFailReason `json:"reason"`
	// The moderation status of the bounty.
	Status *BountyModerationStatus `json:"status"`
	// When the bounty was last moderated.
	UpdatedAt *time.Time `json:"updatedAt"`
}

// A key that can be redeemed for a product.
type BountyProductKey struct {
	// The code that is used to redeem the product.
	Code string `json:"code"`
	// The platform where the code is redeemed.
	Platform *string `json:"platform"`
	// The product type of the key - GAME, DLC, GIVEAWAY, GIFTCARD, etc.
	ProductType *BountyKeyProductType `json:"productType"`
	// The region where the code can be redeemed. The format and granularity of this field varies
	// depending on the product key vendor.
	Region *string `json:"region"`
}

// Defines the restrictions that are placed on a bounty.
type BountyRestriction struct {
	// The days of the week that a bounty can be completed on. The values are from 0 to 6, representing day of the week from Monday to Sunday.
	Days []int `json:"days"`
	// The end of the time period that a bounty can be completed in. This is in 24-hour clock notation, so 2100 means 9 PM UTC.
	EndTime *int `json:"endTime"`
	// The start of the time period that a bounty can be completed in. This is in 24-hour clock notation, so 1000 means 10 AM UTC.
	StartTime *int `json:"startTime"`
}

// A video that the broadcaster must play on stream to complete the bounty.
type BountyVideo struct {
	// The title of the video.
	Title string `json:"title"`
	// The URL of the video.
	URL string `json:"url"`
}

// Brand portal settings configure how a company can interact with the brand portal.
type BrandPortalSettings struct {
	// This determines whether or not a company can access all games in brand portal.
	CanAccessAllGames bool `json:"canAccessAllGames"`
	// This determines whether or not a company can access the Brand Portal.
	IsEnabled bool `json:"isEnabled"`
}

// A historical representation of a live stream.
type Broadcast struct {
	// The game which was last streamed during the broadcast.
	Game *Game `json:"game"`
	// The broadcast's unique identifier.
	ID *string `json:"id"`
	// When the broadcast started.
	StartedAt *time.Time `json:"startedAt"`
	// The title of the broadcast.
	Title *string `json:"title"`
}

// Settings for a User's broadcast that persist between streams.
type BroadcastSettings struct {
	// The game that the user has set as their current game. This will influence what the game field on a Streams object is when the User starts streaming.
	Game *Game `json:"game"`
	// The broadcast setting's unique identifier.
	// This happens to be the same as the User's ID, but should not be assumed to have any meaning.
	ID string `json:"id"`
	// A flag indicating if the user's broadcast is intended for mature audiences only.
	IsMature bool `json:"isMature"`
	// The primary language that the user has configured for their broadcasts. The default value is "", when the user has not indicated a primary language.
	Language Language `json:"language"`
	// The text that will be in the notification that sends when the user starts broadcasting.
	// The default value is "<user> went live!", when the user has not set a custom value.
	LiveUpNotification *string `json:"liveUpNotification"`
	// The information about the live up notification of a user.
	LiveUpNotificationInfo *LiveUpNotificationInfo `json:"liveUpNotificationInfo"`
	// The title of the user's broadcast. The default value is "", when the user has not indicated a title.
	Title string `json:"title"`
}

// An indicator of the viewer reach for a pool of a broadcasters.
type BroadcasterViewerReach struct {
	// Range of the number of broadcasters in the pool.
	BroadcasterPool *Range `json:"broadcasterPool"`
	// Range of minutes watched for this bounty campaign.
	MinutesWatched *Range `json:"minutesWatched"`
	// Range of total viewers across the broadcaster pool.
	ViewerPool *Range `json:"viewerPool"`
}

// Associated metrics for the "Build a Community" quest.
type BuildACommunity struct {
	// Image URL for the quest's badge.
	BadgeURL *string `json:"badgeURL"`
	// Time that this quest was completed.
	CompletedAt *time.Time `json:"completedAt"`
	// Number of followers needed to complete the quest.
	Followers *QuestGoalInt `json:"followers"`
	// Number of Unique Chatters needed to complete the quest.
	UniqueChatters *QuestGoalInt `json:"uniqueChatters"`
}

// Required input to bulk approve a list of unban requests on a channel.
type BulkApproveUnbanRequestInput struct {
	// IDs of the unban requests to be approved.
	Ids []string `json:"ids"`
}

// Result of bulk approving unban requests.
type BulkApproveUnbanRequestPayload struct {
	// Used for errors arising from bulk approving unban requests.
	Error *UnbanRequestError `json:"error"`
	// The approved unban requests.
	UnbanRequests []*UnbanRequest `json:"unbanRequests"`
}

// Required input to deny a list of unban requests on a channel.
type BulkDenyUnbanRequestInput struct {
	// IDs of the unban requests to be denied.
	Ids []string `json:"ids"`
}

// Result of bulk denying unban requests.
type BulkDenyUnbanRequestPayload struct {
	// Used for errors arising from bulk denying unban requests.
	Error *UnbanRequestError `json:"error"`
	// The denied unban requests.
	UnbanRequests []*UnbanRequest `json:"unbanRequests"`
}

// A visible campaign on a given user's channel.
type Campaign struct {
	// The domain that campaign belongs to.
	Domain string `json:"domain"`
	// The time the campaign ends being active.
	EndDate time.Time `json:"endDate"`
	// Unique identifier for the campaign.
	ID string `json:"id"`
	// The objectives users can progress in within this campaign.
	Objectives []*CampaignObjective `json:"objectives"`
	// The time the campaign becomes active.
	StartDate time.Time `json:"startDate"`
}

// This type holds the information about the grouping of objectives. Each group has a list of cheermotes that progress objectives in this particular group.
type CampaignCheergroup struct {
	// A list of upper cased cheermotes that can advance objectives belonging to this group.
	CheerCodes []string `json:"cheerCodes"`
	// An a parent group this cheer group belongs to (e.g. "North America").
	Division *string `json:"division"`
	// A url to the image representing this group (e.g. team icon in esports context).
	ImageURL string `json:"imageUrl"`
	// A name representing this group (e.g. team name in esports context).
	Name string `json:"name"`
}

// This type holds information about a campaign objective, which belongs to a campaign.
// An objective can hold multiple milestones which users can hit and get rewards.
// An objective can hold a cheer group.
type CampaignObjective struct {
	// Cheergroup this objective might belong to.
	Cheergroup *CampaignCheergroup `json:"cheergroup"`
	// Short description about the objective.
	Description string `json:"description"`
	// Unique identifier for the objective.
	ID string `json:"id"`
	// If the objective belongs to an active parent campaign.
	IsActive bool `json:"isActive"`
	// Milestones users can hit by advancing this objective.
	Milestones []*Milestone `json:"milestones"`
	// User's participation towards the objective.
	Participation int `json:"participation"`
	// Global progress for the objective.
	Progress int `json:"progress"`
	// The type of objective this is for. It can be either INDIVIDUAL or GLOBAL (TEAM is deprecated).
	Tag string `json:"tag"`
	// Short title for the objective.
	Title string `json:"title"`
}

// All Campaign properties that are running for a given user.
type CampaignProperties struct {
	// All the current active campaigns for a given user.
	ActiveCampaigns []string `json:"activeCampaigns"`
	// All the current domains a user is participating in.
	Domains []string `json:"domains"`
	// Determines whether or not a user has a pass they can sell on their channel.
	HasPass bool `json:"hasPass"`
	// Objectives users can progress within all the active campaigns for the first domain.
	Objectives []*CampaignObjective `json:"objectives"`
	// Triggers users can activate to get / give rewards within this campaign.
	Triggers []*CampaignTrigger `json:"triggers"`
}

// Metadata for the reward that only impacts how the rewards are rendered on the front end apps.
type CampaignRewardMetadata struct {
	// Whether the reward is initially unavailable upon redeeming.
	IsPending bool `json:"isPending"`
	// Reward subtype usually specific to the game the campaign belongs to (e.g. skin, spray, etc).
	SubType *string `json:"subType"`
}

// This type holds information about a campaign trigger, which belongs to a campaign.
// A trigger has a list of rewards that can be earned by various one time events.
type CampaignTrigger struct {
	// Short description about the trigger.
	Description string `json:"description"`
	// Unique identifier for the trigger.
	ID string `json:"id"`
	// Whether the trigger is currently active.
	IsActive bool `json:"isActive"`
	// List of rewards attached to this trigger.
	Rewards []*TournamentReward `json:"rewards"`
	// Short title for the trigger.
	Title string `json:"title"`
	// Maximum amount of trigger quantity required for the trigger (e.g. # of bits in cheer).
	TriggerAmountMax int `json:"triggerAmountMax"`
	// Minimum amount of trigger quantity required for the trigger (e.g. # of bits in cheer).
	TriggerAmountMin int `json:"triggerAmountMin"`
	// String defining the trigger type (e.g. CHEER).
	TriggerType TriggerType `json:"triggerType"`
}

// Error code for an error that occurs while canceling the active boosts.
type CancelActiveBoostOrdersError struct {
	// Error code for error that occurred while canceling the active boosts.
	Code CancelActiveBoostOrdersErrorCode `json:"code"`
}

// The required input for a cancelActiveBoostOrdersInput mutation.
type CancelActiveBoostOrdersInput struct {
	// The Id of the channel for which we want to cancel boosts.
	ChannelID string `json:"channelID"`
}

// Data that was mutated after canceling the active boosts.
type CancelActiveBoostOrdersPayload struct {
	// The possible error returned from the service.
	Error *CancelActiveBoostOrdersError `json:"error"`
}

// Error code for an error that occurs while canceling the bounty.
type CancelBountyError struct {
	// Error code for error that occurred while canceling the bounty.
	Code CancelBountyErrorCode `json:"code"`
}

// CancelBountyInput includes the bounty a user is trying to cancel.
type CancelBountyInput struct {
	// Unique Identifier for the bounty.
	BountyID string `json:"bountyID"`
	// Reason that the user canceled the bounty.
	Reason *string `json:"reason"`
	// UserID of the user that will cancel the bounty.
	UserID string `json:"userID"`
}

// Data that was mutated after canceling the bounty.
type CancelBountyPayload struct {
	// The canceled bounty with the updated status.
	Bounty *Bounty `json:"bounty"`
	// The possible error returned from the service.
	Error *CancelBountyError `json:"error"`
	// The user that now has the canceled bounty.
	User *User `json:"user"`
}

type CancelFriendRequestInput struct {
	// The authenticated user will cancel the friend request sent to the user with an ID equal to targetID.
	TargetID string `json:"targetID"`
}

type CancelFriendRequestPayload struct {
	// The user whose friend request was just cancelled.
	User *User `json:"user"`
}

// CancelPayoutOnboardingWorkflowInput returns the required input when starting a new workflow for payout onboarding.
type CancelPayoutOnboardingWorkflowInput struct {
	// TargetUserID is the ID of the user whose workflow will be started.
	TargetUserID string `json:"targetUserID"`
}

// CancelPayoutOnboardingWorkflowPayload is the payload returned after canceling a payout onboarding workflow.
type CancelPayoutOnboardingWorkflowPayload struct {
	// A new workflow status.
	Workflow *PayoutOnboardingWorkflow `json:"workflow"`
}

// An error returned from the cancelPredictionEvent mutation.
type CancelPredictionEventError struct {
	// Code describing the error.
	Code CancelPredictionEventErrorCode `json:"code"`
}

// Input for canceling a Prediction Event (and refunding all users who have contributed).
type CancelPredictionEventInput struct {
	// The unique identifier of the Prediction Event to cancel.
	ID string `json:"id"`
}

// Payload for canceling a Prediction Evnet.
type CancelPredictionEventPayload struct {
	// If present, there was an error with the request.
	Error *CancelPredictionEventError `json:"error"`
	// The canceled Prediction Event.
	PredictionEvent *PredictionEvent `json:"predictionEvent"`
}

// CancelRaidError is the error associated with a cancelRaid.
type CancelRaidError struct {
	// The associated error code.
	Code CancelRaidErrorCode `json:"code"`
}

// Inputs to the cancelRaid mutation.
type CancelRaidInput struct {
	// Source ID.
	SourceID string `json:"sourceID"`
}

// Outputs from the cancelRaid mutation.
type CancelRaidPayload struct {
	// The possible error returned from the service.
	Error *CancelRaidError `json:"error"`
	// The cancelled raid.
	Raid *Raid `json:"raid"`
}

// Inputs for the mutation. Gift to be canceled by productID and originID.
type CancelSubscriptionGiftInput struct {
	// originID is the origin id created during the gift purchase.
	OriginID string `json:"originID"`
	// productID is the ticket product id for this gift.
	ProductID string `json:"productID"`
}

// The returned payload from the mutation for canceling a Subscription Gift.
type CancelSubscriptionGiftPayload struct {
	// SubscriptionGift object that was deleted.
	Gift *SubscriptionGift `json:"gift"`
}

// Required input to cancel an unban request.
type CancelUnbanRequestInput struct {
	// ID of the unban request to be canceled.
	ID string `json:"id"`
}

// Result of canceling an unban request.
type CancelUnbanRequestPayload struct {
	// Used for errors arising from canceling the unban request.
	Error *UnbanRequestError `json:"error"`
	// The canceled unban request.
	UnbanRequest *UnbanRequest `json:"unbanRequest"`
}

// Celebration is a configuration that denotes when a celebration is triggerd and when sort of celebration will show when it triggers.
type Celebration struct {
	// Area of the channel page in which the celebration will appear.
	Area CelebrationArea `json:"area"`
	// Duration which the celebration will play.
	DurationMilliseconds int `json:"durationMilliseconds"`
	// Effect which will be shown when then celebration is triggered.
	Effect CelebrationEffect `json:"effect"`
	// Amount that needs to be met in order to trigger this celebration.
	// For example, when the event type is subscription gift, this value will
	// determine how many gifts must be given at a single time to trigger the
	// celebration.
	EventThreshold int `json:"eventThreshold"`
	// Type of event which will trigger this celebration.
	EventType CelebrationEventType `json:"eventType"`
	// Unique identifier for the celebration.
	ID string `json:"id"`
	// Intensity of the celebration.
	// Should be bounded (TBA) value which will determine the spectacle of the celebration.
	Intensity int `json:"intensity"`
	// If true, the celebration is enabled.
	IsEnabled bool `json:"isEnabled"`
}

// The channels configuration of celebrations.
type CelebrationConfig struct {
	// List of celebrations for this channel.
	Celebrations []*Celebration `json:"celebrations"`
	// The identifier for the celebration config.
	ID string `json:"id"`
	// If celebrations are enabled on this channel.
	IsEnabled bool `json:"isEnabled"`
}

// Celebration error.
type CelebrationError struct {
	// Code describing the error.
	Code CelebrationErrorCode `json:"code"`
}

// A celebration product that a user may purchase.
type CelebrationProduct struct {
	// A list of benefits the user will receive when purchasing the celebration product.
	Benefits []ProductCatalogBenefit `json:"benefits"`
	// A description of the product.
	Description *string `json:"description"`
	// The identifier of the celebration product.
	ID string `json:"id"`
	// The intensity of the celebration product.
	Intensity CelebrationIntensity `json:"intensity"`
	// Indicates if the celebration product is enabled for purchase in the channel.
	IsEnabled bool `json:"isEnabled"`
	// A list of offers available for purchasing this celbration product.
	Offers []*Offer `json:"offers"`
	// The owner (ex: channel) of the celebration product.
	Owner string `json:"owner"`
	// A list of potential offers that a broadcaster could set for purchasing this celebration product.
	PotentialOffers []*Offer `json:"potentialOffers"`
	// The title of the product.
	Title string `json:"title"`
}

func (CelebrationProduct) IsProductCatalogItem() {}

// A celebration product benefit the user will receive when purchasing the celebration product.
type CelebrationProductBenefit struct {
	// The identifier of the celebration product benefit.
	ID string `json:"id"`
}

func (CelebrationProductBenefit) IsProductCatalogBenefit() {}

// Configuration settings to change for a celebration product.
type CelebrationProductConfigInput struct {
	// The intensity of the celebration product.
	Intensity CelebrationIntensity `json:"intensity"`
	// If the celebration product is enabled for purchase in the channel.
	IsEnabled *bool `json:"isEnabled"`
	// ID of the offer (i.e. price) through which the celebration can be purchased in the channel.
	OfferID *string `json:"offerID"`
}

// A container for celebration settings for the logged in user.
type CelebrationUserSettings struct {
	// A boolean flag that denotes if the user has opted out of seeing celebrations.
	IsOptedOut bool `json:"isOptedOut"`
}

// A condition to be satisfied by a specific owner.
type ChallengeCondition struct {
	// When the condition was created.
	CreatedAt *time.Time `json:"createdAt"`
	// Settings that define how the effects of the condition participants associated with this condition will be processed.
	EffectSettings []*ChallengeEffectSettings `json:"effectSettings"`
	// Unique ID of the condition.
	ID string `json:"id"`
	// The name of the condition.
	Name string `json:"name"`
	// The user who creates and owns the condition.
	Owner *User `json:"owner"`
	// A summary of condition participants attached to the condition.
	ParticipantSummary *ChallengeConditionParticipantSummaryByState `json:"participantSummary"`
	// The current state of the condition.
	State ChallengeConditionState `json:"state"`
	// The list of effect types supported by this condition.
	SupportedEffects []ChallengeEffectType `json:"supportedEffects"`
	// When the condition times out.
	TimeoutAt *time.Time `json:"timeoutAt"`
	// When the condition was last modified.
	UpdatedAt *time.Time `json:"updatedAt"`
	// Whether the condition becomes inactive once it has been satisfied.
	WillDisableWhenSatisfied bool `json:"willDisableWhenSatisfied"`
}

// A condition participant action that will be taken if an associated condition is satisfied.
type ChallengeConditionParticipant struct {
	// The associated condition.
	Condition *ChallengeCondition `json:"condition"`
	// The effect that will occur if the condition participant is satisfied.
	Effect *ChallengeEffect `json:"effect"`
	// Final state of the condition participant.
	EndState ChallengeConditionParticipantEndState `json:"endState"`
	// Unique ID of the condition participant.
	ID string `json:"id"`
	// The user who creates and owns the condition participant.
	Owner *User `json:"owner"`
	// Whether or not the condition participant was successfully processed upon condition completion.
	ProcessingState ChallengeConditionParticipantProcessingState `json:"processingState"`
}

// A summary of participants attached to a particular condition in a particular state.
type ChallengeConditionParticipantSummary struct {
	// Summary of participant effects attached to a particular condition in a particular state.
	Effects *ChallengeEffectSummary `json:"effects"`
	// Total count of participants attached to a particular condition in a particular state.
	Total int `json:"total"`
}

// A summary of condition participants attached to a particular condition, grouped by state.
type ChallengeConditionParticipantSummaryByState struct {
	// Summary of participants attached to a particular condition in the CANCELED state.
	Canceled *ChallengeConditionParticipantSummary `json:"canceled"`
	// Summary of participants attached to a particular condition in the CONDITION_CANCELED state.
	ConditionCanceled *ChallengeConditionParticipantSummary `json:"conditionCanceled"`
	// Summary of participants attached to a particular condition in the CONDITION_TIMEOUT state.
	ConditionTimeout *ChallengeConditionParticipantSummary `json:"conditionTimeout"`
	// Summary of participants attached to a particular condition in the FAILED_VALIDATION state.
	FailedValidation *ChallengeConditionParticipantSummary `json:"failedValidation"`
	// Summary of participants attached to a particular condition in the PENDING state.
	Pending *ChallengeConditionParticipantSummary `json:"pending"`
	// Summary of participants attached to a particular condition in the SATISFIED state.
	Satisfied *ChallengeConditionParticipantSummary `json:"satisfied"`
	// Summary of participants attached to a particular condition in the TIMEOUT state.
	Timeout *ChallengeConditionParticipantSummary `json:"timeout"`
	// Total count of participants attached to a particular condition.
	Total int `json:"total"`
}

// An effect that will occur if a challenge condition participant is satisfied.
type ChallengeEffect struct {
	// Details of the effect.
	Details ChallengeEffectDetails `json:"details"`
	// The type of effect.
	Type ChallengeEffectType `json:"type"`
}

// Settings that define how effects will be processed when a condition is satisfied.
type ChallengeEffectSettings struct {
	// Details of the effect settings.
	Details ChallengeEffectSettingsDetails `json:"details"`
	// The type of effect.
	Type ChallengeEffectType `json:"type"`
}

// A summary of effects attached to a particular condition in a particular state. Keys correspond to ChallengeEffectType enum.
type ChallengeEffectSummary struct {
	// USE_BITS effects.
	UseBits *ChallengeUseBitsEffectSummary `json:"useBits"`
}

// Details of the UseBits effect.
type ChallengeUseBitsEffectDetails struct {
	// The user who uses the bits.
	Benefactor *User `json:"benefactor"`
	// The amount of bits to be used.
	BitsAmount int `json:"bitsAmount"`
}

func (ChallengeUseBitsEffectDetails) IsChallengeEffectDetails() {}

// Details of the UseBits effect settings.
type ChallengeUseBitsEffectSettingsDetails struct {
	// A list of the different bits recipients and their weighted share of the total bits pool once the condition is satisfied.
	BitsRecipientWeightedShares []*ChallengeUseBitsPoolRecipientWeightedShare `json:"bitsRecipientWeightedShares"`
}

func (ChallengeUseBitsEffectSettingsDetails) IsChallengeEffectSettingsDetails() {}

// A summary of USE_BITS effects attached to a particular condition in a particular state.
type ChallengeUseBitsEffectSummary struct {
	// Sum of Bits rolling up to a particular condition in a particular state.
	TotalBitsAmount int `json:"totalBitsAmount"`
	// Total count of USE_BITS effects rolling up to a particular condition in a particular state.
	TotalEffects int `json:"totalEffects"`
}

// ChallengeUseBitsPoolRecipientWeightedShare represents the weighted share of the total bits pool
// that a recipient user is entitled to upon condition satisfaction.
type ChallengeUseBitsPoolRecipientWeightedShare struct {
	// The bits recipient user.
	Recipient *User `json:"recipient"`
	// The weight of the recipient's share from the total bits pool. The sum of all the recipients' weights
	// dictates the proportion that a particular recipient receives from the pool (shareWeight/totalShareWeight * totalBitsAmountInPool).
	Weight int `json:"weight"`
}

// Error returned during an invalid change username request.
type ChangeUsernameCodeError struct {
	// Error code returned by the backend.
	Code ChangeUsernameErrorCode `json:"code"`
}

// Input for a change username.
type ChangeUsernameInput struct {
	// The new login for the user.
	Login string `json:"login"`
	// User id of the user being updated.
	UserID string `json:"userID"`
}

// The result of a change username.
type ChangeUsernamePayload struct {
	// Error code for error returned from change username.
	Error *ChangeUsernameCodeError `json:"error"`
	// The modified user.
	User *User `json:"user"`
}

// ChangelogEntry is an entry that displays new items and notifications in the creator homepage changelog.
type ChangelogEntry struct {
	// content is localized text content for the changelog entry.
	Content string `json:"content"`
	// iconURL is the url for the entry's icon image.
	IconURL string `json:"iconURL"`
	// id is a unique human readable slug for the entry e.g. "squad-stream".
	ID string `json:"id"`
	// linkText is the text that the linkURL should display.
	LinkText *string `json:"linkText"`
	// linkURL is an optional link for more content for this changelog entry.
	LinkURL *string `json:"linkURL"`
	// position is where entry should be located within changelog entries of the same date.
	Position int `json:"position"`
	// publishedAt is the timestamp that the changelog entry was published.
	PublishedAt *time.Time `json:"publishedAt"`
	// title is the localized title of the changelog entry.
	Title string `json:"title"`
}

// A User's place on Twitch.
type Channel struct {
	// All Prediction Events that are actively accepting new predictions.
	ActivePredictionEvents []*PredictionEvent `json:"activePredictionEvents"`
	// A list of content attributes created for the channel, that can be associated with the chanlets, to augment the multi-view experience.
	AvailableContentAttributes []*MultiviewContentAttribute `json:"availableContentAttributes"`
	// A list of available Drops that viewers of this channel can claim when certain game events are met.
	AvailableDrops []*DropObject `json:"availableDrops"`
	// A paginated list of users who are banned from this channel.
	BannedUsers *ChannelBannedUserConnection `json:"bannedUsers"`
	// The boost settings for the channel.
	BoostSettings *BoostSettings `json:"boostSettings"`
	// The language the broadcaster has chosen to stream in.
	BroadcasterLanguage string `json:"broadcasterLanguage"`
	// The celebration configuration for the channel, which contains if celebrations are enabled and a list of configured celebrations.
	Celebrations *CelebrationConfig `json:"celebrations"`
	// The stream key for this channel if it is a multi-view chanlet. The requesting user must "own" this chanlet to be authorized to see this.
	ChanletStreamKey *string `json:"chanletStreamKey"`
	// A list of the channel's chanlets (sub-channels) in a multi-view experience.
	Chanlets []*Channel `json:"chanlets"`
	// Get the chatters on this channel.
	Chatters *ChattersInfo `json:"chatters"`
	// The clip settings for a channel, includes settings on clip creation.
	ClipsSettings *ChannelClipsSettings `json:"clipsSettings"`
	// Get a single community points custom reward redemption by its ID.
	CommunityPointsCustomRewardRedemption *CommunityPointsCustomRewardRedemption `json:"communityPointsCustomRewardRedemption"`
	// The queue of community points custom reward redemptions in this channel.
	CommunityPointsRedemptionQueue *CommunityPointsCustomRewardRedemptionConnection `json:"communityPointsRedemptionQueue"`
	// Details about community points in the channel.
	CommunityPointsSettings *CommunityPointsChannelSettings `json:"communityPointsSettings"`
	// For a multi-view chanlet, this is the list of content attributes that have been associated with the given chanlet.
	ContentAttributes []*MultiviewContentAttribute `json:"contentAttributes"`
	// The channel's badge flair setting and assets that are available to eligible subscribers.
	CreatorBadgeFlair *CreatorBadgeFlair `json:"creatorBadgeFlair"`
	// Fetch the requesting user's currently playing radio content.
	CurrentRadioTrack *RadioCurrentlyPlaying `json:"currentRadioTrack"`
	// The channel's name, with user-specified formatting.
	DisplayName *string `json:"displayName"`
	// A drop 2.0 campaign including personal settings (e.g. account connection status). (Streamer dashboard individual item).
	DropCampaign *DropCampaign `json:"dropCampaign"`
	// A list of all available Drops 2.0 campaigns that a channel is eligible to participate in. (Streamer dashboard list).
	DropCampaigns []*DropCampaign `json:"dropCampaigns"`
	// founderBadgeAvailability is a number of available slots for Founder Badge entitlement.
	FounderBadgeAvailability int `json:"founderBadgeAvailability"`
	// The name of the last game played on this channel.
	Game string `json:"game"`
	// The Home of a channel.
	Home *ChannelHome `json:"home"`
	// The structure that contains information about the channel's Hype Train execution and config.
	HypeTrain *HypeTrain `json:"hypeTrain"`
	// The channel's unique identfier.
	ID string `json:"id"`
	// A setting which states whether or not users can create Clips on this channel.
	// By default, clipping on a channel is enabled.
	IsClipsEnabled bool `json:"isClipsEnabled"`
	// Whether or not the channel is a hidden multi-view chanlet that is only meant to be accessible through another channel and not exist as a completely independent channel.
	IsHiddenChanlet bool `json:"isHiddenChanlet"`
	// Whether the broadcaster has designated the channel's broadcast for mature audiences only.
	IsMature bool `json:"isMature"`
	// Whether the channel has opted out of drops.
	IsOptedOutOfDrops *bool `json:"isOptedOutOfDrops"`
	// leaderboardSet contains the set of leaderboards that are active on this channel.
	LeaderboardSet *LeaderboardSet `json:"leaderboardSet"`
	// leaderboardTimePeriod indicates whether the leaderboard type is of WEEKLY, ALL-TIME, etc.
	LeaderboardTimePeriod *LeaderboardTimePeriodType `json:"leaderboardTimePeriod"`
	// All Prediction Events that are no longer accepting new predictions, and are awaiting resolution.
	LockedPredictionEvents []*PredictionEvent `json:"lockedPredictionEvents"`
	// Returns a resolver to query moderation logs.
	ModerationLogs *ModerationLogs `json:"moderationLogs"`
	// The channel's name.
	Name string `json:"name"`
	// The user who owns this channel.
	Owner *User `json:"owner"`
	// Configurations for chanlets this channel owns.
	OwnerChanletAttributes *OwnerChanletAttributes `json:"ownerChanletAttributes"`
	// Settings dictating how Prediction Events are run on this channel.
	PredictionSettings *ChannelPredictionSettings `json:"predictionSettings"`
	// Fetches most recent chat messages sent for the given channel.
	RecentChatMessages []*Message `json:"recentChatMessages"`
	// A single page of Prediction Events that have been resolved.
	ResolvedPredictionEvents *PredictionEventConnection `json:"resolvedPredictionEvents"`
	// The restriction that is currently active on the channel for restricting a user's access to it.
	Restriction *ResourceRestriction `json:"restriction"`
	// The stream schedule of the user.
	// Returns null when the user has not set a schedule.
	Schedule *Schedule `json:"schedule"`
	// The requesting user's relationship with the channel.
	Self *ChannelSelfEdge `json:"self"`
	// Extension information pertaining to the active user. Note that this is not part of the `self` property as this still returns data for anonymous users.
	SelfInstalledExtensions []*ExtensionInstallationSelfEdge `json:"selfInstalledExtensions"`
	// The channel's social media links and favicons.
	SocialMedias []*SocialMedia `json:"socialMedias"`
	// A user-defined status message.
	Status string `json:"status"`
	// The live broadcast associated with this channel, if currently broadcasting.
	Stream *Stream `json:"stream"`
	// A list of streams for a given channel for multi-view.
	Streams []*Stream `json:"streams"`
	// Channel trailer for this channel.
	Trailer *Trailer `json:"trailer"`
	// Requests from channel-banned users to be unbanned submitted on the channel.
	// Accessible by users with moderator role or higher.
	UnbanRequests *UnbanRequestConnection `json:"unbanRequests"`
	// Settings for users creating unban requests on the channel.
	UnbanRequestsSettings *UnbanRequestsSettings `json:"unbanRequestsSettings"`
	// The URL to view the channel in a browser.
	URL string `json:"url"`
	// Video stream settings for ingesting a stream such as stream key, latency mode, or vod save preference.
	VideoStreamSettings *VideoStreamSettings `json:"videoStreamSettings"`
	// A list of available Drop 2.0 Campaigns of which drops viewers of this channel can claim when certain game events or minutes watched events are met. (Channel highlight card).
	ViewerDropCampaigns []*DropCampaign `json:"viewerDropCampaigns"`
}

func (Channel) IsRecommendationFeedbackContent() {}

// Channel Analytics in Creator Dashboard.
type ChannelAnalytics struct {
	// SubCountSeries in Channel Analytics that shows a user's sub count over time.
	SubCountSeries *SubCountSeries `json:"subCountSeries"`
}

// Analytics around what other content my viewers watch.
type ChannelAnalyticsContentOverlap struct {
	// Other channels that my viewers like to watch.
	Channels []*ChannelOverlap `json:"channels"`
	// Games that my viewers like to watch.
	Games []*GameOverlap `json:"games"`
}

// ChannelBannedUser is an object that defines metadata about a channel ban.
type ChannelBannedUser struct {
	// When the ban was created.
	BannedAt time.Time `json:"bannedAt"`
	// Representation of the banned user.
	BannedUser *User `json:"bannedUser"`
	// Representation of the mod that banned the user.
	ModUser *User `json:"modUser"`
}

// Paginated list of users banned from a channel.
type ChannelBannedUserConnection struct {
	// The elements of the list.
	Edges []*ChannelBannedUserEdge `json:"edges"`
	// Information about this page of banned users.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Element in a list of users banned from a channel.
type ChannelBannedUserEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// A ban record for a user banned from a channel.
	Node *ChannelBannedUser `json:"node"`
}

// ChannelBlockedTerm is an object that defines things that automod should permit in a channel.
type ChannelBlockedTerm struct {
	// If the term is permitted or banned type.
	Category string `json:"category"`
	// When the term was created.
	CreatedAt *time.Time `json:"createdAt"`
	// When the term expires at.
	ExpiresAt *time.Time `json:"expiresAt"`
	// If mods should be able to see and edit this term.
	IsModEditable bool `json:"isModEditable"`
	// phrases are the string representation of a term.
	Phrases []string `json:"phrases"`
	// Where the term came from, usually a mod user ID.
	Source *string `json:"source"`
	// When the term was last updated.
	UpdatedAt *time.Time `json:"updatedAt"`
}

// A connection between the challenge and metadata.
type ChannelChallengeConnection struct {
	// The list of challenges for the user.
	Edges []*ChannelChallengeEdge `json:"edges"`
	// Information about pagination in this connection.
	PageInfo *PageInfo `json:"pageInfo"`
}

// A page entry, that contains the Challenge item and a cursor to return from the query to allow pagination.
type ChannelChallengeEdge struct {
	// Cursor used for next query.
	Cursor string `json:"cursor"`
	// The underlying challenge.
	Node ChannelChallenge `json:"node"`
}

// A participant contributing to a challenge and associated information.
type ChannelChallengeParticipant struct {
	// The bits this participant has contributed to a challenge.
	Bits int `json:"bits"`
	// The Challenge this participant contributed to.
	Challenge ChannelChallenge `json:"challenge"`
	// Time when participant first contributed to the challenge.
	FirstContributedAt time.Time `json:"firstContributedAt"`
	// id of the participant in the challenge.
	ID string `json:"id"`
	// Time when participant last contributed to the challenge.
	LastContributedAt time.Time `json:"lastContributedAt"`
}

// A connection between a challenge and the authenticated user.
type ChannelChallengeSelfEdge struct {
	// The participant object pertaining to the authenticated user.
	Participant *ChannelChallengeParticipant `json:"participant"`
}

// ChannelClipsCreationAuthRestrictionOptionsInput are the additional options for the auth restrictions.
type ChannelClipsCreationAuthRestrictionOptionsInput struct {
	// The time requirement in minutes, of how long a follower needs to be following to create clips.
	FollowingLengthMinutes *int `json:"followingLengthMinutes"`
}

// ChannelClipsCreationRestrictedTo contains the roles that are allowed to create Clips on a channel
// that has isClipsEnabled set to true.
type ChannelClipsCreationRestrictedTo struct {
	// Clip creation is restricted to users that are followers.
	IsFollower bool `json:"isFollower"`
	// Clip creation is restricted to users that are subscribers.
	IsSubscriber bool `json:"isSubscriber"`
}

// ChannelClipsCreationRestrictedToInput contains the roles that are allowed to create Clips on a channel
// that has isClipsEnabled set to true.
type ChannelClipsCreationRestrictedToInput struct {
	// Allow channel followers to create Clips.
	Followers bool `json:"followers"`
	// Allow channel subscribers to create Clips.
	Subscribers bool `json:"subscribers"`
}

// ChannelClipsCreationRestrictionOptions are the additional options for the auth restrictions.
type ChannelClipsCreationRestrictionOptions struct {
	// The time requirement in minutes, of how long a follower needs to be following to create clips.
	FollowingLengthMinutes *int `json:"followingLengthMinutes"`
}

// ChannelClipsSettings are the clips setting for the channel, including restriction settings for clip creation.
type ChannelClipsSettings struct {
	// If isClipsEnabled is true, allow the following roles to create Clips on the channel.
	CreationRestrictedTo *ChannelClipsCreationRestrictedTo `json:"creationRestrictedTo"`
	// If there are clip creation restrictions, use the following to add options to those restrictions.
	CreationRestrictionOptions *ChannelClipsCreationRestrictionOptions `json:"creationRestrictionOptions"`
	// Set whether or not users can create Clips on this channel.
	IsClipsCreationEnabled bool `json:"isClipsCreationEnabled"`
}

// The Home of a channel.
type ChannelHome struct {
	// The preferences that power a channel's home page.
	Preferences *ChannelHomePreferences `json:"preferences"`
	// The shelves that are shown on a channel's home page.
	Shelves *ChannelHomeShelves `json:"shelves"`
}

// A list of categories displayed on a channel home's Category Shelf.
type ChannelHomeCategoryShelf struct {
	// The list of categories to display in the shelf.
	Edges []*ChannelHomeCategoryShelfEdge `json:"edges"`
}

// The edges of the channel home category shelf.
type ChannelHomeCategoryShelfEdge struct {
	// The category to display in the shelf.
	Node *Game `json:"node"`
}

// A list of categories displayed on a channel home's Category Shelf.
type ChannelHomeCategorySuggestionsShelf struct {
	// The list of categories to display in the shelf.
	Edges []*ChannelHomeCategorySuggestionsShelfEdge `json:"edges"`
}

// Contains a category and a boolean to denote whether the user has chosen to hide that category from their channel home page's category shelf.
type ChannelHomeCategorySuggestionsShelfEdge struct {
	// This is true if the user has chosen to hide this category from their category shelf.
	IsHidden bool `json:"isHidden"`
	// The category.
	Node *Game `json:"node"`
}

// The streamer's channel home preferences.
type ChannelHomePreferences struct {
	// The hero preset.
	HeroPreset HeroPreset `json:"heroPreset"`
	// The type of streamer shelf to display.
	StreamerShelfType StreamerShelfType `json:"streamerShelfType"`
}

// The shelves that are shown on a channel's home page.
type ChannelHomeShelves struct {
	// A list of categories displayed on a channel home's Category Shelf.
	CategoryShelf *ChannelHomeCategoryShelf `json:"categoryShelf"`
	// A list of suggested categories to display on a channel home's Category Shelf.
	CategoryShelfSuggestions *ChannelHomeCategorySuggestionsShelf `json:"categoryShelfSuggestions"`
	// The type and, if applicable, the list of users displayed in a channel home's Streamer Shelf.
	StreamerShelf *ChannelHomeStreamerShelf `json:"streamerShelf"`
}

// The list of users displayed in a channel home's Streamer Shelf.
type ChannelHomeStreamerShelf struct {
	// The list of users to display in the shelf.
	Edges []*ChannelHomeStreamerShelfEdge `json:"edges"`
	// The type of streamer shelf to display (Autohost, Team, or Disabled).
	Type StreamerShelfType `json:"type"`
}

// The edges of the channel home streamer shelf.
type ChannelHomeStreamerShelfEdge struct {
	// The user to display in the shelf.
	Node *User `json:"node"`
}

// Paginated list of moderation actions on a channel.
type ChannelModerationActionConnection struct {
	// List of moderation actions.
	Edges []*ChannelModerationActionEdge `json:"edges"`
	// Information about page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Element in a list of moderation actions of a user on a channel.
type ChannelModerationActionEdge struct {
	// A cursor for the current node.
	Cursor string `json:"cursor"`
	// A moderation action.
	Node ChannelModerationActionEntry `json:"node"`
}

// Moderation Actions relating to automod levels.
// ex: automod level change.
type ChannelModerationActionOnAutomodLevelEntry struct {
	// The action that was taken.
	Action ModerationAction `json:"action"`
	// New automod level properties.
	AutomodNewProperties *AutoModProperties `json:"automodNewProperties"`
	// Previous automod level properties.
	AutomodOldProperties *AutoModProperties `json:"automodOldProperties"`
	// Timestamp when action was taken.
	CreatedAt time.Time `json:"createdAt"`
	// UUID of the moderation action.
	ID string `json:"id"`
	// The moderator who took the action.
	Moderator *User `json:"moderator"`
}

func (ChannelModerationActionOnAutomodLevelEntry) IsChannelModerationActionEntry() {}

// Moderation Actions relating to automod terms.
// ex: add permitted term, remove permitted term, add banned term, remove banned term.
type ChannelModerationActionOnAutomodTermEntry struct {
	// The action that was taken.
	Action ModerationAction `json:"action"`
	// Timestamp when action was taken.
	CreatedAt time.Time `json:"createdAt"`
	// UUID of the moderation action.
	ID string `json:"id"`
	// If the action originated from a message caught by Automod.
	IsFromAutomod bool `json:"isFromAutomod"`
	// The moderator who took the action.
	Moderator *User `json:"moderator"`
	// Strings that were add/deleted from permitted/blocked lists.
	Terms []string `json:"terms"`
}

func (ChannelModerationActionOnAutomodTermEntry) IsChannelModerationActionEntry() {}

// Moderation Actions relating to another channel.
// ex: host, unhost, raid, unraid.
type ChannelModerationActionOnChannelEntry struct {
	// The action that was taken.
	Action ModerationAction `json:"action"`
	// Timestamp when action was taken.
	CreatedAt time.Time `json:"createdAt"`
	// UUID of the moderation action.
	ID string `json:"id"`
	// Is auto hosted.
	IsAutoHosted bool `json:"isAutoHosted"`
	// Is hosted after raiding.
	IsHostedAfterRaiding bool `json:"isHostedAfterRaiding"`
	// The moderator who took the action.
	Moderator *User `json:"moderator"`
	// Should the viewer count for host or raids should be shown.
	ShouldRevealViewerCount bool `json:"shouldRevealViewerCount"`
	// Target channel for hosting and raiding.
	Target *User `json:"target"`
	// How many users participated in a host or raid.
	ViewerCount *int `json:"viewerCount"`
}

func (ChannelModerationActionOnChannelEntry) IsChannelModerationActionEntry() {}

// Moderation Actions relating to chat messages.
// ex: delete message.
type ChannelModerationActionOnChatMessageEntry struct {
	// The action that was taken.
	Action ModerationAction `json:"action"`
	// Timestamp when action was taken.
	CreatedAt time.Time `json:"createdAt"`
	// UUID of the moderation action.
	ID string `json:"id"`
	// The message contents of the message deleted.
	MessageBody *string `json:"messageBody"`
	// The id of the message deleted.
	MessageID *string `json:"messageID"`
	// The sender of the message.
	MessageSender *User `json:"messageSender"`
	// The moderator who took the action.
	Moderator *User `json:"moderator"`
}

func (ChannelModerationActionOnChatMessageEntry) IsChannelModerationActionEntry() {}

// Moderation Actions realting to chat modes.
// ex: slow on, followers only on, emotes only, sub only, clear chat.
type ChannelModerationActionOnChatModeEntry struct {
	// The action that was taken.
	Action ModerationAction `json:"action"`
	// Timestamp when action was taken.
	CreatedAt time.Time `json:"createdAt"`
	// Duration of the chat time in seconds.
	DurationSeconds *int `json:"durationSeconds"`
	// UUID of the moderation action.
	ID string `json:"id"`
	// The moderator who took the action.
	Moderator *User `json:"moderator"`
}

func (ChannelModerationActionOnChatModeEntry) IsChannelModerationActionEntry() {}

// Moderation Actions relating to unban requests.
// ex: approve, deny.
type ChannelModerationActionOnUnbanRequestsEntry struct {
	// The action that was taken.
	Action ModerationAction `json:"action"`
	// Timestamp when action was taken.
	CreatedAt time.Time `json:"createdAt"`
	// UUID of the moderation action.
	ID string `json:"id"`
	// The moderator who took the action.
	Moderator *User `json:"moderator"`
	// Reason for action.
	Reason string `json:"reason"`
	// The user which the action targets if any.
	Target *User `json:"target"`
}

func (ChannelModerationActionOnUnbanRequestsEntry) IsChannelModerationActionEntry() {}

// Moderation Actions relating to a user.
// ex: ban, unban, timeout, untimeout, mod, unmod, vip, unvip.
type ChannelModerationActionOnUserEntry struct {
	// The action that was taken.
	Action ModerationAction `json:"action"`
	// Timestamp when action was taken.
	CreatedAt time.Time `json:"createdAt"`
	// Duration of the chat time in seconds for timeouts.
	DurationSeconds *int `json:"durationSeconds"`
	// UUID of the moderation action.
	ID string `json:"id"`
	// The moderator who took the action.
	Moderator *User `json:"moderator"`
	// Reason for action.
	Reason string `json:"reason"`
	// The user which the action targets if any.
	Target *User `json:"target"`
}

func (ChannelModerationActionOnUserEntry) IsChannelModerationActionEntry() {}

// Moderation Actions that are unused, invalid or deprecated.
type ChannelModerationActionOtherEntry struct {
	// The action that was taken.
	Action ModerationAction `json:"action"`
	// Timestamp when action was taken.
	CreatedAt time.Time `json:"createdAt"`
	// UUID of the moderation action.
	ID string `json:"id"`
	// The moderator who took the action.
	Moderator *User `json:"moderator"`
}

func (ChannelModerationActionOtherEntry) IsChannelModerationActionEntry() {}

type ChannelNotificationSetting struct {
	// The setting category.
	Category string `json:"category"`
	// Whether this setting is on or off for the given event.
	IsEnabled bool `json:"isEnabled"`
	// The exact state of the setting. ("on", "off", "friends_only", etc).
	SettingState string `json:"settingState"`
}

// Data about notification settings for a follow relationship.
type ChannelNotificationSettings struct {
	// If true, enabled notifications will be send. If false, all notifications are disabled, even if their individual setting is enabled.
	IsEnabled bool `json:"isEnabled"`
	// A list of channel notification settings.
	Nodes []*ChannelNotificationSetting `json:"nodes"`
}

// Channel that my viewers also like to watch.
type ChannelOverlap struct {
	// How much my viewers like to watch this channel.
	Score float64 `json:"score"`
	// Channel that my viewers also like to watch.
	ViewersAlsoWatch *User `json:"viewersAlsoWatch"`
}

// ChannelPermittedTerm is an object that defines things that automod should permit in a channel.
type ChannelPermittedTerm struct {
	// If the term is permitted or banned type.
	Category string `json:"category"`
	// When the term was created.
	CreatedAt *time.Time `json:"createdAt"`
	// When the term expires at.
	ExpiresAt *time.Time `json:"expiresAt"`
	// If mods should be able to see and edit this term.
	IsModEditable bool `json:"isModEditable"`
	// phrases are the string representation of a term.
	Phrases []string `json:"phrases"`
	// Where the term came from, usually a mod user ID.
	Source *string `json:"source"`
	// When the term was last updated.
	UpdatedAt *time.Time `json:"updatedAt"`
}

// Settings dictating how Prediction Events are run on a channel.
type ChannelPredictionSettings struct {
	// Whether channel moderators are allowed to create and resolve Prediction Events.
	CanModeratorsManagePredictions bool `json:"canModeratorsManagePredictions"`
	// Whether the channel is allowed to run Prediction Events at all.
	IsEligibleForPredictions bool `json:"isEligibleForPredictions"`
}

// A restriction for a specific channel.
type ChannelRestriction struct {
	// The time that the restriction is no longer active.
	EndsAt *time.Time `json:"endsAt"`
	// Information about being exempt from the restriction.
	ExemptionInfo *ChannelRestrictionExemptionInfo `json:"exemptionInfo"`
	// The ID of the channel restriction.
	ID string `json:"id"`
	// The time that the restriction becomes active.
	StartsAt *time.Time `json:"startsAt"`
	// The type of restriction on this channel.
	Type ChannelRestrictionType `json:"type"`
}

// Exemption information for a specific channel restriction.
type ChannelRestrictionExemptionInfo struct {
	// The type of exemption.
	ExemptionType string `json:"exemptionType"`
}

// Information about the requesting user with respect to a channel.
type ChannelSelfEdge struct {
	// Whether or not the requesting user can request an unban on the channel.
	CanRequestUnban *bool `json:"canRequestUnban"`
	// Properties relating to the authenticated user's community points in a channel.
	// Null if community points are not enabled in the channel.
	CommunityPoints *CommunityPointsProperties `json:"communityPoints"`
	// Whether or not the requesting user is authorized to view the channel's content in a channel restrictions context.
	IsAuthorized bool `json:"isAuthorized"`
	// Whether or not the resource is restricted for the requesting user.
	IsResourceRestricted bool `json:"isResourceRestricted"`
	// Returns the user's last unban request on the channel.
	LastUnbanRequest *UnbanRequest `json:"lastUnbanRequest"`
	// Chat messages sent in a channel that are relevant to moderators.
	ModChatLogs *ModLogsMessageConnection `json:"modChatLogs"`
	// List of channel feature permissions the logged in user has on the channel.
	Permissions []ChannelPermission `json:"permissions"`
	// Channel's layout of quick actions on stream manager page.
	QuickActionLayout *QuickActionLayout `json:"quickActionLayout"`
	// Channel's store of quick actions on stream manager page.
	QuickActionStore *QuickActionStore `json:"quickActionStore"`
	// List of recent (either still active or recently resolved) Predictions made by this user on this Channel.
	RecentPredictions []*Prediction `json:"recentPredictions"`
	// If restricted, how the resource is restricted.
	RestrictionType *ResourceRestrictionType `json:"restrictionType"`
	// Reason why user cannot request an unban on the channel.
	UnbanRequestRestriction *UnbanRequestRestrictionReason `json:"unbanRequestRestriction"`
}

// Information about the intended device for making a refill purchase for a user.
type ChargeInstrument struct {
	// A charge instrument Id.
	ID string `json:"id"`
}

// Input charge instrument information.
type ChargeInstrumentInput struct {
	// A charge instrument Id.
	ID string `json:"id"`
}

// ChargeModel describes the model used for charging the user. Will only contain one credit model, one external model, or one internal model.
type ChargeModel struct {
	// A charge model in which a user is charged using credits purchased or earned on Twitch.
	Credit *CreditChargeModel `json:"credit"`
	// A charge model in which a user is charged via a third-party in a fiat currency.
	External *ExternalChargeModel `json:"external"`
	// A charge model in which a user is charged by Twitch in a fiat currency.
	Internal *InternalChargeModel `json:"internal"`
}

// ChargeModelPlan defines the payment plan of the charge model.
type ChargeModelPlan struct {
	// The time interval for the charge model.
	Interval *ChargeModelPlanInterval `json:"interval"`
	// The renewal policy for the charge model.
	RenewalPolicy RenewalPolicy `json:"renewalPolicy"`
}

// ChargeModelPlanInterval is the time interval for the charge model.
type ChargeModelPlanInterval struct {
	// The duration of the charge model interval (used with the unit).
	Duration int `json:"duration"`
	// The unit of the charge model interval.
	Unit ChargeModelPlanIntervalUnit `json:"unit"`
}

type ChatRoomBanStatus struct {
	// The user being banned of this chat.
	BannedUser *User `json:"bannedUser"`
	// The time the ban was imposed.
	CreatedAt time.Time `json:"createdAt"`
	// The time at which the ban will automatically expire.
	ExpiresAt *time.Time `json:"expiresAt"`
	// The time in ms at which the ban will expire.
	ExpiresInMs *int `json:"expiresInMs"`
	// Conveys if the ban is permanent.
	IsPermanent bool `json:"isPermanent"`
	// The moderator that carried out the action.
	Moderator *User `json:"moderator"`
	// The reason the user was banned.
	Reason *string `json:"reason"`
	// The entity representing the users channel or chat room.
	RoomOwner *User `json:"roomOwner"`
}

// ChatSettings are settings and rules for chatting in a channel.
type ChatSettings struct {
	// autoModLevel is an integer from 0-4 representing the level of automoderation of chat
	// 0 is off, 4 is the highest level of moderation.
	AutoModLevel int `json:"autoModLevel"`
	// blockLinks indicates if links should be deleted from non-mod messages.
	BlockLinks bool `json:"blockLinks"`
	// chatDelayMs is the delay before non-mods see a message.
	ChatDelayMs int `json:"chatDelayMs"`
	// The number of minutes a user must be following the broadcaster in order to chat
	// If value is null, followers only mode is not enabled.
	FollowersOnlyDurationMinutes *int `json:"followersOnlyDurationMinutes"`
	// isBroadcasterLanguageModeEnabled indicates if the broadcaster requires chat messages to
	// match their language.
	IsBroadcasterLanguageModeEnabled bool `json:"isBroadcasterLanguageModeEnabled"`
	// Indicates whether chat is currently enforcing that messages may only contain emotes.
	IsEmoteOnlyModeEnabled bool `json:"isEmoteOnlyModeEnabled"`
	// Indicates whether subscribers are allowed to bypass slowmode.
	IsFastSubsModeEnabled bool `json:"isFastSubsModeEnabled"`
	// If isOptedOutOfGlobalBannedWordsList is true, the legacy twitch banned words list will
	// be inserted into automod if the channel has automod enabled.
	IsOptedOutOfGlobalBannedWordsList bool `json:"isOptedOutOfGlobalBannedWordsList"`
	// Indicates whether chat is currently restricted to subscribers only.
	IsSubscribersOnlyModeEnabled bool `json:"isSubscribersOnlyModeEnabled"`
	// Indicates whether chat is currently enforcing that messages must be reasonably unique
	// from recent messages. Previously known as "r9k mode".
	IsUniqueChatModeEnabled bool `json:"isUniqueChatModeEnabled"`
	// requireVerifiedAccount indicates if users must be verified to chat.
	RequireVerifiedAccount bool `json:"requireVerifiedAccount"`
	// rules is a list of rules to display to users when joining a chat channel.
	Rules []string `json:"rules"`
	// The number of seconds a user must wait in between sending chat messages
	// If value is null, slow mode is not enabled.
	SlowModeDurationSeconds *int `json:"slowModeDurationSeconds"`
}

// Various user specific settings on how to render chat.
type ChatUISettings struct {
	// Setting to store the user's preferred way to pause chat when moderating.
	ChatPauseSetting *ChatPauseSetting `json:"chatPauseSetting"`
	// Setting for how deleted messages should be displayed for channel broadcaster or moderator.
	DeletedMessageDisplaySetting *DeletedMessageDisplaySetting `json:"deletedMessageDisplaySetting"`
	// Whether emote animations are enabled.
	IsEmoteAnimationsEnabled *bool `json:"isEmoteAnimationsEnabled"`
	// Whether readable chat colors are enabled.
	IsReadableChatColorsEnabled *bool `json:"isReadableChatColorsEnabled"`
}

// User info about the chatter.
type Chatter struct {
	// User login of the chatter.
	Login string `json:"login"`
}

// Information about the active chatters on a channel.
type ChattersInfo struct {
	// List with the broadcaster.
	Broadcasters []*Chatter `json:"broadcasters"`
	// Number of active chatters.
	Count int `json:"count"`
	// List of active moderators.
	Moderators []*Chatter `json:"moderators"`
	// List of active staff members.
	Staff []*Chatter `json:"staff"`
	// List of active viewers.
	Viewers []*Chatter `json:"viewers"`
	// List of active VIPs.
	Vips []*Chatter `json:"vips"`
}

// Configs that help initiate the bits checkout flow.
type CheckoutConfiguration struct {
	// Contains configuration (e.g. iFrameURL) to enable completing purchases via Xsolla, a payment provider.
	Xsolla *Xsolla `json:"xsolla"`
}

// Inputs for checkoutConfiguration.
type CheckoutConfigurationInput struct {
	// Whether the gift is anonymous.
	IsAnonymous *bool `json:"isAnonymous"`
	// Whether the purchase is a gift.
	IsGift bool `json:"isGift"`
	// Whether the user is reactivating their subscription with a recurring or non-recurring payment plan.
	IsReactivateRecurring *bool `json:"isReactivateRecurring"`
	// The number of gifts being purchased.
	MysteryGiftCount *int `json:"mysteryGiftCount"`
	// Payment's session tracking.
	PaymentSession *PaymentSession `json:"paymentSession"`
	// The ID of the gift recipient.
	RecipientID *string `json:"recipientID"`
	// The country code for tax purposes.
	TaxCountryCode *string `json:"taxCountryCode"`
}

// Price information about an item in the checkout process.
type CheckoutPriceSummary struct {
	// The currency associated with the price of a subscription product.
	Currency Currency `json:"currency"`
	// The description associated with pricing information.
	Description string `json:"description"`
	// The discounted total with breakdown by discounted price and tax.
	Discount *DiscountBreakdown `json:"discount"`
	// The ISO-4217 wording of deriving price.
	Exponent int `json:"exponent"`
	// Identifier used for caching.
	ID string `json:"id"`
	// If the tax is already included in price.
	IsTaxInclusive bool `json:"isTaxInclusive"`
	// The numerical price of a subscription product.
	Price int `json:"price"`
	// Pricing identifier of the item being purchased.
	PricingIdentifier string `json:"pricingIdentifier"`
	// The tax rate of localized product.
	Tax int `json:"tax"`
	// The total price given price and tax.
	Total int `json:"total"`
}

// CheerInfo is the channel-specific bits/cheer settings and current state.
type CheerInfo struct {
	// Gets the list of available bits badges the user offers.
	AvailableBadges []*Badge `json:"availableBadges"`
	// Badge tier emotes are the emotes in this channel that are unlocked when a user unlocks a Bits badge tier.
	// Filter determines which emotes are returned.
	BadgeTierEmotes []*Emote `json:"badgeTierEmotes"`
	// cheerGroups contain all of the channel-specific Cheermotes, grouped by type.
	CheerGroups []*CheermoteGroup `json:"cheerGroups"`
	// emotes are the metadata about the different cheermotes that can be use to cheer in this channel.
	// This can optionally be filtered to return only certain cheermotes by either prefix and/or emote types.
	// If `prefixes` is null or empty all available cheermotes will be returned, and then `type` filter
	// will be applied to the result unless it's null or empty.
	// If includeUpperTiers is true, the upper tiers of the cheermotes will be returned.
	Emotes []*Cheermote `json:"emotes"`
	// hashtags for augmenting cheering with different actions, such as #charity will donate bits to
	// charity, or like #eddie to cheer and support Eddie.
	Hashtags *BitsHashtagConnection `json:"hashtags"`
	ID       string                 `json:"id"`
	// leaderboard contains the top users by number of bits cheered for the channel.
	Leaderboard *BitsLeaderboard `json:"leaderboard"`
	// recentTimeoutMs is the remaining duration the recent message will be pinned for.
	// This feature is deprecated and will always return 0.
	RecentTimeoutMs int `json:"recentTimeoutMs"`
	// settings are the channel-specific cheer settings.
	Settings *CheerSettings `json:"settings"`
}

// Bits partner settings associated with the badges.
type CheerPartnerBadgeSettings struct {
	// Whether or not the broadcaster is enabled to upload bits badge tier emote rewards.
	CanUploadBadgeTierEmoticons *bool `json:"canUploadBadgeTierEmoticons"`
	// A list of tiers, starting from 1 bit to as high as 5,000,000 bits.
	Tiers []*BitsBadgeTier `json:"tiers"`
}

// Bits partner settings associated with the chat message.
type CheerPartnerChatMessageSettings struct {
	// The setting that controls if the user has project v enabled on their channel.
	IsOptedOutOfProjectV bool `json:"isOptedOutOfProjectV"`
	// The minimum setting that controls the minimum bits that must be part of a cheer emote.
	MinBitsPerEmote int `json:"minBitsPerEmote"`
	// The minimum setting that controls the minimum amount a user must cheer in the channel.
	MinBitsToCheer int `json:"minBitsToCheer"`
}

// Bits partner dashboard settings for the bits cheer bomb events.
type CheerPartnerCheerBombSettings struct {
	// Flag that is true if the user has opted out of seasonal cheer bomb events.
	IsOptedOut bool `json:"isOptedOut"`
}

// Bits partner settings for custom cheermote prefix.
type CheerPartnerCustomPrefixSettings struct {
	// Flag that is set if the user has the custom cheermote prefix enabled.
	IsEnabled bool `json:"isEnabled"`
	// The prefix string that is used in their channel for their custom cheermote.
	Prefix string `json:"prefix"`
	// The custom prefix images that have been uploaded by the user.
	Tiers []*CheermoteTier `json:"tiers"`
}

// Bits partner dashboard settings for the bits leaderboard.
type CheerPartnerLeaderboardSettings struct {
	// Flag that is true if the user has bits leaderboards turned on.
	IsEnabled bool `json:"isEnabled"`
	// The time period the user wants the leaderboard to be displayed as.
	TimePeriod LeaderboardTimePeriodType `json:"timePeriod"`
}

// Bits partner settings associated with recent cheers.
type CheerPartnerRecentCheerSettings struct {
	// Flag that when true pins the recent cheer to their channel.
	CanPin bool `json:"canPin"`
	// The minimum bits a user must cheer to show their cheer on the chat header.
	MinimumBits int `json:"minimumBits"`
	// The amount of time a recent cheer is shown before being dismissed.
	TimeoutMilliseconds int `json:"timeoutMilliseconds"`
}

// Cheer settings, configured in their partner dashboard.
type CheerPartnerSettings struct {
	// Partner settings related to bit badges.
	Badges *CheerPartnerBadgeSettings `json:"badges"`
	// Partner settings related to chat messages with bits.
	ChatMessage *CheerPartnerChatMessageSettings `json:"chatMessage"`
	// Partner settings related to seasonal cheer bomb events.
	CheerBomb *CheerPartnerCheerBombSettings `json:"cheerBomb"`
	// Partner settings related to the custom cheermote prefix.
	CustomPrefix *CheerPartnerCustomPrefixSettings `json:"customPrefix"`
	// Flag that is set when a user has filled out the bits legal ammendement.
	// This can be true and isOnboarding false for legacy partners who onboarded before bits.
	HasSignedBitsAmendment bool `json:"hasSignedBitsAmendment"`
	// An ID used for caching purposes for Apollo.
	ID string `json:"id"`
	// Flag that is set when a user has been onboarded for bits usage.
	IsOnboarded bool `json:"isOnboarded"`
	// Partner settings related to the bits leaderboard.
	Leaderboard *CheerPartnerLeaderboardSettings `json:"leaderboard"`
	// Partner settings related to the recent cheer message.
	RecentCheer *CheerPartnerRecentCheerSettings `json:"recentCheer"`
	// Partner settings related to sponsored cheermotes.
	SponsoredCheermotes *CheerPartnerSponsoredCheermoteSettings `json:"sponsoredCheermotes"`
}

// Partner settings related to sponsored cheermotes.
type CheerPartnerSponsoredCheermoteSettings struct {
	// The sponsored cheermote channel settings that are associated with the user.
	Campaigns *SponsoredCheermoteChannelSettingsConnection `json:"campaigns"`
}

// CheerSettings are the channel-specific cheer settings.
type CheerSettings struct {
	// cheerMinimumBits is the minimum number of bits per message (sum of all cheermotes) required to cheer in this channel.
	CheerMinimumBits int `json:"cheerMinimumBits"`
	// emoteMinimumBits is the smallest number of bits that can be spent on an individual cheermote in this channel.
	EmoteMinimumBits int `json:"emoteMinimumBits"`
	// event is the name of a special cheering event this channel is currently participating in.
	// If there is no current event this will return null.
	Event *string `json:"event"`
	ID    string  `json:"id"`
	// Indicates if the bits football cheerbomb event is enabled on the channel.
	IsCheerBombEventEnabled bool `json:"isCheerBombEventEnabled"`
	// Indicates if polls is enabled.
	IsPollsEnabled bool `json:"isPollsEnabled"`
	// isRecentEnabled indicates if recent cheers are pinned in this channel.
	// This can be used by a client to update `CheerInfo.recent` as new cheers are received.
	IsRecentEnabled bool `json:"isRecentEnabled"`
	// isTopEnabled indicates if top cheers are pinned in this channel.
	// This can be used by a client to update `CheerInfo.top` as new cheers are received.
	IsTopEnabled bool `json:"isTopEnabled"`
	// leaderboard contains all of the Bits settings related to Bits Leaderboards for this channel.
	Leaderboard *BitsLeaderboardSettings `json:"leaderboard"`
	// recentMinimumBits is the number of bits required for a cheer to be pinned.
	RecentMinimumBits int `json:"recentMinimumBits"`
	// recentTimeoutMs is the amount of time a pinned recent message should be displayed for.
	RecentTimeoutMs int `json:"recentTimeoutMs"`
}

// Cheermote is the metadata about different variations of a single cheermote that can be use to cheer in this channel.
type Cheermote struct {
	// A nullable campaign associated with the cheermote. This would only be attached to
	// cheermotes that are of the CheermoteType.SPONSORED.
	Campaign *CheermoteCampaign `json:"campaign"`
	// The ID of the cheermote.
	ID string `json:"id"`
	// prefix for this cheering action (Kappa, cheer, Kreygasm, etc).
	// Any case-insensitive match of this prefix directly followed by a number
	// (Kappa100, kappa100, kApPa100, etc) is to be considered a cheering message.
	Prefix string `json:"prefix"`
	// tiers are bits breakpoints for different images for this cheermote.
	Tiers []*CheermoteTier `json:"tiers"`
	// type is the kind of cheermote (custom vs 1st- or 3rd-party global).
	Type CheermoteType `json:"type"`
}

// A campaign that is in association with a cheermote. Like, Old Spice could have a cheermote with
// Terry Crew's head that they will sponsor X Bits that get added on to cheers that use their cheermote.
type CheermoteCampaign struct {
	// The percentage of remaining bits that can be added to cheers.
	BitsPercentageRemaining float64 `json:"bitsPercentageRemaining"`
	// An optional field that shows the user how many bits are being used to sponsor the campaign.
	BitsTotal *int `json:"bitsTotal"`
	// An optional field that shows the user how many bits have been used out of the sponsored pool.
	BitsUsed *int `json:"bitsUsed"`
	// Image url for the brand image.
	BrandImageURL string `json:"brandImageURL"`
	// The name of the brand, used in strings.
	BrandName string `json:"brandName"`
	// The cheermote campaign ID. This is unique.
	ID string `json:"id"`
	// The minimum bits amount to make a cheer add bits from the sponsored campaign.
	MinimumBitsAmount int `json:"minimumBitsAmount"`
	// The nullable edge that relates the user to the campaign.
	Self *CheermoteCampaignSelfEdge `json:"self"`
	// Thresholds for matching on sponsored cheering.
	Thresholds []*CheermoteCampaignThreshold `json:"thresholds"`
	// Amount of bits that an individual user can contribute.
	UserLimit int `json:"userLimit"`
}

// Edge that relates a cheermote campaign to the logged in user.
type CheermoteCampaignSelfEdge struct {
	// The total bits used by the user in the campaign.
	BitsUsed int `json:"bitsUsed"`
	// Eligibility for the user to cheer with the sponsored bits in the campaign.
	CanBeSponsored bool `json:"canBeSponsored"`
	// The ID is comprised of the campaign ID and the user ID.
	ID string `json:"id"`
}

// Threshold for sponsored cheermote campaign matching.
type CheermoteCampaignThreshold struct {
	// Id for threshold, generated using the campaign id and the minimum bits field.
	ID string `json:"id"`
	// Percentage for matching.
	MatchedPercent float64 `json:"matchedPercent"`
	// Minimum number of bits to get this level of matching.
	MinimumBits int `json:"minimumBits"`
}

// The color that should be used to display each cheer amount.
type CheermoteColorConfig struct {
	// bits is the minimum number of bits that are required to render this tier.
	// To render at this tier the cheemote must have used >= this minimum but < the next smallest tier.
	Bits int `json:"bits"`
	// color is the hex color used to render the number of bits for this tier.
	Color string `json:"color"`
}

// The CheermoteDisplayConfig provides information about how Cheermotes can be displayed
// This includes things like the possible sizes, colors, backgrounds, and display order.
type CheermoteDisplayConfig struct {
	// A list of the backgrounds that a Cheermote can be rendered at. For example, ["light", "dark"]
	// Although this is probably more accurately represented as an emum, these strings are going to have to be used
	// when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
	// same enum -> string mapping, we will just pass these directly as strings.
	Backgrounds []string `json:"backgrounds"`
	// A list of the colors that should be used to display text for each Cheer amount.
	Colors []*CheermoteColorConfig `json:"colors"`
	// A list of the order in which CheermoteTypes should be displayed.
	Order []CheermoteType `json:"order"`
	// A list of the scales that a Cheermote can be rendered at. For example,  ["1", "1.5", "2", "3", "4"]
	// Although this is probably more accurately represented as an emum, these strings are going to have to be used
	// when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
	// same enum -> string mapping, we will just pass these directly as strings.
	Scales []string `json:"scales"`
	// A list of the display types available for Cheermotes.
	Types []*CheermoteDisplayType `json:"types"`
}

// Information about the methods to display a Cheermote.
type CheermoteDisplayType struct {
	// The animation style. For example, "static" or "animated"
	// Although this is probably more accurately represented as an emum, these strings are going to have to be used
	// when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
	// same enum -> string mapping, we will just pass these directly as strings.
	Animation string `json:"animation"`
	// The extension for this animation style. For example, "png" or "gif"
	// Although this is probably more accurately represented as an emum, these strings are going to have to be used
	// when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
	// same enum -> string mapping, we will just pass these directly as strings.
	Extension string `json:"extension"`
}

// Contains a group of related Cheermotes that share the same CDN template.
type CheermoteGroup struct {
	// The Cheermotes which belong to this group.
	Nodes []*Cheermote `json:"nodes"`
	// The template URL that clients can use to construct the image URL for each cheermote tier.
	// The displayConfig field on Query provides values you'll need to fill in this template,
	// so don't forget to request that as well.
	TemplateURL string `json:"templateURL"`
}

// CheermoteImage is a single image variation of a `CheermoteTier`.
type CheermoteImage struct {
	// dpiScale is the scale of the cheermote image.
	// Currently available scales are: 1, 1.5, 2, 3, or 4.
	DpiScale float64 `json:"dpiScale"`
	// The ID of CheermoteImage.
	ID string `json:"id"`
	// isAnimated is true for animated cheermotes and false otherwise.
	IsAnimated bool `json:"isAnimated"`
	// theme is the UI theme the cheermote is designed to be rendered on.
	Theme ChatTheme `json:"theme"`
	// url is the URL of the image asset.
	URL string `json:"url"`
}

// CheermoteTier has information about a single tier of a cheermote.
type CheermoteTier struct {
	// bits is the minimum number of bits that are required to render this tier.
	// To render at this tier the cheemote must have used >= this minimum but < the next smallest tier.
	Bits int `json:"bits"`
	// Can this cheer tier be used as a cheermote.
	CanCheer bool `json:"canCheer"`
	// Can this cheer tier be shown in the Bits card.
	CanShowInBitsCard bool `json:"canShowInBitsCard"`
	// color is the hex color used to render the number of bits for this tier.
	Color string `json:"color"`
	// The ID of CheermoteTier.
	ID string `json:"id"`
	// images are urls for the cheermote that match various settings.
	// This can optionally be filtered to only certain variations or called without arguments to return all available images.
	Images []*CheermoteImage `json:"images"`
	// tierID of this specific cheermote icon. For "Kappa100" this will be "100".
	TierID string `json:"tierID"`
}

// CheermoteToken is used to render a cheermote in a message.
type CheermoteToken struct {
	// The number of bits in the cheermote.
	BitsAmount int `json:"bitsAmount"`
	// The prefix of the cheermote (e.g. cheer in cheer100).
	Prefix string `json:"prefix"`
	// The tier of the cheer used to determine which image to show for the cheermote.
	// In cheer150, this would be 100.
	Tier int `json:"tier"`
}

func (CheermoteToken) IsFragmentContent() {}

// Error code for an error that occurs while claiming the bounty.
type ClaimBountyError struct {
	// Error code for error that occurred while claiming the bounty.
	Code ClaimBountyErrorCode `json:"code"`
}

// ClaimBountyInput includes the bounty a user is trying to claim.
type ClaimBountyInput struct {
	// Unique Identifier for the bounty campaign.
	BountyCampaignID string `json:"bountyCampaignID"`
	// Unique Identifier for the bounty.
	BountyID string `json:"bountyID"`
	// Platform selected by the user to play this bounty's game on.
	Platform *string `json:"platform"`
	// Region selected by the user for the game key.
	Region *string `json:"region"`
	// UserID of the user that will claim the bounty.
	UserID string `json:"userID"`
}

// Data that was mutated after claiming the bounty.
type ClaimBountyPayload struct {
	// The claimed bounty with the updated status.
	ClaimedBounty *Bounty `json:"claimedBounty"`
	// The possible error returned from the service.
	Error *ClaimBountyError `json:"error"`
	// The user that now has the claimed bounty.
	User *User `json:"user"`
}

// An error from claiming community points.
type ClaimCommunityPointsError struct {
	// An identifier for the error that occurred.
	Code *ClaimCommunityPointsErrorCode `json:"code"`
}

// Input for claiming community points.
type ClaimCommunityPointsInput struct {
	// The channel ID the claim is in.
	ChannelID string `json:"channelID"`
	// The claim ID.
	ClaimID string `json:"claimID"`
}

// The response from claiming community points.
type ClaimCommunityPointsPayload struct {
	// The points claim that was claimed.
	Claim *CommunityPointsClaim `json:"claim"`
	// The user's point balance in the channel, after the claim.
	CurrentPoints *int `json:"currentPoints"`
	// An error that occurred while claiming. If there is an error, the claim did not go through.
	Error *ClaimCommunityPointsError `json:"error"`
}

// ClaimDropRewardsInput has fields required to claim a drop.
type ClaimDropRewardsInput struct {
	// dropInstanceID is the unique drop instance to claim.
	DropInstanceID string `json:"dropInstanceID"`
}

// ClaimDropRewardsPayload returns the state of the claim.
type ClaimDropRewardsPayload struct {
	// Summary information for the drop the reward is claimed of.
	Drop *DropObject `json:"drop"`
	// dropInstanceID is the same as the provided input.
	DropInstanceID *string `json:"dropInstanceID"`
	// A single Drop. This could be either an event or time based drop.
	DropType DropType `json:"dropType"`
	// UserAccountConnected is a boolean specifying if the user has a connected account link to the game the Reward is for.
	IsUserAccountConnected *bool `json:"isUserAccountConnected"`
	// rewards lists the rewards that were claimed and their statuses.
	Rewards []*DropReward `json:"rewards"`
	// status is an enum specifying the status of the claim request.
	Status *DropInstanceEligibilityStatus `json:"status"`
}

// Error code for an error that occurs while claiming prime offer.
type ClaimPrimeOfferError struct {
	// Error code for error that occurred while claiming prime offer.
	Code ClaimPrimeOfferErrorCode `json:"code"`
}

type ClaimPrimeOfferInput struct {
	// Unique Identifier for an offer.
	OfferID string `json:"offerID"`
}

// Data that was mutated after claiming the prime offer, in this case, the entitlement.
type ClaimPrimeOfferPayload struct {
	// The possible error returned from the service.
	Error *ClaimPrimeOfferError `json:"error"`
	// The connection for whether the user is entitled to the offer.
	Self *PrimeOfferSelfConnection `json:"self"`
}

// ClearUnreadFriendRequestsPaylod is the payload returned by ClearUnreadFriendRequests.
type ClearUnreadFriendRequestsPayload struct {
	// The modified user.
	User *User `json:"user"`
}

// The authorization a user has provided to an OAuth client.
type ClientAuthorization struct {
	// The ID of the client.
	ClientID string `json:"clientID"`
	// The name of the client.
	ClientName *string `json:"clientName"`
	// The time when the authorization was created.
	CreatedAt *time.Time `json:"createdAt"`
}

// A recorded, replayable part of a live broadcast.
type Clip struct {
	// The broadcast of the clip. This should only be used to fetch the ID of the broadcast.
	// Because not all videos have broadcasts (e.g. uploads), not all clips will have a broadcast.
	Broadcast *Broadcast `json:"broadcast"`
	// The broadcaster from which the clip originated.
	Broadcaster *User `json:"broadcaster"`
	// The curator's clip champ badge if it has been attained on the broadcaster's channel.
	// This will be null if the curator is not a clip champ of the broadcaster's channel.
	ChampBadge *Badge `json:"champBadge"`
	// The time when the clip was created.
	CreatedAt time.Time `json:"createdAt"`
	// Different video qualities are being created in the background.
	// The creation state indicates when the source quality clip is playable
	// and transcoding of the clip in other video qualities has begun.
	CreationState *ClipCreationState `json:"creationState"`
	// The user who created the clip.
	Curator *User `json:"curator"`
	// The duration of the clip, in seconds.
	DurationSeconds int `json:"durationSeconds"`
	// The URL used in the embed player.
	EmbedURL string `json:"embedURL"`
	// The game depicted in the clip.
	Game *Game `json:"game"`
	// The clip's unique identifier.
	ID string `json:"id"`
	// Whether or not the clip has been published.
	IsPublished *bool `json:"isPublished"`
	// The language of the clip.
	Language Language `json:"language"`
	// The playback access token that determines whether the user can watch the clip.
	// Fetched for both authed and unauthed users.
	PlaybackAccessToken *PlaybackAccessToken `json:"playbackAccessToken"`
	// Metadata around the raw media.
	RawMedia *ClipRawMedia `json:"rawMedia"`
	// The different quality options of this clip's raw media used for editing.
	RawVideoQualities []*ClipVideoQuality `json:"rawVideoQualities"`
	// The reactions associated with this clips.
	Reactions []*Reaction `json:"reactions"`
	// Lists of related clips based on different algorithms.
	RelatedClips *ClipRelatedClips `json:"relatedClips"`
	// A URL-friendly identifier.
	Slug string `json:"slug"`
	// A URL to a thumbnail image.
	// Valid sizes are "86x45", "260x147", and "480x272".
	ThumbnailURL string `json:"thumbnailURL"`
	// The title of the clip.
	Title string `json:"title"`
	// A URL to the clip's page.
	URL string `json:"url"`
	// The video of the clip. Because not all broadcasts are archived, not all clips will
	// have a video.
	Video *Video `json:"video"`
	// The number of seconds into a VOD this clip was generated from.
	VideoOffsetSeconds *int `json:"videoOffsetSeconds"`
	// The different quality options of this clip available for playback.
	// The clip will first be available in the source video quality, indicated by when the
	// clipCreationState is 'CREATED'. videoQualities will gradually be added to afterwards as
	// more video quality options become playable.
	VideoQualities []*ClipVideoQuality `json:"videoQualities"`
	// The number of times this clip has been viewed.
	ViewCount int `json:"viewCount"`
}

func (Clip) IsTaggedContent()             {}
func (Clip) IsOnsiteNotificationContent() {}
func (Clip) IsPostEmbed()                 {}
func (Clip) IsShareTarget()               {}
func (Clip) IsVideoShelfItem()            {}
func (Clip) IsReactableContent()          {}
func (Clip) IsFeedEmbed()                 {}
func (Clip) IsShortVideoContent()         {}
func (Clip) IsShelfContent()              {}
func (Clip) IsFeedItemContent()           {}

// A list of clips related to the subject.
type ClipConnection struct {
	// The clips.
	Edges []*ClipEdge `json:"edges"`
	// Information about pagination in this connection.
	PageInfo *PageInfo `json:"pageInfo"`
}

type ClipEdge struct {
	// Uniquely identifies this clip's position in a connection.
	Cursor *string `json:"cursor"`
	// The clip.
	Node *Clip `json:"node"`
}

// ClipRawMedia describes metadata about the clip's raw media used in clip editing.
type ClipRawMedia struct {
	// Default Offset is the seconds into the raw clip media the default clip begins at.
	DefaultClipInitialOffset float64 `json:"defaultClipInitialOffset"`
	// Total duration of the raw media.
	Duration float64 `json:"duration"`
	// Total number of frames displayed in the spritesheet film strip.
	FilmStripFrames int `json:"filmStripFrames"`
	// Seconds covered by each frame in the spritesheet film strip.
	FilmStripSecondsPerFrame int `json:"filmStripSecondsPerFrame"`
	// Height of the frames displayed.
	FrameHeight int `json:"frameHeight"`
	// Width of the frames displayed.
	FrameWidth int `json:"frameWidth"`
	// Spritesheet displayed to user for clip editing.
	SpritesheetURL string `json:"spritesheetURL"`
	// Status of the clip's raw media.
	Status ClipCreationState `json:"status"`
	// URL link to the video mp4 containing to upwards of 90 seconds of the raw video from which the clip can be created from.
	VideoURL string `json:"videoURL"`
}

// There are different algorithms that return a different set of related clips.
// They only return up to 4 clips per list.
type ClipRelatedClips struct {
	// Up-to 4  randomly selected, top viewed clips from the same broadcaster created within the last 4 days.
	Broadcaster []*Clip `json:"broadcaster"`
	// Up-to 10 clips, in order, combined from the other returned clip sets.
	// Clips are included in the priority of similar, broadcaster, game, and then top.
	Combined []*Clip `json:"combined"`
	// Up-to 4  randomly selected, top viewed clips from the same user created within the last 4 days.
	Curator []*Clip `json:"curator"`
	// Up-to 4  randomly selected, top viewed clips from the same game created within the last 4 days.
	Game []*Clip `json:"game"`
	// Up-to 4 similar clips, based on the recommendations service.
	// Deprecated: The underlying recommendations service that determined similar clips has been deprecated.
	Similar []*Clip `json:"similar"`
	// Up-to 4 randomly selected, top viewed clips created within the last 4 days.
	Top []*Clip `json:"top"`
}

// ClipSegmentInput represents a single segment of a clip.
type ClipSegmentInput struct {
	// The number of seconds this clip segment encompasses.
	DurationSeconds float64 `json:"durationSeconds"`
	// The offset into the clip's 90 second raw media.
	OffsetSeconds float64 `json:"offsetSeconds"`
	// Valid input speeds are 0.25, 0.5, 1.0, 1.5, and 2.0.
	// The segment speed will be set to 1 by default if unspecified.
	Speed *float64 `json:"speed"`
}

// ClipVideoQuality describes metadata about an available playback source for a clip.
type ClipVideoQuality struct {
	// Frame rate is the number of frames per second of this video.
	// This value is a 64-bit float, with a default value of 30.0,
	// and is used for supporting different playback speeds.
	// Frame rate will be empty for raw media video qualities.
	FrameRate *float64 `json:"frameRate"`
	// Clips can have multiple playback qualities via transcoding.
	// Some examples of qualities include "1080", "720", "480", "360", and "source".
	Quality string `json:"quality"`
	// The source video URL for the clip in this specific playback quality.
	SourceURL string `json:"sourceURL"`
}

// CloneExtensionDiscoveryData copies a given version's discovery data to another version.
type CloneExtensionDiscoveryDataInput struct {
	// The extension ID of the extension to clone.
	ID string `json:"id"`
	// The version to clone to.
	NewVersion string `json:"newVersion"`
	// The extension version to clone from.
	Version string `json:"version"`
}

// CloneExtensionDiscoveryDataPayload returns any errors that occur during the copying of the discovery data.
type CloneExtensionDiscoveryDataPayload struct {
	// The error when the mutation fails to update an extension.
	Error *CloneExtensionDiscoveryDataError `json:"error"`
	// The updated extension discovery data.
	Manifest *ExtensionVersionDiscoveryManifest `json:"manifest"`
}

// CloneExtensionManifest copies the data in a given extension version to a new version.
type CloneExtensionManifestInput struct {
	// The extension ID of the extension to clone.
	ID string `json:"id"`
	// The version of the clone.
	NewVersion string `json:"newVersion"`
	// The extension version to clone.
	Version string `json:"version"`
}

// CloneExtensionManifestPayload returns any errors that occur during update and the new manifest.
type CloneExtensionManifestPayload struct {
	// The error when the mutation fails to update an extension.
	Error *CloneExtensionManifestError `json:"error"`
	// The updated extension manifest.
	Manifest *ExtensionManifest `json:"manifest"`
}

// Represents a cloud broadcast and its state.
type CloudBroadcast struct {
	// The id of the cloud broadcast.
	ID string `json:"id"`
	// The status of a cloud broadcast.
	State CloudBroadcastState `json:"state"`
	// The ingest URI for the broadcast.
	// This is available if the broadcast is in an online state; otherwise null.
	URI *string `json:"uri"`
}

// A cloud broadcast provider id.
type CloudBroadcastProvider struct {
	// The supported capabilities of a cloud broadcast.
	Capabilities *CloudBroadcastProviderCapabilities `json:"capabilities"`
	// The friendly display name of the provider.
	DisplayName string `json:"displayName"`
	// The logical id of the provider, for interacting with providers.
	ID string `json:"id"`
}

// Capabilities of a cloud broadcast provider.
type CloudBroadcastProviderCapabilities struct {
	// The maximum supported broadcast framerate for the provider, if available.
	Framerate *int `json:"framerate"`
	// The maximum supported broadcast height for the provider, if available.
	Height *int `json:"height"`
	// The ID of the provider associated with the capabilities.
	ID string `json:"id"`
	// Whether or not if the broadcaster can send broadcasts to the service.
	IsAvailable bool `json:"isAvailable"`
	// The maximum supported broadcast width for the provider, if available.
	Width *int `json:"width"`
}

// A cloud broadcast provider id.
type CloudBroadcastProviderKey struct {
	// The friendly display name of the provider.
	DisplayName string `json:"displayName"`
	// The logical id of the provider, for interacting with providers.
	ID string `json:"id"`
}

// Collection (a.k.a. Playlist) is a backend concept for a list of videos.
type Collection struct {
	// The user-supplied description of the collection.
	Description string `json:"description"`
	// The collection's identifier.
	ID string `json:"id"`
	// The paginated items in the collection. At this time, they will all be VoDs.
	Items *CollectionConnection `json:"items"`
	// Total length of the collection as summed from all video lengths.
	LengthSeconds int `json:"lengthSeconds"`
	// The owner of the collection.
	Owner *User `json:"owner"`
	// The thumbnailURL for the collection.
	// If either `height` or `width` are not given, a templated value (i.e. `{height}`, `{width}`) will be present in the URL instead.
	ThumbnailURL *string `json:"thumbnailURL"`
	// The user-supplied title of the collection.
	Title string `json:"title"`
	// The type of collection, either a series or default collection which is ''.
	Type CollectionType `json:"type"`
	// Time when the collection was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
	// The total view count of a collection.
	ViewCount *int `json:"viewCount"`
}

// A paginated list of videos, and its metadata.
type CollectionConnection struct {
	// The list of items in this page.
	Edges []*CollectionItemEdge `json:"edges"`
	// Information about this page of videos.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of items in the collection.
	TotalCount int `json:"totalCount"`
}

// A page entry, that contains a collection item and a cursor to return
// from the query to allow pagination.
type CollectionItemEdge struct {
	Cursor string         `json:"cursor"`
	Node   CollectionItem `json:"node"`
}

// A Collection input to set options to include all items in a collection.
type CollectionOptions struct {
	// Include all playlist items including private and deleted items.
	IncludeAllItems *bool `json:"includeAllItems"`
}

// These two types allow clients to query for a LIST of COLLECTIONS
// (i.e. a two-dimensional array of videos).
type CollectionsConnection struct {
	Edges    []*CollectionsItemEdge `json:"edges"`
	PageInfo *PageInfo              `json:"pageInfo"`
}

type CollectionsItemEdge struct {
	Cursor *string     `json:"cursor"`
	Node   *Collection `json:"node"`
}

// Options for filtering collections.
type CollectionsOptions struct {
	// Option to include empty collections.
	IncludeEmpty *bool `json:"includeEmpty"`
	// Only return collections that include the given video ID.
	WithVideoID *string `json:"withVideoID"`
}

// An automatic community points reward.
type CommunityPointsAutomaticReward struct {
	// The background color for the reward icon.
	BackgroundColor *string `json:"backgroundColor"`
	// The point cost of this reward.
	Cost *int `json:"cost"`
	// The default background color for this reward.
	DefaultBackgroundColor string `json:"defaultBackgroundColor"`
	// The default point cost of this reward.
	DefaultCost int `json:"defaultCost"`
	// The default image for this reward.
	DefaultImage *CommunityPointsImage `json:"defaultImage"`
	// Time that the global template for this reward was last updated in a way that should show a new content indicator to viewers.
	GloballyUpdatedForIndicatorAt time.Time `json:"globallyUpdatedForIndicatorAt"`
	// The unique identifier of this reward in this channel.
	ID string `json:"id"`
	// The custom icon for this reward, if any.
	Image *CommunityPointsImage `json:"image"`
	// Whether this reward is turned on or off in this channel at the moment.
	IsEnabled bool `json:"isEnabled"`
	// Whether only non-subscribers are allowed to redeem this reward in this channel.
	IsHiddenForSubs bool `json:"isHiddenForSubs"`
	// The lowest the broadcaster is allowed to set the cost of this reward.
	MinimumCost int `json:"minimumCost"`
	// The type of automatic reward this is.
	Type CommunityPointsAutomaticRewardType `json:"type"`
	// Time that this reward was last updated for the channel in a way that should show a new content indicator to viewers.
	// Will be null if the channel hasn't made any updates to override the global settings.
	UpdatedForIndicatorAt *time.Time `json:"updatedForIndicatorAt"`
}

// Information on how points are earned by viewers in a specific channel.
type CommunityPointsChannelEarningSettings struct {
	// The average number of points per hour earned by a regular (non-sub) user on this channel.
	AveragePointsPerHour int `json:"averagePointsPerHour"`
	// The average number of points per hour earned by a subscriber on this channel.
	AveragePointsPerHourSubscriber int `json:"averagePointsPerHourSubscriber"`
	// How many points are earned for cheering in a channel.
	CheerPoints int `json:"cheerPoints"`
	// How many minutes will pass in between bonus claims becoming available.
	ClaimPeriodMinutes int `json:"claimPeriodMinutes"`
	// How many points are earned for clicking a bonus claim.
	ClaimPoints int `json:"claimPoints"`
	// How many points are earned for following the channel.
	FollowPoints int `json:"followPoints"`
	// A unique identifier.
	ID string `json:"id"`
	// The possible multipliers users can have on earning points.
	Multipliers []*CommunityPointsMultiplier `json:"multipliers"`
	// How many minutes must be watched to earn points for passively watching the channel.
	PassiveWatchPeriodMinutes int `json:"passiveWatchPeriodMinutes"`
	// How many points are earned for passively watching the channel.
	PassiveWatchPoints int `json:"passiveWatchPoints"`
	// How many points are earned for following a raid by the channel.
	RaidPoints int `json:"raidPoints"`
	// The earning multiplier applied to subscribers to the channel.
	// This multiplier only applies to "watch" and "claim" actions.
	SubscriberMultiplier float64 `json:"subscriberMultiplier"`
	// How many points are earned for gifting a subscription in a channel.
	SubscriptionGiftPoints int `json:"subscriptionGiftPoints"`
	// How many points are earned for watching consecutive streams.
	// This list will be sorted from shortest duration to longest duration.
	// Watch streaks beyond the longest duration here will be treated the same as watch streaks of the longest duration.
	WatchStreakPoints []*CommunityPointsWatchStreakEarningSettings `json:"watchStreakPoints"`
}

// Settings for a channel's Community Points.
type CommunityPointsChannelSettings struct {
	// Archived community goals for this channel.
	ArchivedGoals *CommunityPointsCommunityGoalConnection `json:"archivedGoals"`
	// Automatic rewards for this channel. If no automatic rewards exist, will be an empty array.
	AutomaticRewards []*CommunityPointsAutomaticReward `json:"automaticRewards"`
	// The default max contribution to a community goal per user per stream.
	CommunityGoalMaxContributionPerStream int `json:"communityGoalMaxContributionPerStream"`
	// The default small contribution to a community goal.
	CommunityGoalSmallContribution int `json:"communityGoalSmallContribution"`
	// Single custom reward by the given id for this channel.
	CustomReward *CommunityPointsCustomReward `json:"customReward"`
	// Collections of the custom reward templates for this channel.
	CustomRewardTemplateCollections []*CommunityPointsCustomRewardTemplateCollection `json:"customRewardTemplateCollections"`
	// Custom rewards for this channel. If no custom rewards exist, will be an empty array.
	CustomRewards []*CommunityPointsCustomReward `json:"customRewards"`
	// The default image for community points.
	DefaultImage *CommunityPointsImage `json:"defaultImage"`
	// Properties concerning the user's participation in the Channel Points early access program.
	EarlyAccess *CommunityPointsEarlyAccessSettings `json:"earlyAccess"`
	// Information on how points are earned by viewers in this channel.
	Earning *CommunityPointsChannelEarningSettings `json:"earning"`
	// A list of the emote variants (base emote + modifications) that are available for this channel.
	EmoteVariants []*CommunityPointsEmoteVariant `json:"emoteVariants"`
	// Non-archived community goals for this channel.
	Goals []*CommunityPointsCommunityGoal `json:"goals"`
	// The channel's custom community points icon. Null if they have not set an icon.
	Image *CommunityPointsImage `json:"image"`
	// Whether the channel is allowed to turn community points on now.
	IsAvailable bool `json:"isAvailable"`
	// Whether the channel will be allowed to turn community points on at full public launch.
	IsAvailableAtLaunch bool `json:"isAvailableAtLaunch"`
	// Whether the channel has community points turned on now.
	IsEnabled bool `json:"isEnabled"`
	// Whether the channel will have community points turned on at full public launch.
	IsEnabledAtLaunch bool `json:"isEnabledAtLaunch"`
	// The channel's custom community points name. Null if they have not set a name.
	Name *string `json:"name"`
	// The amount of points earned for participating in a raid from the channel.
	RaidPointAmount int `json:"raidPointAmount"`
	// A list of Smart Costs acknowledgements.
	SmartCostsAcknowledgements []*SmartCostsAcknowledgement `json:"smartCostsAcknowledgements"`
	// A summary of information about unfulfilled redemptions of each custom reward.
	SummarizedRewards []*CommunityPointsRewardSummary `json:"summarizedRewards"`
	// A list of the progress for all ongoing Update Custom Reward Redemption Statuses requests.
	UpdateCustomRewardRedemptionStatusesProgress []*CommunityPointsUpdateCustomRewardRedemptionStatusesProgress `json:"updateCustomRewardRedemptionStatusesProgress"`
}

// Points that are available for a user to click to claim in a channel.
type CommunityPointsClaim struct {
	// The claim's unique ID.
	ID string `json:"id"`
	// The multipliers that will affect this claim.
	// Multipliers start at a base of 1.0, and are additive.
	// Two multipliers of [0.2] and [0.3] will give a final multiplier of 1.5x.
	Multipliers []*CommunityPointsMultiplier `json:"multipliers"`
	// The baseline points this claim will grant, before applying multipliers.
	PointsEarnedBaseline int `json:"pointsEarnedBaseline"`
	// The total points this claim will grant.
	PointsEarnedTotal int `json:"pointsEarnedTotal"`
}

// Community goal.
type CommunityPointsCommunityGoal struct {
	// The amount of community points that this goal needs to succeed.
	AmountNeeded int `json:"amountNeeded"`
	// The background color of this goal. Should be a hex color string, for example "FF0000".
	BackgroundColor string `json:"backgroundColor"`
	// The default image of community goals.
	DefaultImage *CommunityPointsImage `json:"defaultImage"`
	// The description of this goal.
	Description *string `json:"description"`
	// The *initial* duration the streamer set for the goal.
	// Only really used during the UNSTARTED state; once the goal is started
	// the endedAt timestamp is populated (and updated for extended deadlines).
	DurationDays int `json:"durationDays"`
	// When the goal ended / will end.
	EndedAt *time.Time `json:"endedAt"`
	// The id of the goal.
	ID string `json:"id"`
	// The image of the goal.
	Image *CommunityPointsImage `json:"image"`
	// If this goal is available to be contributed to.
	// true when the goal is active and the streamer is live.
	// For MLP, this is just whether the channel is live.
	IsInStock bool `json:"isInStock"`
	// The max per stream, per user contribution limit.
	PerStreamUserMaximumContribution int `json:"perStreamUserMaximumContribution"`
	// The total points contributed to this goal.
	PointsContributed int `json:"pointsContributed"`
	// The small contribution needed to contribute to the goal. Contribution can only be
	// less than this amount if the goal has less than this amount left to complete or if
	// the viewer has less than this amount to be able to contribute.
	SmallContribution int `json:"smallContribution"`
	// When the goal started.
	StartedAt *time.Time `json:"startedAt"`
	// The current status of this goal.
	Status CommunityPointsCommunityGoalStatus `json:"status"`
	// The title of this goal.
	Title string `json:"title"`
	// The type of this goal.
	Type CommunityPointsCommunityGoalType `json:"type"`
}

// A paginated list of community goals.
type CommunityPointsCommunityGoalConnection struct {
	// The list of community goals in this page.
	Edges []*CommunityPointsCommunityGoalEdge `json:"edges"`
	// Information about this page of community goals.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Community goal contribution.
type CommunityPointsCommunityGoalContribution struct {
	// The community goal.
	Goal *CommunityPointsCommunityGoal `json:"goal"`
	// The amount of user's channel points contributed to this community goal this stream.
	UserPointsContributedThisStream int `json:"userPointsContributedThisStream"`
}

// A community goal page entry, contains an item and a cursor.
type CommunityPointsCommunityGoalEdge struct {
	// Identifies this community goal's position in a connection.
	Cursor string `json:"cursor"`
	// The community goal.
	Node *CommunityPointsCommunityGoal `json:"node"`
}

// A custom community points reward on a channel.
type CommunityPointsCustomReward struct {
	// The custom background color for this reward. If no background color specified, will be null.
	BackgroundColor *string `json:"backgroundColor"`
	// The cooldown expires at field indidicates when reward will be able to be redeemed after the cooldown is set.
	// This field will only have a value if the global cooldown feature is enabled and has been recently redeemed.
	CooldownExpiresAt *time.Time `json:"cooldownExpiresAt"`
	// The point cost of this reward.
	Cost int `json:"cost"`
	// The default image for community points custom rewards.
	DefaultImage *CommunityPointsImage `json:"defaultImage"`
	// The most rewards of this type that can be redeemed per the global cooldown.
	GlobalCooldownSetting *CommunityPointsCustomRewardGlobalCooldownSetting `json:"globalCooldownSetting"`
	// Whether this reward has real world value. Null if the broadcaster has not set this field yet.
	HasRealWorldValue *bool `json:"hasRealWorldValue"`
	// The unique identifier for this reward.
	ID string `json:"id"`
	// The custom image for this reward. If no image exists, will be null.
	Image *CommunityPointsImage `json:"image"`
	// Whether this reward is enabled in this channel at the moment.
	IsEnabled bool `json:"isEnabled"`
	// Whether this reward is in stock at the moment.
	// If the reward has already been redeemed the maximum number of times per stream, this will be false.
	IsInStock bool `json:"isInStock"`
	// Whether redemptions of this reward are temporarily paused.
	IsPaused bool `json:"isPaused"`
	// Whether only subscribers are allowed to redeem this reward in this channel.
	IsSubOnly bool `json:"isSubOnly"`
	// Whether this reward requires users to enter text input.
	IsUserInputRequired bool `json:"isUserInputRequired"`
	// The most rewards of this type that can be redeemed per stream.
	MaxPerStreamSetting *CommunityPointsCustomRewardMaxPerStreamSetting `json:"maxPerStreamSetting"`
	// The most rewards of this type that can be redeemed per user per stream.
	MaxPerUserPerStreamSetting *CommunityPointsCustomRewardMaxPerUserPerStreamSetting `json:"maxPerUserPerStreamSetting"`
	// The user-facing prompt for this reward. If no prompt exists, will be null.
	Prompt *string `json:"prompt"`
	// The value of redemptions of the reward for the current stream.
	// This field will only have a value if the max per user per stream is enabled and has been recently redeemed.
	RedemptionsRedeemedCurrentStream *int `json:"redemptionsRedeemedCurrentStream"`
	// Whether redemptions for this reward should skip the broadcaster's request queue and get
	// automatically fulfilled.
	ShouldRedemptionsSkipRequestQueue bool `json:"shouldRedemptionsSkipRequestQueue"`
	// The id for the CustomReward template this reward was created from. Will be null if not created from a template.
	TemplateID *string `json:"templateID"`
	// The short title displayed for this reward.
	Title string `json:"title"`
	// Time that this reward was last updated in a way that should show a new content indicator to viewers.
	UpdatedForIndicatorAt time.Time `json:"updatedForIndicatorAt"`
}

// Settings for how often a custom reward may be redeemed per stream.
type CommunityPointsCustomRewardGlobalCooldownSetting struct {
	// The most rewards of this type that can be redeemed per the global cooldown.
	GlobalCooldownSeconds int `json:"globalCooldownSeconds"`
	// Whether the cooldown is being enforced.
	IsEnabled bool `json:"isEnabled"`
}

// Input for creating and updating a Community Points custom reward's max per stream settings.
type CommunityPointsCustomRewardGlobalCooldownSettingInput struct {
	// The most rewards of this type that can be redeemed per global cooldown.
	GlobalCooldownSeconds int `json:"globalCooldownSeconds"`
	// Whether the cooldown is being enforced.
	IsEnabled bool `json:"isEnabled"`
}

// Settings for how often a custom reward may be redeemed per stream.
type CommunityPointsCustomRewardMaxPerStreamSetting struct {
	// Whether the maximum is being enforced.
	IsEnabled bool `json:"isEnabled"`
	// The most rewards of this type that can be redeemed per stream.
	MaxPerStream int `json:"maxPerStream"`
}

// Input for creating and updating a Community Points custom reward's max per stream settings.
type CommunityPointsCustomRewardMaxPerStreamSettingInput struct {
	// Whether the maximum is being enforced.
	IsEnabled bool `json:"isEnabled"`
	// The most rewards of this type that can be redeemed per stream.
	MaxPerStream int `json:"maxPerStream"`
}

// Settings for how often a custom reward may be redeemed per stream.
type CommunityPointsCustomRewardMaxPerUserPerStreamSetting struct {
	// Whether the maximum is being enforced.
	IsEnabled bool `json:"isEnabled"`
	// The most rewards of this type that can be redeemed per user per stream.
	MaxPerUserPerStream int `json:"maxPerUserPerStream"`
}

// Input for creating and updating a Community Points custom reward's max per stream settings.
type CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput struct {
	// Whether the maximum is being enforced.
	IsEnabled bool `json:"isEnabled"`
	// The most rewards of this type that can be redeemed per user per stream.
	MaxPerUserPerStream int `json:"maxPerUserPerStream"`
}

// A community points custom reward that has been redeemed in a channel.
type CommunityPointsCustomRewardRedemption struct {
	// The unique ID of this redemption.
	ID string `json:"id"`
	// The user-provided text input, if it exists.
	Input *string `json:"input"`
	// The custom reward that was redeemed.
	Reward *CommunityPointsCustomReward `json:"reward"`
	// The unique ID of the reward that was redeemed.
	RewardID string `json:"rewardID"`
	// The title of the custom reward that was redeemed, at the time it was redeemed.
	RewardTitle string `json:"rewardTitle"`
	// The status of this redemption.
	Status CommunityPointsCustomRewardRedemptionStatus `json:"status"`
	// The time that the reward was redeemed at.
	Timestamp time.Time `json:"timestamp"`
	// The user that redeemed the reward.
	User *User `json:"user"`
}

// A paginated list of Community Points redemptions, and its metadata.
// Only returns results for logged-in, authorized users, otherwise returns a nil response.
type CommunityPointsCustomRewardRedemptionConnection struct {
	// The list of items in this page.
	Edges []*CommunityPointsCustomRewardRedemptionEdge `json:"edges"`
	// Information about this page of Community Points redemptions.
	PageInfo *PageInfo `json:"pageInfo"`
}

// A page entry, that contains a CommunityPointsCustomRewardRedemption item and a cursor to
// return from the query to allow pagination.
type CommunityPointsCustomRewardRedemptionEdge struct {
	// Cursor used for next query.
	Cursor string `json:"cursor"`
	// The underlying Community Points redemption.
	Node *CommunityPointsCustomRewardRedemption `json:"node"`
}

// A template used to create a custom reward.
type CommunityPointsCustomRewardTemplate struct {
	// The custom background color for a reward created from this template.
	BackgroundColor string `json:"backgroundColor"`
	// The point cost for a reward created from this template.
	Cost int `json:"cost"`
	// The maximum number of redemptions for the reward created from this
	// template that can be redeemed per the global cooldown.
	GlobalCooldownSetting *CommunityPointsCustomRewardGlobalCooldownSetting `json:"globalCooldownSetting"`
	// The unique identifier for this reward template.
	ID string `json:"id"`
	// The default image for a reward created from this template.
	Image *CommunityPointsImage `json:"image"`
	// Whether only subscribers are allowed to redeem the reward created
	// from this template.
	IsSubOnly bool `json:"isSubOnly"`
	// Whether the reward created from this template requires users to enter
	// text input.
	IsUserInputRequired bool `json:"isUserInputRequired"`
	// The maximum number of redemptions for the reward created from this
	// template that can be redeemed per stream.
	MaxPerStreamSetting *CommunityPointsCustomRewardMaxPerStreamSetting `json:"maxPerStreamSetting"`
	// The maximum number of redemptions for the reward created from this
	// template that can be redeemed per user per stream.
	MaxPerUserPerStreamSetting *CommunityPointsCustomRewardMaxPerUserPerStreamSetting `json:"maxPerUserPerStreamSetting"`
	// The user-facing prompt for the reward created from this template.
	// If no prompt exists, will be null.
	Prompt *string `json:"prompt"`
	// Whether redemptions for the reward created from this template should
	// skip the broadcaster's request queue and get automatically fulfilled.
	ShouldRedemptionsSkipRequestQueue bool `json:"shouldRedemptionsSkipRequestQueue"`
	// The short title displayed for the reward created from this template.
	Title string `json:"title"`
}

// A collection of custom reward templates for a category on a channel.
type CommunityPointsCustomRewardTemplateCollection struct {
	// The category these templated custom rewards are for.
	Category CommunityPointsCustomRewardTemplateCollectionCategory `json:"category"`
	// The templated custom rewards.
	CustomRewardTemplates []*CommunityPointsCustomRewardTemplate `json:"customRewardTemplates"`
}

// Custom reward user redemption.
type CommunityPointsCustomRewardUserRedemption struct {
	// The custom reward.
	Reward *CommunityPointsCustomReward `json:"reward"`
	// The amount of redempetions per user on this reward during the current stream.
	UserRedemptionsCurrentStream int `json:"userRedemptionsCurrentStream"`
}

// Properties concerning the user's participation in the Community Points early access program.
type CommunityPointsEarlyAccessSettings struct {
	// Whether the user is eligible to sign up for Community Points early access.
	CanSignUp bool `json:"canSignUp"`
	// Whether the user has signed up for Community Points early access.
	IsSignedUp bool `json:"isSignedUp"`
}

// A community points emote.
type CommunityPointsEmote struct {
	// The emote's identifier.
	ID string `json:"id"`
	// The text token of the emote.
	Token string `json:"token"`
}

// A community points emote modification.
type CommunityPointsEmoteModification struct {
	// The modified emote.
	Emote *CommunityPointsEmote `json:"emote"`
	// Time that the modification was last updated globally in a way that should show a new content indicator to viewers.
	GloballyUpdatedForIndicatorAt time.Time `json:"globallyUpdatedForIndicatorAt"`
	// The emote modification's identifier.
	ID string `json:"id"`
	// The dark version of the icon to represent the modification made to the emote.
	ModifierIconDark *CommunityPointsImage `json:"modifierIconDark"`
	// The light version of the icon to represent the modification made to the emote.
	ModifierIconLight *CommunityPointsImage `json:"modifierIconLight"`
	// The title for the modification.
	Title string `json:"title"`
}

// A community points emote variant, includes base emote plus modifications.
type CommunityPointsEmoteVariant struct {
	// The base emote for this variant.
	Emote *CommunityPointsEmote `json:"emote"`
	// The emote variant's identifier.
	ID string `json:"id"`
	// Whether community points can be used to unlock the base emote.
	IsUnlockable bool `json:"isUnlockable"`
	// The modifications available to be unlocked for this emote.
	Modifications []*CommunityPointsEmoteModification `json:"modifications"`
}

// Image URLs of different sizes for community points rewards.
type CommunityPointsImage struct {
	// The URL for the small size image.
	URL string `json:"url"`
	// The URL for the medium size image.
	URL2x string `json:"url2x"`
	// The URL for the large size image.
	URL4x string `json:"url4x"`
}

// The information required for the client to upload an image for Community Points.
type CommunityPointsImageUploadInfo struct {
	// The upload ID.
	UploadID string `json:"uploadID"`
	// The URL to upload to.
	URL string `json:"url"`
}

// Holds the last time a content type was viewed.
type CommunityPointsLastViewedContentByType struct {
	// The type of content that was viewed at the lastViewedAt time.
	ContentType CommunityPointsContentType `json:"contentType"`
	// The time at which the contentType was last viewed. Will be null if the content hasn't been viewed.
	LastViewedAt *time.Time `json:"lastViewedAt"`
}

// Holds the last time a specific piece of content was viewed.
type CommunityPointsLastViewedContentByTypeAndID struct {
	// A unique identifier for the piece of content based on the type of content dictated by contentType.
	ContentID string `json:"contentID"`
	// The type of content that was viewed at the lastViewedAt time.
	ContentType CommunityPointsContentType `json:"contentType"`
	// The time at which the content was last viewed. Will be null if the content hasn't been viewed.
	LastViewedAt *time.Time `json:"lastViewedAt"`
}

// Availability of limited earn actions for a viewer in a specific channel.
type CommunityPointsLimitedEarnings struct {
	// Timestamp of when points will become available for cheering on the channel.
	// This will be nil if isCheerAvailable is true and can be nil when isCheerAvailable is false
	// indicating that there is not currently a time in the future when it will become available.
	CheerAvailableAt *time.Time `json:"cheerAvailableAt"`
	// A unique identifier.
	ID string `json:"id"`
	// Can the user cheer to get points on the channel.
	IsCheerAvailable bool `json:"isCheerAvailable"`
	// Can the user follow to get points on the channel.
	IsFollowAvailable bool `json:"isFollowAvailable"`
	// Can the user gift a subscription in the channel to get points on the channel.
	IsSubscriptionGiftAvailable bool `json:"isSubscriptionGiftAvailable"`
	// Timestamp of when points will become available for gifting subscriptions on the channel.
	// This will be nil if isSubscriptionGiftAvailable is true and can be nil when isSubscriptionGiftAvailable is false
	// indicating that there is not currently a time in the future when it will become available.
	SubscriptionGiftAvailableAt *time.Time `json:"subscriptionGiftAvailableAt"`
}

// A multiplier affecting the rate of community points earned for a user in a channel.
type CommunityPointsMultiplier struct {
	// The multiplying factor being applied.
	// Multipliers start at a base of 1.0, and are additive.
	// Two multipliers of [0.2] and [0.3] will give a final multiplier of 1.5x.
	Factor float64 `json:"factor"`
	// The reason that the multiplier is being applied.
	ReasonCode CommunityPointsMultiplierReason `json:"reasonCode"`
}

// Properties relating to a user's community points in a channel.
type CommunityPointsProperties struct {
	// Multipliers currently affecting the logged in user's rate of point gaining in this channel.
	// If there are no multipliers active, will be an empty array.
	ActiveMultipliers []*CommunityPointsMultiplier `json:"activeMultipliers"`
	// Points that are available for the user to click to claim in this channel. Null if there are no points available to claim.
	AvailableClaim *CommunityPointsClaim `json:"availableClaim"`
	// The number of community points this user currently has available to use in this channel.
	Balance int `json:"balance"`
	// Whether the user can redeem rewards on this channel for free.
	// The main example is broadcasters on their own channels.
	CanRedeemRewardsForFree bool `json:"canRedeemRewardsForFree"`
	// The community goal contributions.
	GoalContributions []*CommunityPointsCommunityGoalContribution `json:"goalContributions"`
	// Timestamps of when the user last viewed the different types of community points content on the channel.
	LastViewedContent []*CommunityPointsLastViewedContentByType `json:"lastViewedContent"`
	// Availability of limited earning actions for the user in this channel.
	LimitedEarnings *CommunityPointsLimitedEarnings `json:"limitedEarnings"`
	// The custom reward user redemptions for the current live stream.
	UserRedemptions []*CommunityPointsCustomRewardUserRedemption `json:"userRedemptions"`
}

// Optional filters that can be applied to a redemption queue query.
type CommunityPointsRedemptionQueueOptions struct {
	// The order of the results, either oldest first or newest first.
	Order *CommunityPointsCustomRewardRedemptionQueueSortOrder `json:"order"`
	// Filter results to only redemptions of this reward.
	RewardID *string `json:"rewardID"`
	// Filter results to only redemptions of this status.
	Status *CommunityPointsCustomRewardRedemptionStatus `json:"status"`
}

// A summary of information about redemptions of a given custom community points reward.
// Only returns results for logged-in, authorized users, otherwise returns a nil response.
type CommunityPointsRewardSummary struct {
	// The total number of unfulfilled redemptions of this reward on the channel.
	Count int `json:"count"`
	// If the count is at the max, the true count could be any number greater than or equal to the count.
	// Clients should indicate that there could be more redemptions than the number indicates.
	// For example, if count = 100 and isCountAtMaximum = true, clients could show "100+".
	IsCountAtMaximum bool `json:"isCountAtMaximum"`
	// The reward being summarized.
	Node *CommunityPointsCustomReward `json:"node"`
}

// An error from redeeming an unlock emote Community Points reward.
type CommunityPointsUnlockEmoteError struct {
	// The error code.
	Code CommunityPointsUnlockEmoteErrorCode `json:"code"`
}

// The type representing Community Points Update Custom Reward Redemption Statuses Progress.
type CommunityPointsUpdateCustomRewardRedemptionStatusesProgress struct {
	// The channel ID the redemptions are being updated for.
	ChannelID string `json:"channelID"`
	// Unique identifier for the progress.
	ID string `json:"id"`
	// The method being used to update the custom reward redemption statuses.
	Method CommunityPointsUpdateCustomRewardRedemptionStatusesMethod `json:"method"`
	// The new status the redemptions are being set to.
	NewStatus CommunityPointsCustomRewardRedemptionStatus `json:"newStatus"`
	// The number of redemptions that have been processed so far.
	Processed int `json:"processed"`
	// The reward ID the redemptions being updated are for.
	// Will only be set if method is BY_REWARD.
	RewardID *string `json:"rewardID"`
	// The total number of redemptions being updated.
	Total int `json:"total"`
}

// Properties relating to a user's community points across twitch.
type CommunityPointsUserProperties struct {
	// Timestamps of when the user last viewed the different global pieces of content for community points.
	LastViewedContent []*CommunityPointsLastViewedContentByTypeAndID `json:"lastViewedContent"`
}

// Settings for how many community points are awarded for a watch streak of a specific duration.
type CommunityPointsWatchStreakEarningSettings struct {
	// How many points are awarded for a streak of this length.
	Points int `json:"points"`
	// How long of a streak a user has.
	StreakLength int `json:"streakLength"`
}

// A company that is on Twitch.
type Company struct {
	// The bounty board campaigns that the company owns.
	BountyCampaigns *BountyCampaignConnection `json:"bountyCampaigns"`
	// The brand portal settings for the company.
	BrandPortalSettings *BrandPortalSettings `json:"brandPortalSettings"`
	// ID of the Company in the CurseForge Infrastructure.
	CurseCompanyID *string `json:"curseCompanyID"`
	// The estimated viewer reach for the pool of broadcasters this company is considering targeting.
	EstimatedBroadcasterViewerReach *BroadcasterViewerReach `json:"estimatedBroadcasterViewerReach"`
	// The games associated with the company. Optionally include games that a company can use for Bounty Board
	// campaigns (ie. "Just Chatting" for trailer campaigns).
	Games []*Game `json:"games"`
	// The company's unique identifier.
	ID string `json:"id"`
	// Legacy Companies need to agree to the Drops Terms.
	IsCampaignsEnabled bool `json:"isCampaignsEnabled"`
	// Legacy Companies are required to sign the Contract.
	IsContractSigned bool `json:"isContractSigned"`
	// Indicates if the Company is a Legacy Company from the first iteration of the DevSite.
	IsLegacy bool `json:"isLegacy"`
	// The human-readable name of the company.
	Name string `json:"name"`
	// Indicates if company is a developer, publisher or other.
	Type OrganizationType `json:"type"`
	// The Company URL for their Corporate Website.
	URL string `json:"url"`
}

// A Competition created by a competition organizer.
type Competition struct {
	// Banner image for the competition event page.
	BannerImageURL *string `json:"bannerImageURL"`
	// This is the amount of time (in minutes) available for participants to check-in once competition startAt has passed.
	CheckInDurationMinutes int `json:"checkInDurationMinutes"`
	// The time the competition was created.
	CreatedAt time.Time `json:"createdAt"`
	// Long form text block description for the competition and will be converted to Markdown client-side.
	Description *string `json:"description"`
	// The time the competition is scheduled to end.
	EndAt time.Time `json:"endAt"`
	// The format contains the type and type metadata of the competition. (i.e. single elimination, round robin, etc.).
	Format *CompetitionFormat `json:"format"`
	// The game being played in the competition.
	Game *Game `json:"game"`
	// Unique Competition ID.
	ID string `json:"id"`
	// Primary artwork for the competition.
	ImageURL *string `json:"imageURL"`
	// The name of the competition.
	Name string `json:"name"`
	// The competition organizer.
	Owner *User `json:"owner"`
	// The participant-facing points of contact for the competition that only registered participants can see.
	ParticipantOnlyContactInfo *CompetitionContactInfo `json:"participantOnlyContactInfo"`
	// The type of participant for the competition. e.g. SOLO, TEAM, ...
	ParticipantType CompetitionParticipantType `json:"participantType"`
	// Paginated list of participants in the competition.
	Participants *CompetitionParticipantConnection `json:"participants"`
	// A list of phases in the competition.
	Phases []*CompetitionPhase `json:"phases"`
	// Paginated list of players in the competition.
	Players *CompetitionPlayerConnection `json:"players"`
	// Long form text block description that explains the prizing for the competition and will be converted to Markdown client-side.
	PrizeDescription *string `json:"prizeDescription"`
	// The public points of contact for the competition that anyone can see.
	PublicContactInfo *CompetitionContactInfo `json:"publicContactInfo"`
	// The time the competition is scheduled to end registration.
	RegistrationEndAt time.Time `json:"registrationEndAt"`
	// The maximum number of players in a REGISTERED state.
	RegistrationLimit int `json:"registrationLimit"`
	// The type of a registration for the competition. e.g. OPEN, INVITATIONAL, ...
	RegistrationType RegistrationType `json:"registrationType"`
	// Long form text block description that explains the rules for the competition and will be converted to Markdown client-side.
	RulesDescription *string `json:"rulesDescription"`
	// The relationship between the authenticated user and the competition.
	Self *CompetitionSelfEdge `json:"self"`
	// Paginated, ordered list representing the standings of the competition.
	Standings *CompetitionStandingConnection `json:"standings"`
	// The time the competition is scheduled to start.
	StartAt time.Time `json:"startAt"`
	// The state of the tournament.
	State CompetitionState `json:"state"`
	// The number of players within a single team entity. Must be 1 for solo-type competitions.
	TeamSize int `json:"teamSize"`
	// Paginated list of teams in the competition.
	Teams *CompetitionTeamConnection `json:"teams"`
	// Link URL to any additional terms and conditions.
	TermsURL *string `json:"termsURL"`
	// The time the competition was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
	// Visibility of the competition.
	Visibility CompetitionVisibilityState `json:"visibility"`
}

// Paginated list of Competitions.
type CompetitionConnection struct {
	// The elements of the list.
	Edges []*CompetitionEdge `json:"edges"`
	// Are there more competitions in the list and what is the cursor.
	PageInfo *PageInfo `json:"pageInfo"`
}

// The contact information to contact the organizers for the competition.
type CompetitionContactInfo struct {
	// Link to Discord server for competition contact purposes.
	DiscordURL *string `json:"discordURL"`
	// Email address point of contact for the competition.
	Email *string `json:"email"`
}

// Contains information about a Competition's relationship to a given page (connection),
// and the Competition itself.
type CompetitionEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// A competition record in the list of competitons.
	Node *Competition `json:"node"`
}

// Information to communicate to the user about an error state.
type CompetitionError struct {
	// The error code.
	Code CompetitionErrorCode `json:"code"`
	// The error message string.
	Message string `json:"message"`
}

// The CompetitionFormat contains the type and type metadata of the competition. (i.e. single elimination, round robin, etc.).
type CompetitionFormat struct {
	// The details of the format, currently only used for LEADERBOARD type.
	Details FormatTypeDetails `json:"details"`
	// The type of the format for the competition.
	Type FormatType `json:"type"`
}

// A Lobby in a phase.
type CompetitionLobby struct {
	// Lobby ID of lobby to advance the winner to.
	AdvanceNextLobby *string `json:"advanceNextLobby"`
	// Unique lobby ID.
	ID string `json:"id"`
	// Lobby ID of lobby to advance the loser to.
	LossNextLobby *string `json:"lossNextLobby"`
	// The participants of a lobby, and their scores.
	Participants []*CompetitionLobbyParticipant `json:"participants"`
	// The count of reported scores of the lobby.
	ReportedScoreCount int `json:"reportedScoreCount"`
	// The state of the lobby.
	State LobbyState `json:"state"`
	// The participant who had a higher score, if scores are equal and the lobby is done, the lobby ended in a tie and winner returns null
	Winner *CompetitionLobbyParticipant `json:"winner"`
}

// A CompetitionLobbyParticipant, and its scores, in a lobby.
type CompetitionLobbyParticipant struct {
	// The detailed participant associated with the lobby participant, can be a Competition Player or Competition Team.
	DetailedParticipant CompetitionParticipant `json:"detailedParticipant"`
	// Unique ID for CompetitionLobbyParticipant.
	ID string `json:"id"`
	// The score for this participant.
	Score *int `json:"score"`
	// Tie breaker points awarded to the participant for this lobby
	TiebreakerScore *int `json:"tiebreakerScore"`
}

// The features a user has access to when creating a competition with the Versus product.
type CompetitionOrganizerCapability struct {
	// The features a user available to them when they are a Competition Organizer. null or [] mean no special permissions are given to this user.
	AllowedRegistrationTypes []RegistrationType `json:"allowedRegistrationTypes"`
	// Can this user upload or attach additional terms of service for a competition.
	CanAttachTerms *bool `json:"canAttachTerms"`
}

// Sorted list of competition participants.
type CompetitionParticipantConnection struct {
	// The elements of the list.
	Edges []*CompetitionParticipantEdge `json:"edges"`
	// Are there more competition participants and what is the cursor.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total amount of competition participants in the competition.
	TotalCount int `json:"totalCount"`
}

// Contains information about a competition participant relationship to the paginated request,
// and the participant themselves.
type CompetitionParticipantEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// A competition participant record.
	Node CompetitionParticipant `json:"node"`
}

// A Phase created by a competition organizer.
type CompetitionPhase struct {
	// Unique phase ID.
	ID string `json:"id"`
	// The lobbies in a phase.
	Lobbies []*CompetitionLobby `json:"lobbies"`
	// The state of the phase. It is derived on whether any of the lobbies are actively playing.
	State PhaseState `json:"state"`
	// For more complex tournaments, the type determines how you progress after a phase.
	Type *CompetitionPhaseType `json:"type"`
}

// The placement within the competition for an participant.
type CompetitionPlacement struct {
	// The position in the total participant list a participant ranks.
	Position *int `json:"position"`
}

// A player is solo participant in a Competition.
type CompetitionPlayer struct {
	// Competition ID player is a part of.
	CompetitionID string `json:"competitionID"`
	// The time the player was added.
	CreatedAt time.Time `json:"createdAt"`
	// The discord username for the player.
	DiscordUsername *string `json:"discordUsername"`
	// Unique ID for competition player.
	ID string `json:"id"`
	// The in game username for the player.
	InGameUsername *string `json:"inGameUsername"`
	// Indicates whether the player is disqualified.
	IsDisqualified bool `json:"isDisqualified"`
	// The state a player has in the competition.
	State CompetitionPlayerState `json:"state"`
	// The associated team the user is part of.
	Team *CompetitionTeam `json:"team"`
	// The total score for the competition player.
	TotalScore int `json:"totalScore"`
	// The associated user.
	User *User `json:"user"`
}

func (CompetitionPlayer) IsCompetitionParticipant() {}

// Paginated list of players in a Competition.
type CompetitionPlayerConnection struct {
	// The elements of the list.
	Edges []*CompetitionPlayerEdge `json:"edges"`
	// Are there more players in the competition and what is the cursor.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total amount of players in the competition.
	TotalCount int `json:"totalCount"`
}

// Contains information about a Players relationship to a given page (connection),
// and the Player themselves.
type CompetitionPlayerEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// A competition record in the list of competitions.
	Node *CompetitionPlayer `json:"node"`
}

// The relationship between the authenticated user and the competition.
type CompetitionSelfEdge struct {
	// Whether the user is invited to the competition.
	IsInvited *bool `json:"isInvited"`
	// Whether the user is the owner.
	IsOwner *bool `json:"isOwner"`
	// Whether the user is a player in the competition.
	IsPlayer *bool `json:"isPlayer"`
	// Whether the user is registered in the competition.
	IsRegistered *bool `json:"isRegistered"`
}

// A single participant's competition standing including score and placement.
type CompetitionStanding struct {
	// A record of all lobbies (1 per phase) in which the participant has competed.
	History []*HistoricalCompetitionLobby `json:"history"`
	// The participant whose score and placement are being reported.
	Participant CompetitionParticipant `json:"participant"`
	// Placement is a participant's rank in the competition standings.
	Placement *CompetitionPlacement `json:"placement"`
	// The participant's current score for the competition.
	Score *int `json:"score"`
	// Summation of bonus points awarded to a participant.
	TiebreakerScore *int `json:"tiebreakerScore"`
	// Percentage of done lobbies the participant has won out of the done lobbies the participant in, if participant is not in any done lobbies this will be null.
	WinPercentage *int `json:"winPercentage"`
}

// Paginated list of standings for a Competition.
type CompetitionStandingConnection struct {
	// The elements of the list.
	Edges []*CompetitionStandingEdge `json:"edges"`
	// Are there more standings for the competition and what is the cursor.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Contains information about a CompetitionStanding's relationship to a given page (connection),
// and the standing itself.
type CompetitionStandingEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// A competition standing record in the list of competition standings.
	Node *CompetitionStanding `json:"node"`
}

// A Team is scheduled or has competed in a Competition.
type CompetitionTeam struct {
	// The captain of the team is a Competition Player.
	Captain *CompetitionPlayer `json:"captain"`
	// CompetitionID we are a part of.
	CompetitionID string `json:"competitionID"`
	// Unique ID for competition team.
	ID string `json:"id"`
	// Indicates whether the team is disqualified.
	IsDisqualified bool `json:"isDisqualified"`
	// The members of the team are Competition Players.
	Members []*CompetitionPlayer `json:"members"`
	// The name of the competition team.
	Name string `json:"name"`
	// The relationship between the authenticated user and the competition team.
	Self *CompetitionTeamSelfEdge `json:"self"`
	// The total score for the competition team.
	TotalScore int `json:"totalScore"`
}

func (CompetitionTeam) IsCompetitionParticipant() {}

// List of competition teams and their scores.
type CompetitionTeamConnection struct {
	// The elements of the list.
	Edges []*CompetitionTeamEdge `json:"edges"`
	// Are there more teams in the competition and what is the cursor.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total amount of teams in the competition.
	TotalCount int `json:"totalCount"`
}

// Contains information about a Team relationship to a given page (connection),
// and the Team themselves.
type CompetitionTeamEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// A competition team record.
	Node *CompetitionTeam `json:"node"`
}

// The relationship between the authenticated user and the competition Team.
type CompetitionTeamSelfEdge struct {
	// Whether the user is the captain.
	IsCaptain bool `json:"isCaptain"`
}

// The required configuration to activate a component extension.
type ComponentActivationInput struct {
	// The slot name of where the component extension should be displayed.
	Slot string `json:"slot"`
	// The horizontal positioning of the left side of the component extension from the left side
	// of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
	X *int `json:"x"`
	// The vertical positioning of the top side of the component extension from the top side
	// of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
	Y *int `json:"y"`
}

// The view configuration of an extension if the component anchor is supported.
type ComponentView struct {
	// Specifies the width of a component extension in relation to it's targetHeight and aspectRatioY.
	//
	// NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth.
	//        however, since both will be used for a short time during the rollout of the new UI,
	//        aspectWidth and aspectHeight will not be deprecated until later.
	AspectRatioX int `json:"aspectRatioX"`
	// Specifies the height of a component extension in relation to it's targetHeight and aspectRatioX.
	//
	// NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
	//        however, since both will be used for a short time during the rollout of the new UI,
	//        aspectWidth and aspectHeight will not be deprecated until later.
	AspectRatioY int `json:"aspectRatioY"`
	// Specifies whether or not the extension has the ability to link to external websites.
	CanLinkExternalContent bool `json:"canLinkExternalContent"`
	// Specifies whether to automatically scale the extension iframe using css zoom as the video
	// player dimensions change.
	HasAutoscale bool `json:"hasAutoscale"`
	// If Autoscale is true, this indicates the baseline width of the extension.
	// This fields is optional, but is required if hasAutoscale is true.
	ScalePixels *int `json:"scalePixels"`
	// The percentage of the available space (0-100) (between the top and bottom player controls)
	// that the extension aims to consume.
	//
	// NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
	//        however, since both will be used for a short time during the rollout of the new UI,
	//        aspectWidth and aspectHeight will not be deprecated until later.
	TargetHeight int `json:"targetHeight"`
	// Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
	ViewerPath string `json:"viewerPath"`
	// The URL which should be loaded in for the extension.
	ViewerURL string `json:"viewerURL"`
}

func (ComponentView) IsExtensionView() {}

// The view configuration of an extension if the component anchor is supported.
type ComponentViewInput struct {
	// The developer configured height of the extension as a ratio relative to it's width.
	AspectHeight int `json:"aspectHeight"`
	// The developer configured width of the extension as a ratio relative to it's height.
	AspectWidth int `json:"aspectWidth"`
	// Specifies whether CSS zooming should be applied to the CE container, creating a consistent
	// size of 1024 pixels along the long edge of the component. Default: true.
	HasZoom bool `json:"hasZoom"`
	// Size of the long edge of the Component Extension, relative to the length of the corresponding
	// interactable dimension of the video.
	Size float64 `json:"size"`
	// Relative path of the HTML file to load for this view.
	ViewerPath string `json:"viewerPath"`
	// If hasZoom is set to true, specify the effective CSS zoom to apply to the long edge of the CE.
	// Default: 1024.
	ZoomPixels *int `json:"zoomPixels"`
}

// ConfigView holds the view configuration of an extension if the config page is supported.
type ConfigView struct {
	// Specifies whether or not the extension has the ability to link to external websites.
	CanLinkExternalContent bool `json:"canLinkExternalContent"`
	// Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
	ViewerPath string `json:"viewerPath"`
	// The URL which should be loaded in for the extension.
	ViewerURL string `json:"viewerURL"`
}

func (ConfigView) IsExtensionView() {}

// ConfigViewInput holds the view configuration of an extension if the config page is supported.
type ConfigViewInput struct {
	// Relative path of the HTML file to load for this view.
	ViewerPath string `json:"viewerPath"`
}

// ConnectAdIdentityInput accepts a deviceID and other parameters to generate an ad identity for that user.
type ConnectAdIdentityInput struct {
	// mobile is an optional field that provides mobile device data.
	Mobile *MobileAdIdentityInput `json:"mobile"`
	// targetDeviceID is the acting device ID.
	TargetDeviceID string `json:"targetDeviceID"`
}

// ConnectAdIdentityPayload contains the identity URL.
type ConnectAdIdentityPayload struct {
	// URL that the client should use to link ad identity.
	IdentityURL *string `json:"identityURL"`
}

// The consent status returned for the current user.
type Consent struct {
	// The unique identifier of a consent status.
	ID string `json:"id"`
	// Identifier to determine whether consent is denied due to user underage.
	IsDeniedUnderage bool `json:"isDeniedUnderage"`
	// Privacy law, e.g. CCPA or GDPR.
	PrivacyLawName PrivacyLawName `json:"privacyLawName"`
	// Identifier to determine whether should notification to the user.
	ShouldShowNotification bool `json:"shouldShowNotification"`
	// Identifier to determine whether should show the consent settings page to the user.
	ShouldShowSettingsPage bool `json:"shouldShowSettingsPage"`
	// A list of vendor consent status of a user.
	VendorStatus []*VendorConsentStatus `json:"vendorStatus"`
}

// Contribute community goal error.
type ContributeCommunityPointsCommunityGoalError struct {
	// The error code.
	Code ContributeCommunityPointsCommunityGoalErrorCode `json:"code"`
}

// Contribute community goal input.
type ContributeCommunityPointsCommunityGoalInput struct {
	// The redemption amount.
	Amount int `json:"amount"`
	// The channel.
	ChannelID string `json:"channelID"`
	// The id of the community goal.
	GoalID string `json:"goalID"`
	// The id of this transaction.
	TransactionID string `json:"transactionID"`
}

// Contribute community goal payload.
type ContributeCommunityPointsCommunityGoalPayload struct {
	// The error, if any.
	Error *ContributeCommunityPointsCommunityGoalError `json:"error"`
}

// Contribute to challenge error.
type ContributeToChallengeError struct {
	// Code describing the error.
	Code ContributeToChallengeErrorCode `json:"code"`
}

// Inputs for contributing to a challenge.
type ContributeToChallengeInput struct {
	// The amount of bits being contributed for this challenge.
	Bits int `json:"bits"`
	// The id of the challenge that is being contributed to.
	ChallengeID string `json:"challengeID"`
	// The user id of the contributer.
	UserID string `json:"userID"`
}

// Output from the contribute to challenge mutation.
type ContributeToChallengePayload struct {
	// The participant object returned by the Contribute to Challenge operation.
	ChallengeParticipant *ChannelChallengeParticipant `json:"challengeParticipant"`
	// If present, there was an error with the request.
	Error *ContributeToChallengeError `json:"error"`
}

// A 4xx-level error from the CreateBadgeFlair mutation
type CreateBadgeFlairError struct {
	// Code describing the cause of the error
	Code CreateBadgeFlairErrorCode `json:"code"`
	// String containing any relevant error message from Subscriptions
	Message string `json:"message"`
}

// Input to the CreateBadgeFlair mutation
type CreateBadgeFlairInput struct {
	// ID of the creator/channel which owns this custom badge flair.
	ChannelID string `json:"channelID"`
	// The S3 ID of the 1x sized badge, provided to clients by Upload Service. (See the createLoyaltyBadgeUploadConfig mutation.)
	Image1xID string `json:"image1xID"`
	// The S3 ID of the 2x sized badge provided to clients by Upload Service. (See the createLoyaltyBadgeUploadConfig mutation.)
	Image2xID string `json:"image2xID"`
	// The S3 ID of the 4x sized badge provided to clients by Upload Service. (See the createLoyaltyBadgeUploadConfig mutation.)
	Image4xID string `json:"image4xID"`
	// Sub tier which receives access to this flair.
	Tier CreatorBadgeFlairTier `json:"tier"`
}

// Payload from the CreateBadgeFlair mutation
type CreateBadgeFlairPayload struct {
	// Error representing any 4xx-level error, if any
	Error *CreateBadgeFlairError `json:"error"`
}

// CreateBitsChallengeConditionForExtensionInput creates a Bits condition on behalf of a user by an extension.
type CreateBitsChallengeConditionForExtensionInput struct {
	// A list of the different bits recipients and their weighted share of the total bits pool once the condition is satisfied.
	// If this is not defined during condition creation, it must be defined when the condition is satisfied.
	BitsRecipientWeightedShares []*BitsChallengeConditionPoolRecipientWeightedShare `json:"bitsRecipientWeightedShares"`
	// Description of the condition.
	Description *string `json:"description"`
	// Whether to disable the condition once it has been satisfied or keep it active.
	DisableWhenSatisfied bool `json:"disableWhenSatisfied"`
	// ID of the extension creating the conditional.
	ExtensionID string `json:"extensionID"`
	// ID of the channel where the extension is installed.
	// TODO: change to required once the extension coordinator starts sending this param.
	ExtensionInstallationChannelID *string `json:"extensionInstallationChannelID"`
	// Name of the condition.
	Name string `json:"name"`
	// Time when the condition should time out.
	TimeoutAt *time.Time `json:"timeoutAt"`
}

// CreateBitsChallengeConditionForExtensionPayload returns the new condition that was created.
type CreateBitsChallengeConditionForExtensionPayload struct {
	// The newly created condition.
	Condition *ChallengeCondition `json:"condition"`
	// If present, there was an error in the request.
	Error *CreateChallengeConditionError `json:"error"`
}

// CreateBitsChallengeConditionParticipantForExtensionInput creates a Bits condition participant on behalf of a user by an extension.
type CreateBitsChallengeConditionParticipantForExtensionInput struct {
	// Bits quantity to be held pending condition satisfaction.
	BitsAmount int `json:"bitsAmount"`
	// ID of the associated condition.
	ConditionID string `json:"conditionID"`
	// TUID of condition owner.
	ConditionOwnerID string `json:"conditionOwnerID"`
	// ID of the extension creating the conditionParticipant.
	ExtensionID string `json:"extensionID"`
	// Time in seconds, after which the conditionParticipant is expired and the Bits are released (range: 1-43_200).
	TTLSeconds int `json:"ttlSeconds"`
}

// CreateBitsChallengeConditionParticipantForExtensionPayload returns the new condition participant that was created.
type CreateBitsChallengeConditionParticipantForExtensionPayload struct {
	// The newly created condition participant.
	ConditionParticipant *ChallengeConditionParticipant `json:"conditionParticipant"`
	// If present, there was an error in the request.
	Error *CreateChallengeConditionParticipantError `json:"error"`
}

// CreateBountyCampaignInput includes the campaign that is being created.
type CreateBountyCampaignInput struct {
	// The platforms that the campaign applies to.
	AvailablePlatforms []string `json:"availablePlatforms"`
	// The list of broadcaster IDs to blacklist (if any) for the campaign.
	BlacklistedBroadcasters []string `json:"blacklistedBroadcasters"`
	// Optional box art URL for the campaign.
	BoxArtURL *string `json:"boxArtURL"`
	// The message that will be shown to the broadcaster when they view the campaign.
	BroadcasterMessage *string `json:"broadcasterMessage"`
	// The multiplier for the broadcaster payout rate.
	BroadcasterMultiplier float64 `json:"broadcasterMultiplier"`
	// The budget for the campaign in cents.
	BudgetCents int `json:"budgetCents"`
	// The chat Calls to Action for the campaign.
	ChatCTAs []*BountyCampaignChatCTAInput `json:"chatCTAs"`
	// The ID of the content that the campaign is related to.
	ContentID *string `json:"contentID"`
	// Optional cover URL for the campaign.
	CoverURL *string `json:"coverURL"`
	// Optional display for the campaign.
	DisplayName *string `json:"displayName"`
	// When the campaign will end.
	EndAt time.Time `json:"endAt"`
	// If the campaing is a promotional campaign.
	IsPromotionEligible *bool `json:"isPromotionEligible"`
	// The ID of the organization that the campaign is related to.
	OrganizationID string `json:"organizationID"`
	// If the campaign should allow any game to be played.
	ShouldAllowAllGames *bool `json:"shouldAllowAllGames"`
	// The optional name of the sponsor of the campaign.
	Sponsor *string `json:"sponsor"`
	// When the campaign will start.
	StartAt time.Time `json:"startAt"`
	// Deprecated. How long the broadcaster needs to stream the sponsored content to complete the bounty (in minutes).
	StreamLengthMinutes *int `json:"streamLengthMinutes"`
	// How long the broadcaster needs to stream the sponsored content to complete the bounty (in seconds).
	StreamLengthSeconds *int `json:"streamLengthSeconds"`
	// Flag to target all broadcaters for the campaign.
	TargetAllBroadcasters *bool `json:"targetAllBroadcasters"`
	// Flag to target all countries for the campaign.
	TargetAllCountries *bool `json:"targetAllCountries"`
	// Flag to target all games for the campaign.
	TargetAllGames *bool `json:"targetAllGames"`
	// The click target of the campaign if it is a promotional campaign.
	TargetPromotionalVideoClicks *int `json:"targetPromotionalVideoClicks"`
	// Flag to target variety broadcaters for the campaign.
	TargetVarietyBroadcasters *bool `json:"targetVarietyBroadcasters"`
	// Targeted countries for the campaign (represented by ISO 3166-1 alpha-2).
	TargetedCountries []string `json:"targetedCountries"`
	// Targeted Games (game titles) for the campaign.
	TargetedGames []string `json:"targetedGames"`
	// The title of the campaign.
	Title string `json:"title"`
	// The tracking URLs for this campaign.
	TrackingPixels []*TrackingPixelInput `json:"trackingPixels"`
	// The type of the campaign.
	Type *BountyCampaignType `json:"type"`
	// Deprecated, use videos instead. The URL of the video for this campaign.
	VideoURL *string `json:"videoURL"`
	// The video URLS for the campaign.
	Videos []*BountyCampaignVideoInput `json:"videos"`
}

// Data that was mutated after the campaign was created.
type CreateBountyCampaignPayload struct {
	// The campaign that was created.
	Campaign *BountyCampaign `json:"campaign"`
}

// CreateBountyCampaignUploadConfigInput is the input for create bounty campaign upload configuration.
type CreateBountyCampaignUploadConfigInput struct {
	// The ID of the organization that the campaign is related to.
	OrganizationID string `json:"organizationID"`
	// The image type to be uploaded.
	UploadType BountyCampaignUploadType `json:"uploadType"`
}

// Returned information about image upload including URL to upload the image to.
type CreateBountyCampaignUploadConfigPayload struct {
	// Unique identifier for the image.
	ImageID *string `json:"imageID"`
	// Unique identifier for the generated URL.
	UploadID *string `json:"uploadID"`
	// The actual URL to be used by the client to upload the image.
	UploadURL *string `json:"uploadURL"`
}

// Inputs for creating a new celebration.
type CreateCelebrationInput struct {
	// Where on the channel page the celebration will show.
	Area CelebrationArea `json:"area"`
	// Channel id to create the celebration on.
	ChannelID string `json:"channelID"`
	// Length the celebration will play.
	DurationMilliseconds int `json:"durationMilliseconds"`
	// Effect which will show when the celebration triggers (ex Fireworks).
	Effect CelebrationEffect `json:"effect"`
	// Threshold which will trigger the celebration (ex: Cheering 100 Bits).
	EventThreshold int `json:"eventThreshold"`
	// Event type which will trigger the celebration (ex: Cheering Bits).
	EventType CelebrationEventType `json:"eventType"`
	// Intensity of the celebration.
	// Should be bounded (TBA) value which will determine the spectacle of the celebration.
	Intensity int `json:"intensity"`
	// If true, the celebration is enabled.
	IsEnabled bool `json:"isEnabled"`
}

// Outputs from the create celebration mutation.
type CreateCelebrationPayload struct {
	// The created celebration.
	Celebration *Celebration `json:"celebration"`
	// If present, there was an error with the request.
	Error *CelebrationError `json:"error"`
}

// Create Challenge Condition error.
type CreateChallengeConditionError struct {
	// Code describing the error.
	Code CreateChallengeConditionErrorCode `json:"code"`
}

// Create Challenge Condition Participant error.
type CreateChallengeConditionParticipantError struct {
	// Code describing the error.
	Code CreateChallengeConditionParticipantErrorCode `json:"code"`
}

// CreateChanletInput creates a chanlet under the given channelID.
type CreateChanletInput struct {
	// The ID of the channel the chanlet should belong to.
	ChannelID string `json:"channelID"`
}

// CreateChanletPayload returns the new chanlet that was created.
type CreateChanletPayload struct {
	// The chanlet that was created.
	Chanlet *Channel `json:"chanlet"`
	// The channelID that the chanlet was created under.
	ChannelID string `json:"channelID"`
}

// CreateClipError is an error associated with the createClip mutation.
type CreateClipError struct {
	// The associated error code.
	Code *CreateClipErrorCode `json:"code"`
}

// CreateClipInput creates a clip either from a broadcast or video. If both broadcastID
// and videoID are set, the broadcastID will be preferred.
type CreateClipInput struct {
	// The ID of the broadcast to create a clip from.
	BroadcastID *string `json:"broadcastID"`
	// The ID of the broadcaster that the broadcast or video belongs to.
	BroadcasterID string `json:"broadcasterID"`
	// The number of seconds into the broadcast or video to create the clip from.
	OffsetSeconds float64 `json:"offsetSeconds"`
	// The ID of the video to create a clip from.
	VideoID *string `json:"videoID"`
}

// CreateClipPayload returns the created clip or any error that prevented the clip creation.
type CreateClipPayload struct {
	// The created clip has all fields execpt for durationSeconds and viewCount.
	Clip *Clip `json:"clip"`
	// The error when a clip fails to create.
	Error *CreateClipError `json:"error"`
}

// Inputs for creating a new collection.
type CreateCollectionInput struct {
	// A description of the collection being created.
	Description *string `json:"description"`
	// The id of the user who will own the collection.
	OwnerID string `json:"ownerID"`
	// The title of the collection being created.
	Title string `json:"title"`
}

// The response from creating a new collection.
type CreateCollectionPayload struct {
	// The newly created collection.
	Collection *Collection `json:"collection"`
}

// Create community goal error.
type CreateCommunityPointsCommunityGoalError struct {
	// The error code.
	Code CreateCommunityPointsCommunityGoalErrorCode `json:"code"`
}

// Create community goal input.
type CreateCommunityPointsCommunityGoalInput struct {
	// The amount of community points that this goal needs to succeed.
	AmountNeeded int `json:"amountNeeded"`
	// The background color of this goal.
	BackgroundColor string `json:"backgroundColor"`
	// The channel.
	ChannelID string `json:"channelID"`
	// The description of this goal.
	Description *string `json:"description"`
	// The *initial* duration the streamer set for the goal.
	// Only really used during the UNSTARTED state; once the goal is started
	// the endedAt timestamp is populated (and updated for extended deadlines).
	DurationDays int `json:"durationDays"`
	// The title of this goal.
	Title string `json:"title"`
}

// Create community goal payload.
type CreateCommunityPointsCommunityGoalPayload struct {
	// The error, if any.
	Error *CreateCommunityPointsCommunityGoalError `json:"error"`
	// The community goal that was created.
	Goal *CommunityPointsCommunityGoal `json:"goal"`
}

// An error from creating a custom Community Points reward in a channel.
type CreateCommunityPointsCustomRewardError struct {
	// An identifier for the error that occurred.
	Code CreateCommunityPointsCustomRewardErrorCode `json:"code"`
	// On TOO_MANY_REWARDS, the most custom rewards a channel can have.
	MaxRewards *int `json:"maxRewards"`
}

// Input for creating a custom Community Points reward in a channel.
type CreateCommunityPointsCustomRewardInput struct {
	// The optional custom background color for this reward.
	// Should be a hex color string, for example "FF0000".
	BackgroundColor *string `json:"backgroundColor"`
	// The channel ID that the reward is being created in.
	ChannelID string `json:"channelID"`
	// The point cost of this reward.
	Cost int `json:"cost"`
	// The length of the global cooldown applied to rewards redeemed of this type.
	GlobalCooldownSetting *CommunityPointsCustomRewardGlobalCooldownSettingInput `json:"globalCooldownSetting"`
	// Whether only subscribers are allowed to redeem this reward in this channel.
	IsSubOnly bool `json:"isSubOnly"`
	// Whether this reward requires users to enter text input.
	IsUserInputRequired bool `json:"isUserInputRequired"`
	// The most rewards of this type that can be redeemed per stream.
	MaxPerStreamSetting *CommunityPointsCustomRewardMaxPerStreamSettingInput `json:"maxPerStreamSetting"`
	// The most rewards of this type that can be redeemed per user per stream.
	MaxPerUserPerStreamSetting *CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput `json:"maxPerUserPerStreamSetting"`
	// The optional user-facing prompt for this reward.
	Prompt *string `json:"prompt"`
	// Optional boolean for whether redemptions for this reward should skip the broadcaster's
	// request queue and get automatically fulfilled. Defaults to false.
	ShouldRedemptionsSkipRequestQueue *bool `json:"shouldRedemptionsSkipRequestQueue"`
	// The id for the CustomRewardTemplate this reward is being created from. Null if a template wasn't used.
	TemplateID *string `json:"templateID"`
	// The short title displayed for this reward.
	Title string `json:"title"`
}

// The response from creating a custom Community Points reward in a channel.
type CreateCommunityPointsCustomRewardPayload struct {
	// An error that occurred while creating a custom Community Points reward in a channel.
	Error *CreateCommunityPointsCustomRewardError `json:"error"`
	// The newly created reward.
	Reward *CommunityPointsCustomReward `json:"reward"`
}

// An error from generating upload info for Community Points images.
type CreateCommunityPointsImageUploadInfoError struct {
	// An identifier for the error that occurred.
	Code *CreateCommunityPointsImageUploadInfoErrorCode `json:"code"`
}

// Input for generating upload info (urls and upload IDs) for uploading Community Points images.
// Channel ID is required. Only one of the other three fields should be set, to indicate what the image is being uploaded for.
type CreateCommunityPointsImageUploadInfoInput struct {
	// If set, this request is for uploading new images for the given automatic reward.
	AutomaticRewardType *CommunityPointsAutomaticRewardType `json:"automaticRewardType"`
	// The channel ID to upload images for.
	ChannelID string `json:"channelID"`
	// If set, this request is for uploading new images for the given custom reward.
	CustomRewardID *string `json:"customRewardID"`
	// If set, this request is for uploading new images for the given community goal.
	GoalID *string `json:"goalID"`
	// If set, this request is for uploading new images for the channel Community Points icon.
	Icon *bool `json:"icon"`
}

// The response from generating upload info for Community Points images.
type CreateCommunityPointsImageUploadInfoPayload struct {
	// An error that occurred retrieving upload info for Community Points.
	Error *CreateCommunityPointsImageUploadInfoError `json:"error"`
	// The upload info (url and upload ID) for the large version of the image.
	UploadInfoLarge *CommunityPointsImageUploadInfo `json:"uploadInfoLarge"`
	// The upload info (url and upload ID) for the medium version of the image.
	UploadInfoMedium *CommunityPointsImageUploadInfo `json:"uploadInfoMedium"`
	// The upload info (url and upload ID) for the small version of the image.
	UploadInfoSmall *CommunityPointsImageUploadInfo `json:"uploadInfoSmall"`
}

// The competition contact info for creates.
type CreateCompetitionContactInfoInput struct {
	// Link to Discord server for competition contact purposes.
	DiscordURL *string `json:"discordURL"`
	// Email address point of contact for the competition.
	Email *string `json:"email"`
}

// Create a Competition.
type CreateCompetitionInput struct {
	// Banner image for the competition event page.
	BannerImageURL *string `json:"bannerImageURL"`
	// This is the amount of time (in minutes) available for participants to check-in once competition startAt has passed.
	CheckInDurationMinutes int `json:"checkInDurationMinutes"`
	// Long form description of the competition.
	Description *string `json:"description"`
	// The time the competition is scheduled to end.
	EndAt time.Time `json:"endAt"`
	// The competition format type (i.e. enum values of LEADERBOARD, ROUND_ROBIN, SINGLE_ELIM etc.).
	FormatType FormatType `json:"formatType"`
	// The game_id of the game being played in the competition.
	GameID string `json:"gameID"`
	// Primary artwork for the competition.
	ImageURL *string `json:"imageURL"`
	// The required inputs for leaderboard format.
	LeaderboardDetails *CreateCompetitionLeaderboardDetailsInput `json:"leaderboardDetails"`
	// The name of the competition.
	Name string `json:"name"`
	// Owner of the Competition, or filled in as user making the request.
	OwnerID *string `json:"ownerID"`
	// The participant-facing points of contact for the competition that only registered players can see.
	ParticipantOnlyContactInfo *CreateCompetitionContactInfoInput `json:"participantOnlyContactInfo"`
	// The type of participant for the competition. e.g. SOLO, TEAM, ...
	ParticipantType CompetitionParticipantType `json:"participantType"`
	// Long form text block description that explains the prizing for the competition and will be converted to Markdown client-side.
	PrizeDescription *string `json:"prizeDescription"`
	// The public points of contact for the competition that anyone can see.
	PublicContactInfo *CreateCompetitionContactInfoInput `json:"publicContactInfo"`
	// The time the competition is scheduled to end registration.
	RegistrationEndAt time.Time `json:"registrationEndAt"`
	// The maximum number of players in a REGISTERED state. A default value will be set if none is provided.
	RegistrationLimit *int `json:"registrationLimit"`
	// The type of a registration for the competition. e.g. OPEN, INVITATIONAL, ...
	RegistrationType RegistrationType `json:"registrationType"`
	// Long form text block description that explains the rules for the competition and will be converted to Markdown client-side.
	RulesDescription *string `json:"rulesDescription"`
	// The time the competition is scheduled to start.
	StartAt time.Time `json:"startAt"`
	// The state the Competition. Defaults to the UPCOMING state if not specified.
	State *CompetitionState `json:"state"`
	// The number of players within a single team entity. Must be 1 for solo-type competitions.
	TeamSize int `json:"teamSize"`
	// Link URL to any additional terms and conditions.
	TermsURL *string `json:"termsURL"`
}

// The required inputs for leaderboard format.
type CreateCompetitionLeaderboardDetailsInput struct {
	// The max participant count for a lobby in phase. Valid values are 1-100.
	LobbyMaxSize int `json:"lobbyMaxSize"`
	// The number of phases to be created for the competition. Valid values are 1-20.
	PhaseCount int `json:"phaseCount"`
	// A label for additional points to resolve a tie.
	TiebreakerLabel *TiebreakerLabel `json:"tiebreakerLabel"`
}

// Data that was mutated after the competition was created.
type CreateCompetitionPayload struct {
	// The competition that was created.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// Create new tags associated with CLIP, STREAM, or VOD with contentID.
type CreateContentTagsInput struct {
	// ID of the channel owning the content.
	AuthorID string `json:"authorID"`
	// ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs.
	ContentID string `json:"contentID"`
	// Type of content being returned. Can only be of values CLIP, STREAM, or VOD.
	ContentType ContentType `json:"contentType"`
	// List of tag IDs to be added to the content.
	TagIDs []string `json:"tagIDs"`
}

// Result of mutation is the updated tags.
type CreateContentTagsPayload struct {
	// Content which tags have been added to.
	Content TaggedContent `json:"content"`
}

// CreateDropBenefitInput has fields required to create a drop benefit.
type CreateDropBenefitInput struct {
	// The redirect URL where a user can link their account.
	AccountLinkURL string `json:"accountLinkURL"`
	// The ID of this benefit object.
	BenefitID string `json:"benefitID"`
	// The display name of this benefit object.
	BenefitName string `json:"benefitName"`
	// The global limit of how often this benefit can be entitled to a user.
	EntitlementLimit int `json:"entitlementLimit"`
	// The game that awarded the Drop.
	GameID string `json:"gameID"`
	// Specifies if this reward is considered for a game that is available on iOS.
	IsIosAvailable *bool `json:"isIosAvailable"`
	// The RBAC organization ID of the owner.
	OwnerID string `json:"ownerID"`
}

// CreateDropBenefitPayload returns the result of the creation.
type CreateDropBenefitPayload struct {
	// Returns the created Benefit.
	DropBenefit *DropBenefit `json:"dropBenefit"`
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// CreateDropCampaignInput has the fields necessary to create a campaign for an RBAC organization.
type CreateDropCampaignInput struct {
	// The redirect URL where a user can link their account.
	AccountLinkURL string `json:"accountLinkURL"`
	// The type of a campaign defines what type of drops are allowed to be added to the campaign.
	CampaignType *CampaignType `json:"campaignType"`
	// The description of this campaign.
	Description string `json:"description"`
	// The URL that links to the details / marketing page for this drop.
	DetailsURL string `json:"detailsURL"`
	// The date at which this campaign ends and all contained drops end at the latest.
	EndAt time.Time `json:"endAt"`
	// The game associated with this campaign.
	GameID string `json:"gameID"`
	// The name of the campaign.
	Name string `json:"name"`
	// This is the Organization ID (RBAC) to determine access / ownership of the campaign and attached drops.
	OwnerID string `json:"ownerID"`
	// The date at which this campaign starts and all contained drops start the earliest.
	StartAt time.Time `json:"startAt"`
}

// CreateDropCampaignyPayload returns the newly created campaign.
type CreateDropCampaignPayload struct {
	// Returns the created Campaign.
	DropCampaign *DropCampaign `json:"dropCampaign"`
	// error, if there was one.
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// Information needed to generate a URL to upload a drop image to.
type CreateDropImageUploadURLInput struct {
	// The campaign this image is for if it's of type LINK_NOTIFICATION.
	CampaignID *string `json:"campaignID"`
	// The type of image this is.
	ImageType DropImageType `json:"imageType"`
	// The item ID this image is for if it's of type ITEM.
	ItemID *string `json:"itemID"`
	// The drop service this image will be created for.
	ServiceID string `json:"serviceID"`
	// The JWT used to verify the request.
	Token string `json:"token"`
}

// Returned information about image upload including URL to upload the image to.
type CreateDropImageUploadURLPayload struct {
	// Error (if any) from trying to create the upload URL.
	Error *CreateDropImageUploadURLErrorCode `json:"error"`
	// Unique identifier for the generated URL.
	UploadID *string `json:"uploadID"`
	// The actual URL to be used by the client to upload the image.
	URL *string `json:"url"`
}

// CreateExtensionClientInput creates an extension with a given name.
type CreateExtensionClientInput struct {
	// name is the name of the extension client ID.
	Name string `json:"name"`
	// organizationID is the organization ID that the extension will be binded with in RBAC.
	OrganizationID *string `json:"organizationID"`
	// redirectURI is the URI that can be used for OAuth login using the extension's client ID.
	RedirectURI string `json:"redirectURI"`
}

// CreateExtensionClientPayload returns the created extension ID.
type CreateExtensionClientPayload struct {
	// The created extension client.
	Client *ExtensionClient `json:"client"`
	// The error when the mutation fails to create an extension client.
	Error *CreateExtensionClientError `json:"error"`
}

// CreateExtensionImageUploadInfoError is wrapper for error associated with the createExtensionImageUploadInfo mutation.
type CreateExtensionImageUploadInfoError struct {
	// Error code.
	Code CreateExtensionImageUploadInfoErrorCode `json:"code"`
	// On TOO_MANY_UPLOAD_DISCOVERY_IMAGE, TOO_MANY_UPLOAD_LOGO_IMAGE ,TOO_MANY_UPLOAD_SCREENSHOT_IMAGE, TOO_MANY_UPLOAD_TASKBAR_IMAGE, the maximum number of specific image allowed (existing + incoming).
	Maximum *int `json:"maximum"`
	// On NOT_ENOUGH_UPLOAD_DISCOVERY_IMAGE, NOT_ENOUGH_UPLOAD_LOGO_IMAGE ,NOT_ENOUGH_UPLOAD_SCREENSHOT_IMAGE, NOT_ENOUGH_UPLOAD_TASKBAR_IMAGE, the minimum number of screenshots allowed (existing + incoming).
	Minimum *int `json:"minimum"`
}

// Information needed to generate a URL and UploadId to upload extension images to.
type CreateExtensionImageUploadInfoInput struct {
	// Whether to upload new discovery image.
	Discovery *bool `json:"discovery"`
	// The extension:version the images are for.
	ExtensionID string `json:"extensionID"`
	// Whether to upload new logo image.
	Logo *bool `json:"logo"`
	// Amount of new screenshot image to be uploaded.
	Screenshots *int `json:"screenshots"`
	// Whether to upload new taskbar image.
	Taskbar *bool `json:"taskbar"`
}

// Returned information about images upload including URL to upload the image to.
type CreateExtensionImageUploadInfoPayload struct {
	// Url and UploadId for discovery.
	Discovery *ExtensionImageUploadResponse `json:"discovery"`
	// The error when the mutation fails to create upload information.
	Error *CreateExtensionImageUploadInfoError `json:"error"`
	// Url and UploadId for logo.
	Logo *ExtensionImageUploadResponse `json:"logo"`
	// Urls and UploadIds for screenshots.
	Screenshots []*ExtensionImageUploadResponse `json:"screenshots"`
	// Url and UploadId for taskbar.
	Taskbar *ExtensionImageUploadResponse `json:"taskbar"`
}

// Information needed to generate a URL and UploadId to upload extension zip file to.
type CreateExtensionZipUploadInfoInput struct {
	// The extension:version the zip file is for.
	ExtensionID string `json:"extensionID"`
	// The file name of the zip file.
	Filename *string `json:"filename"`
}

// Returned information about zip file upload including URL to upload the zip to.
type CreateExtensionZipUploadInfoPayload struct {
	// The error when the mutation fails to upload a zip file.
	Error *CreateExtensionZipUploadInfoError `json:"error"`
	// Url and UploadId for zip file.
	Response *ExtensionZipUploadResponse `json:"response"`
}

type CreateFriendRequestInput struct {
	// The authenticated user will send a friend request to the user with an ID equal to targetID.
	TargetID string `json:"targetID"`
}

type CreateFriendRequestPayload struct {
	// The user who is the target of the friend request.
	User *User `json:"user"`
}

// Error associated with mutation CreateGameApplication.
type CreateGameApplicationError struct {
	// Error code.
	Code *CreateGameApplicationErrorCode `json:"code"`
}

// Input to the CreateGameApplication mutation.
type CreateGameApplicationInput struct {
	// Company ID.
	CompanyID string `json:"companyID"`
	// Game ID.
	GameID string `json:"gameID"`
}

// Output from the CreateGameApplication mutation.
type CreateGameApplicationPayload struct {
	// The possible error returned from service.
	Error *CreateGameApplicationError `json:"error"`
	// The game application.
	GameApplication *GameApplication `json:"gameApplication"`
}

// GameID that needs to upload a box art image.
type CreateGameBoxArtUploadURLInput struct {
	// Game identifier.
	GameID string `json:"gameID"`
}

// URL info that can be used to upload the image.
type CreateGameBoxArtUploadURLPayload struct {
	// response with non-nullable data.
	Response *CreateGameBoxArtUploadURLResponse `json:"response"`
}

// URL info that can be used to upload the image.
type CreateGameBoxArtUploadURLResponse struct {
	// Upload id to be used on the upload request.
	UploadID string `json:"uploadID"`
	// URL to be used by the client, to upload the image.
	// NOTE: The image that is uploaded later must be a 600x800px, no larger than 1 MB, JPEG.
	URL string `json:"url"`
}

// CreateLoyaltyBadge creates a new badge with these settings.
type CreateLoyaltyBadgeInput struct {
	// The channel ID where the badge will be uploaded.
	ChannelID string `json:"channelID"`
	// The S3 ID of the 1x sized badge.
	Image1xID string `json:"image1xID"`
	// The S3 ID of the 2x sized badge.
	Image2xID string `json:"image2xID"`
	// The S3 ID of the 4x sized badge.
	Image4xID string `json:"image4xID"`
	// The number of months of the badge.
	RequiredTenureMonths int `json:"requiredTenureMonths"`
}

// CreateLoyaltyBadgePayload returns the created badge.
type CreateLoyaltyBadgePayload struct {
	// The created badge.
	Badge *LoyaltyBadge `json:"badge"`
	// A code indicating why the create call failed, if it did.
	ErrorCode *CreateLoyaltyBadgeResponseCode `json:"errorCode"`
}

// CreateLoyaltyBadgeUploadConfig creates a config with URL to upload the badge image to.
type CreateLoyaltyBadgeUploadConfigInput struct {
	// The channel ID where the badge will be uploaded.
	ChannelID string `json:"channelID"`
	// The size of the badge.
	Size int `json:"size"`
}

// CreateLoyaltyBadgeUploadConfigPayload returns the badge upload config.
type CreateLoyaltyBadgeUploadConfigPayload struct {
	// A code indicating why the config call failed, if it did.
	ErrorCode *CreateLoyaltyBadgeUploadConfigResponseCode `json:"errorCode"`
	// The badge upload config.
	UploadConfig *LoyaltyBadgeUploadConfig `json:"uploadConfig"`
}

// The required input to create a moderator comment on a channel.
type CreateModeratorCommentInput struct {
	// The channel where the moderator comment was created.
	ChannelID string `json:"channelID"`
	// The target of the moderator comment.
	TargetID string `json:"targetID"`
	// The body of the comment.
	Text string `json:"text"`
}

// Result of a createModeratorComment mutation.
type CreateModeratorCommentPayload struct {
	// The moderator comment created.
	Comment *ModLogsComment `json:"comment"`
}

// Input for creating a new highlight with multi-segment support.
type CreateMultiVideoHighlightInput struct {
	// Metadata used to create the highlight.
	Metadata *CreateMultiVideoHighlightMetadata `json:"metadata"`
}

// Metadata to describe the requested highlight to be created.
type CreateMultiVideoHighlightMetadata struct {
	// The ID of the user who created this highlight.
	CreatorID string `json:"creatorID"`
	// The long form description of the Highlight content.
	Description string `json:"description"`
	// The primary game featured in the highlight, if any.
	Game *string `json:"game"`
	// List of ordered time ranges from the source VOD used to create the highlight.
	HighlightRanges []*HighlightRange `json:"highlightRanges"`
	// The language the highlight content is in.
	Language string `json:"language"`
	// Discovery tags to associate with the Highlight.
	Tags []string `json:"tags"`
	// The title of the the highlight.
	Title string `json:"title"`
}

// Response of highlight creation, the new highlight entering the creation process.
type CreateMultiVideoHighlightPayload struct {
	// The created Video representing the Highlight.
	Highlight *Video `json:"highlight"`
}

// Contains the channel ID to create new image upload URL for.
type CreateMultiviewContentAttributeImageUploadConfigInput struct {
	// The channel for which the content attribute belongs to.
	ChannelID string `json:"channelID"`
}

// Payload contains the upload ID and URL, as well as the URL to access the uploaded image.
type CreateMultiviewContentAttributeImageUploadConfigPayload struct {
	// The channel for which the content attribute belongs to.
	Channel *Channel `json:"channel"`
	// The URL to access this image once uploaded.
	ImageURL string `json:"imageURL"`
	// Generated unique identifier for this upload.
	UploadID string `json:"uploadID"`
	// Generated unique URL to upload the image to.
	UploadURL string `json:"uploadURL"`
}

// Contains a list of new content attributes to be created.
type CreateMultiviewContentAttributesInput struct {
	// params is a list of multi-view content attribute params for creating new records.
	Params []*MultiviewContentAttributeParams `json:"params"`
}

// Contains the results from the create request.
type CreateMultiviewContentAttributesPayload struct {
	// Unprocessed content attributes.
	FailedCreates []*MultiviewContentAttribute `json:"failedCreates"`
	// Processed content attributes.
	SucceededCreates []*MultiviewContentAttribute `json:"succeededCreates"`
}

// Error associated with mutation CreateGameApplication.
type CreateOrganizationApplicationError struct {
	// Error code.
	Code *CreateOrganizationApplicationErrorCode `json:"code"`
}

// Input to the CreateOrganizationApplication mutation.
type CreateOrganizationApplicationInput struct {
	// City the applying Organization is located in. e.g. San Fransico.
	City *string `json:"city"`
	// Email of the person creating the application.
	// Deprecated as we are no longer collecting contact email. Using TwitchID and Dart to send notifications instead.
	ContactEmail *string `json:"contactEmail"`
	// First Name of person creating the application.
	ContactFirstName string `json:"contactFirstName"`
	// Last Name of the person creating the application.
	ContactLastName string `json:"contactLastName"`
	// Title of the person creating the application. e.g. Director of Sales.
	ContactTitle string `json:"contactTitle"`
	// Country the applying organization is located in. e.g. US.
	Country string `json:"country"`
	// List of game IDs that belong to the applying organization.
	GameIDs []string `json:"gameIDs"`
	// Industry the applying organization is operating in e.g. e-sports, gaming, health care, energy.
	Industry string `json:"industry"`
	// Reason for wanting to add the organization.
	JoinReason *string `json:"joinReason"`
	// The name of applying organization.
	OrganizationName string `json:"organizationName"`
	// Indicate which Twitch products the organization wants to manage; e.g. creating Drops, managing game box art, accessing game Insights.
	ProductInterest *string `json:"productInterest"`
	// Estimated size of the applying organization. e.g. 1-5, 6-20, 21-50, 51-100, 101-1000, and 1000+.
	Size string `json:"size"`
	// State the applying organization is located in. e.g. CA.
	State *string `json:"state"`
	// The type of work the applying organization does.
	Type OrganizationType `json:"type"`
	// The Twitch ID for the user submitting the applicaton.
	// Deprecated as the userID now comes off the authenticated user.
	UserID *string `json:"userID"`
	// The website address for the applying organization.
	Website string `json:"website"`
}

// Output from the CreateGameApplication mutation.
type CreateOrganizationApplicationPayload struct {
	// The organization application id.
	ApplicationID *string `json:"applicationID"`
	// The possible error returned from service.
	Error *CreateOrganizationApplicationError `json:"error"`
}

// CreateOrganizationInviteError is the error associated with a CreateOrganizationInvite.
type CreateOrganizationInviteError struct {
	// The associated error code.
	Code CreateOrganizationInviteErrorCode `json:"code"`
}

// Inputs to the CreateOrganizationInvite mutation.
type CreateOrganizationInviteInput struct {
	// The Twitch ID of user being invited to join the organization.
	InviteeTwitchID string `json:"inviteeTwitchID"`
	// The Twitch ID of user being doing the inviting and is already a member of the organization.
	InviterTwitchID string `json:"inviterTwitchID"`
	// The ID of the organization.
	OrganizationID string `json:"organizationID"`
	// The Role a Invite has in an organization.
	Role OrganizationMemberRole `json:"role"`
}

// Outputs from the CreateOrganizationInvite mutation.
type CreateOrganizationInvitePayload struct {
	// The possible error returned from the service.
	Error *CreateOrganizationInviteError `json:"error"`
	// The created invite. returned on successful creation.
	Invite *OrganizationInvite `json:"invite"`
}

// CreateOrganizationJWTError is the error associated with a CreateOrganizationJWT.
type CreateOrganizationJWTError struct {
	// The associated error code.
	Code CreateOrganizationJWTErrorCode `json:"code"`
}

// Inputs to the CreateOrganizationJWT mutation.
type CreateOrganizationJWTInput struct {
	// Operation to be used in drops to get a jwt for.
	Operation string `json:"operation"`
	// Organization id for which to generate the jwt.
	OrganizationID string `json:"organizationID"`
}

// Outputs from the CreateOrganizationJWT mutation.
type CreateOrganizationJWTPayload struct {
	// The possible error returned from the service.
	Error *CreateOrganizationJWTError `json:"error"`
	// The new orgnizationJWT.
	Jwt *string `json:"jwt"`
}

// CreateOrganizationMemberError is the error associated with a CreateOrganizationMember.
type CreateOrganizationMemberError struct {
	// The associated error code.
	Code CreateOrganizationMemberErrorCode `json:"code"`
}

// Inputs to the CreateOrganizationMember mutation.
type CreateOrganizationMemberInput struct {
	// Users email.
	Email string `json:"email"`
	// Users first name.
	FirstName string `json:"firstName"`
	// Users last name.
	LastName string `json:"lastName"`
	// The ID of the organization.
	OrganizationID string `json:"organizationID"`
	// The Role a member has in an organization.
	Role OrganizationMemberRole `json:"role"`
	// Users title.
	Title string `json:"title"`
	// The user's Twitch ID.
	UserID string `json:"userID"`
}

// Outputs from the CreateOrganizationMember mutation.
type CreateOrganizationMemberPayload struct {
	// The possible error returned from the service.
	Error *CreateOrganizationMemberError `json:"error"`
	// The new orgnizationMember.
	OrganizationMember *OrganizationMember `json:"organizationMember"`
}

// The upload info struct that is returned from AWS.
type CreatePanelImageUploadInfo struct {
	// A unique identifier for the generated URL.
	UploadID string `json:"uploadID"`
	// The actual URL to be used by the client to upload the image.
	URL string `json:"url"`
}

// Information required to generate a URL to upload a panel image to.
type CreatePanelImageUploadInfoInput struct {
	// The channel the panel belongs to.
	ChannelID string `json:"channelID"`
	// The cropped height of the image.
	Height int `json:"height"`
	// The left edge of the cropped image.
	Left int `json:"left"`
	// The top edge of the cropped image.
	Top int `json:"top"`
	// The cropped width of the image.
	Width int `json:"width"`
}

// The response resulting from a successful panel image URL creation.
type CreatePanelImageUploadInfoPayload struct {
	// The upload info struct that is returned from AWS.
	UploadInfo *CreatePanelImageUploadInfo `json:"uploadInfo"`
}

// CreatePanelInput contains a panel with created data
// The schema here has arguments for both extension panels and default panels
// each panel needs a PanelType, and channelID it corresponds to,
// but each panel does not need the other arguments
// extension panels can have a slotID
// default panels can have a title, image, link, and/or description.
type CreatePanelInput struct {
	ChannelID   string    `json:"channelID"`
	Description *string   `json:"description"`
	ImageURL    *string   `json:"imageURL"`
	LinkURL     *string   `json:"linkURL"`
	SlotID      *string   `json:"slotID"`
	Title       *string   `json:"title"`
	Type        PanelType `json:"type"`
}

// CreatePanelPayload contains the panel data after the create succeeds.
type CreatePanelPayload struct {
	Panel Panel `json:"panel"`
}

// CreatePartnershipApplication accepts a userID and other parameters to create the partnership application of a given user.
// The required input for a createPartnershipApplicationInput mutation.
type CreatePartnershipApplicationInput struct {
	// Broadcast category (selected by the applicant).
	// eg: gaming, creative.
	Category string `json:"category"`
	// Country from where the applicant belongs (selected by the applicant).
	// eg: US, NZ, UK.
	Country string `json:"country"`
	// Description why the applicant wants to be a partner.
	Description string `json:"description"`
	// First and last name of the applicant.
	FullName string `json:"fullName"`
	// Broadcast language (selected by the applicant).
	Language string `json:"language"`
}

// Whether or not the partnership application submission to was successful.
// The result of a createPartnershipApplicationInput mutation.
type CreatePartnershipApplicationPayload struct {
	// A successful creation returns the partnership application.
	// A failed creation returns null.
	PartnershipApplication *PartnershipApplication `json:"partnershipApplication"`
}

// Inputs for creating a choice.
type CreatePollChoiceInput struct {
	// Title of the choice.
	Title string `json:"title"`
}

// Vote in poll error.
type CreatePollError struct {
	// Code describing the error.
	Code CreatePollErrorCode `json:"code"`
}

// Inputs for creating a new poll.
type CreatePollInput struct {
	// The cost in bits for casting a vote.
	BitsCost *int `json:"bitsCost"`
	// Denotes if votes can be cast with bits.
	BitsVoting *bool `json:"bitsVoting"`
	// Choices that can be voted for in the poll.
	Choices []*CreatePollChoiceInput `json:"choices"`
	// The cost in Community Points for casting a vote.
	CommunityPointsCost *int `json:"communityPointsCost"`
	// Duration of the poll in seconds.
	DurationSeconds int `json:"durationSeconds"`
	// Denotes if votes can be cast with Community Points.
	IsCommunityPointsVotingEnabled *bool `json:"isCommunityPointsVotingEnabled"`
	// Denotes if the poll allows voting for multiple options.
	MultichoiceEnabled *bool `json:"multichoiceEnabled"`
	// Id of the channel this poll is owned by.
	OwnedBy string `json:"ownedBy"`
	// Denotes if subscribers receives bonus votes.
	// Deprecated: Subscriber multipliers are no longer supported.
	SubscriberMultiplier *bool `json:"subscriberMultiplier"`
	// Denotes if the poll is only open to subscribers.
	// Deprecated: Subscriber-only polls are no longer supported.
	SubscriberOnly *bool `json:"subscriberOnly"`
	// Title of the poll.
	Title string `json:"title"`
}

// Outputs from the create poll mutation.
type CreatePollPayload struct {
	// If present, there was an error with the request.
	Error *CreatePollError `json:"error"`
	// The created poll.
	Poll *Poll `json:"poll"`
}

type CreatePostInput struct {
	Body          string   `json:"body"`
	ChannelID     string   `json:"channelID"`
	EmbedURLs     []string `json:"embedURLs"`
	PostToTwitter *bool    `json:"postToTwitter"`
}

type CreatePostPayload struct {
	Post        *Post   `json:"post"`
	Tweet       *string `json:"tweet"`
	TweetStatus int     `json:"tweetStatus"`
}

// An error returned from the createPredictionEvent mutation.
type CreatePredictionEventError struct {
	// Code describing the error.
	Code CreatePredictionEventErrorCode `json:"code"`
	// If the error code is TOO_MANY_OUTCOMES, this will be the maximum number of Outcomes.
	MaxOutcomes *int `json:"maxOutcomes"`
	// If the error code is INVALID_PREDICTION_WINDOW, this will be the maximum Prediction Window in seconds.
	MaxPredictionWindowSeconds *int `json:"maxPredictionWindowSeconds"`
}

// Input for creating a Prediction Event.
type CreatePredictionEventInput struct {
	// The channel to create the Prediction Event on.
	ChannelID string `json:"channelID"`
	// Outcomes that can be chosen in the Prediction Event.
	Outcomes []*CreatePredictionOutcomeInput `json:"outcomes"`
	// The duration of the Prediction Window, in seconds.
	PredictionWindowSeconds int `json:"predictionWindowSeconds"`
	// The intended title of the Prediction Event.
	Title string `json:"title"`
}

// Payload for creating a prediction event.
type CreatePredictionEventPayload struct {
	// If present, there was an error with the request.
	Error *CreatePredictionEventError `json:"error"`
	// The created Prediction Event.
	PredictionEvent *PredictionEvent `json:"predictionEvent"`
}

// Input for creating a Prediction Outcome.
type CreatePredictionOutcomeInput struct {
	// Color of the Outcome.
	Color PredictionOutcomeColor `json:"color"`
	// Title of the Outcome.
	Title string `json:"title"`
}

// CreateRaidError is the error associated with a createRaid.
type CreateRaidError struct {
	// The associated error code.
	Code CreateRaidErrorCode `json:"code"`
}

// Inputs to the createRaid mutation.
type CreateRaidInput struct {
	// Caller is expected to be a channel owner, editor, or staff.
	// User ID of the source channel hosting the raid.
	SourceID string `json:"sourceID"`
	// User ID of the target channel.
	TargetID string `json:"targetID"`
}

// Outputs from the createRaid mutation.
type CreateRaidPayload struct {
	// The possible error returned from the service.
	Error *CreateRaidError `json:"error"`
	// The created raid.
	Raid *Raid `json:"raid"`
}

// Inputs to the createRewardedVideo mutation.
type CreateRewardedVideoTokenInput struct {
	// userID requesting the rewarded video token.
	UserID string `json:"userID"`
}

// Outputs from the createRewardedVideo mutation.
type CreateRewardedVideoTokenPayload struct {
	// token used to initialize the truex client application.
	Token *string `json:"token"`
}

type CreateRoomError struct {
	Code CreateRoomErrorCode `json:"code"`
	// On MAX_ROOMS_LIMIT_EXCEEDED: Maximum number of rooms user can create.
	MaxAllowedRooms *int `json:"maxAllowedRooms"`
	// On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Maximum number of characters.
	MaxLength *int `json:"maxLength"`
	// On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Minimum number of characters.
	MinLength *int `json:"minLength"`
}

type CreateRoomInput struct {
	// Deprecated. Use minimumReadMessagesRole instead.
	IsPreviewable *bool `json:"isPreviewable"`
	// Deprecated. Use minimumReadMessagesRole and minimumSendMessagesRole instead.
	MinimumAllowedRole *RoomRole `json:"minimumAllowedRole"`
	// Minimum role required to read messages in the room.
	MinimumReadMessagesRole *RoomRole `json:"minimumReadMessagesRole"`
	// Minimum role required to send messages in the room.
	MinimumSendMessagesRole *RoomRole `json:"minimumSendMessagesRole"`
	// The name of the room.
	Name string `json:"name"`
	// The topic for the room.
	Topic string `json:"topic"`
}

type CreateRoomPayload struct {
	Error *CreateRoomError `json:"error"`
	Room  *Room            `json:"room"`
}

// The input to create a schedule.
type CreateScheduleInput struct {
	// The channel ID the schedule belongs to.
	ChannelID string `json:"channelID"`
}

// The payload returned after creating a schedule.
type CreateSchedulePayload struct {
	// The channel with the new schedule.
	Channel *Channel `json:"channel"`
	// The possible error.
	Error *CreateScheduleError `json:"error"`
}

// CreateScheduleSegmentError is a wrapper for error associated with the CreateScheduleSegment mutation.
type CreateScheduleSegmentError struct {
	// Error code.
	Code CreateScheduleSegmentErrorCode `json:"code"`
	// If the error is related to overlapping segments, provide the existing segment causing a conflict.
	ConflictingSegment *ScheduleSegment `json:"conflictingSegment"`
	// If the error is related to an input out of service-defined bounds, provide the maximum allowed value.
	Maximum *int `json:"maximum"`
	// If the error is related to an input out of service-defined bounds, provide the minimum allowed value.
	Minimum *int `json:"minimum"`
}

// The input to create a new schedule segment.
type CreateScheduleSegmentInput struct {
	// The categories of the new segment.
	Categories []string `json:"categories"`
	// The duration of the segment in minutes.
	DurationMinutes *int `json:"durationMinutes"`
	// The ID of the schedule.
	ScheduleID string `json:"scheduleID"`
	// The start time of the new segment.
	Start *SegmentStartTimeInput `json:"start"`
	// The geographic timezone of the new segment defined by IANA; i.e. "America/Los_Angeles".
	Timezone string `json:"timezone"`
	// The title of the new segment.
	Title *string `json:"title"`
}

// The payload returned when creating a new schedule segment.
type CreateScheduleSegmentPayload struct {
	// The possible error.
	Error *CreateScheduleSegmentError `json:"error"`
	// The updated schedule with the created segment.
	Schedule *Schedule `json:"schedule"`
}

// CreateSocialMediaInput creates social media under the given channelID.
type CreateSocialMediaInput struct {
	// The ID of the channel the social media should belong to.
	ChannelID string `json:"channelID"`
	// The visible text of the social media item.
	Title string `json:"title"`
	// The web address of the social media item.
	URL string `json:"url"`
}

// CreateSocialMediaPayload returns the new social medias that were created.
type CreateSocialMediaPayload struct {
	// The channel of the social media that was created.
	Channel *Channel `json:"channel"`
	// The potential error when creating a social media.
	Error *CreateSocialMediaError `json:"error"`
}

// CreateSquadStreamInvitationError is the error associated with a createSquadStreamInvitation.
type CreateSquadStreamInvitationError struct {
	// The associated error code.
	Code CreateSquadStreamInvitationErrorCode `json:"code"`
}

// Inputs to the createSquadStreamInvitation mutation.
type CreateSquadStreamInvitationInput struct {
	// The user ID of the broadcaster that should be invited to join the squad stream.
	RecipientUserID string `json:"recipientUserID"`
	// The user ID of the broadcaster that is sending the invitation to join the squad stream.
	SenderUserID string `json:"senderUserID"`
}

// Outputs from the createSquadStreamInvitation mutation.
type CreateSquadStreamInvitationPayload struct {
	// The possible error returned from the service.
	Error *CreateSquadStreamInvitationError `json:"error"`
	// The updated squad stream.
	SquadStream *SquadStream `json:"squadStream"`
}

// Inputs to creating a stucco.
type CreateStuccoInput struct {
	// ID of the channel this stucco belongs to.
	ChannelID string `json:"channelID"`
	// Description representing the stucco, should be the words contained in the stucco, used by screen readers.
	Description string `json:"description"`
	// Base64 encoded binary data of the 92x28px stucco ("1x") image asset.
	ImageData1x string `json:"imageData1x"`
	// Base64 encoded binary data of the 182x56px stucco ("2x") image asset.
	ImageData2x string `json:"imageData2x"`
	// Base64 encoded binary data of the 368x112px stucco ("4x") image asset.
	ImageData4x string `json:"imageData4x"`
	// Text code representing the stucco without any prefixes (prefixes are added in the backend).
	Suffix string `json:"suffix"`
}

// Inputs for creating a new stucco pack.
type CreateStuccoPackInput struct {
	// Id of the channel this pack is part of.
	ChannelID string `json:"channelID"`
	// Updated list of stuccos for this pack.
	Stuccos []*CreateStuccoPackItemInput `json:"stuccos"`
}

// Single item in a stuccopack, as part of the create stucco pack call, representing one stucco to be used in a certain slot.
type CreateStuccoPackItemInput struct {
	// Slot index in the pack (used for ordering).
	SlotIndex int `json:"slotIndex"`
	// Id of the stucco.
	StuccoID string `json:"stuccoID"`
}

// Outputs from the create stucco pack mutation.
type CreateStuccoPackPayload struct {
	// The created stucco pack.
	StuccoPack *StuccoPack `json:"stuccoPack"`
}

// The output for the create update stucco mutation.
type CreateStuccoPayload struct {
	// The created or updated stucco.
	Stucco *Stucco `json:"stucco"`
}

// Error from create unban request mutation.
type CreateUnbanRequestError struct {
	// Error code from create unban request mutation.
	Code CreateUnbanRequestErrorCode `json:"code"`
}

// Required input to create an unban request on a channel.
type CreateUnbanRequestInput struct {
	// Channel on which requester is requesting an unban.
	ChannelID string `json:"channelID"`
	// Custom message from unban requester to attach to unban request.
	RequesterMessage string `json:"requesterMessage"`
}

// Result of a createUnbanRequest mutation.
type CreateUnbanRequestPayload struct {
	// Error from attempting to create unban request.
	Error *CreateUnbanRequestError `json:"error"`
	// The newly created unban request.
	UnbanRequest *UnbanRequest `json:"unbanRequest"`
}

// CreateVideoBookmarkError is the error associated with a createVideoBookmark.
type CreateVideoBookmarkError struct {
	// The associated error code.
	Code *CreateVideoBookmarkErrorCode `json:"code"`
}

// Input for creating a new bookmark.
type CreateVideoBookmarkInput struct {
	// ID of the broadcast the bookmark is made for.
	BroadcastID *string `json:"broadcastID"`
	// Channel ID of the channel the bookmark is made for.
	ChannelID *string `json:"channelID"`
	// A description for the bookmark.
	Description *string `json:"description"`
	// The medium where the request came from.
	// e.g. "popout_chat", "chat", "live_dashboard_button", "live_dashboard_hotkey", "live_dashboard_chat".
	Medium string `json:"medium"`
	// The platform where the request came from.
	// e.g."web", "android", "ios".
	Platform string `json:"platform"`
}

// Response for creating a bookmark, the bookmark that was created.
type CreateVideoBookmarkPayload struct {
	// Error of the create video bookmark request.
	Error *CreateVideoBookmarkError `json:"error"`
	// The bookmark that was created.
	VideoBookmark *VideoBookmark `json:"videoBookmark"`
}

type CreateVideoCommentInput struct {
	// The id of the parent video comment when you reply.
	CommentID *string `json:"commentID"`
	// Position of the video where this comment will be added.
	ContentOffsetSeconds int `json:"contentOffsetSeconds"`
	// The message of the comment.
	Message string `json:"message"`
	// The id of the video this comment belongs to.
	VideoID string `json:"videoID"`
}

type CreateVideoCommentPayload struct {
	// The comment that was created.
	Comment *VideoComment `json:"comment"`
}

type CreateVideoHighlightInput struct {
	// The time in the source Archive type video that the Highlight will end at.
	EndOffsetSeconds int `json:"endOffsetSeconds"`
	// Metadata to set for the highlight.
	Metadata *CreateVideoHighlightMetadata `json:"metadata"`
	// The id of the Archive type video to create the Highlight from.
	SourceVideoID string `json:"sourceVideoID"`
	// The time in the source Archive type video that the Highlight will begin at.
	StartOffsetSeconds int `json:"startOffsetSeconds"`
}

type CreateVideoHighlightMetadata struct {
	// The long form description of the Highlight content.
	Description string `json:"description"`
	// The primary game featured in the highlight, if any.
	Game *string `json:"game"`
	// The language the highlight content is in.
	Language string `json:"language"`
	// Discovery tags to associate with the Highlight.
	Tags []string `json:"tags"`
	// The title of the the highlight.
	Title string `json:"title"`
}

type CreateVideoHighlightPayload struct {
	// The created Video representing the Highlight.
	Highlight *Video `json:"highlight"`
}

// Data pertaining to a creator's badge flair for their own channel.
type CreatorBadgeFlair struct {
	// The creator's setting for which badge flair, if any, can be displayed.
	Setting *CreatorBadgeFlairSetting `json:"setting"`
	// The set of badge flair assets for each tier.
	Assets []*CreatorBadgeFlairAsset `json:"assets"`
}

// A set of URLs where clients can find the badge flair asset for a given creator at a given tier
type CreatorBadgeFlairAsset struct {
	// The tier to which these flair assets correspond to, as determined by the creator at time of upload
	Tier CreatorBadgeFlairTier `json:"tier"`
	// The "1x" dimension (18x18) image URL
	Image1xURL string `json:"image1xURL"`
	// The "2x" dimension (36x36) image URL
	Image2xURL string `json:"image2xURL"`
	// The "4x" dimension (72x72) image URL
	Image4xURL string `json:"image4xURL"`
}

// A CreatorCampArticle is a represenation of an article from
// https://www.twitch.tv/creatorcamp.
type CreatorCampArticle struct {
	// The ID of the article is also a human readable "slug" e.g. "twitch-101".
	ID string `json:"id"`
	// The locale associated with this article's translations.
	Locale string `json:"locale"`
	// A URL pointing to an image associated with this article.
	PreviewImage *string `json:"previewImage"`
	// A short introduction for the article.
	PreviewText *string `json:"previewText"`
	// The localized title of the article.
	Title string `json:"title"`
	// The cannonical location of this article on the CreatorCamp site.
	URL string `json:"url"`
	// The length of the article's video in seconds.
	VideoDurationSeconds *int `json:"videoDurationSeconds"`
	// A URL pointing to the embedded video in this article. Most
	// CreatorCamp articles have an assoicated video.
	VideoURL *string `json:"videoURL"`
}

// A CreatorCampCategory is a grouping of CreatorCamp articles.
// https://www.twitch.tv/creatorcamp.
type CreatorCampCategory struct {
	// A list of CreatorCamp articles in this category.
	Articles []*CreatorCampArticle `json:"articles"`
	// The ID of the category is also a human-readable "slug" e.g. "learn-the-basics".
	ID string `json:"id"`
	// The localized title of the category.
	Title string `json:"title"`
}

// Creator Dashboard shown in twilight.
type CreatorDashboard struct {
	// Channel Analytics query for the Channel Analytics Tab in the Creator Dashboard.
	ChannelAnalytics *ChannelAnalytics `json:"channelAnalytics"`
}

// The container for creator gifts the creator has. This will be null if the creator
// does not have this feature enabled.
type CreatorGifting struct {
	// The identifier for the creator gifting type. This is the user's ID.
	ID string `json:"id"`
	// The balance of gift subscriptions the creator has to give. These subscriptions do not pay out to the creator.
	SubscriptionsBalance *int `json:"subscriptionsBalance"`
}

// Creator metrics for the given time period.
type CreatorMetricsByInterval struct {
	// Creator metrics aggregated and broken up by the interval length.
	Items []*CreatorMetricsByIntervalItem `json:"items"`
}

// Creator metrics for the given time period.
type CreatorMetricsByIntervalItem struct {
	// Ad breaks in seconds for the time period.
	AdBreaksInSecondsString string `json:"adBreaksInSecondsString"`
	// Ad seconds per hour for the time period.
	AdSecondsPerHour float64 `json:"adSecondsPerHour"`
	// Average viewers for the time period.
	AverageViewers float64 `json:"averageViewers"`
	// Clips views for the time period.
	ClipViewsString string `json:"clipViewsString"`
	// Clips created for the time period.
	ClipsCreatedString string `json:"clipsCreatedString"`
	// Number of follows for the time period.
	FollowsString string `json:"followsString"`
	// Host raids percentage for the time period.
	HostRaidsPercentage float64 `json:"hostRaidsPercentage"`
	// Live views for the time period.
	LiveViewsString string `json:"liveViewsString"`
	// Max viewers for the time period.
	MaxViewersString string `json:"maxViewersString"`
	// Time streamed (in minutes) for the time period.
	MinutesStreamedString string `json:"minutesStreamedString"`
	// Minutes watched for the time period.
	MinutesWatchedString string `json:"minutesWatchedString"`
	// New subscriptions for the time period.
	NewSubscriptionsString string `json:"newSubscriptionsString"`
	// Promotion clicks for the time period.
	PromotionClickString string `json:"promotionClickString"`
	// Promotion displays for the time period.
	PromotionDisplayString string `json:"promotionDisplayString"`
	// Starting timestamp for the time period.
	Timestamp time.Time `json:"timestamp"`
	// Total chat messages for the time period.
	TotalChatMessagesString string `json:"totalChatMessagesString"`
	// Total chatters for the time period.
	TotalChattersString string `json:"totalChattersString"`
	// Unique viewers for the time period.
	UniqueViewersString string `json:"uniqueViewersString"`
}

// Onboarding content and tips that are shown during the streamer onboarding experience.
type CreatorOnboardingContent struct {
	// The time when the onboarding content was first shown to the user.
	FirstSeenAt *time.Time `json:"firstSeenAt"`
	// The id of the creator onboarding content.
	ID string `json:"id"`
}

// A url to be shared by a creator to gain referrals, and associated metadata.
type CreatorReferralLink struct {
	// The body text that will show on social media when the associated url is shared -- og:description.
	Description string `json:"description"`
	// The ID of the referral link.
	ID string `json:"id"`
	// The image that will show on social media when the associated url is shared -- og:image.
	ImageURL string `json:"imageURL"`
	// The title text that will show on social media when the associated url is shared -- og:title.
	Title string `json:"title"`
	// The url of the referral link.
	URL string `json:"url"`
}

// A paginated list of creator referral links.
type CreatorReferralLinkConnection struct {
	// The list edges contain CreatorReferralLink with pagination information.
	Edges []*CreatorReferralLinkEdge `json:"edges"`
	// Information about this page of creator referral links.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An element in a paginated list of creator referral links.
type CreatorReferralLinkEdge struct {
	// Cursor represents the position of the current edge/node.
	Cursor string `json:"cursor"`
	// Node represents the creator referral link for the current edge.
	Node *CreatorReferralLink `json:"node"`
}

// Contains a reference to the link object and the number of referrals from that link.
type CreatorReferralLinkStat struct {
	// The reference to the link that caused the associated number of referrals.
	Link *CreatorReferralLink `json:"link"`
	// The number of referred users for the given link.
	ReferralCount int `json:"referralCount"`
}

// Contains the statistics summary for creator referral link.
type CreatorReferralSummary struct {
	// Average referrals per day in the given date range.
	AverageReferrals int `json:"averageReferrals"`
	// List of data points in the summary.
	Days []*CreatorReferralSummaryDay `json:"days"`
	// Total referrals in the given date range.
	TotalReferrals int `json:"totalReferrals"`
	// Trend of the referrals per day in the given date range, when compared to the previous date range of the same length.
	Trend CreatorReferralTrend `json:"trend"`
}

// Each data point contains date and list of links with number of referred users.
type CreatorReferralSummaryDay struct {
	// The date for the enclosed data.
	Date time.Time `json:"date"`
	// List of CreatorReferralLinkStat objects on the given date.
	LinkStats []*CreatorReferralLinkStat `json:"linkStats"`
	// The total number of referred users on the given date.
	ReferralCountSum int `json:"referralCountSum"`
}

// Single item of stats for the time series.
type CreatorTimeseriesItem struct {
	// Streamed duration (in minutes).
	MinutesStreamed *int `json:"minutesStreamed"`
	// Timestamp of the broken down time series.
	Timestamp time.Time `json:"timestamp"`
	// Value at the timestamp.
	Value float64 `json:"value"`
}

// List of timestamp, value metric pairs and total for that metric.
type CreatorTimeseriesMetric struct {
	// CreatorTimeseries data (timestamp, value) associated with this metric.
	Items []*CreatorTimeseriesItem `json:"items"`
	// Total (sum) of all CreatorTimeseriesMetrics values.
	Total int `json:"total"`
}

// Metrics within a time frame broken down by granularity.
// This is used for per team stats, per channel stats use "TimeseriesStats".
type CreatorTimeseriesMetrics struct {
	// Seconds of ads played per time chunk.
	AdBreaksInSeconds *CreatorTimeseriesMetric `json:"adBreaksInSeconds"`
	// Ad time (in seconds) per hour per time chunk.
	AdTimePerHour *CreatorTimeseriesMetric `json:"adTimePerHour"`
	// Average number of viewers per time chunk.
	AverageViewers *CreatorTimeseriesMetric `json:"averageViewers"`
	// Number of chat messages per time chunk.
	ChatMessages *CreatorTimeseriesMetric `json:"chatMessages"`
	// Number of clip views per time chunk.
	ClipViews *CreatorTimeseriesMetric `json:"clipViews"`
	// Number of clips created per time chunk.
	ClipsCreated *CreatorTimeseriesMetric `json:"clipsCreated"`
	// Number of follows during this timestamp.
	Follows *CreatorTimeseriesMetric `json:"follows"`
	// Granularity of the time series, default unit is five minutes.
	Granularity Granularity `json:"granularity"`
	// Host/Raid viewers per time chunk.
	HostRaidViewers *CreatorTimeseriesMetric `json:"hostRaidViewers"`
	// Live number of views per time chunk.
	LiveViews *CreatorTimeseriesMetric `json:"liveViews"`
	// Max viewers per time chunk.
	MaxViewers *CreatorTimeseriesMetric `json:"maxViewers"`
	// Minutes watched per time chunk.
	MinutesWatched *CreatorTimeseriesMetric `json:"minutesWatched"`
	// Number of subscriptions per time chunk.
	NewSubscriptions *CreatorTimeseriesMetric `json:"newSubscriptions"`
	// Promotion clicks for the time period.
	PromotionClick *CreatorTimeseriesMetric `json:"promotionClick"`
	// Promotion displays for the time period.
	PromotionDisplay *CreatorTimeseriesMetric `json:"promotionDisplay"`
	// Time streamed per time chunk.
	TimeStreamed *CreatorTimeseriesMetric `json:"timeStreamed"`
	// Number of people chatting per time chunk.
	UniqueChatters *CreatorTimeseriesMetric `json:"uniqueChatters"`
	// Number of unique people watching per time chunk.
	UniqueViewers *CreatorTimeseriesMetric `json:"uniqueViewers"`
}

// CreditChargeModel defines a charge model using non-FIAT currencies.
type CreditChargeModel struct {
	// The value of the credit.
	Amount int `json:"amount"`
	// The type of credit.
	CreditType CreditType `json:"creditType"`
}

// CurrentPrimePayout is the detail breakdown of the payout that will be made in this specific payout cycle.
type CurrentPrimePayout struct {
	// pastCyclePayoutAmount is the part of the payout that was earned in previous payout cycle(s).
	PastCyclePayoutAmount int `json:"pastCyclePayoutAmount"`
	// thisCyclePayoutAmount is the part of the payout that was earned in this payout cycle itself.
	ThisCyclePayoutAmount int `json:"thisCyclePayoutAmount"`
	// totalPayoutAmount is the total amount for this payout.
	TotalPayoutAmount int `json:"totalPayoutAmount"`
}

// When a user AutoHosts a channel.
type DashboardActivityFeedActivityAutoHosting struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// User/Channel who is now AutoHosting the channel.
	Host *User `json:"host"`
	// Unique identifier for this AutoHosting action.
	ID string `json:"id"`
	// When the host initiated the AutoHosting session.
	Timestamp time.Time `json:"timestamp"`
	// Number of viewers from the host channel.
	ViewerCount int `json:"viewerCount"`
}

func (DashboardActivityFeedActivityAutoHosting) IsDashboardActivityFeedActivity() {}

// When a user uses Bits for or sends Bits to a channel.
type DashboardActivityFeedActivityBitsUsage struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// Bits spent.
	Amount int `json:"amount"`
	// Unique identifier for this Bits usage.
	ID string `json:"id"`
	// Whether the Cheer was anonymized to other users.
	// If true, then `user` is guaranteed to be null.
	IsAnonymous bool `json:"isAnonymous"`
	// When the Bits were used.
	Timestamp time.Time `json:"timestamp"`
	// Bits spender.
	User *User `json:"user"`
}

func (DashboardActivityFeedActivityBitsUsage) IsDashboardActivityFeedActivity() {}

// When a Boost completes for the given user.
type DashboardActivityFeedActivityBoostComplete struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// The progress made toward the goalTarget.
	GoalProgress int `json:"goalProgress"`
	// The target size for the boost order.
	GoalTarget int `json:"goalTarget"`
	// Unique identifier for this Boost event.
	ID string `json:"id"`
	// The user who purchased the boost order.
	Purchaser *User `json:"purchaser"`
	// The number of boosts in the order.
	Quantity int `json:"quantity"`
	// When this Boost event occurred.
	Timestamp time.Time `json:"timestamp"`
}

func (DashboardActivityFeedActivityBoostComplete) IsDashboardActivityFeedActivity() {}

// When a Boost starts for the given user.
type DashboardActivityFeedActivityBoostStart struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// The progress made toward the goalTarget.
	GoalProgress int `json:"goalProgress"`
	// The target size for the boost order.
	GoalTarget int `json:"goalTarget"`
	// Unique identifier for this Boost event.
	ID string `json:"id"`
	// The user who purchased the boost order.
	Purchaser *User `json:"purchaser"`
	// The number of boosts in the order.
	Quantity int `json:"quantity"`
	// When this Boost event occurred.
	Timestamp time.Time `json:"timestamp"`
}

func (DashboardActivityFeedActivityBoostStart) IsDashboardActivityFeedActivity() {}

// When a Celebration event occurs for the given user.
type DashboardActivityFeedActivityCelebrationPurchaseEvent struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// The effect used for the celebration.
	Effect CelebrationEffect `json:"effect"`
	// Unique identifier for this Celebration event.
	ID string `json:"id"`
	// The intensity of the celebration.
	Intensity CelebrationIntensity `json:"intensity"`
	// The user who purchased the celebration.
	PurchasingUser *User `json:"purchasingUser"`
	// When this Celebration event occurred.
	Timestamp time.Time `json:"timestamp"`
}

func (DashboardActivityFeedActivityCelebrationPurchaseEvent) IsDashboardActivityFeedActivity() {}

// When a user redeems a community points reward on a channel.
type DashboardActivityFeedActivityCommunityPointsReward struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// Unique identifier for this redemption.
	ID string `json:"id"`
	// The user that redeemed the reward.
	RedeemingUser *User `json:"redeemingUser"`
	// The redemption object itself.
	Redemption *CommunityPointsCustomRewardRedemption `json:"redemption"`
	// When the reward was redeemed.
	Timestamp time.Time `json:"timestamp"`
	// The title of the reward.
	Title string `json:"title"`
	// The user's text input, if provided.
	UserInput *string `json:"userInput"`
}

func (DashboardActivityFeedActivityCommunityPointsReward) IsDashboardActivityFeedActivity() {}

// When a user gifts subscriptions to a community for a channel.
type DashboardActivityFeedActivityCommunitySubscriptionGifting struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// Total subscriptions gifted by the gifter.
	GiftQuantity int `json:"giftQuantity"`
	// Total number of months the gifted subscription lasts for.
	GiftedMonths int `json:"giftedMonths"`
	// Subscription purchaser & gifter.
	Gifter *User `json:"gifter"`
	// Unique identifier for this gifting action.
	ID string `json:"id"`
	// Whether the subscription gifting was anonymized to other users.
	// If true, then `gifter` is guaranteed to be null.
	IsAnonymous bool `json:"isAnonymous"`
	// Users who received the gift.
	// Maximum count is currently 100.
	Recipients []*User `json:"recipients"`
	// The gifted subscription's tier.
	Tier SubscriptionTier `json:"tier"`
	// When the subscriptions were gifted.
	Timestamp time.Time `json:"timestamp"`
}

func (DashboardActivityFeedActivityCommunitySubscriptionGifting) IsDashboardActivityFeedActivity() {}

// Paginated list of past activities for a channel's Dashboard Activity Feed.
type DashboardActivityFeedActivityConnection struct {
	// Activity elements of the list.
	Edges []*DashboardActivityFeedActivityEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// When a Community Goal ends for the channel.
type DashboardActivityFeedActivityCopoGoalEnd struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// The target number of points for the goal that has ended.
	GoalAmount int `json:"goalAmount"`
	// The id of the goal that has ended.
	GoalID string `json:"goalID"`
	// The title of the goal that has ended.
	GoalTitle string `json:"goalTitle"`
	// Unique identifier for this goal end event.
	ID string `json:"id"`
	// The number of points contributed towards the goal.
	PointsContributed int `json:"pointsContributed"`
	// The name of the community points on the channel.
	PointsName *string `json:"pointsName"`
	// When this goal end event occurred.
	Timestamp time.Time `json:"timestamp"`
}

func (DashboardActivityFeedActivityCopoGoalEnd) IsDashboardActivityFeedActivity() {}

// When a creator completes a drop quest and a drop can now be claimed by users/viewers.
type DashboardActivityFeedActivityDropClaimWindowOpen struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// The community claimable drop which has been activated.
	Drop *DropObject `json:"drop"`
	// Unique identifier for this drop activity.
	ID string `json:"id"`
	// When the quest was completed.
	Timestamp time.Time `json:"timestamp"`
}

func (DashboardActivityFeedActivityDropClaimWindowOpen) IsDashboardActivityFeedActivity() {}

// Activity element in a list of past activities of a channel's Dashboard Activity Feed.
type DashboardActivityFeedActivityEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// Activity that occurred.
	Node DashboardActivityFeedActivity `json:"node"`
}

// When a user newly follows or refollows a channel.
type DashboardActivityFeedActivityFollowing struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// User who is now following the channel.
	Follower *User `json:"follower"`
	// Unique identifier for this follow action.
	ID string `json:"id"`
	// When the user followed the channel.
	Timestamp time.Time `json:"timestamp"`
}

func (DashboardActivityFeedActivityFollowing) IsDashboardActivityFeedActivity() {}

// When a user hosts a channel.
type DashboardActivityFeedActivityHosting struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// User/Channel who is now hosting the channel.
	Host *User `json:"host"`
	// Unique identifier for this hosting action.
	ID string `json:"id"`
	// When the host initiated the hosting session.
	Timestamp time.Time `json:"timestamp"`
	// Number of viewers from the host channel.
	ViewerCount *int `json:"viewerCount"`
}

func (DashboardActivityFeedActivityHosting) IsDashboardActivityFeedActivity() {}

// When a HypeTrain event occurs for the given user.
type DashboardActivityFeedActivityHypeTrainEvent struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// Unique identifier of the Hype Train.
	HypeTrainID string `json:"hypeTrainID"`
	// Unique identifier for this HypeTrain event.
	ID string `json:"id"`
	// When this HypeTrain event occurred.
	Timestamp time.Time `json:"timestamp"`
	// The type of this HypeTrain event.
	Type HypeTrainEventType `json:"type"`
}

func (DashboardActivityFeedActivityHypeTrainEvent) IsDashboardActivityFeedActivity() {}

// When a user gifts a single subscription to another individual user for a channel.
type DashboardActivityFeedActivityIndividualSubscriptionGifting struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// Total number of months the gifted subscription lasts for.
	GiftedMonths int `json:"giftedMonths"`
	// Subscription purchaser & gifter.
	Gifter *User `json:"gifter"`
	// Unique identifier for this gifting action.
	ID string `json:"id"`
	// Whether the subscription gifting was anonymized to other users.
	// If true, then `gifter` is guaranteed to be null.
	IsAnonymous bool `json:"isAnonymous"`
	// User that received the gift.
	Recipient *User `json:"recipient"`
	// The gifted subscription's tier.
	Tier SubscriptionTier `json:"tier"`
	// When the subscription was gifted.
	Timestamp time.Time `json:"timestamp"`
}

func (DashboardActivityFeedActivityIndividualSubscriptionGifting) IsDashboardActivityFeedActivity() {}

// When an ingest session begins.
// Deprecated type: no longer exists in activity feed.
type DashboardActivityFeedActivityIngestSessionStarting struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// Unique identifier for the start of this ingest session.
	ID string `json:"id"`
	// Start time of the ingest session.
	Timestamp time.Time `json:"timestamp"`
}

func (DashboardActivityFeedActivityIngestSessionStarting) IsDashboardActivityFeedActivity() {}

// When a user resubscribes via Twitch Prime to a channel.
type DashboardActivityFeedActivityPrimeResubscribing struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// Duration of the subscription.
	DurationMonths int `json:"durationMonths"`
	// Unique identifier for the act of renewing the subscription.
	ID string `json:"id"`
	// Custom message submitted by the resubscribing user to share in chat.
	Message *string `json:"message"`
	// Custom message submitted by the resubscribing user to share in chat.
	// Message is filtered for moderation and emotes are extracted as message fragments.
	MessageContent *MessageContent `json:"messageContent"`
	// User who is renewing the subscription.
	Resubscriber *User `json:"resubscriber"`
	// When the subscription was renewed.
	Timestamp time.Time `json:"timestamp"`
}

func (DashboardActivityFeedActivityPrimeResubscribing) IsDashboardActivityFeedActivity() {}

// When a user subscribes for the first time via Twitch Prime to a channel.
type DashboardActivityFeedActivityPrimeSubscribing struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// Unique identifier for the act of subscribing.
	ID string `json:"id"`
	// User who made the subscription.
	Subscriber *User `json:"subscriber"`
	// When the subscription was made.
	Timestamp time.Time `json:"timestamp"`
}

func (DashboardActivityFeedActivityPrimeSubscribing) IsDashboardActivityFeedActivity() {}

// When a user raids a channel.
type DashboardActivityFeedActivityRaiding struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// Unique identifier for this raiding action.
	ID string `json:"id"`
	// Number of users who participated in the raid.
	PartySize int `json:"partySize"`
	// User/Channel who is now raiding the channel.
	Raider *User `json:"raider"`
	// When the raid was initiated.
	Timestamp time.Time `json:"timestamp"`
	// Number of users who participated in the raid.
	ViewerCount int `json:"viewerCount"`
}

func (DashboardActivityFeedActivityRaiding) IsDashboardActivityFeedActivity() {}

// When a user resubscribes (NOT via Twitch Prime) to a channel.
type DashboardActivityFeedActivityResubscribing struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// Duration of the subscription.
	DurationMonths int `json:"durationMonths"`
	// Unique identifier for the act of renewing the subscription.
	ID string `json:"id"`
	// Custom message submitted by the resubscribing user to share in chat.
	Message *string `json:"message"`
	// Custom message submitted by the resubscribing user to share in chat.
	// Message is filtered for moderation and emotes are extracted as message fragments.
	MessageContent *MessageContent `json:"messageContent"`
	// Duration of the multi month subscription.
	MultiMonthDuration int `json:"multiMonthDuration"`
	// Tenure of the user's current multi month subscription.
	MultiMonthTenure int `json:"multiMonthTenure"`
	// User who is renewing the subscription.
	Resubscriber *User `json:"resubscriber"`
	// Subscription tier.
	Tier SubscriptionTier `json:"tier"`
	// When the subscription was renewed.
	Timestamp time.Time `json:"timestamp"`
}

func (DashboardActivityFeedActivityResubscribing) IsDashboardActivityFeedActivity() {}

// When a user subscribes for the first time (NOT via Twitch Prime) to a channel.
type DashboardActivityFeedActivitySubscribing struct {
	// Status of the corresponding alert.
	AlertStatus *DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// Unique identifier for the act of subscribing.
	ID string `json:"id"`
	// Duration of the multi month subscription.
	MultiMonthDuration int `json:"multiMonthDuration"`
	// Tenure of the user's current multi month subscription.
	MultiMonthTenure int `json:"multiMonthTenure"`
	// User who made the subscription.
	Subscriber *User `json:"subscriber"`
	// Subscription tier.
	Tier SubscriptionTier `json:"tier"`
	// When the subscription was made.
	Timestamp time.Time `json:"timestamp"`
}

func (DashboardActivityFeedActivitySubscribing) IsDashboardActivityFeedActivity() {}

// Paginated list of past activities for a channel's Dashboard Alert Queue.
type DashboardAlertQueueActivityConnection struct {
	// Activity elements of the list.
	Edges []*DashboardAlertQueueActivityEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Activity element in a list of past activities of a channel's Dashboard Alert Queue.
type DashboardAlertQueueActivityEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// Activity that occurred.
	Node DashboardActivityFeedActivity `json:"node"`
}

// Preferences of a user controlling the types of dashboard alerts to be published.
type DashboardAlertQueuePreferences struct {
	// If true, cannot publish alerts to the user.
	IsDNDModeEnabled bool `json:"isDNDModeEnabled"`
	// When the preferences were last modified.
	LastModified *time.Time `json:"lastModified"`
	// If true, cannot publish bits alerts to the user.
	ShouldHideBits bool `json:"shouldHideBits"`
	// If true, cannot publish follows alerts to the user.
	ShouldHideFollows bool `json:"shouldHideFollows"`
	// If true, cannot publish subscription gift alerts to the user.
	ShouldHideGiftSubscriptions bool `json:"shouldHideGiftSubscriptions"`
	// If true, cannot publish hosts alerts to the user.
	ShouldHideHosts bool `json:"shouldHideHosts"`
	// If true, cannot publish raids alerts to the user.
	ShouldHideRaids bool `json:"shouldHideRaids"`
	// If true, cannot publish regular subscriptions alerts to the user (gift subs are still shown).
	ShouldHideSubscriptions bool `json:"shouldHideSubscriptions"`
}

// A shelf title token type that contains a date with various formatters.
type DateToken struct {
	// The date to display for this token.
	Time time.Time `json:"time"`
}

func (DateToken) IsTitleTokenNode() {}

// The required input for a deactivateExtension mutation.
type DeactivateExtensionInput struct {
	// The composite ID of an extension installation <extensionID:version:channelID>.
	ExtensionInstallationID string `json:"extensionInstallationID"`
}

// The resulting payload after a deactivateExtension mutation.
type DeactivateExtensionPayload struct {
	// The resulting extension installation record from the deactivate.
	InstalledExtension *ExtensionInstallation `json:"installedExtension"`
}

// Error associated with mutation DeclineOrganizationInvite.
type DeclineOrganizationInviteError struct {
	// Error code.
	Code DeclineOrganizationInviteErrorCode `json:"code"`
}

// Input to the DeclineOrganiztaionInvite mutation.
type DeclineOrganizationInviteInput struct {
	// ID of the invite to decline.
	OrganizationInviteID string `json:"organizationInviteID"`
}

// Output from the DeclineOrganizationInvite mutation.
type DeclineOrganizationInvitePayload struct {
	// The possible error returned from service.
	Error *DeclineOrganizationInviteError `json:"error"`
}

// DefaultPanel is the normal panel type that displays text and images.
type DefaultPanel struct {
	// description is markdown-formatted text to be displayed below the title and image.
	// If the panel doesn't have a description this will be null.
	Description *string `json:"description"`
	// id is a unique identifier for the panel.
	ID string `json:"id"`
	// imageURL is a URL to an image to be displayed at the top of the panel (but below the header).
	// If the panel doesn't use an image this will be null.
	ImageURL *string `json:"imageURL"`
	// linkURL is the URL to navigate to when a user clicks on the image.
	// If the panel's image doesn't link anywhere this will be null.
	LinkURL *string `json:"linkURL"`
	// title is the header text to display in the panel.
	// If the panel doesn't have a title this will return null.
	Title *string `json:"title"`
	// type is `PanelType.DEFAULT`.
	Type PanelType `json:"type"`
}

func (DefaultPanel) IsPanel() {}

// DeferredPrimePayout is the earning that has been deferred to future payout cycles.
type DeferredPrimePayout struct {
	// totalPayoutAmount is the total amount for this payout.
	TotalPayoutAmount int `json:"totalPayoutAmount"`
}

// The input for delete bits badge tier emoticon.
type DeleteBitsBadgeTierEmoticonInput struct {
	// channelID is the owner of the emoticon being deleted.
	ChannelID string `json:"channelID"`
	// emoteID is the unique identifier for the emote.
	EmoteID string `json:"emoteID"`
	// The visual representation of the emote.
	// For example, "O_o" instead of "(O|o)_(o|O)".
	Text string `json:"text"`
	// threshold is the badge tier threshold associated with this emoticon.
	Threshold int `json:"threshold"`
}

// Result of delete bits badge tier emoticon.
type DeleteBitsBadgeTierEmoticonPayload struct {
	// Time that the emoticon got deleted.
	DeletedAt *time.Time `json:"deletedAt"`
}

// Inputs for deleting a celebration.
type DeleteCelebrationInput struct {
	// ID of celebration to delete.
	CelebrationID string `json:"celebrationID"`
	// ID of channel where the celebration to delete exists.
	ChannelID string `json:"channelID"`
}

// Outputs from the create celebration mutation.
type DeleteCelebrationPayload struct {
	// If present, there was an error with the request.
	Error *CelebrationError `json:"error"`
}

// Errors that the mutation returns.
type DeleteChannelBlockedTermError struct {
	// The error code that the mutation returned.
	Code DeleteChannelBlockedTermErrorCode `json:"code"`
}

// Inputs for the mutation. channel ID and a list of phrases to be deleted.
type DeleteChannelBlockedTermInput struct {
	// channelID is the owner of the term being deleted.
	ChannelID string `json:"channelID"`
	// phrases is the strings representation of the term being deleted.
	Phrases []string `json:"phrases"`
}

// The returned payload from the mutation.
type DeleteChannelBlockedTermPayload struct {
	// The time term was deleted.
	DeletedAt *time.Time `json:"deletedAt"`
	// Mutation error caused by the user input.
	Error *DeleteChannelBlockedTermError `json:"error"`
	// The phrases that were deleted.
	Phrases []string `json:"phrases"`
}

// Inputs for the deleting a channel's clip.
type DeleteChannelClipsInput struct {
	// channelID is the channel's ID.
	ChannelID string `json:"channelID"`
}

// The returned payload from the mutation.
type DeleteChannelClipsPayload struct {
	// channelID is the channel's ID.
	ChannelID string `json:"channelID"`
}

// The errors returned from this mutation.
type DeleteChannelPermittedTermError struct {
	// Error code that was returned.
	Code DeleteChannelPermittedTermErrorCode `json:"code"`
}

// Inputs for the mutation. channel ID and a list of phrases to be deleted.
type DeleteChannelPermittedTermInput struct {
	// channelID is the ID of the owner of the permitted term being deleted.
	ChannelID string `json:"channelID"`
	// phrases is the string representation of the term being deleted.
	Phrases []string `json:"phrases"`
}

// Returned payload of the mutation.
type DeleteChannelPermittedTermPayload struct {
	// The time term was deleted.
	DeletedAt *time.Time `json:"deletedAt"`
	// Mutation error caused by the user input.
	Error *DeleteChannelPermittedTermError `json:"error"`
	// The phrases that were deleted.
	Phrases []string `json:"phrases"`
}

// The input for deleteChatMessage.
type DeleteChatMessageInput struct {
	// The channel the message was sent in.
	ChannelID string `json:"channelID"`
	// The UUID of the message to be deleted.
	MessageID string `json:"messageID"`
}

// The returned payload for deleteChatMessage.
type DeleteChatMessagePayload struct {
	// The returned message.
	Message *DeletedMessage `json:"message"`
	// The response codes for this mutation.
	ResponseCode DeleteChatMessageStatusCode `json:"responseCode"`
}

// Error returned after attempting to delete a cheermote tier.
type DeleteCheermoteTierError struct {
	// The error code associated with this error.
	Code DeleteCheermoteTierErrorCode `json:"code"`
}

// The input for delete cheermote tier.
type DeleteCheermoteTierInput struct {
	// Threshold of the cheermote tier to be deleted.
	TierThreshold CheermoteTierThreshold `json:"tierThreshold"`
	// ID of the owner of the cheermote tier being deleted.
	UserID string `json:"userID"`
}

// Result of delete cheermote tier.
type DeleteCheermoteTierPayload struct {
	// Time that the cheermote tier got deleted.
	DeletedAt *time.Time `json:"deletedAt"`
	// Error returned after attempting to delete a cheermote tier.
	Error *DeleteCheermoteTierError `json:"error"`
}

// DeleteClipsInput accepts either a list of slugs, a video id, or a broadcast id
// to determine the clips to delete.
type DeleteClipsInput struct {
	// The id of the broadcast to delete clips from.
	BroadcastID *string `json:"broadcastID"`
	// The list of clip slugs to be deleted.
	Slugs []string `json:"slugs"`
	// The id of the video to delete clips from.
	VideoID *string `json:"videoID"`
}

// DeleteClipsPayload returns the deleted clips. Only the slug and id can be accessed
// from the returned list of deleted clips.
type DeleteClipsPayload struct {
	// The clips that were deleted. Only Slug and ID can be accessed.
	Clips []*Clip `json:"clips"`
	// The amount of clips that were deleted.
	Count int `json:"count"`
}

// DeleteCollectionInput accepts a collection ID to delete a collection.
type DeleteCollectionInput struct {
	// The id of the collection to be deleted.
	CollectionID string `json:"collectionID"`
}

// DeleteCollectionPayload resolves the deleted collection.
type DeleteCollectionPayload struct {
	// The collection that was just deleted.
	Collection *Collection `json:"collection"`
}

// Delete community goal error.
type DeleteCommunityPointsCommunityGoalError struct {
	// The error code.
	Code DeleteCommunityPointsCommunityGoalErrorCode `json:"code"`
}

// Delete community goal input.
type DeleteCommunityPointsCommunityGoalInput struct {
	// The channel.
	ChannelID string `json:"channelID"`
	// The community goal.
	GoalID string `json:"goalID"`
}

// Delete community goal payload.
type DeleteCommunityPointsCommunityGoalPayload struct {
	// The error, if any.
	Error *DeleteCommunityPointsCommunityGoalError `json:"error"`
	// The community goal that was deleted.
	Goal *CommunityPointsCommunityGoal `json:"goal"`
}

// An error from deleting a custom Community Points reward in a channel.
type DeleteCommunityPointsCustomRewardError struct {
	// An identifier for the error that occurred.
	Code DeleteCommunityPointsCustomRewardErrorCode `json:"code"`
}

// Input for deleting a custom Community Points reward in a channel.
type DeleteCommunityPointsCustomRewardInput struct {
	// The channel ID that the reward is being deleted in.
	ChannelID string `json:"channelID"`
	// The ID of the reward being deleted.
	RewardID string `json:"rewardID"`
	// Rewards cannot be deleted while they have unfulfilled redemptions.
	// All unfulfilled redemptions will be set to this new state asynchronously after the reward is deleted.
	UnfulfilledRedemptionsNewStatus *CommunityPointsCustomRewardRedemptionStatus `json:"unfulfilledRedemptionsNewStatus"`
}

// The response from deleting a custom Community Points reward in a channel.
type DeleteCommunityPointsCustomRewardPayload struct {
	// An error that occurred while deleting a custom Community Points reward in a channel.
	Error *DeleteCommunityPointsCustomRewardError `json:"error"`
	// The now deleted reward.
	Reward *CommunityPointsCustomReward `json:"reward"`
}

// Delete a Competition.
type DeleteCompetitionInput struct {
	// Unique Competition Id.
	ID string `json:"id"`
}

// Result of the remove operation.
type DeleteCompetitionPayload struct {
	// The deleted competition.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// Delete tags associated with CLIP, STREAM, or VOD with contentID.
type DeleteContentTagsInput struct {
	// ID of the channel owning the content.
	AuthorID string `json:"authorID"`
	// ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs.
	ContentID string `json:"contentID"`
	// Type of content being returned. Can only be of values CLIP, STREAM, or VOD.
	ContentType ContentType `json:"contentType"`
	// List of tag IDs to be deleted from the content.
	TagIDs []string `json:"tagIDs"`
}

// Result of mutation is the contentID.
type DeleteContentTagsPayload struct {
	// Content which tags have been deleted from.
	Content TaggedContent `json:"content"`
}

// The input required when making a request to delete a user's default payment method for a given provider.
type DeleteDefaultPaymentMethodInput struct {
	// The payment provider we're deleting the payment method on.
	Provider PaymentProvider `json:"provider"`
	// The user to delete default payment method for.
	UserID string `json:"userID"`
}

// Payload returned after deleting a default payment method for a given provider.
type DeleteDefaultPaymentMethodPayload struct {
	// Time when payment method was deleted.
	UpdatedAt *time.Time `json:"updatedAt"`
	// User who had their default payment method deleted.
	User *User `json:"user"`
}

// DeleteDeviceTokenInput accepts a token and user ID and deletes that pair from the database.
type DeleteDeviceTokenInput struct {
	// The token to be deleted.
	DeviceToken string `json:"deviceToken"`
	// ID for the user associated with the device token.
	UserID string `json:"userID"`
}

// The response from deleting a push notification token from a user.
type DeleteDeviceTokenPayload struct {
	// The ID of the token that was deleted.
	DeviceToken string `json:"deviceToken"`
}

// DeleteDropCampaignInput has fields required to delete a campaign.
type DeleteDropCampaignInput struct {
	// The id of the Drop campaign to be deleted.
	CampaignID string `json:"campaignID"`
}

// DeleteDropCampaignPayload returns the result of the deletion.
type DeleteDropCampaignPayload struct {
	// A potential error being thrown.
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// DeleteDropInput has fields required to delete a drop.
type DeleteDropInput struct {
	// The id of the Drop to be deleted.
	DropID string `json:"dropID"`
}

// DeleteDropPayload returns the result of the deletion.
type DeleteDropPayload struct {
	// A potential error being thrown.
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// Error returned after attempting to delete an emote.
type DeleteEmoteError struct {
	// The error code associated with this error.
	Code DeleteEmoteErrorCode `json:"code"`
}

// The input for delete emote.
type DeleteEmoteInput struct {
	// ID of the emote to be deleted.
	ID string `json:"id"`
}

// Result of delete emote.
type DeleteEmotePayload struct {
	// Error returned after attempting to delete an emote.
	Error *DeleteEmoteError `json:"error"`
}

// Information needed to delete images on extension.
type DeleteExtensionImageInput struct {
	// The extension:version the images are for.
	ExtensionID string `json:"extensionID"`
	// Urls to be deleted.
	Urls []string `json:"urls"`
}

// DeleteExtensionImagePayload returns the update Extension manifest.
type DeleteExtensionImagePayload struct {
	// The error when the mutation fails to update an extension.
	Error *DeleteExtensionImageError `json:"error"`
	// The updated extension manifest.
	Manifest *ExtensionManifest `json:"manifest"`
}

// Inputs for the deleteExtension mutation.
type DeleteExtensionInput struct {
	// ID for the extension being deleted.
	ID string `json:"id"`
}

// The returned payload from the deleteExtension mutation.
type DeleteExtensionPayload struct {
	// Error response from the deleteExtension mutation.
	// null if the delete was successful.
	Error *DeleteExtensionError `json:"error"`
}

// The information we need to delete the extension's secrets.
type DeleteExtensionSecretsInput struct {
	// The extensionID whose secrets should be removed.
	ExtensionID string `json:"extensionID"`
}

// Returns nothing but an error, should one occur.
type DeleteExtensionSecretsPayload struct {
	// An useful error for the user.
	Error *DeleteExtensionSecretsError `json:"error"`
}

// Inputs for the mutation. Loyalty Badge to be deleted by channelID, badgeID, and channelTenureMethodID.
type DeleteLoyaltyBadgeInput struct {
	// badgeID correlated to the badge being deleted.
	BadgeID string `json:"badgeID"`
	// channelID correlated to the badge being deleted.
	ChannelID string `json:"channelID"`
	// channelTenureMethodID uniquely identifies the badge being deleted.
	ChannelTenureMethodID string `json:"channelTenureMethodID"`
}

// The returned payload from the mutation for Deleting a Loyalty Badge.
type DeleteLoyaltyBadgePayload struct {
	// LoyaltyBadge object that was deleted.
	Badge *LoyaltyBadge `json:"badge"`
}

// Output from the DeleteModeratorComment mutation.
type DeleteModeratorCommentInput struct {
	// ID of the comment to be deleted.
	ID string `json:"ID"`
}

// Output from the DeleteModeratorComment mutation.
type DeleteModeratorCommentPayload struct {
	// The deleted comment.
	Comment *ModLogsComment `json:"comment"`
}

// Contains a list of IDs of content attributes that are to be deleted.
type DeleteMultiviewContentAttributesInput struct {
	// A list of content attribute IDs.
	IDs []string `json:"IDs"`
}

// Contains the results from the delete request.
type DeleteMultiviewContentAttributesPayload struct {
	// Unprocessed content attributes.
	FailedDeletes []*MultiviewContentAttribute `json:"failedDeletes"`
	// Processed content attributes.
	SucceededDeletes []*MultiviewContentAttribute `json:"succeededDeletes"`
}

type DeleteNotificationInput struct {
	// The notification to delete.
	ID string `json:"id"`
}

type DeleteNotificationPayload struct {
	// The notification that was deleted. Only the ID is accessible.
	Notification *OnsiteNotification `json:"notification"`
}

type DeletePanelInput struct {
	ID string `json:"id"`
}

type DeletePanelPayload struct {
	Panel Panel `json:"panel"`
}

type DeletePostInput struct {
	PostID string `json:"postID"`
}

type DeletePostPayload struct {
	Post *Post `json:"post"`
}

// Data required to delete recommendation feedback.
type DeleteRecommendationFeedbackInput struct {
	// The id of the feedback.
	FeedbackID string `json:"feedbackID"`
	// The page this event was fired from.
	SourceItemPage string `json:"sourceItemPage"`
}

// Returns the created feedback item back to the client.
type DeleteRecommendationFeedbackPayload struct {
	// The id of the feedback you just deleted.
	FeedbackID string `json:"feedbackID"`
}

type DeleteRoomInput struct {
	RoomID string `json:"roomID"`
}

type DeleteRoomMessageInput struct {
	MessageID string `json:"messageID"`
	RoomID    string `json:"roomID"`
}

type DeleteRoomMessagePayload struct {
	Message *RoomMessage `json:"message"`
}

type DeleteRoomPayload struct {
	Room *Room `json:"room"`
}

// The input to delete a schedule.
type DeleteScheduleInput struct {
	// The channel ID.
	ChannelID string `json:"channelID"`
	// The schedule ID.
	ScheduleID string `json:"scheduleID"`
}

// The payload returned after deleting a schedule.
type DeleteSchedulePayload struct {
	// The channel with the deleted schedule.
	Channel *Channel `json:"channel"`
	// The possible error.
	Error *DeleteScheduleError `json:"error"`
}

// The input to delete a schedule segment.
type DeleteScheduleSegmentInput struct {
	// The schedule id.
	ScheduleID string `json:"scheduleID"`
	// The segment id to delete.
	SegmentID string `json:"segmentID"`
}

// The returned payload when deleting a schedule segment.
type DeleteScheduleSegmentPayload struct {
	// The possible error.
	Error *DeleteScheduleSegmentError `json:"error"`
	// The updated schedule without the deleted segment.
	Schedule *Schedule `json:"schedule"`
}

// Mutation input to delete a social media item by ID under the given channelID.
type DeleteSocialMediaInput struct {
	// The ID of the channel the social media belongs to.
	ChannelID string `json:"channelID"`
	// The ID of the social media item.
	ID string `json:"id"`
}

// DeleteSocialMediaPayload returns an error, if any.
type DeleteSocialMediaPayload struct {
	// The channel of the social media that was deleted.
	Channel *Channel `json:"channel"`
}

// Errors from deleteSquadStreamInvitation mutation.
type DeleteSquadStreamInvitationError struct {
	// Error from request to delete invitation.
	Code DeleteSquadStreamInvitationErrorCode `json:"code"`
}

// Inputs to the deleteSquadStreamInvitation mutation.
type DeleteSquadStreamInvitationInput struct {
	// ID of the invitation to be deleted.
	InvitationID string `json:"invitationID"`
}

// Outputs from the deleteSquadStreamInvitation mutation.
type DeleteSquadStreamInvitationPayload struct {
	// Error from mutation if exists.
	Error *DeleteSquadStreamInvitationError `json:"error"`
	// The deleted invitation.
	Invitation *SquadStreamInvitation `json:"invitation"`
}

// Error that may be returned by the DeleteStreamAuthorizedUser mutation.
type DeleteStreamAuthorizedUserError struct {
	// Type of mutation error.
	Code DeleteStreamAuthorizedUserErrorCode `json:"code"`
}

// DeleteStreamAuthorizedUserInput contains the channelID for the broadcaster and the authorized userID.
type DeleteStreamAuthorizedUserInput struct {
	// authorizedUserID for an authorized user who was allowed to stream on behalf of broadcaster.
	AuthorizedUserID string `json:"authorizedUserID"`
	// channelID of the broadcaster.
	ChannelID string `json:"channelID"`
}

// DeleteStreamAuthorizedUserPayload contains the VideoStreamSettings with updated authorized users.
type DeleteStreamAuthorizedUserPayload struct {
	// The updated channel of broadcaster.
	Channel *Channel `json:"channel"`
	// Error code.
	Error *AddStreamAuthorizedUserError `json:"error"`
}

// Inputs for the deleting clips made by user.
type DeleteUserClipsInput struct {
	// userID is the user's ID.
	UserID string `json:"userID"`
}

// The returned payload from the mutation.
type DeleteUserClipsPayload struct {
	// userID is the user's ID.
	UserID string `json:"userID"`
}

// Inputs for the DeleteUserColors mutation.
type DeleteUserColorsInput struct {
	// The ID of the user whose creator color is being deleted.
	UserID string `json:"userID"`
}

// The returned payload from the DeleteUserColors mutation.
type DeleteUserColorsPayload struct {
	// The modified user.
	User *User `json:"user"`
}

type DeleteVideoCommentPayload struct {
	// The comment that was deleted.
	Comment *VideoComment `json:"comment"`
}

// A deleted message sent by a user to a stream chat.
type DeletedMessage struct {
	// Content of the deleted message.
	Content *RoomMessageContent `json:"content"`
	// UUID of the deleted message.
	ID string `json:"id"`
	// Sender of the message.
	Sender *User `json:"sender"`
}

// Defines ads management attributes for channel.
type Density struct {
	// Ad schedule for ads management.
	AdSchedule []*AdSlot `json:"adSchedule"`
	// Duration of auto ads.
	AutoAdLengthSeconds *int `json:"autoAdLengthSeconds"`
	// Period inbetween each auto ad.
	AutoAdPeriodMinutes *int `json:"autoAdPeriodMinutes"`
	// If channel is a custom contract partner.
	IsCcp bool `json:"isCCP"`
	// Minutes elapsed since stream started.
	MinutesElapsed *int `json:"minutesElapsed"`
	// If contract is enforced on this channel.
	ShouldEnforceContract bool `json:"shouldEnforceContract"`
	// Ad density target for a specific channel.
	TargetAdMinutes *int `json:"targetAdMinutes"`
	// Total amount of ad time.
	TotalAdSeconds *int `json:"totalAdSeconds"`
}

type DenyRejectedChatMessageInput struct {
	ID string `json:"id"`
}

type DenyRejectedChatMessagePayload struct {
	Message *RejectedChatMessage `json:"message"`
}

// Input to the denyRejectedCheer mutation.
type DenyRejectedCheerInput struct {
	// Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
	// The server will reject any request with an ID that has already been used.
	ID string `json:"id"`
	// ID of the user whose message is automodded.
	TargetUserID string `json:"targetUserID"`
}

// Payload from the denyRejectedCheer mutation.
type DenyRejectedCheerPayload struct {
	// Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
	// The server will reject any request with an ID that has already been used.
	ID string `json:"id"`
}

// Required input to deny an unban request on a channel.
type DenyUnbanRequestInput struct {
	// ID of the unban request to be resolved.
	ID string `json:"id"`
	// Optional message from the resolver to be shown to the unban requester.
	ResolverMessage *string `json:"resolverMessage"`
}

// Result of denying an unban request.
type DenyUnbanRequestPayload struct {
	// Used for errors arising from resolving unban request.
	Error *UnbanRequestError `json:"error"`
	// The resolved unban request.
	UnbanRequest *UnbanRequest `json:"unbanRequest"`
}

// Inputs for deselecting a channel badge.
type DeselectChannelBadgeInput struct {
	// ID of the channel this badge is selected on.
	ChannelID string `json:"channelID"`
}

// The output for the deselect channel badge mutation.
type DeselectChannelBadgePayload struct {
	// The channel (user object of channel) this badge is deselected on.
	User *User `json:"user"`
}

// The output for the deselect global badge mutation.
type DeselectGlobalBadgePayload struct {
	// The user (contains the badge status).
	User *User `json:"user"`
}

// Paginated list of Directories.
// Implements the Relay cursor connections specification.
// See: https://facebook.github.io/relay/graphql/connections.htm.
type DirectoryConnection struct {
	Edges    []*DirectoryEdge `json:"edges"`
	PageInfo *PageInfo        `json:"pageInfo"`
}

// Contains information about a Directory's relationship to a given page (connection),
// and the Directory itself.
type DirectoryEdge struct {
	Cursor *string   `json:"cursor"`
	Node   Directory `json:"node"`
}

// Disable Prerolls Ability contains the properties used by the Disable Prerolls Feature.
type DisablePrerollsAbility struct {
	// DisablePrerollsFreeTime define relation of midroll-length:preroll-free-time-earned on this channel.
	DisablePrerollsTimeEarned []*DisablePrerollsFreeTime `json:"disablePrerollsTimeEarned"`
	// If "disable prerolls for midrolls" feature is accessible on this channel.
	HasDisablePrerollsAbilityAccess *bool `json:"hasDisablePrerollsAbilityAccess"`
	// If "disable prerolls for midrolls" feature is enabled on this channel.
	HasDisablePrerollsAbilityEnabled *bool `json:"hasDisablePrerollsAbilityEnabled"`
	// If disable preroll notifications are enabled on this channel.
	HasDisablePrerollsNotificationsEnabled *bool `json:"hasDisablePrerollsNotificationsEnabled"`
	// Maximum amount of preroll-free time (in seconds) that can be accumulated on this channel.
	MaxDisablePrerollsCapacity *int `json:"maxDisablePrerollsCapacity"`
}

// Disable Prerolls Free Time maps the relationship between a specific midroll length and amount of preroll-free time earned for a channel.
type DisablePrerollsFreeTime struct {
	// The length (in seconds) of a midroll ad.
	MidrollLengthSeconds int `json:"midrollLengthSeconds"`
	// The amount of preroll-free time (in seconds) earned on this channel for running midroll of related length.
	PrerollFreeTimeSeconds int `json:"prerollFreeTimeSeconds"`
}

// Error returned during a invalid user request.
type DisableTwoFactorError struct {
	// Error code returned by the backend.
	Code DisableTwoFactorErrorCode `json:"code"`
	// The localized external error message.
	Message string `json:"message"`
}

// The required input for a disableTwoFactor mutation.
type DisableTwoFactorInput struct {
	// The ID of the user that is requesting to disable two factor authentication.
	UserID string `json:"userID"`
}

// The result of a disableTwoFactorPayload mutation.
type DisableTwoFactorPayload struct {
	// error code and localized error.
	Error *DisableTwoFactorError `json:"error"`
}

// Error type that DisableUserAccountPayload returns.
type DisableUserAccountError struct {
	// Error Code, see DisableUserAccountErrorCode.
	Code DisableUserAccountErrorCode `json:"code"`
}

// Inputs to the disableUserAccount mutation.
type DisableUserAccountInput struct {
	// Reason for a user to disable their account.
	Description *string `json:"description"`
	// Permanently delete account.
	// false means account will be disabled and can be reenabled in the future.
	// true means the account will be disabled and will be permanently deleted after a period of time.
	// default is false.
	IsDelete *bool `json:"isDelete"`
	// The ID of the user to disable or delete.
	// Only the requester's user ID is allowed.
	UserID string `json:"userID"`
}

// Output from the disableUserAccount mutation.
type DisableUserAccountPayload struct {
	// Error if operation failed from user error.
	Error *DisableUserAccountError `json:"error"`
	// User that has been deleted or disabled.
	User *User `json:"user"`
}

// DiscountBreakdown shows discounted pricing for a promotional offer.
type DiscountBreakdown struct {
	// The numerical price of a discounted offer.
	Price int `json:"price"`
	// The localized tax rate of a offer.
	Tax int `json:"tax"`
	// The total discounted price given price and tax.
	Total int `json:"total"`
}

type DismissFriendRecommendationInput struct {
	// The recommendation to the authenticated user to become friends with a user with ID targetID will be removed.
	TargetID string `json:"targetID"`
}

type DismissFriendRecommendationPayload struct {
	// The user who was previously a friend recommendation to the target user.
	User *User `json:"user"`
}

type DismissRitualTokenError struct {
	Code DismissRitualTokenErrorCode `json:"code"`
}

// DismissRitualTokenInput is the input when dismissing a ritual token.
type DismissRitualTokenInput struct {
	// The channel to dismiss the ritual token in.
	ChannelID string `json:"channelID"`
	// The type of ritual token to dismiss.
	Type RitualTokenType `json:"type"`
}

// DismissRitualTokenPayload is the response when dismissing a ritual token.
type DismissRitualTokenPayload struct {
	Error *DismissRitualTokenError `json:"error"`
	Token *RitualToken             `json:"token"`
}

// Input for dismissing a video's suggested highlight.
type DismissVideoSuggestedHighlightInput struct {
	// VideoID of the video whos automated highlight suggestions were dismissed.
	VideoID string `json:"videoID"`
}

// Ouput for dismissing a video's suggested highlight.
type DismissVideoSuggestedHighlightPayload struct {
	// Video whos automated highlight suggestions were dismissed.
	Video *Video `json:"video"`
}

// Contains all of the information about a Drop awarded to a user.
type Drop struct {
	// The game that awarded the Drop.
	Game *Game `json:"game"`
	// The assigned ID of this drop.
	ID string `json:"id"`
	// The image URL of the Drop. Images are 80x80 pixels.
	ImageURL string `json:"imageURL"`
	// The developer-provided name of the Drop.
	Name string `json:"name"`
}

// A mapping of the client ID set to determine whether a user has set up account linking for the game.
type DropAccountLink struct {
	// The associated clientID for a game used to determine if users have an account link
	// created between tuid and in-game userID.
	ClientID string `json:"clientID"`
	// The date when this clientID was first added.
	UpdatedAt time.Time `json:"updatedAt"`
}

// Contains all of the information about a Drop's action stating what happens when a drop is triggered. //To be deprecated.
type DropAction struct {
	// The time in seconds a user has to claim a drop after occurence.
	ClaimDurationSeconds int `json:"claimDurationSeconds"`
	// The description of this drop's action.
	Description string `json:"description"`
	// The Action ID.
	ID string `json:"id"`
	// The type of action happening when a drop is triggered.
	Type DropActionType `json:"type"`
}

// Data about the award of a drop to a user. // deprecated.
type DropAward struct {
	// The timestamp when the Drop was awarded to the user.
	AwardedAt *time.Time `json:"awardedAt"`
	// The drop that was awarded to the user.
	Node *Drop `json:"node"`
	// The reason the Drop was awarded.
	Reason *string `json:"reason"`
}

// Contains all of the information about a Drop awarded to a user.
type DropBenefit struct {
	// The redirect URL where a user can link their account.
	AccountLinkURL string `json:"accountLinkURL"`
	// The time the benefit was created.
	CreatedAt time.Time `json:"createdAt"`
	// The display description of this award object. //To be deprecated.
	Description string `json:"description"`
	// The limit of how often this benefit can globally be awarded to a user. Set to -1 if the drop can be entitled unlimited amounts.
	// The per drop entitlementLimit of a reward is on DropObject.Drop2BenefitObject.
	EntitlementLimit int `json:"entitlementLimit"`
	// The game that awarded the Drop.
	Game *Game `json:"game"`
	// The ID of this reward object.
	ID string `json:"id"`
	// An image asset for this reward object.
	ImageAssetURL string `json:"imageAssetURL"`
	// Specifies if this benefit is considered for a game that is available on iOS.
	IsIosAvailable bool `json:"isIosAvailable"`
	// The display name of this award object.
	Name string `json:"name"`
	// The ID of the owner of the item for this reward.
	Owner *User `json:"owner"`
	// The (RBAC) Organization that owns the drop benefit.
	OwnerOrganization *Organization `json:"ownerOrganization"`
}

// The DropBenefitEdge links a drop with a benefit and describes how many times that benefit
// can be granted by this drop. A benefit can be granted multiple times by event based drops.
// For example, a benefit could be granted every time the broadcaster gets a kill streak, up to
// 3 times.
type DropBenefitEdge struct {
	// The benefit description.
	Benefit *DropBenefit `json:"benefit"`
	// The number of times a benefit has been claimed.
	ClaimCount *int `json:"claimCount"`
	// A restriction of the benefit on how often it can be claimed within a drop.
	EntitlementLimit int `json:"entitlementLimit"`
}

// A campaign a developer is running to give drops away to viewers of their game
// To be considered live, a campaign must be enabled with the current time
// being after the start but before the end times
// To apply to a particular channel a campaign must be live and additionally
// the channel must be playing an applicable game and either must be one of the
// applicable channels or the campaign must have an empty applicable channel list
// (where an empty list specifically means all channels are eligible).
type DropCampaign struct {
	// The URL users who aren't linked should click on to create a link that will
	// allow them create an account link for the developer of the game(s)
	// this campaign is for.
	AccountLinkURL string `json:"accountLinkURL"`
	// The only channels allowed to be eligible for the drop campaign.
	Allow *DropCampaignACL `json:"allow"`
	// If isAvailableToAllChannels is false, applicableChannels is the list of
	// what channels this campaign is targeted to.  If the flag is true but the
	// list is empty, that means that all whitelisted users cannot be loaded.
	// An applicable channel must also be playing an applicable game for the
	// campaign to apply to the channel.
	ApplicableChannels []*User `json:"applicableChannels"`
	// The games that this campaign is enabled on
	// A channel playing one of these games must be in the applicable channels
	// list or list must be empty for the campaign to apply to the channel.
	ApplicableGames []*Game `json:"applicableGames"`
	// The drops this campaign can award.
	AwardableDrops []*Drop `json:"awardableDrops"`
	// The channels blocked from being eligible for the drop campaign.
	Block *DropCampaignACL `json:"block"`
	// The URL users who aren't linked should click on to create a link that will
	// allow them create an account link for the developer of the game(s)
	// this campaign is for.
	ConnectionURL string `json:"connectionURL"`
	// The description contains the full details about the campaign.
	Description string `json:"description"`
	// The URL that links to the details / marketing page for this campaign.
	DetailsURL string `json:"detailsURL"`
	// The time this campaign ends
	// To be considered live, a campaign must be enabled with the current time
	// being after the start but before the end times.
	EndAt time.Time `json:"endAt"`
	// Drops triggered by in-game events.
	EventBasedDrops []*EventBasedDrop `json:"eventBasedDrops"`
	// The Game associated with this campaign.
	Game *Game `json:"game"`
	// GUID identifying this campaign.
	ID string `json:"id"`
	// An image asset for this campaign no larger than 160 x 160 pixels.
	ImageURL string `json:"imageURL"`
	// Indicates if this campaign is available to all channels or if only some.
	// If false, applicableChannels should contain the channels where the campaign
	// is available.
	IsAvailableToAllChannels bool `json:"isAvailableToAllChannels"`
	// If this campaign is enabled
	// To be considered live, a campaign must be enabled with the current time
	// being after the start but before the end times.
	IsEnabled bool `json:"isEnabled"`
	// Drops that can be triggered by manual events.
	ManualTriggerBasedDrops []*ManualTriggerBasedDrop `json:"manualTriggerBasedDrops"`
	// The name of the campaign.
	Name string `json:"name"`
	// This is the Organization (RBAC) that has ownership of the campaign and attached drops.
	Owner *Organization `json:"owner"`
	// User specific data for the campaign.
	Self *DropCampaignSelfEdge `json:"self"`
	// The time this campaign starts
	// To be considered live, a campaign must be enabled with the current time
	// being after the start but before the end times.
	StartAt time.Time `json:"startAt"`
	// The current status of the campaign.
	Status DropCampaignStatus `json:"status"`
	// Test viewers can participate in campaigns while the campaign is in the test status.
	TestViewers []*User `json:"testViewers"`
	// Drops triggered by accumulating minutes watched on a game.
	TimeBasedDrops []*TimeBasedDrop `json:"timeBasedDrops"`
	// The type of a campaign defines what type of drops are allowed to be added to the campaign.
	Type CampaignType `json:"type"`
}

// A toggleable access control list of channels given certain access to drop campaigns.
type DropCampaignACL struct {
	// The channels that are either granted or denied access.
	Channels []*Channel `json:"channels"`
	// Whether the access list is currently in use.
	IsEnabled bool `json:"isEnabled"`
}

// DropCampaignSelfEdge returns user specific information about the drops campaign.
type DropCampaignSelfEdge struct {
	// Has the user linked their game account with the campaign.
	IsAccountConnected bool `json:"isAccountConnected"`
}

// Contains all of the information about the channel seetings for a Drop.
type DropChannelSetting struct {
	// UserAccountConnected is a boolean specifying if a streamer has a connected account link to the game required for the game developers to send drop related game data for this user.
	IsUserAccountConnected bool `json:"isUserAccountConnected"`
}

// The drop that is closest to completing for the current user that is actively earning progress.
type DropCurrentSession struct {
	// The channelID where Progresso is currently tracking progress.
	Channel *Channel `json:"channel"`
	// The number of minutes that the user has accrued toward completing the drop.
	CurrentMinutesWatched int `json:"currentMinutesWatched"`
	// The ID for the Drop that we're currently tracking (not surfaced; used for fulfillment).
	DropID string `json:"dropID"`
	// The Game name that we're tracking for the currently-tracked drop.
	Game *Game `json:"game"`
	// The total number of minutes required in order to complete the drop.
	RequiredMinutesWatched int `json:"requiredMinutesWatched"`
}

// Contains all of the information about a Drop awarded to a user.
type DropEligibility struct {
	// The remaining time in which this reward can be claimed.
	ClaimSecondsRemaining int `json:"claimSecondsRemaining"`
	// Summary information for the drop the reward is claimed of.
	Drop *DropObject `json:"drop"`
	// The unique ID of this drop instance.
	DropInstanceID string `json:"dropInstanceID"`
	// A single Drop. This could be either an event or time based drop.
	DropType DropType `json:"dropType"`
	// Rewards available to the user for this drop and their statuses.
	Rewards []*DropReward `json:"rewards"`
	// User eligibility for this drop instance.
	Status DropInstanceEligibilityStatus `json:"status"`
}

// Defines a condition that must be met for an in game event to trigger a drop.
type DropEventCondition struct {
	// Specifies the event to look for in the event payload.
	Key string `json:"key"`
	// The comparator of the value to the event payload.
	Operator DropEventConditionOperator `json:"operator"`
	// Specifies the value to compare the event payload to.
	Value string `json:"value"`
}

// A measurement against an in-game event to determine whether the drop should trigger.
type DropEventConditionInput struct {
	// The key of the in-game event that can trigger the drop.
	Key string `json:"key"`
	// The operator to apply to the event.
	Operator DropEventConditionOperator `json:"operator"`
	// The value of the in-game event that the operator is compared to.
	Value string `json:"value"`
}

// DropImageUploadInput has the fields required to upload a drop's image asset.
type DropImageUploadInput struct {
	// The ownerID of the content owner.
	OwnerID string `json:"ownerID"`
	// The ID for the referenced scope item.
	ReferenceID string `json:"referenceID"`
	// The scope of what the image gets uploaded for.
	Scope Scope `json:"scope"`
}

// SetDropCampaignStatusPayload returns the result of the creation/update.
type DropImageUploadPayload struct {
	// The ID of the image once uploaded.
	UploadID *string `json:"uploadID"`
	// The URL to upload the image to.
	UploadURL *string `json:"uploadURL"`
}

// Contains all of the information about a Drop awardable to a user. // deprecated in favor of EventBasedDrop and TimeBasedDrop.
type DropObject struct {
	// The redirect URL where a user can link their account.
	AccountLinkURL string `json:"accountLinkURL"`
	// The actions defining what happens after a drop is triggered.
	Actions []*DropAction `json:"actions"`
	// The description of this drop.
	Description string `json:"description"`
	// The URL that links to the details / marketing page for this drop.
	DetailsURL string `json:"detailsURL"`
	// The date at which this drop can no longer occur.
	EndDate time.Time `json:"endDate"`
	// The game associated with this drop.
	Game *Game `json:"game"`
	// The Drops ID.
	ID string `json:"id"`
	// An image asset for this drop.
	ImageURL string `json:"imageURL"`
	// The friendly name of this drop.
	Name string `json:"name"`
	// The OrganizationID of the owner of this drop.
	OwnerID string `json:"ownerID"`
	// The friendly name of the owner of this drop.
	OwnerName string `json:"ownerName"`
	// The Quest name for this specific Drop.
	QuestName string `json:"questName"`
	// The rules defining what needs to happen to trigger this drop.
	Rules []*DropRule `json:"rules"`
	// The date at which this drop can start to occur.
	StartDate time.Time `json:"startDate"`
}

// DropPrecondition is the tuple of DropID and the DropPreconditionID, which is the drop that must be attained first.
type DropPrecondition struct {
	// The drop that can be claimed once the preconditions are met.
	DropID string `json:"dropID"`
	// The drop that must have been claimed before you can make progress on this drop.
	DropPreconditionID string `json:"dropPreconditionID"`
}

// Contains all of the information about a Drop awarded to a user.
type DropReward struct {
	// The URL where a user can link their account for this reward.
	AccountLinkURL string `json:"accountLinkURL"`
	// An availability enum for this reward.
	Availability DropRewardAvailability `json:"availability"`
	// The DropBenefit that a user is claiming or get verified to.
	Benefit *DropBenefit `json:"benefit"`
	// The display description of this award object.
	Description string `json:"description"`
	// The ID of this reward object.
	ID string `json:"id"`
	// An image asset for this reward object.
	ImageAssetURL string `json:"imageAssetURL"`
	// Specifies if this reward is considered for a game that is available on iOS.
	IsIosAvailable bool `json:"isIosAvailable"`
	// The display name of this award object.
	Name string `json:"name"`
	// The ID of the owner of the item for this reward.
	OwnerID string `json:"ownerID"`
	// The display name of item owner for this drop.
	OwnerName string `json:"ownerName"`
}

// Contains all of the information about a Drop's rule stating what a broadcaster has to do to trigger a drop. //To be deprecated.
type DropRule struct {
	// The description of this drop's rule.
	Description string `json:"description"`
	// The Rule ID.
	ID string `json:"id"`
}

// An error that has been mapped from a DropsManagementService twirp error. Can sometimes include messages.
type DropsError struct {
	// The error code.
	Code DropsErrorCode `json:"code"`
	// The error message string.
	Message *string `json:"message"`
}

type EditRoomMessageInput struct {
	Message   string `json:"message"`
	MessageID string `json:"messageID"`
	RoomID    string `json:"roomID"`
}

type EditRoomMessagePayload struct {
	Message *RoomMessage `json:"message"`
}

// Paginated list of channels a user is an editor for.
type EditableChannelConnection struct {
	// The elements of the list.
	Edges []*EditableChannelEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Points to a editable channel with the editor.
type EditableChannelEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// The user whose channel has the editor.
	Node *User `json:"node"`
}

// Paginated list of editors of a channel.
type EditorConnection struct {
	// The elements of the list.
	Edges []*EditorEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Points to a user with the editor status, with metadata regarding the relationship.
type EditorEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// Timestamp of when the editor status was granted.
	GrantedAt time.Time `json:"grantedAt"`
	// The user who has the editor status.
	Node *User `json:"node"`
}

// The list of payment methods that are supported for web checkout for a user.
type EligiblePaymentMethod struct {
	// Availability status of the underlying payment gateway.
	AvailabilityStatus PaymentMethodAvailabilityStatus `json:"availabilityStatus"`
	// Name of the payment method.
	Name EligiblePaymentMethodName `json:"name"`
}

// EmbeddedEmote is an encoding format used to describe an emote embedded in a string of text.
//
// Example:
//   body = "hey KappaHD"
//   from = 4
//   to = 10
//
//   "KappaHD" will be replaced with the KappaHD emote image.
type EmbeddedEmote struct {
	// The emote's identifier, for example "115847" -> KappaHD.
	EmoteID *string `json:"emoteID"`
	// from is the index of the string where replacement starts.
	From *int    `json:"from"`
	ID   *string `json:"id"`
	// setID is the identifier of the set this emote is in.
	SetID *string `json:"setID"`
	// to is the index of the string where replacement ends.
	To *int `json:"to"`
}

// EmitCampaignDiscoveryEventInput contains the campaign objective type of the event being emitted
// and the channelID from which this event is born.
type EmitCampaignDiscoveryEventInput struct {
	// The channelID from the channel this event is taking place on.
	ChannelID string `json:"channelID"`
	// The campaign objective type of the event.
	DiscoveryType CampaignDiscoveryEventType `json:"discoveryType"`
}

// EmitCampaignDiscoveryEventPayload is the success response for emitting a campaign discovery event.
type EmitCampaignDiscoveryEventPayload struct {
	// Whether the call succeeded or not.
	IsSuccess bool `json:"isSuccess"`
}

type Emote struct {
	// The type of image asset of the emote (static, animated, etc.).
	AssetType *EmoteAssetType `json:"assetType"`
	// The Bits Badge Tier metadata associated with this Bits Badge Tier Emote. Nil for other emote types.
	BitsBadgeTierSummary *EmoteBitsBadgeTierSummary `json:"bitsBadgeTierSummary"`
	// The timestamp at which this emote was created.
	CreatedAt *time.Time `json:"createdAt"`
	// The emote's identifier.
	// For example, "115847".
	ID *string `json:"id"`
	// The list of modifiers a user is entitled to use for an emote.
	Modifiers []*EmoteModifier `json:"modifiers"`
	// A priority order for displaying this emote among others in the same group.
	Order *int `json:"order"`
	// The user who owns the subscription product that this emote belongs to.
	Owner *User `json:"owner"`
	// Identifies which set this emote belongs to.
	SetID *string `json:"setID"`
	// The state of an emote. Can be either active or pending.
	State EmoteState `json:"state"`
	// The subscription product this emote belongs to. Nil for globals.
	SubscriptionProduct *SubscriptionProduct `json:"subscriptionProduct"`
	// The subscription info for this emote (if the emote is obtainable via subscription).
	SubscriptionSummaries []*SubscriptionSummary `json:"subscriptionSummaries"`
	// For subscription and bits badge tier emotes, this is the user generated suffix.
	// For example, for "lirikLUL" suffix would be "LUL".
	Suffix *string `json:"suffix"`
	// The visual representation of the emote.
	// For example, "O_o" instead of "(O|o)_(o|O)".
	Text *string `json:"text"`
	// The text token of the emote.
	// For example, "KappaHD".
	Token *string `json:"token"`
	// The type of emote that this is.
	// For example, a global emote, a turbo emote, a prime emote, a sub emote, etc.
	Type *EmoteType `json:"type"`
}

func (Emote) IsFragmentContent() {}

// Bits Badges Tier metadata for emotes.
type EmoteBitsBadgeTierSummary struct {
	// The Bits Badge Tier Summary data that is user-dependent.
	Self *EmoteBitsBadgeTierSummarySelfEdge `json:"self"`
	// The amount of bits any user must cheer to achieve this tier.
	Threshold int `json:"threshold"`
}

// The Bits Badge Tier Summary data that is user-dependent.
type EmoteBitsBadgeTierSummarySelfEdge struct {
	// Is true if the user has unlocked this emote.
	IsUnlocked bool `json:"isUnlocked"`
	// The number of bits that this user must use in order to unlock this emote. 0 if already unlocked.
	NumberOfBitsUntilUnlock int `json:"numberOfBitsUntilUnlock"`
}

// The ID, Size and AssetType of a previously uploaded subscription emote.
type EmoteImageAssetInput struct {
	// The asset type of the image.
	AssetType EmoteAssetType `json:"assetType"`
	// Image ID generated by Mako for image.
	ID string `json:"id"`
	// Size of the image.
	Size EmoteImageSize `json:"size"`
}

// Represents the data needed to continue the upload of an emoticon image asset.
type EmoteImageUploadConfiguration struct {
	// The id used by upload service to publish updates via pubsub about the uploaded image.
	UploadID *string `json:"uploadID"`
	// The url in s3 for where the front-end should post the image asset.
	UploadURL *string `json:"uploadURL"`
}

// The name of an emote modifier and it's abbreviated code.
type EmoteModifier struct {
	// The code to use the emote modifier in chat.
	Code string `json:"code"`
	// The name of the emote modifier.
	Name PermanentEmoteModifier `json:"name"`
}

// A set of modifications to apply to a tier of emotes for a creator.
type EmoteModifierGroupInput struct {
	// The modifiers to set.
	Modifiers []PermanentEmoteModifier `json:"modifiers"`
	// The ID of the product to set the modifiers for.
	ProductID string `json:"productID"`
}

// A set of modifiers that have been set on a tier of emotes for a creator.
type EmoteModifierGroupPayload struct {
	// The modifiers that were set.
	Modifiers []PermanentEmoteModifier `json:"modifiers"`
	// The product the modifiers were set for.
	Product *SubscriptionProduct `json:"product"`
}

// The new order for the specified emote in a particular emote group.
type EmoteOrder struct {
	// The ID of this emote.
	EmoteID string `json:"emoteID"`
	// The ID of the group we are setting this emote's order in. When emotes can exist in multiple groups they may have different
	// order values in each group (as the other emotes in each group will be different) so we must specify which group we are operating on.
	GroupID string `json:"groupID"`
	// The new order value for this emote.
	Order int `json:"order"`
}

// Represents a group of emotes.
type EmoteSet struct {
	// The list of emotes which belong to this set.
	Emotes []*Emote `json:"emotes"`
	// The emote set's identifier.
	ID *string `json:"id"`
	// The channel associated with the emote set. Nil for emote sets not associated
	// with an owner (prime, fuel, rewards, etc.).
	Owner *User `json:"owner"`
}

// Represents an emote that is currently in the process of being uploaded.
type EmoteUploadConfiguration struct {
	// The relevant metadata for the 1X image asset.
	ImageUploadConfig1x *EmoteImageUploadConfiguration `json:"imageUploadConfig1X"`
	// The relevant metadata for the 2X image asset.
	ImageUploadConfig2x *EmoteImageUploadConfiguration `json:"imageUploadConfig2X"`
	// The relevant metadata for the 4X image asset.
	ImageUploadConfig4x *EmoteImageUploadConfiguration `json:"imageUploadConfig4X"`
}

// Channels have emoticon prefixes.
type EmoticonPrefix struct {
	// If the prefix can be edited or not.
	IsEditable bool `json:"isEditable"`
	// Name of the prefix.
	Name string `json:"name"`
	// If the prefix has been approved or not.
	State EmoticonPrefixState `json:"state"`
}

// The required input for an EndUseBitsInExtension mutation.
type EndUseBitsInExtensionInput struct {
	// The transaction ID of this bits spend event.
	TransactionID string `json:"transactionID"`
}

// The result of a EndUseBitsInExtension mutation.
type EndUseBitsInExtensionPayload struct {
	// The user's new bits balance.
	Balance *int `json:"balance"`
}

// Paginated list of endorsed channels using the Relay cursor specification.
type EndorsedChannelConnection struct {
	// The endorsed channels.
	Edges []*EndorsedChannelEdge `json:"edges"`
	// Pagination information for this connection.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Element in a list of endorsed channels.
type EndorsedChannelEdge struct {
	// Cursor identifying the position of this edge for future queries.
	Cursor string `json:"cursor"`
	// The information about the endorsed channel.
	Node *Channel `json:"node"`
	// Unique id per channel item, used by the client to attribute display/clicks of items.
	TrackingID string `json:"trackingID"`
}

// EnhancedExperiencesClient is an OAuth app that is authorized to use
// the Enhanced Experiences (E2) API for game integrations.
type EnhancedExperiencesClient struct {
	// The client ID of the OAuth app.
	ID string `json:"id"`
	// The name of the client.
	Name string `json:"name"`
	// The timestamp when the the client was onboarded to the Enhanced Experiences (E2) API.
	OnboardedAt *time.Time `json:"onboardedAt"`
}

// Episode metadata.
type EpisodeDetails struct {
	// Total length of the content.
	DurationSeconds *int `json:"durationSeconds"`
	// The episode number.
	Episode *int `json:"episode"`
	// The season number.
	Season *int `json:"season"`
	// The name of the series.
	Series *string `json:"series"`
}

func (EpisodeDetails) IsWatchPartyItemDetails() {}

// Drop triggered by an in-game event.
type EventBasedDrop struct {
	// The rewards for this drop and how often those rewards can be awarded.
	BenefitEdges []*DropBenefitEdge `json:"benefitEdges"`
	// The campaign this drop belongs to.
	Campaign *DropCampaign `json:"campaign"`
	// Amount of time the viewer has to claim the drop after the rule is completed.
	ClaimDurationSeconds int `json:"claimDurationSeconds"`
	// The event conditions which must be met for this drop to be earned.
	Conditions []*DropEventCondition `json:"conditions"`
	// The time this drop becomes unavailable.
	EndAt time.Time `json:"endAt"`
	// A unique identifier.
	ID string `json:"id"`
	// Describes how the event will be accomplished.
	MissionDescription string `json:"missionDescription"`
	// Name of the mission a streamer has to achieve.
	MissionName string `json:"missionName"`
	// The name of this drop.
	Name string `json:"name"`
	// The time this drop becomes available.
	StartAt time.Time `json:"startAt"`
}

func (EventBasedDrop) IsDropType() {}

// Settings for a given event.
type EventNotificationSetting struct {
	// The setting category.
	Category string `json:"category"`
	// Settings for individual platforms.
	Platforms []*PlatformEventSetting `json:"platforms"`
}

// Experimental properties that should NOT be used outside of experiments.
// When your property is no longer in use, please mark as deprecated and then formally delete it.
type Experiment struct {
	// The selected promoted Stream for placement experiments.
	PromotedStream *Stream `json:"promotedStream"`
}

// Data about an inactive subscription to a broadcaster.
type ExpiredSubscription struct {
	// The channel that the expired subscription belongs to.
	ChannelOwner *User `json:"channelOwner"`
	// The unique identifier.
	ID string `json:"id"`
	// Resolves the product that the expired subscription is to.
	Product *SubscriptionProduct `json:"product"`
	// The total tenure of a user to a broadcaster.
	Tenure *SubscriptionTenure `json:"tenure"`
}

// A paginated list of expired subscriptions.
type ExpiredSubscriptionConnection struct {
	// The list of expired subscriptions.
	Edges []*ExpiredSubscriptionEdge `json:"edges"`
	// Information about this page of expired subs.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An element in a paginated list of expired subscriptions.
type ExpiredSubscriptionEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// The element node.
	Node *ExpiredSubscription `json:"node"`
}

// Twitch Extension.
type Extension struct {
	// The anchor point the extension expects to render into on the client.
	Anchor ExtensionAnchor `json:"anchor"`
	// A list of assets which the extension must have uploaded to the Twitch Extensions CDN.
	AssetURLs []string `json:"assetURLs"`
	// The author of the extension as specified by the developer's extension manifest.
	AuthorName string `json:"authorName"`
	// The bits support level required by the broadcaster for the extension to operate.
	BitsSupportLevel ExtensionBitsSupportLevel `json:"bitsSupportLevel"`
	// The list of categories that the developer has set for the extension.
	Categories []*ExtensionCategory `json:"categories"`
	// A single challenge condition associated with the specified extension.
	ChallengeCondition *ChallengeCondition `json:"challengeCondition"`
	// The list of challenge condition participants that are associated with this extension for a particular condition participant owner and condition owner.
	ChallengeConditionParticipants *ExtensionChallengeConditionParticipantConnection `json:"challengeConditionParticipants"`
	// The list of challenge conditions that are associated with this extension.
	ChallengeConditions *ExtensionChallengeConditionConnection `json:"challengeConditions"`
	// The client ID of the extension. Also used as the non-composite, non-unique ID of an extension internally.
	ClientID string `json:"clientID"`
	// The URL which is used to preset the configuration experience of the extension.
	ConfigURL string `json:"configURL"`
	// The list of games that an extension is content-matched to. This list is managed internally by Twitch.
	ContentMatchedGames []*Game `json:"contentMatchedGames"`
	// The description of the extension specified by the developer's extension manifest
	// (max-length: 1024 characters).
	Description string `json:"description"`
	// The list of games that an extension is associated to. This list is managed by the extension developer.
	Games []*Game `json:"games"`
	// Whether the extension developer has turned on chat support for this extension.
	HasChatSupport bool `json:"hasChatSupport"`
	// Represents whether or not the developer of the extension would like to provide users with
	// the ability to link their identity with the extension.
	HasIdentityLinking bool `json:"hasIdentityLinking"`
	// The extension icon URLs used to visually represent the extension.
	IconURLs *ExtensionIcons `json:"iconURLs"`
	// The extension ID which is a composite form of <clientID>:<version>.
	ID string `json:"id"`
	// Represents whether or not the extension supports bits monetization.
	IsBitsEnabled bool `json:"isBitsEnabled"`
	// The URL which is used to preset the live-dashboard experience of the extension.
	LiveConfigURL string `json:"liveConfigURL"`
	// The name of the extension specified by the developer's extension manifest
	// (max-length: 40 characters).
	Name string `json:"name"`
	// The panel height specified by the developer's extension manifest -or- 300.
	PanelHeight int `json:"panelHeight"`
	// The link to the extension's privacy policy as specified by the developer's extension manifest.
	PrivacyPolicyURL string `json:"privacyPolicyURL"`
	// Screenshots of the URL used to showcase the extension on extension details pages.
	ScreenshotURLs []string `json:"screenshotURLs"`
	// Represents whether the requesting user is able to install the extension.
	Self *ExtensionSelfConnection `json:"self"`
	// The sku of the extension for monetizable extensions.
	Sku string `json:"sku"`
	// The current state of the extension in our approval process.
	State ExtensionState `json:"state"`
	// The subscription support level required by the broadcaster for the extension to operate.
	SubscriptionsSupportLevel ExtensionSubscriptionsSupportLevel `json:"subscriptionsSupportLevel"`
	// The summary of the extension specified by the developer's extension manifest
	// (max-length: 140 characters).
	Summary string `json:"summary"`
	// The support contact email as specified by the developer's extension manifest.
	SupportEmail string `json:"supportEmail"`
	// End-user license agreement terms of service URL.
	TermsURL string `json:"termsURL"`
	// The vendor code of the extension for monetizable extensions.
	VendorCode string `json:"vendorCode"`
	// The current version of the extension specified by the developer's extension manifest.
	Version string `json:"version"`
	// The URL which is used to preset the viewer experience of the extension.
	ViewerURL string `json:"viewerURL"`
	// The UI configurations of each supported view of the extension.
	Views *ExtensionViews `json:"views"`
	// The list of URLs an extension can link to while loaded in the configuration experience.
	WhitelistedConfigURLs []string `json:"whitelistedConfigURLs"`
	// The list of URLs a panel extension can link to while loaded in the viewer experience.
	WhitelistedPanelURLs []string `json:"whitelistedPanelURLs"`
}

// The current activation configuration for an installed extension.
type ExtensionActivationConfig struct {
	// The anchor that the installation has been activated into. If not activated into a slot,
	// the value will be null.
	Anchor *ExtensionAnchor `json:"anchor"`
	// The slot that the installation has been activated into. If not activated into a slot,
	// the value will be null.
	Slot *string `json:"slot"`
	// The activation state of the extension installation.
	State ActivationState `json:"state"`
	// The horizontal positioning of the left side of the component extension from the left side
	// of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
	X *int `json:"x"`
	// The vertical positioning of the top side of the component extension from the top side
	// of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
	Y *int `json:"y"`
}

// Represents the action which should be taken on the provided installation ID. If no
// anchor configuration is provided, the installation will be deactivated.
type ExtensionActivationInput struct {
	// The required activation input to apply activation state to a component anchor.
	Component *ComponentActivationInput `json:"component"`
	// The installation ID of the component extension you're attempting to activate.
	InstallationID string `json:"installationID"`
	// The required activation input to apply activation state to a panel anchor.
	Panel *PanelActivationInput `json:"panel"`
	// The required activation input to apply activation state to a video overyla anchor.
	VideoOverlay *VideoOverlayActivationInput `json:"videoOverlay"`
}

// ExtensionAssetManifest is data related to the assets of an extension.
type ExtensionAssetManifest struct {
	// Hash of the asset zip file.
	AssetHash string `json:"assetHash"`
	// Base URI used for extensions out of local test.
	BaseURI *string `json:"baseURI"`
	// The name of the file that was uploaded.
	FileName *string `json:"fileName"`
	// The size of the file that was uploaded.
	FileSize *string `json:"fileSize"`
	// The time that the assets were uploaded.
	UploadedAt *time.Time `json:"uploadedAt"`
	// The user that uploaded the assets.
	Uploader *User `json:"uploader"`
}

// ExtensionAssetManifestInput is data related to the assets of an extension.
type ExtensionAssetManifestInput struct {
	// Hash of the asset zip file.
	AssetHash string `json:"assetHash"`
}

// ExtensionCapabilities contains data about what an Extension can do, in general, and at the time of interaction.
type ExtensionCapabilities struct {
	// The bit support level required by the broadcaster for the extension to operate. Defaults to "NONE".
	BitsSupportLevel ExtensionBitsSupportLevel `json:"bitsSupportLevel"`
	// Location of configuration.
	ConfigurationLocation ExtensionConfigurationLocation `json:"configurationLocation"`
	// Does this extension use bits.
	HasBitsSupport bool `json:"hasBitsSupport"`
	// Does this extension support chat.
	HasChatSupport bool `json:"hasChatSupport"`
	// Required configuration string.
	RequiredConfiguration string `json:"requiredConfiguration"`
	// The subscription support level required by the broadcaster for the extension to operate. Defaults to "NONE".
	SubscriptionsSupportLevel ExtensionSubscriptionsSupportLevel `json:"subscriptionsSupportLevel"`
	// Whitelists for restricting extension access and behavior.
	Whitelists *ExtensionWhitelists `json:"whitelists"`
	// Will this extension request an identity link.
	WillRequestIdentityLink bool `json:"willRequestIdentityLink"`
}

// ExtensionCapabilitiesInput contains data about what an Extension can do, in general, and at the time of interaction.
type ExtensionCapabilitiesInput struct {
	// The bits support level required by the broadcaster for the extension to operate. Defaults to "NONE".
	BitsSupportLevel *ExtensionBitsSupportLevel `json:"bitsSupportLevel"`
	// Location of configuration.
	ConfigurationLocation ExtensionConfigurationLocation `json:"configurationLocation"`
	// Does this extension use bits.
	HasBitsSupport bool `json:"hasBitsSupport"`
	// Does this extension support chat.
	HasChatSupport bool `json:"hasChatSupport"`
	// Required configuration string.
	RequiredConfiguration string `json:"requiredConfiguration"`
	// The subscription support level required by the broadcaster for the extension to operate. Defaults to "NONE".
	SubscriptionsSupportLevel *ExtensionSubscriptionsSupportLevel `json:"subscriptionsSupportLevel"`
	// Whitelists for restricting extension access and behavior.
	Whitelists *ExtensionWhitelistsInput `json:"whitelists"`
	// Will this extension request an identity link.
	WillRequestIdentityLink bool `json:"willRequestIdentityLink"`
}

// An extension carousel.
type ExtensionCarousel struct {
	// List of entries associated with the carousel.
	Entries []*ExtensionCarouselEntry `json:"entries"`
	// Unique ID of the carousel.
	ID string `json:"id"`
}

// An extension carousel entry.
type ExtensionCarouselEntry struct {
	// URL the user is directed to when clicking the carousel entry.
	ClickThroughURL string `json:"clickThroughURL"`
	// Unique ID of the entry.
	ID string `json:"id"`
	// URL of the image to display for the carousel entry.
	ImageURL string `json:"imageURL"`
	// Text associated with the carousel entry.
	Title string `json:"title"`
}

// An extension category.
type ExtensionCategory struct {
	// Description for what kind of extensions this category represents.
	Description string `json:"description"`
	// The paginated list of extensions in the category.
	Extensions *ExtensionConnection `json:"extensions"`
	// The category ID which is uniquely generated.
	ID string `json:"id"`
	// Boolean value representing whether a category has been deleted.
	IsDeleted bool `json:"isDeleted"`
	// Denotes that no updates can be made to the category and no extensions can be added to it.
	IsReadOnly bool `json:"isReadOnly"`
	// Boolean value representing whether this category should be hidden from listings.
	IsVisible bool `json:"isVisible"`
	// Human readable name for the Category.
	Name string `json:"name"`
	// Display order for this category. Categories are returned in ascending order.
	Order float64 `json:"order"`
	// The URL-safe slug for the category. This slug may be used as the identifier to retrieve
	// categories from the root Query.
	Slug *string `json:"slug"`
	// Enumerated value specifying how this category's content should be ordered. Popularity, manual, etc.
	SortKey ExtensionCategorySortKey `json:"sortKey"`
	// Category Type which can be curated or developer.
	Type ExtensionCategoryType `json:"type"`
}

// A paginated list of extension categories, and their metadata.
type ExtensionCategoryConnection struct {
	// The list of extension categories in this page.
	Edges []*ExtensionCategoryEdge `json:"edges"`
	// Information about this page of extension categories.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of extension categories.
	TotalCount int `json:"totalCount"`
}

// An element in a paginated list of extension categories and its metadata.
type ExtensionCategoryEdge struct {
	// Cursor represents the position of the current edge/node.
	Cursor string `json:"cursor"`
	// Node represents the extension category for the current edge.
	Node *ExtensionCategory `json:"node"`
}

// Parameters for filtering ChallengeConditionParticipants.
type ExtensionChallengeConditionByIDInput struct {
	// The ID of the condition for the specified owner.
	ConditionID string `json:"conditionID"`
	// TUID of condition participant's associated condition's owner.
	ConditionOwnerID string `json:"conditionOwnerID"`
}

// A paginated list of extension challenge conditions.
type ExtensionChallengeConditionConnection struct {
	// The elements of the paginated list.
	Edges []*ExtensionChallengeConditionEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An element in a paginated list of extension challenge conditions.
type ExtensionChallengeConditionEdge struct {
	// An opaque cursor identifying the edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// The element node.
	Node *ChallengeCondition `json:"node"`
}

// A paginated list of extension challenge conditionParticipants.
type ExtensionChallengeConditionParticipantConnection struct {
	// The elements of the paginated list.
	Edges []*ExtensionChallengeConditionParticipantEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An element in a paginated list of extension challenge conditionParticipants.
type ExtensionChallengeConditionParticipantEdge struct {
	// An opaque cursor identifying the edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// The element node.
	Node *ChallengeConditionParticipant `json:"node"`
}

// Parameters for filtering ChallengeConditionParticipants.
type ExtensionChallengeConditionParticipantsInput struct {
	// TUID of condition participant's associated condition's owner.
	ConditionOwnerID string `json:"conditionOwnerID"`
	// TUID of condition participant owner.
	ConditionParticipantOwnerID string `json:"conditionParticipantOwnerID"`
	// Filter condition participants with this state.
	EndState ChallengeConditionParticipantEndState `json:"endState"`
}

// Parameters for filtering ChallengeConditions.
type ExtensionChallengeConditionsInput struct {
	// TUID of condition owner. This will typically be the broadcaster's user ID.
	ConditionOwnerID string `json:"conditionOwnerID"`
	// Filter conditions with this state.
	State ChallengeConditionState `json:"state"`
}

// ExtensionClient is the authorization component of an extension.
type ExtensionClient struct {
	// A organization member assigned as a billing manager for this extension. Null when extension is not an organization or the extension is not monetized.
	AssignedBillingManager *OrganizationMember `json:"assignedBillingManager"`
	// CreatedAt is the timestamp at which this client was created.
	CreatedAt time.Time `json:"createdAt"`
	// ID is the OAuth ID representing the extension.
	ID string `json:"id"`
	// Name is the name of the extension.
	Name string `json:"name"`
	// Organization is the Organization entity of the extension, it means which organization the extension belongs to.
	Organization *Organization `json:"organization"`
	// RedirectURI is the URI used for client redirect on OAuth login.
	RedirectURI string `json:"redirectURI"`
}

func (ExtensionClient) IsPredictionEventActor() {}

// A paginated list of extension clients.
type ExtensionClientConnection struct {
	// The list of extension clients in this page.
	Edges []*ExtensionClientEdge `json:"edges"`
	// Information about this page of extension clients.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An element in a paginated list of extension clients.
type ExtensionClientEdge struct {
	// Cursor represents the position of the current edge/node.
	Cursor string `json:"cursor"`
	// Node represents the extension client for the current edge.
	Node *ExtensionClient `json:"node"`
}

// ExtensionComment contains the data for the comment of an extension review.
type ExtensionComment struct {
	// The review comment text provided by the user.
	Content string `json:"content"`
	// The ID of the recorded comment.
	ID string `json:"id"`
}

// The hosted configuration for an extension that comes from config service.
type ExtensionConfiguration struct {
	// The broadcaster-set, per-channel segment of the extension configuration.
	Broadcaster *ExtensionConfigurationRecord `json:"broadcaster"`
	// The developer-set, per-channel segment of the extension configuration.
	Developer *ExtensionConfigurationRecord `json:"developer"`
	// The id of the extension that this configuration document belongs to.
	ExtensionID string `json:"extensionID"`
	// The developer-set segment of the extension configuration that affects all
	// installs of the extension.
	Global *ExtensionConfigurationRecord `json:"global"`
}

// A single segment from the extensions configuration service.
type ExtensionConfigurationRecord struct {
	// The content of the configuration segment.
	Content string `json:"content"`
	// The version of the configuration segment.
	Version string `json:"version"`
}

// A paginated list of extensions, and its metadata.
type ExtensionConnection struct {
	// The list of extensions in this page.
	Edges []*ExtensionEdge `json:"edges"`
	// Information about this page of extensions.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of extensions in the larger collection.
	TotalCount int `json:"totalCount"`
}

// ExtensionDeveloperManifest is the developer specific extension data.
type ExtensionDeveloperManifest struct {
	// Author email.
	AuthorEmail string `json:"authorEmail"`
	// Time when an extension was created.
	CreatedAt string `json:"createdAt"`
	// Time when an extensions version was last transitioned.
	LastTransitionedAt *time.Time `json:"lastTransitionedAt"`
	// Testing uri for extension development.
	TestingBaseURI string `json:"testingBaseURI"`
	// Current state of this version in the development timeline.
	VersionState ExtensionState `json:"versionState"`
}

// ExtensionDeveloperManifestInput is the developer specific extension data.
type ExtensionDeveloperManifestInput struct {
	// Author email.
	AuthorEmail string `json:"authorEmail"`
	// Testing uri for extension development.
	TestingBaseURI string `json:"testingBaseURI"`
}

// Extension metadata used for discovery.
type ExtensionDiscoveryManifest struct {
	// Name of the extension author.
	AuthorName string `json:"authorName"`
	// Extension categories.
	Categories []*ExtensionCategory `json:"categories"`
	// Games that an extension is content-matched to. This list is managed internally by Twitch.
	ContentMatchedGames []*Game `json:"contentMatchedGames"`
	// Extension descriprion. 1024 character limit.
	Description string `json:"description"`
	// Games that an extension is associated to. This list is managed by the extension developer.
	Games []*Game `json:"games"`
	// Icon urls for extensions.
	IconURLs *ExtensionIcons `json:"iconURLs"`
	// name of the extension.
	Name string `json:"name"`
	// Url to an extensions privacy policy.
	PrivacyPolicyURL string `json:"privacyPolicyURL"`
	// Extension screenshot urls.
	ScreenshotURLs []string `json:"screenshotURLs"`
	// Extension summary. 140 character limit.
	Summary string `json:"summary"`
	// Extension developers support email.
	SupportEmail string `json:"supportEmail"`
	// Extension eula/tos url.
	TermsURL string `json:"termsURL"`
	// Extension viewer summary.
	ViewerSummary string `json:"viewerSummary"`
}

// Extension metadata used for discovery.
type ExtensionDiscoveryManifestInput struct {
	// Name of the extension author.
	AuthorName string `json:"authorName"`
	// Extension categories.
	Categories []string `json:"categories"`
	// Extension descriprion. 1024 character limit.
	Description string `json:"description"`
	// games an extension is associated with.
	Games []string `json:"games"`
	// name of the extension.
	Name string `json:"name"`
	// Url to an extensions privacy policy.
	PrivacyPolicyURL string `json:"privacyPolicyURL"`
	// Extension summary. 140 character limit.
	Summary string `json:"summary"`
	// Extension developers support email.
	SupportEmail string `json:"supportEmail"`
	// Extension eula/tos url.
	TermsURL string `json:"termsURL"`
	// A summary of the extension's functionality from a viewer's perspective.
	ViewerSummary *string `json:"viewerSummary"`
}

// ExtensionDynamicManagementInput represents the game ID and whether it is dynamically managed or not on an extension.
type ExtensionDynamicManagementInput struct {
	// The discovery game ID.
	GameID string `json:"gameID"`
	// If the game has been marked as dynamically managed or not.
	IsManaged bool `json:"isManaged"`
}

// An element in a paginated extensions of videos, and its metadata.
type ExtensionEdge struct {
	// Cursor represents the position of the current edge/node.
	Cursor string `json:"cursor"`
	// Node represents the extension for the current edge.
	Node *Extension `json:"node"`
}

// The complete set of potential icons provided by a developer to represent their Extension on the site.
type ExtensionIcons struct {
	// 300x200 splash image used in extension discovery & management.
	DiscoverySplash string `json:"discoverySplash"`
	// Square 100x100 icon used in extension discovery & management.
	Square100 string `json:"square100"`
	// Square 24x24 icon used in video player taskbar.
	Square24 string `json:"square24"`
}

// Url and UploadId provided by Upload Service.
type ExtensionImageUploadResponse struct {
	// Upload ID.
	UploadID string `json:"uploadID"`
	// Upload URL.
	URL string `json:"url"`
}

// Extension Installation are models which contain an Extension and it's associated installation metadata.
type ExtensionInstallation struct {
	// The abilities this extension can use for the channel it is installed on.
	Abilities *ExtensionInstallationAbilities `json:"abilities"`
	// The current activation metadata for the extension.
	ActivationConfig *ExtensionActivationConfig `json:"activationConfig"`
	// The extension which the installation record is for.
	Extension *Extension `json:"extension"`
	// The the composite extension installation ID in the form of <clientID>:<version>:<channelID>.
	ID string `json:"id"`
	// The installer's decision whether to allow an extension to use a particular feature.
	PermittedFeatures *ExtensionInstallationFeatureFlags `json:"permittedFeatures"`
	// The required, if any, for the installed extension after an activation.
	RequiredActions []*ExtensionRequiredAction `json:"requiredActions"`
	// The self connection of the extension installation.
	Self *ExtensionInstallationSelfConnection `json:"self"`
}

// The set of abilities an extension is authorized to use.
type ExtensionInstallationAbilities struct {
	// Whether the extension can use bits in the current context.
	IsBitsEnabled bool `json:"isBitsEnabled"`
	// Whether the extension can send chat messages in the current context.
	IsChatEnabled bool `json:"isChatEnabled"`
	// Whether the extension has access to subscription status in the current context.
	IsSubscriptionStatusAvailable bool `json:"isSubscriptionStatusAvailable"`
}

// The dynamic management setting for a content-matched game on an extension installation.
type ExtensionInstallationDynamicManagement struct {
	// The game that the setting is for.
	Game *Game `json:"game"`
	// Whether or not dynamic management is turned on for this extensions.
	IsManaged bool `json:"isManaged"`
}

// The set of extension features an installer can opt in or out of.
type ExtensionInstallationFeatureFlags struct {
	// Whether the installer has granted the extension access to their subscriptions list.
	CanRetrieveSubscriptionStatus bool `json:"canRetrieveSubscriptionStatus"`
	// Whether the installer has opted in or out of chat capabilities in extensions.
	CanSendChat bool `json:"canSendChat"`
	// Whether the installer has opted in or out of bit capabilities in extensions.
	CanUseBits bool `json:"canUseBits"`
	// The dynamic management settings for the extension installation.
	DynamicManagement []*ExtensionInstallationDynamicManagement `json:"dynamicManagement"`
}

// The connection a user has to an Installed Extension.
type ExtensionInstallationSelfConnection struct {
	// Represents whether the requesting user can activate the extension.
	CanActivate bool `json:"canActivate"`
}

// The data that links the active user with a particular extension
// installation on a channel.
type ExtensionInstallationSelfEdge struct {
	// The extension installation.
	Installation *ExtensionInstallation `json:"installation"`
	// Authentication information that links the active user and the installation.
	Token *ExtensionToken `json:"token"`
	// Configurations set for this extension/user pair.
	Configuration *ExtensionConfiguration `json:"configuration"`
	// The time this response was issuedAt, so the client can set a timer for when
	// the token needs to be refreshed.
	IssuedAt *time.Time `json:"issuedAt"`
}

// Extension Link User Error.
type ExtensionLinkUserError struct {
	// The error code.
	Code *ExtensionLinkUserErrorCode `json:"code"`
}

// The required input for an ExtensionLinkUser mutation.
type ExtensionLinkUserInput struct {
	// The id of the channel the extension is currently installed on.
	ChannelID string `json:"channelID"`
	// The ID of the extension that the user would like to link/unlink with.
	ExtensionID string `json:"extensionID"`
	// The current extension jwt for the user being linked/unlinked.
	Jwt *string `json:"jwt"`
	// Whether to link or unlink the user from this extension.
	ShowUser bool `json:"showUser"`
}

// The result of a ExtensionLinkUser mutation.
type ExtensionLinkUserPayload struct {
	// Error from an Extension Link User Call.
	Error *ExtensionLinkUserError `json:"error"`
	// The user's new token reflecting their now linked/unlinked status.
	Token *ExtensionToken `json:"token"`
}

// ExtensionManifest is the data that represents an entire extension manfiest.
type ExtensionManifest struct {
	// ExtensionAssetManifest is data related to the assets of an extension.
	AssetManifest *ExtensionAssetManifest `json:"assetManifest"`
	// Data about what an Extension can do, in general, and at the time of interaction.
	Capabilities *ExtensionCapabilities `json:"capabilities"`
	// ExtensionDeveloperManifest is the developer specific extension data.
	DeveloperManifest *ExtensionDeveloperManifest `json:"developerManifest"`
	// Extension metadata used for discovery.
	DiscoveryManifest *ExtensionDiscoveryManifest `json:"discoveryManifest"`
	// Extension id.
	ID string `json:"id"`
	// Extension version.
	Version string `json:"version"`
	// Extension views.
	Views *ExtensionViews `json:"views"`
}

// A paginated list of extension manifests.
type ExtensionManifestConnection struct {
	// The list of extension manifests in this page.
	Edges []*ExtensionManifestEdge `json:"edges"`
	// Information about this page of extension manifests.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An element in a paginated list of extension manifests.
type ExtensionManifestEdge struct {
	// Cursor represents the position of the current edge/node.
	Cursor string `json:"cursor"`
	// Node represents the extension manifest for the current edge.
	Node *ExtensionManifest `json:"node"`
}

// A summary of extension state and the associated manifests.
type ExtensionManifestsSummary struct {
	// The global deleted state of the extension.
	IsDeleted bool `json:"isDeleted"`
	// The list of extension manifests.
	Manifests *ExtensionManifestConnection `json:"manifests"`
}

// ExtensionPanel is a placeholder in the panel list for arbitrary iframed content.
type ExtensionPanel struct {
	// id is a unique identifier for the panel.
	ID string `json:"id"`
	// slotID is an identifier to map extensions content from `User.extensions` to the proper place in the `User.panels` list.
	SlotID string `json:"slotID"`
	// type is `PanelType.EXTENSION`.
	Type PanelType `json:"type"`
}

func (ExtensionPanel) IsPanel() {}

// ExtensionRating contains the information of a user's rating of a Twitch extension.
type ExtensionRating struct {
	// The ID of the recorded rating.
	ID string `json:"id"`
	// Whether the user recommended the extension or not.
	IsRecommended bool `json:"isRecommended"`
	// Where the user submitted the rating.
	Location ExtensionRatingLocation `json:"location"`
}

// A holder for the presigned S3 URL for an extension ratings report.
type ExtensionRatingsCSVReportPresignedURL struct {
	// The presigned URL, if one is ready.  Otherwise empty string.
	PresignedURL *string `json:"presignedURL"`
}

// Extension recommendation.
type ExtensionRecommendation struct {
	// The recommended extension.
	Extension *Extension `json:"extension"`
}

// The action a user must take to complete an activation of an extension installation.
type ExtensionRequiredAction struct {
	// On PROMPT_FOR_PERMISSIONS the redirectURI to load for OAuth.
	RedirectURI *string `json:"redirectURI"`
	// The action the user must take in order to complete the activation.
	Type ExtensionRequiredActionType `json:"type"`
}

// The shared secret between the extension and the extension validator service.
type ExtensionSecret struct {
	// When the secret was activated.
	ActiveAt time.Time `json:"activeAt"`
	// The actual content of the secret.
	Content string `json:"content"`
	// When the secret expires.
	ExpiresAt time.Time `json:"expiresAt"`
}

// The extensions secrets information.
type ExtensionSecretsInfo struct {
	// A user-friendly error, should one occur.
	Error *GetExtensionSecretsError `json:"error"`
	// A list of secrets.
	Secrets []*ExtensionSecret `json:"secrets"`
}

// The connection a user has to an Extension object.
type ExtensionSelfConnection struct {
	// Represents whether the requesting user is able to install extensions.
	CanInstall bool `json:"canInstall"`
}

// The user-specific token for an installed extension on a channel.
type ExtensionToken struct {
	// The ID of the extension associated with this token.
	ExtensionID string `json:"extensionID"`
	// The JWT token for the requesting user.
	Jwt string `json:"jwt"`
}

// ExtensionVersionDiscoveryManifest is the data that represents an extension discovery manifest.
type ExtensionVersionDiscoveryManifest struct {
	// Extension metadata used for discovery.
	DiscoveryManifest *ExtensionDiscoveryManifest `json:"discoveryManifest"`
	// Extension id.
	ID string `json:"id"`
	// Extension version.
	Version string `json:"version"`
}

// The potential anchor-specific configurations and extension can have.
type ExtensionViews struct {
	// The developer configuration of the extension as a component extension, if supported.
	Component *ComponentView `json:"component"`
	// The developer configuration of the extension's configuration view, if supported.
	Config *ConfigView `json:"config"`
	// The configuration for a hidden extension. The only hidden extension is used for load testing.
	Hidden *HiddenView `json:"hidden"`
	// The developer configuration of the extension's live configuration dashboard view, if supported.
	LiveConfig *LiveConfigView `json:"liveConfig"`
	// The developer configuration of the extension as a mobile extension, if supported.
	Mobile *MobileView `json:"mobile"`
	// The developer configuration of the extension as a panel extension, if supported.
	Panel *PanelView `json:"panel"`
	// The developer configuration of the extension as a video overlay extension, if supported.
	VideoOverlay *VideoOverlayView `json:"videoOverlay"`
}

// The potential anchor-specific configurations and extension can have.
type ExtensionViewsInput struct {
	// The developer configuration of the extension as a component extension, if supported.
	Component *ComponentViewInput `json:"component"`
	// The developer configuration of the extension's configuration view, if supported.
	Config *ConfigViewInput `json:"config"`
	// The developer configuration of the extension's live configuration dashboard view, if supported.
	LiveConfig *LiveConfigViewInput `json:"liveConfig"`
	// The developer configuration of the extension as a mobile extension, if supported.
	Mobile *MobileViewInput `json:"mobile"`
	// The developer configuration of the extension as a panel extension, if supported.
	Panel *PanelViewInput `json:"panel"`
	// The developer configuration of the extension as a video overlay extension, if supported.
	VideoOverlay *VideoOverlayViewInput `json:"videoOverlay"`
}

// Whitelists for restricting extension access and behavior.
type ExtensionWhitelists struct {
	// List of broadcaster account IDs allowed to install an extension after release.
	// If this is empty or missing, all broadcasters can use this extension.
	Broadcasters []string `json:"broadcasters"`
	// URLs which are permitted to be opened from the configuration dialog.
	ConfigURLs []string `json:"configURLs"`
	// URLs which are permitted to be opened from an extension set as a panel.
	PanelURLs []string `json:"panelURLs"`
	// List of account IDs which should have access to a version of an extension.
	// Users in this list are ignored by the broadcaster whitelist check.
	Testers []string `json:"testers"`
}

// ExtensionWhitelistsInput contains whitelists for restricting extension access and behavior.
type ExtensionWhitelistsInput struct {
	// List of broadcaster account IDs allowed to install an extension after release.
	// If this is empty or missing, all broadcasters can use this extension.
	Broadcasters []string `json:"broadcasters"`
	// URLs which are permitted to be opened from the configuration dialog.
	ConfigURLs []string `json:"configURLs"`
	// URLs which are permitted to be opened from an extension set as a panel.
	PanelURLs []string `json:"panelURLs"`
	// List of account IDs which should have access to a version of an extension.
	// Users in this list are ignored by the broadcaster whitelist check.
	Testers []string `json:"testers"`
}

// Url and UploadId provided by Upload Service.
type ExtensionZipUploadResponse struct {
	// Upload ID.
	UploadID string `json:"uploadID"`
	// Upload URL.
	URL string `json:"url"`
}

// ExternalChargeModel defines a 3P managed SKU for a given offer.
type ExternalChargeModel struct {
	// The provider for this externally managed SKU.
	Provider string `json:"provider"`
	// Externally managed SKU identifier.
	Sku string `json:"sku"`
}

type FeatureFlags struct {
	IsPulseEnabled *bool `json:"isPulseEnabled"`
}

// FeaturedContentSections contain the a set of FeaturedItems that should be shown together in a particular section of Twitch apps.
type FeaturedContentSection struct {
	// A combination of the type and style for a given section, i.e. spotlight-previews.
	ID    string          `json:"id"`
	Items []*FeaturedItem `json:"items"`
}

type FeaturedItem struct {
	// The featured item's content.
	Content FeaturedItemContent `json:"content"`
	// An markdown description of the item, available when a item is featured.
	Description string `json:"description"`
	// ID used for tracking interactions.
	ID string `json:"id"`
	// A URL for a special thumbnail image, when this item is featured.
	ImageURL string `json:"imageURL"`
	// Is this item featured because it is scheduled?
	IsScheduled bool `json:"isScheduled"`
	// Is this item featured because it is sponsored?
	IsSponsored bool `json:"isSponsored"`
	// A lower priority level means the item is higher priority.
	PriorityLevel int `json:"priorityLevel"`
	// When featured, the title of the item.
	Title string `json:"title"`
}

// FeaturedStream contains extra metadata for presenting a featured Stream.
type FeaturedStream struct {
	// The featured stream's broadcaster.
	Broadcaster *User `json:"broadcaster"`
	// The featured channel.
	Channel *Channel `json:"channel"`
	// A markdown description of the stream, available when a stream is featured.
	Description *string `json:"description"`
	// An HTML description of the stream, available when a stream is featured.
	DescriptionHTML *string `json:"descriptionHTML"`
	// A URL for a special thumbnail image, when this stream is featured.
	ImageURL *string `json:"imageURL"`
	// Is this stream featured because it is scheduled?
	IsScheduled *bool `json:"isScheduled"`
	// Is this stream featured because it is sponsored?
	IsSponsored *bool `json:"isSponsored"`
	// A lower priority level means the stream is higher priority.
	PriorityLevel *int `json:"priorityLevel"`
	// The featured live steam.
	Stream *Stream `json:"stream"`
	// When featured, the title of the stream.
	Title *string `json:"title"`
}

// DEPRECATED: do not use, it is subject to change.
// FeaturedVideo contains extra metadata for presenting a featured video.
type FeaturedVideo struct {
	// An markdown description of the video, available when a video is featured.
	Description string `json:"description"`
	// A URL for a special thumbnail image, when this video is featured.
	ImageURL string `json:"imageURL"`
	// Is this video featured because it is scheduled?
	IsScheduled bool `json:"isScheduled"`
	// Is this video featured because it is sponsored?
	IsSponsored bool `json:"isSponsored"`
	// A lower priority level means the stream is higher priority.
	PriorityLevel int `json:"priorityLevel"`
	// When featured, the title of the video.
	Title string `json:"title"`
	// The featured video.
	Video *Video `json:"video"`
}

// Feed is twitch's pulse product of content a user may enjoy.
type Feed struct {
	ID    string              `json:"id"`
	Items *FeedItemConnection `json:"items"`
}

// FeedItem is the units of a feed.
// They do not have an identifier because you cannot look them up by identifier.
type FeedItem struct {
	Content  FeedItemContent   `json:"content"`
	Reasons  []*FeedItemReason `json:"reasons"`
	Tracking *FeedItemTracking `json:"tracking"`
}

type FeedItemConnection struct {
	Edges    []*FeedItemEdge `json:"edges"`
	PageInfo *PageInfo       `json:"pageInfo"`
}

type FeedItemEdge struct {
	Cursor *string   `json:"cursor"`
	Node   *FeedItem `json:"node"`
}

// FeedItemReason explains why an item is in your feed.
type FeedItemReason struct {
	Reason *string `json:"reason"`
}

// FeedItemTracking contains the tracking info of a feeditem.
type FeedItemTracking struct {
	BatchID            *string `json:"batchID"`
	CardImpressionID   *string `json:"cardImpressionID"`
	RecGenerationID    *string `json:"recGenerationID"`
	RecGenerationIndex *int    `json:"recGenerationIndex"`
}

// FinalizeCompetitionLobbyInput contains the inputs required to change a lobby's status to done.
type FinalizeCompetitionLobbyInput struct {
	// The competition id of the competition.
	CompetitionID string `json:"competitionID"`
	// The lobbyID of the competition that we want to mark done.
	LobbyID string `json:"lobbyID"`
	// The phase id of the competition that this lobby belongs to.
	PhaseID string `json:"phaseID"`
}

// FinalizeCompetitionLobbyPayload is the success response for updating a lobby to done.
type FinalizeCompetitionLobbyPayload struct {
	// The new state of competition after marking the lobby as done.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// Settings specific to the first cheer tutorial.
type FirstCheerTutorial struct {
	// Optional field that dictates whether a user has exited out of the first cheer tutorial by clicking out of the experience.
	HasAbandoned *bool `json:"hasAbandoned"`
	// Optional field that dictates whether a user has skipped the first cheer tutorial by clicking the skip button.
	HasSkipped *bool `json:"hasSkipped"`
}

// Data about the relationship between one User and a User they are following.
type Follow struct {
	// Whether to disable notifications for this relationship.
	DisableNotifications *bool `json:"disableNotifications"`
	// Represents when this relationship was established.
	FollowedAt *time.Time `json:"followedAt"`
	// The user who is followed.
	User *User `json:"user"`
}

// A paginated list of follows relationships.
type FollowConnection struct {
	// The elements of the paginated list.
	Edges []*FollowEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of followers.
	TotalCount *int `json:"totalCount"`
}

// An element in a paginated list of follows relationships.
// Contains metadata about the follow relationship between two users.
type FollowEdge struct {
	// An opaque cursor identifying the edge's position in the paginted list.
	Cursor string `json:"cursor"`
	// Whether to disable notifications for this relationship.
	DisableNotifications *bool `json:"disableNotifications"`
	// Represents when this relationship was established.
	FollowedAt *time.Time `json:"followedAt"`
	// The user who is followed.
	Node *User `json:"node"`
	// Notification settings for this relationship.
	NotificationSettings *ChannelNotificationSettings `json:"notificationSettings"`
}

type FollowGameInput struct {
	// The identifier of the game to follow.
	GameID string `json:"gameID"`
}

type FollowGamePayload struct {
	// The game that was followed if the operation was successful.
	Game *Game `json:"game"`
}

// Information to communicate to the user about an error state.
type FollowUserError struct {
	// Error code.
	Code FollowUserErrorCode `json:"code"`
}

type FollowUserInput struct {
	// disableNotifications, when true, prevents the followed user's stream from sending email and push notifications to
	// the authenticated user when it goes live.
	DisableNotifications bool   `json:"disableNotifications"`
	TargetID             string `json:"targetID"`
}

type FollowUserPayload struct {
	// Used for user blocked errors.
	Error *FollowUserError `json:"error"`
	// The new follow relationship.
	Follow *Follow `json:"follow"`
}

// A list of followed games.
type FollowedGameConnection struct {
	// The elements of the paginated list.
	Nodes []*Game `json:"nodes"`
}

// A list of broadcasters followed by a user and hosting live broadcasters.
type FollowedHostConnection struct {
	// The broadcasters.
	Nodes []*User `json:"nodes"`
}

// A list of live-streaming broadcasters followed by a user.
type FollowedLiveUserConnection struct {
	// The live broadcasters.
	Edges []*FollowedLiveUserEdge `json:"edges"`
	// The live broadcasters.
	Nodes []*User `json:"nodes"`
	// Pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// A live streaming broadcaster with cursor.
type FollowedLiveUserEdge struct {
	Cursor string `json:"cursor"`
	Node   *User  `json:"node"`
}

// A paginated list of followers relationships.
type FollowerConnection struct {
	// The elements of the paginated list.
	Edges []*FollowerEdge `json:"edges"`
	// Metadata about this page.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of followers.
	TotalCount *int `json:"totalCount"`
}

// An element in a paginated list of followers.
// Contains metadata about the follower relationship between two users.
type FollowerEdge struct {
	// An opaque cursor identifying the edge's position in the paginted list.
	Cursor string `json:"cursor"`
	// Whether to disable notifications for this relationship.
	DisableNotifications *bool `json:"disableNotifications"`
	// Represents when this relationship was established.
	FollowedAt *time.Time `json:"followedAt"`
	// The user who is a follower.
	Node *User `json:"node"`
	// Notification settings for this relationship.
	NotificationSettings *ChannelNotificationSettings `json:"notificationSettings"`
}

// A list of a user's friend relationships.
type FriendConnection struct {
	// The friend elements of this list.
	Edges []*FriendEdge `json:"edges"`
	// The total number of friends this user has.
	TotalCount int `json:"totalCount"`
}

// The friendship between the authenticated user and another user.
type FriendEdge struct {
	// An action that a user or session is performing.
	Activity Activity `json:"activity"`
	// The computed state of a user or session.
	Availability Availability `json:"availability"`
	// The last time the friend's availability or activity changed.
	LastStatusChangeAt *time.Time `json:"lastStatusChangeAt"`
	// The friend user.
	Node *User `json:"node"`
}

func (FriendEdge) IsFriendRelationship() {}

// GDPR Consent contains user consent on different tracking vendors.
type GDPRConsent struct {
	// Whether Amazon has user GDPR consent.
	AllowAmazon *bool `json:"allowAmazon"`
	// Whether Comscore has user GDPR consent.
	AllowComscore *bool `json:"allowComscore"`
	// Whether Google has user GDPR consent.
	AllowGoogle *bool `json:"allowGoogle"`
	// Whether Nielson has user GDPR consent.
	AllowNielsen *bool `json:"allowNielsen"`
	// Whether Salesforce has user GDPR consent.
	AllowSalesforce *bool `json:"allowSalesforce"`
}

// A Game is often the subject of a Stream on Twitch.
type Game struct {
	// What campaigns are active for this game.
	ActiveDropCampaigns []*DropCampaign `json:"activeDropCampaigns"`
	// URL to an avatar image.
	// The image dimensions are specifiable via the `height` and `width` parameters.
	//
	// If `height` or `width` are not specified, the URL will contain
	// the template strings `{height}` and/or `{width}` in their respective places.
	AvatarURL *string `json:"avatarURL"`
	// URL to a box art image.
	// The image dimensions are specifiable via the `height` and `width` parameters.
	//
	// If `height` or `width` are not specified, the URL will contain
	// the template strings `{height}` and/or `{width}` in their respective places.
	BoxArtURL *string `json:"boxArtURL"`
	// Number of broadcasters streaming this game.
	BroadcastersCount *int `json:"broadcastersCount"`
	// Number of channels currently streaming this game.
	ChannelsCount *int `json:"channelsCount"`
	// A paginated list of clips featuring this game, ordered by view count descending.
	// When criteria is not specified, the default values are used.
	Clips *ClipConnection `json:"clips"`
	// URL to a cover image.
	// The image dimensions are specifiable via the `height` and `width` parameters.
	//
	// If `height` or `width` are not specified, the URL will contain
	// the template strings `{height}` and/or `{width}` in their respective places.
	CoverURL *string `json:"coverURL"`
	// The type of directory – in this case, always GAME.
	DirectoryType *DirectoryType `json:"directoryType"`
	// The translated game name used for display purposes.
	// Use name for tracking props or URLs.
	DisplayName string `json:"displayName"`
	// The associated clientID for a game used to determine if users have an account link
	// created between tuid and in-game userID as well as the timestamp of when this link was created.
	DropAccountLink *DropAccountLink `json:"dropAccountLink"`
	// A list of clients that use the Enhanced Experiences (E2) API for
	// Twitch integrations with this game.
	EnhancedExperiencesClients []*EnhancedExperiencesClient `json:"enhancedExperiencesClients"`
	// A list of extension recommendations, according to the game.
	ExtensionRecommendations []*ExtensionRecommendation `json:"extensionRecommendations"`
	// Number of users that follow this game.
	FollowersCount *int `json:"followersCount"`
	// The game's unique GiantBomb identifier.
	GiantBombID *string `json:"giantBombID"`
	// The game's unique Twitch identifier.
	// It is used to associate games with product offers.
	ID string `json:"id"`
	// URL to a game logo image.
	// The image dimensions are specifiable via the `height` and `width` parameters.
	//
	// If `height` or `width` are not specified, the URL will contain
	// the template strings `{height}` and/or `{width}` in their respective places.
	LogoURL *string `json:"logoURL"`
	// The name of the game. This string is untranslated.
	// This field should only be used in limited occassions, like tracking and URLs.
	// You should use displayName for all all game names shown to the users.
	Name string `json:"name"`
	// A measure of the games popularity.
	PopularityScore *int `json:"popularityScore"`
	// The game's unique Presto identifier.
	PrestoID *string `json:"prestoID"`
	// The authenticated user's relationship with this Game.
	Self *GameSelfConnection `json:"self"`
	// Get a page of live streams broadcasting this game.
	// The languages param can be used to filter the streams. Otherwise all languages will be returned.
	// The filters param contains additional metadata filters, for example {hearthstoneGameMode: "arena"}.
	// The sort param can be used to change the default sorting, which sometimes is specific to specific games.
	// The tags param are an array of tag ID as optional filters for streams.
	// DEPRECATED field arguments: languages, requestID, sort, tags
	// Use GameStreamOptions instead.
	Streams *StreamConnection `json:"streams"`
	// List of recommeded tags in the corresponding category.
	Tags []*Tag `json:"tags"`
	// A paginated list of top videos for this game.
	Videos *VideoConnection `json:"videos"`
	// Number of viewers currently watching a stream which features this game.
	ViewersCount *int `json:"viewersCount"`
}

func (Game) IsTaggedContent()                 {}
func (Game) IsOnsiteNotificationContent()     {}
func (Game) IsDirectory()                     {}
func (Game) IsShelfTitleContext()             {}
func (Game) IsRecommendationFeedbackContent() {}
func (Game) IsTitleTokenNode()                {}
func (Game) IsShelfContent()                  {}
func (Game) IsVerticalContentContext()        {}

// GameApplication is an application to associate a game with an organization.
type GameApplication struct {
	// Creation time.
	CreatedAt time.Time `json:"createdAt"`
	// Game that is added in the application.
	Game *Game `json:"game"`
	// ID of the game application, stored in RBAC.
	ID string `json:"id"`
	// Organization that is going to be associated with the game.
	Organization *Organization `json:"organization"`
}

// Moment Details specific to a game change.
type GameChangeMomentDetails struct {
	// The game that the user changed to.
	Game *Game `json:"game"`
}

func (GameChangeMomentDetails) IsVideoMomentDetails() {}

// Filtering criteria for paginated game clips results.
type GameClipsInput struct {
	// The ID of the broadcaster to filter results by.
	BroadcasterID *string `json:"broadcasterID"`
	// The ID of the curator to filter results by.
	CuratorID *string `json:"curatorID"`
	// Overrides the period. if startAt is provided, but endAt isn't, the endAt value will be the day when the query was made.
	EndAt *time.Time `json:"endAt"`
	// DEPRECATED: `filter` should no longer be used. Prefer `period` and `sort` instead.
	// A filter which restricts results.
	Filter *ClipsFilter `json:"filter"`
	// Clip results will be filtered by this language.
	// Omit this input field to get results by all languages.
	Languages []Language `json:"languages"`
	// The time period to restrict clips based on creation time.
	Period *ClipsPeriod `json:"period"`
	// The sort order for the clips results.
	Sort *ClipsSort `json:"sort"`
	// Overrides the period param. If endAt is provided, but startAt isn't, 2015-01-01 will be used for it.
	StartAt *time.Time `json:"startAt"`
}

// Paginated list of Games.
// Implements the Relay cursor connections specification.
// See: https://facebook.github.io/relay/graphql/connections.htm.
type GameConnection struct {
	// The list of games to display.
	Edges    []*GameEdge `json:"edges"`
	PageInfo *PageInfo   `json:"pageInfo"`
}

// Contains information about a Game's relationship to a given page (connection),
// and the Game itself.
type GameEdge struct {
	Cursor *string `json:"cursor"`
	Node   *Game   `json:"node"`
	// Unique id per game response item, used by clients to attribute displays/clicks to items.
	TrackingID *string `json:"trackingID"`
}

// Game followed by a User.
type GameFollow struct {
	// Represents when this relationship was established.
	FollowedAt time.Time `json:"followedAt"`
	// The game that is followed.
	Game *Game `json:"game"`
	// The user who is following.
	User *User `json:"user"`
}

// Optional input to filter categories.
// Add any additional optional fields to this input.
type GameOptions struct {
	// The locale of the user.
	Locale *string `json:"locale"`
	// If sorted by relevance, this provides additional context used to influence recommendations.
	RecommendationsContext *RecommendationsContext `json:"recommendationsContext"`
	// A GUID that is created by the caller for tracking. This should be globally unique per request and is required if sort=RELEVANCE.
	RequestID *string `json:"requestID"`
	// The sort param can be used to change the default sorting of results.
	Sort *GameSort `json:"sort"`
	// Tags are an array of tag IDs as optional filters for categories.
	Tags []string `json:"tags"`
}

// Game that my viewers also like to watch.
type GameOverlap struct {
	// How much my viewers like to watch this game.
	Score float64 `json:"score"`
	// Game that my viewers also like to watch.
	ViewersAlsoWatch *Game `json:"viewersAlsoWatch"`
}

// The relationship between the authenticated user and a game.
type GameSelfConnection struct {
	// The current user's follow relationship with this game.
	Follow *GameFollow `json:"follow"`
	// Whether or not the current user has a link to this game that can be used
	// for Drops.
	IsDropsLinked *bool `json:"isDropsLinked"`
}

// Optional input to filter game specific streams.
// add additional optional fields to this input.
type GameStreamOptions struct {
	// Filter streams based on restriction types.
	IncludeRestricted []StreamRestrictionType `json:"includeRestricted"`
	// Broadcaster languages to filter streams by.
	// Deprecated: use language tags instead.
	Languages []string `json:"languages"`
	// The locale of the user.
	Locale *string `json:"locale"`
	// If sorted by relevance, this provides additional context used to influence recommendations.
	RecommendationsContext *RecommendationsContext `json:"recommendationsContext"`
	// RequestID must be specified if sort=RELEVANCE.
	RequestID *string `json:"requestID"`
	// The sort param can be used to change the default sorting, which sometimes is specific to specific games.
	Sort *StreamSort `json:"sort"`
	// The tags param are an array of tag ID as optional filters for streams.
	Tags []string `json:"tags"`
}

// GenerateExtensionRatingsCSVInput takes an extensionID and some time range info for generating a CSV of extension ratings
// data for an extension developer.
// Authenticated on UserID via oauth token and OWL (via the ExtensionRatings backend).
type GenerateExtensionRatingsCSVReportInput struct {
	// endAt is expected to be RFC3339 UTC and is inclusive in the results when truncated to YYYY-MM-DD.
	EndAt time.Time `json:"endAt"`
	// extensionID to generate a CSV of ratings data for.
	ExtensionID string `json:"extensionID"`
	// startAt is expected to be RFC3339 UTC and is inclusive in the results when truncated to YYYY-MM-DD.
	StartAt time.Time `json:"startAt"`
}

// GenerateExtensionRatingsCSVPayload returns the filename that the CSV report will have when it is completed, and gives
// the caller something to poll for.
type GenerateExtensionRatingsCSVReportPayload struct {
	// reportFilename is the filename for the generated report.
	ReportFilename *string `json:"reportFilename"`
}

// Error returned during a invalid user request.
type GenerateSecondFactorQRCodeError struct {
	// Error code returned by the backend.
	Code GenerateSecondFactorQRCodeErrorCode `json:"code"`
	// The localized external error message.
	Message string `json:"message"`
}

// The required input for a generateSecondFactorQRCode mutation.
type GenerateSecondFactorQRCodeInput struct {
	// The ID of the user that is requesting a new second factor QR code.
	UserID string `json:"userID"`
}

// The result of a generateSecondFactorQRCode mutation.
type GenerateSecondFactorQRCodePayload struct {
	// error code and localized error.
	Error *GenerateSecondFactorQRCodeError `json:"error"`
	// qrCode will be a url to a png file.
	QrCode *string `json:"qrCode"`
}

// GenerateSubscribersCSVInput takes a channelID to generate a CSV of subscribers for.
// Authenticated on channelID.
type GenerateSubscribersCSVInput struct {
	// channelID to generate a CSV of subscribers for.
	ChannelID string `json:"channelID"`
}

// GenerateSubscribersCSVPayload returns the channelID it currently generating
// a CSV for.
type GenerateSubscribersCSVPayload struct {
	// channelID that a subscribers CSV is being generated for.
	ChannelID string `json:"channelID"`
}

// The input for getting upload config.
type GetEmoteUploadConfigInput struct {
	// The type of asset to be uploaded.
	AssetType *EmoteAssetType `json:"assetType"`
	// If the asset type is "animated", whether to generate the static versions from the first frame.
	GenerateStaticVersionOfAnimatedAssets *bool `json:"generateStaticVersionOfAnimatedAssets"`
	// Resizing plan to use.
	ResizePlan EmoteResizePlan `json:"resizePlan"`
	// Sizes to provide upload URLs for.
	Sizes []EmoteImageSize `json:"sizes"`
}

// Response payload.
type GetEmoteUploadConfigPayload struct {
	// Upload config for resizing/original.
	UploadConfig *UploadConfig `json:"uploadConfig"`
	// Upload config for 1x image resouce.
	UploadConfig1x *UploadConfig `json:"uploadConfig1x"`
	// Upload config for 2x image resource.
	UploadConfig2x *UploadConfig `json:"uploadConfig2x"`
	// Upload config for 4x image resource.
	UploadConfig4x *UploadConfig `json:"uploadConfig4x"`
	// Upload configs for all sizes and asset types.
	UploadConfigs []*UploadConfig `json:"uploadConfigs"`
}

// GiftCardCode that can be claimed to add a monetary balance to a user's account.
type GiftCardCode struct {
	// A description of what is claimable for the code.
	Description string `json:"description"`
	// The ID of the Gift Card code.
	ID string `json:"id"`
	// The field that gives us claim information for the logged in user.
	Self SelfClaimEdge `json:"self"`
	// The type is `ClaimableType.GIFT_CARD_CODE`.
	Type ClaimableType `json:"type"`
}

func (GiftCardCode) IsClaimable() {}

// User edge relating the pin's status to the user.
type GiftCardCodeSelfClaimEdge struct {
	// If the user is eligible to claim the key code.
	CanClaim bool `json:"canClaim"`
	// Nullable field for the country where the user redeemed the claimable.
	CountryOfResidence *string `json:"countryOfResidence"`
	// The user ID that is claiming the code.
	ID string `json:"id"`
	// Nullable status code for if the user cannot claim the key code.
	StatusCode *string `json:"statusCode"`
}

func (GiftCardCodeSelfClaimEdge) IsSelfClaimEdge() {}

// GlobalCheerConfig contains information about (1) How to display Cheers and (2) What Cheermotes are globally available.
type GlobalCheerConfig struct {
	// The CheermoteDisplayConfig provides information about how Cheermotes can be displayed
	// This includes things like the possible sizes, colors, backgrounds, and display order.
	DisplayConfig *CheermoteDisplayConfig `json:"displayConfig"`
	// The Cheermote Groups containing the Global Cheermotes.
	Groups []*CheermoteGroup `json:"groups"`
}

// Analytics associated with a given notification.
type GoLiveNotification struct {
	// Custom notification text, e.g., "Summit1g playing Hearthstone today".
	CustomText string `json:"customText"`
	// Number of followers that engaged with the notification.
	Engagements int `json:"engagements"`
	// Number of followers at the time the notification was sent.
	FollowerCount int `json:"followerCount"`
	// Number of followers that were sent the notification.
	FollowersNotified int `json:"followersNotified"`
	// Time that the associated stream went live.
	StreamStartTime time.Time `json:"streamStartTime"`
}

// GoLiveNotificationConnection represents GoLiveNotification edges and page metadata.
type GoLiveNotificationConnection struct {
	// Each GoLiveNotificationEdge contains the GoLiveNotification node and cursor data.
	Edges []*GoLiveNotificationEdge `json:"edges"`
	// Page metadata includes hasNextPage/hasPreviousPage.
	PageInfo *PageInfo `json:"pageInfo"`
}

// GoLiveNotificationEdges are returned by a given GoLiveNotificationConnection.
type GoLiveNotificationEdge struct {
	// A GoLiveNotification cursor is represented by an exclusive stream start time.
	Cursor string `json:"cursor"`
	// The actual GoLiveNotification payload associated with a given edge.
	Node *GoLiveNotification `json:"node"`
}

// Analytics associated with go live notification timeseries.
type GoLiveNotificationTimeseries struct {
	// Grouping of notification timeseries items with timestamp and engagements.
	Items []*GoLiveNotificationTimeseriesItem `json:"items"`
	// Sum of all notification engagements for a given date range.
	Total int `json:"total"`
}

// Single go live notification timeseries item. Represents day, or week/monthly aggregation.
type GoLiveNotificationTimeseriesItem struct {
	// Number of engagements for a single set of go live notifications.
	Engagements int `json:"engagements"`
	// First timestamp for a single set of go live notifications.
	Timestamp time.Time `json:"timestamp"`
}

// GoRaidError is the error associated with a goRaid.
type GoRaidError struct {
	// The associated error code.
	Code GoRaidErrorCode `json:"code"`
}

// Inputs to the goRaid mutation.
type GoRaidInput struct {
	// Source ID.
	SourceID string `json:"sourceID"`
}

// Outputs from the goRaid mutation.
type GoRaidPayload struct {
	// The possible error returned from the service.
	Error *GoRaidError `json:"error"`
	// The raid then just went.
	Raid *Raid `json:"raid"`
}

// GrantVIPError contains details about a client error that occurred.
type GrantVIPError struct {
	// The type of error that occurred when granting VIP status.
	Code GrantVIPErrorCode `json:"code"`
}

// GrantVIPInput contains the parameters to grant the VIP status to a user for a channel.
type GrantVIPInput struct {
	// The channel for which the VIP status of a user will be granted.
	ChannelID string `json:"channelID"`
	// The ID of the user who will be granted the VIP status.
	// Either granteeID or granteeLogin must be provided.
	GranteeID *string `json:"granteeID"`
	// The login of the user who will be granted the VIP status.
	// Either granteeID or granteeLogin must be provided.
	GranteeLogin *string `json:"granteeLogin"`
}

// GrantVIPPayload is the response after attemping to grant the VIP status to a user.
type GrantVIPPayload struct {
	// The channel for which the VIP status of the user was granted.
	Channel *User `json:"channel"`
	// The client error that has occurred.
	// Null if the operation is successful.
	Error *GrantVIPError `json:"error"`
	// The user who was granted the VIP status.
	Grantee *User `json:"grantee"`
}

// The hearthstone game mode that was played.
type HearthsoneMomentGameMode struct {
	// The game type (e.g. Ranked, Casual, Arena, Pack Opening, etc.).
	Type string `json:"type"`
	// The value for the game type (e.g. 0-11 for Arena, Priest vs Warlock for Ranked).
	Value *string `json:"value"`
}

// Moment Details specific to the hearthstone game.
type HearthstoneMomentDetails struct {
	// The broadcasters hero, can be null.
	BroadcasterHero *HearthstoneMomentHero `json:"broadcasterHero"`
	// The game mode that was played, can be null.
	GameMode *HearthsoneMomentGameMode `json:"gameMode"`
	// The oponents hero, can be null.
	OpponentHero *HearthstoneMomentHero `json:"opponentHero"`
}

func (HearthstoneMomentDetails) IsVideoMomentDetails() {}

// The hero that either the broadcaster or opponent played.
type HearthstoneMomentHero struct {
	// The hero's (capitalized) class.
	Class string `json:"class"`
	// The hero's id.
	ID string `json:"id"`
	// The hero's (capitalized) name.
	Name string `json:"name"`
}

// HiddenView holds the view configuration of an extension if it is a hidden load test extension.
type HiddenView struct {
	// Specifies whether or not the extension has the ability to link to external websites.
	CanLinkExternalContent bool `json:"canLinkExternalContent"`
	// Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
	ViewerPath string `json:"viewerPath"`
	// The URL which should be loaded in for the extension.
	ViewerURL string `json:"viewerURL"`
}

func (HiddenView) IsExtensionView() {}

// HiddenView holds the view configuration of an extension if it is a hidden load test extension.
type HiddenViewInput struct {
	// Relative path of the HTML file to load for this view.
	ViewerPath string `json:"viewerPath"`
}

// Input to describe a single continuous time range of the source VOD to be included in the highlight.
type HighlightRange struct {
	// The end time offset in milliseconds into the VOD.
	EndMs int `json:"endMs"`
	// The start time offset in milliseconds into the VOD.
	StartMs int `json:"startMs"`
	// The ID of the source VOD to create a Highlight from.
	VodID string `json:"vodID"`
}

// An minimal version of a DONE CompetitionLobby focusing on the outcome of a lobby
type HistoricalCompetitionLobby struct {
	// id is the unique id of the HistoricalCompetitionLobby
	ID string `json:"id"`
	// The participant who had a higher score, if scores are equal and the lobby is done, the lobby ended in a tie
	Winner *CompetitionLobbyParticipant `json:"winner"`
}

// Paginated list of Users hosting a particular target User.
type HostConnection struct {
	// Users hosting a target User.
	Edges []*HostEdge `json:"edges"`
	// Pagination information for this connection.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of users hosting a target.
	TotalCount *int `json:"totalCount"`
}

// Edge between Users hosting a target.
type HostEdge struct {
	// Unique identifier for each Users hosting.
	Cursor string `json:"cursor"`
	// A User hosting.
	Node *User `json:"node"`
}

// HostTargetChannelError contains a error code.
type HostTargetChannelError struct {
	// The type of error that occurred when trying to host.
	Code HostTargetChannelErrorCode `json:"code"`
}

// HostTargetChannelInput contains the necessary inputs to host a target channel.
type HostTargetChannelInput struct {
	// Channel ID where host was initiated on.
	ChannelID string `json:"channelID"`
	// Target channel ID to host.
	TargetID string `json:"targetID"`
}

// HostTargetChannelPayload is the response after attempting to host.
type HostTargetChannelPayload struct {
	// The client error that has occurred.
	// Null if the operation is successful.
	Error *HostTargetChannelError `json:"error"`
	// The channel that is hosting.
	Source *User `json:"source"`
	// The target channel that is hosted.
	Target *User `json:"target"`
}

// The wrapper structure that contains information regarding a Hype Train.
type HypeTrain struct {
	// Configuration for Hype Trains for a channel, normally loaded this way when configuring the Hype Train from the
	// Broadcaster's perspective.
	Config *HypeTrainConfig `json:"config"`
	// Information pertaining to executions of Hype Trains in a channel. This is loaded on channel page load.
	Execution *HypeTrainExecution `json:"execution"`
}

// The Hype Train reward that's a Badge.
type HypeTrainBadgeReward struct {
	// The badge that is to be entitled.
	Badge *Badge `json:"badge"`
	// The identifier of the reward.
	ID string `json:"id"`
	// The type of reward, which will be HypeTrainRewardType.BADGE.
	Type HypeTrainRewardType `json:"type"`
}

func (HypeTrainBadgeReward) IsHypeTrainReward() {}

// A conductor of the Hype Train.
type HypeTrainConductor struct {
	// The participation that made them the Hype Train conductor.
	Participation []*HypeTrainParticipation `json:"participation"`
	// The conductor source.
	Source HypeTrainParticipationSource `json:"source"`
	// The user object that is the conductor.
	User *User `json:"user"`
}

// The configured conductor rewards for a given participation source.
type HypeTrainConductorReward struct {
	// The rewards entitled for being the conductor and contributing from this source.
	Rewards []HypeTrainReward `json:"rewards"`
	// The source that the conductor participated from.
	Source HypeTrainParticipationSource `json:"source"`
	// The type of conductor that gets this reward.
	Type HypeTrainConductorType `json:"type"`
}

// The Hype Train config for a channel.
type HypeTrainConfig struct {
	// A custom setting that will be an emote that the user has chosen (or PogChamp if not set) to display in their Hype Train events.
	CalloutEmote *Emote `json:"calloutEmote"`
	// The conductor rewards for a Hype Train successful execution.
	ConductorRewards []*HypeTrainConductorReward `json:"conductorRewards"`
	// The cooldown period between Hype Train executions.
	CooldownPeriodMinutes int `json:"cooldownPeriodMinutes"`
	// The difficulty of the Hype Train.
	Difficulty HypeTrainDifficulty `json:"difficulty"`
	// The configured levels of the Hype Train.
	DifficultySettings []*HypeTrainDifficultySettings `json:"difficultySettings"`
	// The identifier for the hype train.
	ID string `json:"id"`
	// The boolean flag that denotes if the Hype Train is enabled or not.
	IsEnabled bool `json:"isEnabled"`
	// The structure that holds the parameters for tweaking how a Hype Train gets kicked off.
	Kickoff *HypeTrainKickoffConfig `json:"kickoff"`
	// The duration a Hype Train level executes for.
	LevelDurationSeconds int `json:"levelDurationSeconds"`
	// The threshold for a notification to be displayed.
	NotificationThresholds []*HypeTrainNotificationThreshold `json:"notificationThresholds"`
	// The conversion rates for all the actions that contribute to Hype Train progress.
	ParticipationConversionRates []*HypeTrainParticipationConversionRate `json:"participationConversionRates"`
	// Hex color for the current hype train. Null if not enabled or no theme color is set.
	PrimaryHexColor *string `json:"primaryHexColor"`
	// A boolean flag that indicates if the hype train settings should be personalized by Twitch.
	ShouldUsePersonalizedSettings bool `json:"shouldUsePersonalizedSettings"`
	// A custom setting for using the creators color as the base color of hype trains.
	WillUseCreatorColor bool `json:"willUseCreatorColor"`
}

// A mapping between a difficulty and the levels that correspond.
type HypeTrainDifficultySettings struct {
	// The difficulty of the level.
	Difficulty HypeTrainDifficulty `json:"difficulty"`
	// The levels associated with the difficulty.
	Levels []*HypeTrainLevel `json:"levels"`
}

// The Hype Train reward that's an Emote.
type HypeTrainEmoteReward struct {
	// The emote that is to be entitled.
	Emote *Emote `json:"emote"`
	// The identifier of the reward.
	ID string `json:"id"`
	// The type of reward, which will be HypeTrainRewardType.EMOTE.
	Type HypeTrainRewardType `json:"type"`
}

func (HypeTrainEmoteReward) IsHypeTrainReward() {}

// The structure that defines Hype Train Execution in a channel.
type HypeTrainExecution struct {
	// The conductors of the Hype Train.
	Conductors []*HypeTrainConductor `json:"conductors"`
	// The Hype Train config that the train was started with.
	Config *HypeTrainConfig `json:"config"`
	// The reason the Hype Train was ended, if it has been ended.
	EndReason *HypeTrainEndReason `json:"endReason"`
	// The time the Hype Train was ended, if the Hype Train was a previous execution.
	EndedAt *time.Time `json:"endedAt"`
	// The time that the Hype Train will expire at.
	ExpiresAt time.Time `json:"expiresAt"`
	// The identifier of the execution.
	ID string `json:"id"`
	// Boolean flag that denotes if the Hype Train is active or not.
	IsActive bool `json:"isActive"`
	// The participation events in the Hype Train.
	Participations []*HypeTrainParticipation `json:"participations"`
	// The progress structure that contains relevant information about how much progress the Hype Train acheived.
	Progress *HypeTrainProgress `json:"progress"`
	// The time that the Hype Train started.
	StartedAt time.Time `json:"startedAt"`
	// The last time the Hype Train was updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// The Hype Train kickoff configuration.
type HypeTrainKickoffConfig struct {
	// What quantity of current commerce events can trigger a Hype Train.
	EventsThreshold int `json:"eventsThreshold"`
	// The minimum value of points that the combined events have to equal to kick off a Hype Train.
	MinPoints int `json:"minPoints"`
	// The period of time that is required for these commerce events to occur in to execute a Hype Train.
	PeriodSeconds int `json:"periodSeconds"`
}

// HypeTrainKickoffInput specifies settings for kicking off hype trains.
type HypeTrainKickoffInput struct {
	// The number of qualifying events needed to kickoff a hype train.
	EventsThreshold *int `json:"eventsThreshold"`
}

// The Hype Train level configuration, which includes information about level completion and associated rewards.
type HypeTrainLevel struct {
	// The value of participation that will take to complete the level.
	Goal int `json:"goal"`
	// The level ID.
	ID string `json:"id"`
	// The associated rewards for completing the level.
	Rewards []HypeTrainReward `json:"rewards"`
	// The value of the level, like Level 1, 2, etc. Can be configurable.
	Value int `json:"value"`
}

// The notification threshold for an action / source combination.
type HypeTrainNotificationThreshold struct {
	// The action performed.
	Action HypeTrainParticipationAction `json:"action"`
	// The source of the action.
	Source HypeTrainParticipationSource `json:"source"`
	// The value that is the theshold for displaying a notification.
	Value int `json:"value"`
}

// The Hype Train participation structure that contains relevant information about the participation event.
type HypeTrainParticipation struct {
	// The type of participation.
	Action HypeTrainParticipationAction `json:"action"`
	// The amount that the participation is valued in the Hype Train progress.
	Quantity int `json:"quantity"`
	// The participation source.
	Source HypeTrainParticipationSource `json:"source"`
}

// The participation conversion rate for what an action will count towards the Hype Train.
type HypeTrainParticipationConversionRate struct {
	// The action performed.
	Action HypeTrainParticipationAction `json:"action"`
	// The source of the action.
	Source HypeTrainParticipationSource `json:"source"`
	// The rate that it will be converted as in the Hype Train progress calculations.
	Value int `json:"value"`
}

// The structure that contains relevant information about the current progress in the Hype Train.
type HypeTrainProgress struct {
	// The goal value that the Hype Train is trying to complete.
	Goal int `json:"goal"`
	// The Level that the Hype Train is currently on.
	Level *HypeTrainLevel `json:"level"`
	// The current progression that the channel has made in the level.
	Progression int `json:"progression"`
	// The number of seconds left until this Hype Train execution ends.
	RemainingSeconds int `json:"remainingSeconds"`
	// The total progression overall that has occurred in the Hype Train across all levels.
	Total int `json:"total"`
}

type Image struct {
	// The original height of the image in pixels.
	Height int `json:"height"`
	// The URL source of the image.
	ImageURL string `json:"imageURL"`
	// The URL source of the image.
	URL string `json:"url"`
	// The original width of the image in pixels.
	Width int `json:"width"`
}

type ImageOptions struct {
	// The height of the image in pixels.
	Height *int `json:"height"`
	// The width of the image in pixels.
	Width *int `json:"width"`
}

// Friend requests sent from other users to this user.
type IncomingFriendRequestConnection struct {
	// The friend request elements of this list.
	Edges []*IncomingFriendRequestEdge `json:"edges"`
	// The most recent incoming friend request received by this user, if any exist. This field is provided as a
	// convenience, as edges is not strictly time-ordered. The incoming friend request's presence in this field does not
	// prevent it from also occurring in edges.
	NewestEdge *IncomingFriendRequestEdge `json:"newestEdge"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of incoming friend requests.
	TotalCount int `json:"totalCount"`
	// The total number of unseen incoming friend requests. Use the ClearUnreadFriendRequests mutation to set this to 0.
	TotalUnreadCount int `json:"totalUnreadCount"`
}

// A friend request sent from another user to this user.
type IncomingFriendRequestEdge struct {
	// The time at which the friend request was sent.
	CreatedAt time.Time `json:"createdAt"`
	// An opaque cursor identifying the edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// The user who sent the friend request.
	Node *User `json:"node"`
}

func (IncomingFriendRequestEdge) IsFriendRelationship() {}

// IngestFrameDrop represent an event where a video frame is dropped while ingesting a video stream.
type IngestFrameDrop struct {
	// Duration of events in seconds.
	DurationSeconds float64 `json:"durationSeconds"`
	// Start time of the event.
	StartedAt time.Time `json:"startedAt"`
}

// IngestSession is a set of stream metadata related to ingest events.
type IngestSession struct {
	// Type of live stream.
	BroadcastFormat BroadcastFormat `json:"broadcastFormat"`
	// Staff-only field. Hostname for the session where ingest stream was received.
	IngestHost *string `json:"ingestHost"`
	// Name of Ingest Server PoP that received the broadcast. Ex) IAD or PDX.
	IngestProxy string `json:"ingestProxy"`
	// How many seconds were intentionally delayed in stream as requested by the broadcaster.
	StreamDelaySeconds int `json:"streamDelaySeconds"`
	// The time when the stream was ended.
	StreamDownAt *time.Time `json:"streamDownAt"`
	// The time when the stream was started.
	StreamUpAt *time.Time `json:"streamUpAt"`
}

// IngestStarvationEvent represent an event where an expected video frame from broadcaster does not arrive.
type IngestStarvationEvent struct {
	// Duration of events in seconds.
	DurationSeconds float64 `json:"durationSeconds"`
	// Starr time of the event.
	StartedAt time.Time `json:"startedAt"`
}

// Set of codes to warn the broadcaster about what is wrong with the stream.
type IngestStreamHealth struct {
	// Reasons why the stream is unstable.
	Reasons []IngestStreamHealthReason `json:"reasons"`
	// Indicate whether the stream is at okay, warning or unstable status.
	Status IngestStreamHealthStatus `json:"status"`
}

// InstallExtensionError is wrapper for error associated with the installExtension mutation.
type InstallExtensionError struct {
	// Error code.
	Code InstallExtensionErrorCode `json:"code"`
	// The installation id if got EXTENSION_ALREADY_INSTALLED error.
	InstallationID *string `json:"installationID"`
}

// The required input for an installExtension mutation.
type InstallExtensionInput struct {
	// The channelID the user is installing the extension on.
	ChannelID string `json:"channelID"`
	// The composite ID of an extension <extensionID:version>.
	ExtensionID string `json:"extensionID"`
}

// The result of an installExtension mutation.
type InstallExtensionPayload struct {
	// The error when the mutation fails to install extension.
	Error *InstallExtensionError `json:"error"`
	// The resulting extension installation record from the install.
	InstalledExtension *ExtensionInstallation `json:"installedExtension"`
}

// A shelf title token type that contains a number with various formatters.
type IntegerToken struct {
	// The numerical value to display for this token.
	Value int `json:"value"`
}

func (IntegerToken) IsTitleTokenNode() {}

// InternalChargeModel defines a 1P price identifier for the offer.
type InternalChargeModel struct {
	// The charge model plan. It will be omitted for consumable purchases (e.g. Bits).
	Plan *ChargeModelPlan `json:"plan"`
	// Preview of the price.
	PreviewPrice *PriceInfo `json:"previewPrice"`
	// The price identifier.
	PriceID string `json:"priceID"`
	// The authenticated user's relationship with the internal charge model.
	Self *InternalChargeModelSelfEdge `json:"self"`
}

// The authenticated user's relationship with the internal charge model.
type InternalChargeModelSelfEdge struct {
	// Contains information on the final checkout price of this offer.
	CheckoutPrice *ProductPurchase `json:"checkoutPrice"`
}

// InterruptScheduleBoundsError represents errors that are due to input being out of bounds.
type InterruptScheduleBoundsError struct {
	// Error code.
	Code InterruptScheduleErrorCode `json:"code"`
	// If the error is related to an input out of service-defined bounds, provide the maximum allowed value.
	Maximum *int `json:"maximum"`
	// If the error is related to an input out of service-defined bounds, provide the miniimum allowed value.
	Minimum *int `json:"minimum"`
}

func (InterruptScheduleBoundsError) IsInterruptScheduleError() {}

// The input to interrupt a schedule.
type InterruptScheduleInput struct {
	// The end time when the schedule will no longer be disabled.
	EndAt time.Time `json:"endAt"`
	// The reason the schedule was disabled.
	Reason ScheduleInterruptionReason `json:"reason"`
	// The id of the schedule.
	ScheduleID string `json:"scheduleID"`
	// The start time when the schedule will be disabled.
	StartAt time.Time `json:"startAt"`
	// The geographic timezone of the new segment defined by IANA; i.e. "America/Los_Angeles".
	Timezone string `json:"timezone"`
}

// The payload returned when interrupting a schedule.
type InterruptSchedulePayload struct {
	// The possible error.
	Error InterruptScheduleError `json:"error"`
	// The updated stream schedule.
	Schedule *Schedule `json:"schedule"`
}

// InterruptScheduleStandardError represents general errors that are not related to bound errors.
type InterruptScheduleStandardError struct {
	// Error code.
	Code InterruptScheduleErrorCode `json:"code"`
}

func (InterruptScheduleStandardError) IsInterruptScheduleError() {}

// Arguments for the invalidation of all of a user's sessions.
type InvalidateAuthenticatedSessionsInput struct {
	// Session to keep alive.
	KeepSession *string `json:"keepSession"`
	// Twitch user owner of the sessions.
	UserID string `json:"userID"`
}

// Payload after invalidating sessions.
type InvalidateAuthenticatedSessionsPayload struct {
	// Twitch User.
	User *User `json:"user"`
}

// InvalidateEmailAssociationPayload is input required to mark a user as not owning an email address.
type InvalidateEmailAssociationInput struct {
	// Email address that is incorrectly attributed to a user.
	Email string `json:"email"`
	// EmailAssociationOpaqueID is the OpaqueID of the association to the above email.
	EmailAssociationOpaqueID string `json:"emailAssociationOpaqueID"`
}

// InvalidateEmailAssociationPayload is the response payload.
type InvalidateEmailAssociationPayload struct {
	// HasSucceeded indicates whether or not the request has succeeded.
	HasSucceeded bool `json:"hasSucceeded"`
}

// Contains the inventory for a particular user, which consists of drops.
type Inventory struct {
	// The campaigns which have drops that the user is eligible for and has banked (or is currently earning) minutes-watched progress for.
	DropCampaignsInProgress []*DropCampaign `json:"dropCampaignsInProgress"`
	// The drops awarded to this user via Drops 1.0 and triggered by game publishers according to minutes watched data.
	Drops *UserDropAwardConnection `json:"drops"`
	// The drops awarded to this user via Drops 2.0 and triggered by broadcaster's game events.
	GameEventDrops []*UserDropReward `json:"gameEventDrops"`
}

// Associated metrics for the "It Begins" quest.
type ItBegins struct {
	// Image URL for the quest's badge.
	BadgeURL *string `json:"badgeURL"`
	// Time that this quest was completed.
	CompletedAt *time.Time `json:"completedAt"`
	// Whether or not the user has streamed before.
	HasStreamed *bool `json:"hasStreamed"`
	// Whether or not the user has updated their category before.
	HasUpdatedCategory *bool `json:"hasUpdatedCategory"`
	// Whether or not the user has updated their stream title before.
	HasUpdatedStreamTitle *bool `json:"hasUpdatedStreamTitle"`
	// Whether or not the user has visited their stream manager.
	HasVisitedDashboard *bool `json:"hasVisitedDashboard"`
}

type JoinChannelRoomsInput struct {
	ChannelID string `json:"channelID"`
}

type JoinChannelRoomsPayload struct {
	Channel *User `json:"channel"`
}

// Inputs to the joinRaid mutation.
type JoinRaidInput struct {
	// The raid ID being joined by the user.
	RaidID string `json:"raidID"`
}

// Outputs from the joinRaid mutation.
type JoinRaidPayload struct {
	// The ID of the raid that was joined by the user.
	RaidID *string `json:"raidID"`
}

// The connection of key batches for a given key pool.
type KeyBatchConnection struct {
	// The list of key batch edges in the connection.
	Edges []*KeyBatchEdge `json:"edges"`
	// The metadata about having more key batches to fetch, or if there is a previous page of key batches.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of key batches for the key pool.
	TotalCount int `json:"totalCount"`
}

// The key batch edge which contains our cursor and node.
type KeyBatchEdge struct {
	// The cursor of the edge, which is the key batch ID.
	Cursor string `json:"cursor"`
	// The node of the edge, which contains all information about the key batch.
	Node *KeyBatchNode `json:"node"`
}

// The information associated with a given key batch.
type KeyBatchNode struct {
	// The key batch ID, which is unique for a given key pool.
	ID string `json:"id"`
	// The number of keys in the batch.
	NumKeys int `json:"numKeys"`
	// The status of the batch.
	Status KeyBatchStatus `json:"status"`
}

// The connection of key pools to a user.
type KeyPoolConnection struct {
	// The list of key pool edges associated with the user.
	Edges []*KeyPoolEdge `json:"edges"`
	// The metadata about having more key pools to fetch, or if there is a previous page of key pools.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of key pools for the given user.
	TotalCount int `json:"totalCount"`
}

// The key pool edge which contains our cursor and node.
type KeyPoolEdge struct {
	// The cursor of the edge, which is also the key pool ID.
	Cursor string `json:"cursor"`
	// The node of the edge, which contains all information about the key pool.
	Node *KeyPoolNode `json:"node"`
}

// The information associated with a given key pool.
type KeyPoolNode struct {
	// The key batches that have been generated in the key pool.
	Batches *KeyBatchConnection `json:"batches"`
	// The description of the key pool.
	Description string `json:"description"`
	// The key pool ID, which is unique.
	ID string `json:"id"`
	// The product type associated with the key pool, which determines what kind of keys are generated.
	ProductType string `json:"productType"`
	// The SKU associated with the key pool, which is used to redeem content.
	Sku string `json:"sku"`
	// Status of the key pool, which can be active, inactive, or invalidated.
	Status KeyPoolStatus `json:"status"`
}

// Caller should store all of these fields.
type LWAToken struct {
	// Access token to pass in on subsequent requests.
	AccessToken string `json:"accessToken"`
	// TTL in seconds, default is 3600.
	ExpiresIn int `json:"expiresIn"`
	// Should be stored, though generally shouldn't change.
	RefreshToken string `json:"refreshToken"`
}

// The details of Leaderboard format.
type LeaderboardDetails struct {
	// The max participant count for a lobby in phase. Valid values are 1-100.
	LobbyMaxSize int `json:"lobbyMaxSize"`
	// The number of phases to be created for the competition. Valid values are 1-20.
	PhaseCount int `json:"phaseCount"`
	// A display string conveying how a Competition Organizer intends to resolve ties.
	TiebreakerLabel *TiebreakerLabel `json:"tiebreakerLabel"`
}

func (LeaderboardDetails) IsFormatTypeDetails() {}

// LeaderboardSet contains the set of leaderboards that are active on a channel.
type LeaderboardSet struct {
	// bits contains the leaderboard of top users by number of bits cheered for the channel.
	Bits *UserLeaderboard `json:"bits"`
	// subGift contains the leaderboard of top users by number of sub gifts given in the channel.
	SubGift *UserLeaderboard `json:"subGift"`
}

// Partner dashboard settings for the bits cheering and sub gifting leaderboards.
type LeaderboardSettings struct {
	// The default leaderboard the user wants to show.
	DefaultLeaderboard LeaderboardType `json:"defaultLeaderboard"`
	// Flag that is true if the user has bits cheering leaderboards turned on.
	IsCheerEnabled bool `json:"isCheerEnabled"`
	// Flag that is true if the user has sub gifting leaderboards turned on.
	IsSubGiftEnabled bool `json:"isSubGiftEnabled"`
	// The time period the user wants the leaderboard to be displayed as.
	TimePeriod LeaderboardTimePeriodType `json:"timePeriod"`
}

type LeaveChannelRoomsInput struct {
	ChannelID string `json:"channelID"`
}

type LeaveChannelRoomsPayload struct {
	Channel *User `json:"channel"`
}

// Inputs to the leaveRaid mutation.
type LeaveRaidInput struct {
	// The raid ID being left by the user.
	RaidID string `json:"raidID"`
}

// Outputs from the leaveRaid mutation.
type LeaveRaidPayload struct {
	// The ID of the raid that was joined by the user.
	RaidID *string `json:"raidID"`
}

// LeaveSquadStreamError is the error associated with a leaveSquadStream.
type LeaveSquadStreamError struct {
	// The associated error code.
	Code LeaveSquadStreamErrorCode `json:"code"`
}

// Inputs to the leaveSquadStream mutation.
type LeaveSquadStreamInput struct {
	// The optional ID of a squad member that is leaving the squad (defaults to ID from auth token).
	MemberID string `json:"memberID"`
	// The ID of the squad stream that the caller wants to leave.
	SquadStreamID string `json:"squadStreamID"`
}

// Outputs from the leaveSquadStream mutation.
type LeaveSquadStreamPayload struct {
	// The possible error returned from the service.
	Error *LeaveSquadStreamError `json:"error"`
	// The updated squad stream.
	SquadStream *SquadStream `json:"squadStream"`
}

// LinkOEmbed is a link oEmbed.  This looks strange being empty, but mirrors the oEmbed official spec most exactly.
type LinkOEmbed struct {
	AuthorName   *string          `json:"authorName"`
	AuthorURL    *string          `json:"authorURL"`
	CacheAge     *int             `json:"cacheAge"`
	InputURL     string           `json:"inputURL"`
	ProviderName *string          `json:"providerName"`
	ProviderURL  *string          `json:"providerURL"`
	Thumbnail    *ThumbnailOEmbed `json:"thumbnail"`
	Title        *string          `json:"title"`
	Type         string           `json:"type"`
	Version      string           `json:"version"`
}

func (LinkOEmbed) IsPostEmbed() {}
func (LinkOEmbed) IsOEmbed()    {}
func (LinkOEmbed) IsFeedEmbed() {}

// LinkSSOError is an error that occurs when account linking fails.
type LinkSSOError struct {
	// The error code that describes why account linking failed.
	Code LinkSSOErrorCode `json:"code"`
}

// LinkSSOInput links an SSO app to the authenticated user's account if the activation code is valid.
type LinkSSOInput struct {
	// The code that identifies the single sign-on (SSO) app that should be linked to the authenticated user's account.
	Code string `json:"code"`
}

// LinkSSOPayload returns the newly created link or an error if account linking failed.
type LinkSSOPayload struct {
	// The error when an app cannot be linked to the user's account.
	Error *LinkSSOError `json:"error"`
	// The new SSO link.
	Link *SSOLink `json:"link"`
}

// LiveConfigView holds the view configuration of an extension if the live config dashboard page is supported.
type LiveConfigView struct {
	// Specifies whether or not the extension has the ability to link to external websites.
	CanLinkExternalContent bool `json:"canLinkExternalContent"`
	// Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
	ViewerPath string `json:"viewerPath"`
	// The URL which should be loaded in for the extension.
	ViewerURL string `json:"viewerURL"`
}

func (LiveConfigView) IsExtensionView() {}

// LiveConfigViewInput holds the view configuration of an extension if the live config dashboard page is supported.
type LiveConfigViewInput struct {
	// Relative path of the HTML file to load for this view.
	ViewerPath string `json:"viewerPath"`
}

type LiveRecommendationConnection struct {
	// The list of recommended streams with metadata to display.
	Edges []*StreamRecommendationEdge `json:"edges"`
	// Per-generation tracking id for identifying a recommendation model.
	GenerationID string `json:"generationID"`
	// The list of recommended streams to display.
	Nodes []*Stream `json:"nodes"`
	// Unique tracking id per response.
	ResponseID string `json:"responseID"`
}

// Information about the live up notification of a user.
type LiveUpNotificationInfo struct {
	// Whether the user's liveUpNotification field is the default value (i.e. "<user> went live!").
	IsDefault *bool `json:"isDefault"`
	// The text that will be in the notification that sends when the user starts broadcasting.
	// The default value is currently a translated version of "<user> went live!" when the user has not set a custom value.
	LiveUpNotification *string `json:"liveUpNotification"`
}

// An error returned from the lockPredictionEvent mutation.
type LockPredictionEventError struct {
	// Code describing the error.
	Code LockPredictionEventErrorCode `json:"code"`
}

// Input for moving a Prediction Event from ACTIVE to LOCKED, so that users can no longer make predictions on it.
type LockPredictionEventInput struct {
	// The unique identifier of the Prediction Event to move from ACTIVE to LOCKED.
	ID string `json:"id"`
}

// Payload from closing a prediciton event to new predictions.
type LockPredictionEventPayload struct {
	// If present, there was an error with the request.
	Error *LockPredictionEventError `json:"error"`
	// The updated Prediction Event.
	PredictionEvent *PredictionEvent `json:"predictionEvent"`
}

// Communicates a Loyalty Badge (usually during upload).
type LoyaltyBadge struct {
	// Unique identifier the badges method of tenure by channelid and cumulative months.
	ChannelTenureMethodID string `json:"channelTenureMethodID"`
	// The channel's loyalty badge unique identifier.
	ID string `json:"id"`
	// image1xURL to retrieve the 1x sized Badge.
	Image1xURL string `json:"image1xURL"`
	// Image1xURL to retrieve the 2x sized Badge.
	Image2xURL string `json:"image2xURL"`
	// image4xURL to retrieve the 4x sized Badge.
	Image4xURL string `json:"image4xURL"`
	// Identifies the amount of cumulative tenure months to acquire Badge.
	RequiredTenureMonths int `json:"requiredTenureMonths"`
	// A localized, human-friendly title for the badge.
	// Defaults to English if no translation exists for the requested locale.
	Title string `json:"title"`
}

// LoyaltyBadgeUploadConfig is the upload configuration for creating loyalty badges.
type LoyaltyBadgeUploadConfig struct {
	// The image ID of the badge image.
	ImageID *string `json:"imageID"`
	// The resulting URL of the badge image.
	ImageURL *string `json:"imageURL"`
	// The upload ID of the badge file.
	UploadID *string `json:"uploadID"`
	// The URL to upload the badge image to.
	UploadURL *string `json:"uploadURL"`
}

// Input for creating a batch download URL for key codes.
type MakeKeyBatchDownloadURLInput struct {
	// The ID of the batch to download.
	BatchID string `json:"batchID"`
}

// The results of creating a key batch download.
type MakeKeyBatchDownloadURLPayload struct {
	// The decryption key to decrypt the batch of keys.
	DecryptionKey string `json:"decryptionKey"`
	// The URL created for downloading the batch of keys.
	URL string `json:"url"`
}

// An error returned from the makePrediction mutation.
type MakePredictionError struct {
	// Code describing the error.
	Code MakePredictionErrorCode `json:"code"`
	// If the error code is MAX_POINTS_PER_EVENT, this will specify how many total points the user is allowed to spend.
	MaxPointsPerEvent *int `json:"maxPointsPerEvent"`
	// If the error code is MAX_POINTS_PER_EVENT, this will specify how many points the user has already spent.
	UserPointsSpent *int `json:"userPointsSpent"`
}

// Input for making a Prediction.
type MakePredictionInput struct {
	// The unique identifier of the Prediction Event to make the prediction on.
	EventID string `json:"eventID"`
	// The unique identifier of the Prediction Outcome to make the prediction on.
	OutcomeID string `json:"outcomeID"`
	// The number of points to spend on this Prediction.
	Points int `json:"points"`
	// Client-set identifier for the transaction. This ID should be universally unique.
	TransactionID string `json:"transactionID"`
}

// Payload for making a prediction.
type MakePredictionPayload struct {
	// If present, there was an error with the request.
	Error *MakePredictionError `json:"error"`
	// The created or updated Prediction.
	Prediction *Prediction `json:"prediction"`
}

// A custom challenge created by the broadcaster.
type ManualChannelChallenge struct {
	// Total bits amount contributed.
	BitsAmount int `json:"bitsAmount"`
	// Time when challenge was created.
	CreatedAt time.Time `json:"createdAt"`
	// User that created the challenge.
	CreatedBy *User `json:"createdBy"`
	// Amount of seconds from when the challenge starts to when it ends.
	DurationSeconds int `json:"durationSeconds"`
	// ID of challenge.
	ID string `json:"id"`
	// User who owns this challenge. The challenge will appear on their channel.
	OwnedBy *User `json:"ownedBy"`
	// Amount of milliseconds before the challenge times out.
	// 0 when the challenge has timed out.
	RemainingDurationMilliseconds int `json:"remainingDurationMilliseconds"`
	// The authenticated user's relationship with this challenge.
	// Main use case is to connect the user to a challenge to allow bit contributions.
	// Null if un-authenticated user is making this query.
	Self *ChannelChallengeSelfEdge `json:"self"`
	// The status of the challenge.
	Status ChannelChallengeStatus `json:"status"`
	// Title of the challenge.
	Title string `json:"title"`
	// Time when challenge was updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

func (ManualChannelChallenge) IsChannelChallenge() {}

// Drop manually triggered.
type ManualTriggerBasedDrop struct {
	// The rewards for this drop and how often those rewards can be awarded.
	BenefitEdges []*DropBenefitEdge `json:"benefitEdges"`
	// The campaign this drop belongs to.
	Campaign *DropCampaign `json:"campaign"`
	// Amount of time the viewer has to claim the drop after the rule is completed.
	ClaimDurationSeconds int `json:"claimDurationSeconds"`
	// The time this drop becomes unavailable.
	EndAt time.Time `json:"endAt"`
	// A unique identifier.
	ID string `json:"id"`
	// The name of this drop.
	Name string `json:"name"`
	// The time this drop becomes available.
	StartAt time.Time `json:"startAt"`
}

func (ManualTriggerBasedDrop) IsDropType() {}

// ManuallyTriggerDrop has fields required to update a campaign summary.
type ManuallyTriggerDropInput struct {
	// The id of the campaign that includes the drop to trigger.
	CampaignID string `json:"campaignID"`
	// The id of the drop to trigger.
	DropID string `json:"dropID"`
	// This is the Organization ID (RBAC) to determine access / ownership of the campaign and attached drops.
	OwnerID string `json:"ownerID"`
}

// ManuallyTriggerDropPayload returns the result of the creation/update.
type ManuallyTriggerDropPayload struct {
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
	// Returns a list of channels the drop was tried to be triggered on and the trigger restult.
	TriggerResults []*TriggerResult `json:"triggerResults"`
}

// Input for readAllCreatorNotifications mutation.
type MarkAllCreatorNotificationsAsReadInput struct {
	// The ID of the user performing the reading.
	UserID string `json:"userID"`
}

// The result of a readAllCreatorNotifications mutation.
type MarkAllCreatorNotificationsAsReadPayload struct {
	// Whether the mutation succeeded.
	HasSucceeded *bool `json:"hasSucceeded"`
}

// Input for readAllViewerNotifications mutation.
type MarkAllViewerNotificationsAsReadInput struct {
	// The ID of the user performing the reading.
	UserID string `json:"userID"`
}

// The result of a readAllViewerNotifications mutation.
type MarkAllViewerNotificationsAsReadPayload struct {
	// Whether the mutation succeeded.
	HasSucceeded *bool `json:"hasSucceeded"`
}

// A message from a user.
type Message struct {
	// The text and emoticon content of a message.
	Content *MessageContent `json:"content"`
	// Time the message was deleted or purged. Null if the message is not deleted.
	DeletedAt *time.Time `json:"deletedAt"`
	// UUID of the message.
	ID string `json:"id"`
	// Replies to this message.
	Replies *MessageReplyConnection `json:"replies"`
	// The user that sent the message.
	Sender *User `json:"sender"`
	// Time the message was sent.
	SentAt time.Time `json:"sentAt"`
}

// MessageBody is a way of encoding emote annotated text.  The original text is included as content and the
// parsed emotes are included which indicate the start and end indexes they should replace.
type MessageBody struct {
	// The text content of the body.
	Content *string `json:"content"`
	// Collection of rune indexed emotes to be replaced clientside.
	Emotes []*EmbeddedEmote `json:"emotes"`
}

// The content of a user's message to a channel's chat.
type MessageContent struct {
	// Parsed list of fragments in the message, include emotes, mentions, and plaintext.
	Fragments []*MessageFragment `json:"fragments"`
	// String representation of the user message.
	Text string `json:"text"`
}

// One parsed part of a message, which may be an emote, mention, or plaintext.
type MessageFragment struct {
	// Contains an emote or a mentioned user depending on the text of the fragment.
	Content FragmentContent `json:"content"`
	// Plaintext representation of the fragment.
	Text string `json:"text"`
}

// A list of messages.
type MessageReplyConnection struct {
	// Nodes is the list of replies to a message.
	Nodes []*Message `json:"nodes"`
	// The total number of replies to a message.
	TotalCount int `json:"totalCount"`
}

// Milestone is a construct is used within a tournament. For a given threshold, when the user
// cheers at or past this amount, they are able to claim a reward for cheering at this level.
// Rewards can be fulfilled by different platforms.
// Types of milestones:
// - **Global milestone**: for a given threshold, this milestone is reached when cheers from all
//   users on the channel is greater than or equal to the threshold.
//   This unlocks a reward for all users who have cheered.
// - **Individual milestone**: for a given threshold, this milestone is reached when an individual
//   user's total cheers in the channel is greater than or equal to the threshold.
//   This unlocks a reward for the individual user who cheered.
// - **Team milestone**: for a given threshold, this milestone is reached when an individual cheers
//   for a specific team in total is greater than or equal to the threshold.
//   This unlocks a reward for the individual user who cheered.
//
// NOTE: Should have been named CheeringTournamentMilestone.
type Milestone struct {
	// End date for when a milestone is no longer active.
	EndDate string `json:"endDate"`
	// GraphQL ID of the milestone.
	ID string `json:"id"`
	// Whether the milestone is for prime users only.
	IsPrimeOnly bool `json:"isPrimeOnly"`
	// The type of milestone this is for. e.g INDIVIDUAL or GLOBAL.
	ObjectiveTag string `json:"objectiveTag"`
	// Threshold that needs to be cheered by an individual to claim reward.
	ParticipationThreshold int `json:"participationThreshold"`
	// The subs that this milestone’s completion requires.
	RequiredSubscriptions []*SubscriptionProduct `json:"requiredSubscriptions"`
	// The rewards associated with milestones.
	Rewards []*TournamentReward `json:"rewards"`
	// Start date for when a milestone is active.
	StartDate string `json:"startDate"`
	// Threshold that needs to be cheered to claim reward.
	Threshold int `json:"threshold"`
}

// MobileAdIdentityInput contains mobile device information.
type MobileAdIdentityInput struct {
	// deviceInfo is a MobileAdDeviceInfo contains a certain number of attributes required by TIFA.
	DeviceInfo *MobileDeviceInfo `json:"deviceInfo"`
	// lmt is limit ad tracking signal read from mobile device.
	Lmt bool `json:"lmt"`
	// mAID is the mobile ad identifier.
	MAid string `json:"mAID"`
	// platform is an enum that describes the device platform.
	Platform AdPlatform `json:"platform"`
	// userAgent is a string sent by mobile clients.
	UserAgent string `json:"userAgent"`
}

// MobileDeviceInfo contains attributes required by TIFA.
type MobileDeviceInfo struct {
	// Hardware brand name, ex. samsung.
	Make string `json:"make"`
	// Hardware model, ex: "Galaxy S10".
	Model string `json:"model"`
	// Hardware os: ex. "Android".
	Os string `json:"os"`
	// Os version number.
	OsVersion string `json:"osVersion"`
}

// MobileView holds the view configuration of an extension if mobile is supported.
type MobileView struct {
	// Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
	ViewerPath string `json:"viewerPath"`
	// The URL which should be loaded in for the extension.
	ViewerURL string `json:"viewerURL"`
}

func (MobileView) IsExtensionView() {}

// MobileViewInput holds the view configuration of an extension if mobile is supported.
type MobileViewInput struct {
	// Relative path of the HTML file to load for this view.
	ViewerPath string `json:"viewerPath"`
}

// Paginated list of moderators of a channel.
type ModConnection struct {
	// The elements of the list.
	Edges []*ModEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Element in a list of moderators of a channel.
type ModEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// Timestamp of when the moderator status was granted.
	GrantedAt time.Time `json:"grantedAt"`
	// Whether the moderator is connected to the channel's chat.
	IsActive *bool `json:"isActive"`
	// The user that is a moderator.
	Node *User `json:"node"`
}

// An interface to query subsets of the moderation logs information for a given channel.
type ModLogs struct {
	// The comments left by moderators on a specified user on the given channel.
	Comments *ModLogsCommentConnection `json:"comments"`
	// The chat history for an specified user on a given channel.
	MessagesBySender *ModLogsMessageConnection `json:"messagesBySender"`
	// The chat moderation history on a specified user on the given channel.
	TargetedModActions *ModLogsTargetedModActionsConnection `json:"targetedModActions"`
}

// ModLogsAccess defines the access level of a channel role to the channel's moderator logs.
type ModLogsAccess struct {
	// The access level to moderator logs.
	AccessLevel ModLogsAccessLevel `json:"accessLevel"`
	// The user role.
	ChannelRole ChannelUserRole `json:"channelRole"`
}

// ModLogsCommentsEntry defines an entry of a user's moderation history on a channel.
type ModLogsComment struct {
	// Author is the moderator that created the comment.
	Author *User `json:"author"`
	// Channel is where the moderator comment was created.
	Channel *User `json:"channel"`
	// Details about the moderator comment.
	Details *ModLogsCommentDetails `json:"details"`
	// UUID of the moderator comment.
	ID string `json:"id"`
	// Target is the target user of the moderator comment.
	Target *User `json:"target"`
	// Timestamp when comment was created.
	Timestamp time.Time `json:"timestamp"`
}

// Paginated list of moderator comments on a user in a channel.
type ModLogsCommentConnection struct {
	// The elements of the list.
	Edges []*ModLogsCommentEdge `json:"edges"`
	// Information about this page of mod logs.
	PageInfo *PageInfo `json:"pageInfo"`
}

// ModLogsCommentDetails contains the details of a moderator comment.
type ModLogsCommentDetails struct {
	// Body of the comment.
	Text *string `json:"text"`
}

// Element in a list of moderator comments on a user in a channel.
type ModLogsCommentEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// A moderator comment on a user in a channel.
	Node *ModLogsComment `json:"node"`
}

// A message sent from a user to a room.
type ModLogsMessage struct {
	// The text and emoticon content of a message.
	Content *ModLogsMessageContent `json:"content"`
	// UUID of the message.
	ID string `json:"id"`
	// The user that sent the message.
	Sender *User `json:"sender"`
	// Time the message was sent.
	SentAt time.Time `json:"sentAt"`
}

func (ModLogsMessage) IsModLogsMessageResult() {}

// Paginated list of messages from a single sender in a channel.
type ModLogsMessageConnection struct {
	// The elements of the list.
	Edges []*ModLogsMessageEdge `json:"edges"`
	// The partial count of messages (up to 1000).
	// Empty if includeMessageCount was not set when the query was requested.
	MessageCount *int `json:"messageCount"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// The content of a user's message to a room.
type ModLogsMessageContent struct {
	// Parsed list of fragments in the message, include emotes, mentions, and plaintext.
	Fragments []*ModLogsMessageFragment `json:"fragments"`
	// String representation of the user message.
	Text string `json:"text"`
}

// Element in a list of messages.
type ModLogsMessageEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// The message or targeted moderation action.
	Node ModLogsMessageResult `json:"node"`
}

// One parsed part of a message, which may be an emote, mention, or plaintext.
type ModLogsMessageFragment struct {
	// Contains an emote or a mentioned user depending on the text of the fragment.
	Content FragmentContent `json:"content"`
	// Plaintext representation of the fragment.
	Text string `json:"text"`
}

// Paginated list of mod logs of a user on a channel.
type ModLogsTargetedModActionsConnection struct {
	// The partial count of targeted mod actions (bans or timeouts), up to 100.
	// Does not count undo actions (unbans or untimeouts).
	ActionCount int `json:"actionCount"`
	// The elements of the list.
	Edges []*ModLogsTargetedModActionsEdge `json:"edges"`
	// Information about this page of mod logs.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Element in a list of mod logs of a user on a channel.
type ModLogsTargetedModActionsEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// A mod log of the user.
	Node *ModLogsTargetedModActionsEntry `json:"node"`
}

// ModLogsTargetedModActionsEntry defines an entry of a user's moderation history on a channel.
type ModLogsTargetedModActionsEntry struct {
	// Action is the mod action of the entry.
	Action ModLogsAction `json:"action"`
	// Channel is where the mod action was taken.
	Channel *User `json:"channel"`
	// Details about the mod action.
	Details *TargetedModActionDetails `json:"details"`
	// The UUID of the entry.
	ID string `json:"id"`
	// Target is the target user of the mod action.
	Target *User `json:"target"`
	// Timestamp when entry was created.
	Timestamp time.Time `json:"timestamp"`
	// User is the mod that created the action.
	User *User `json:"user"`
}

func (ModLogsTargetedModActionsEntry) IsModLogsMessageResult() {}

// ModUserError contains details about a client error that occurred.
type ModUserError struct {
	// The enum indicating what error has occurred.
	Code ModUserErrorCode `json:"code"`
}

// ModUserInput contains the parameters to add a user as a moderator to a channel.
type ModUserInput struct {
	// The channel that the user will be added as a moderator to.
	ChannelID string `json:"channelID"`
	// The ID of the user that will be added as a moderator.
	// Either targetID or targetLogin must be provided.
	TargetID *string `json:"targetID"`
	// The login of the user that will be added as a moderator.
	// Either targetID or targetLogin must be provided.
	TargetLogin *string `json:"targetLogin"`
}

// ModUserPayload is the response when adding a user as a moderator.
type ModUserPayload struct {
	// The channel that the user is added as a moderator to.
	Channel *User `json:"channel"`
	// The client error that has occurred.
	// Null if the operation is successful.
	Error *ModUserError `json:"error"`
	// The user that is added as a moderator.
	Target *User `json:"target"`
}

// ModViewNewsfeedEntry is an entry that displays content for the Mod View page's "What's New" feed.
type ModViewNewsfeedEntry struct {
	// content is localized text content for the changelog entry.
	Content string `json:"content"`
	// iconURL is the url for the entry's icon image.
	IconURL *string `json:"iconURL"`
	// id is a unique human readable slug for the entry e.g. "squad-stream".
	ID string `json:"id"`
	// linkText is the text that the linkURL should display.
	LinkText *string `json:"linkText"`
	// linkURL is an optional link for more content for this changelog entry.
	LinkURL *string `json:"linkURL"`
	// position is where entry should be located within changelog entries of the same date.
	Position int `json:"position"`
	// publishedAt is the timestamp that the changelog entry was published.
	PublishedAt *time.Time `json:"publishedAt"`
	// title is the localized title of the changelog entry.
	Title string `json:"title"`
}

// Settings for Mod View Page.
type ModViewSettings struct {
	// Date that tuorial was SEEN (nullable when tutorial is dismissed or unseen).
	TutorialSeenAt *time.Time `json:"tutorialSeenAt"`
	// Setting to store whether the user has completed the mod view tutorial.
	TutorialState *TutorialState `json:"tutorialState"`
}

// An interface to query subsets of the moderation logs information for a given channel.
type ModerationLogs struct {
	// The moderation actions that have been take in the given channel.
	Actions *ChannelModerationActionConnection `json:"actions"`
}

// Movie metadata.
type MovieDetails struct {
	// Total length of the content.
	DurationSeconds *int `json:"durationSeconds"`
}

func (MovieDetails) IsWatchPartyItemDetails() {}

// A multiplayer ad offer is an ad offer.
type MultiplayerAdOffer struct {
	// The duration of the ad in seconds.
	AdDurationSeconds int `json:"adDurationSeconds"`
	// The name of the brand associated with the ad.
	BrandName *string `json:"brandName"`
	// The message to be display to the broadcaster.
	BroadcasterMessage *string `json:"broadcasterMessage"`
	// When the offer expires.
	ExpiresAt time.Time `json:"expiresAt"`
	// The offer's unique identifier.
	ID string `json:"id"`
	// If offer has reward, the max rate for reward. (e.g. vote per bits for polling).
	RewardsMaxRate *float64 `json:"rewardsMaxRate"`
	// If offer has reward, the min rate for reward. (e.g. vote per bits for polling).
	RewardsMinRate *float64 `json:"rewardsMinRate"`
}

// Multi-view content attribute(s) are used to augment the multi-view experience.
// they are used for filterings and groupings of chanlets to help viewers find content that they are interested in.
type MultiviewContentAttribute struct {
	// childIDs is an optional list of child content attribute ids.
	ChildIDs []string `json:"childIDs"`
	// Time when this content attribute is created.
	CreatedAt *time.Time `json:"createdAt"`
	// id is a unique identifier generated on the server side.
	ID string `json:"id"`
	// URL to the image (icon) of the content attribute.
	ImageURL *string `json:"imageURL"`
	// key is a grouping identifier for content attributes of the same type.
	Key string `json:"key"`
	// name is a human-readable string of the content attribute type.
	Name string `json:"name"`
	// ownerChannel is the channel that this content attribute is created under.
	OwnerChannel *Channel `json:"ownerChannel"`
	// parentID is an optional pointer to specify the parent attribute.
	ParentID *string `json:"parentID"`
	// parentKey is an optional pointer to specifiy the key of the parent attribute.
	ParentKey *string `json:"parentKey"`
	// Time when this content attribute is last modified.
	UpdatedAt *time.Time `json:"updatedAt"`
	// value is the human-readble value of the attribute value.
	Value string `json:"value"`
	// valueShortName is an optional abbreviation of value.
	ValueShortName *string `json:"valueShortName"`
}

// Contains all information to create a new content attribute.
type MultiviewContentAttributeParams struct {
	// Optional list of child content attribute ids.
	ChildIDs []string `json:"childIDs"`
	// Unique identifier.
	ID *string `json:"id"`
	// Optional an URL to the icon of this content attribute.
	ImageURL *string `json:"imageURL"`
	// Indicates the type of the attribute.
	Key string `json:"key"`
	// Human-readable name of the attribute.
	Name string `json:"name"`
	// The channel that the content attribute is created under.
	OwnerChannelID *string `json:"ownerChannelID"`
	// Optional pointer to a parent content attribute instance.
	ParentID *string `json:"parentID"`
	// Optional pointer to a parent content attribute key.
	ParentKey *string `json:"parentKey"`
	// value of the attribute.
	Value string `json:"value"`
	// Optional abbreviation of value.
	ValueShortName *string `json:"valueShortName"`
}

// Information about a registered developer OAuth application.
type OAuthApp struct {
	// The category that describes the app's type.
	Category *OAuthAppCategory `json:"category"`
	// The timestamp when the app was created.
	CreatedAt time.Time `json:"createdAt"`
	// The ID of the app. It is the value of the `Client-ID` header when the app makes API requests.
	ID string `json:"id"`
	// The name of the app.
	Name string `json:"name"`
	// The user-provided description of the app's type. Used if `Category` is Other.
	OtherDescription *string `json:"otherDescription"`
	// Owner is the user that owns this app.
	Owner *User `json:"owner"`
	// The URI to which users should be redirected after authorizing the app.
	RedirectURI string `json:"redirectURI"`
	// The client secret of the app.
	Secret string `json:"secret"`
	// The timestamp when the app was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
	// Whether the app's OAuth tokens expire.
	WillTokensExpire bool `json:"willTokensExpire"`
}

// A list of applications.
type OAuthAppConnection struct {
	// The applications.
	Edges []*OAuthAppEdge `json:"edges"`
	// Pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// A broadcaster user with cursor.
type OAuthAppEdge struct {
	// Cursor represents the position of the current edge/node.
	Cursor string `json:"cursor"`
	// Node represents the app for the current edge.
	Node *OAuthApp `json:"node"`
}

// Offer describes something that is purchasable.
type Offer struct {
	// Details of the user's eligibility to purchase the Offer.
	Eligibility *OfferEligibility `json:"eligibility"`
	// The time at which this Offer ceases to be valid for purchase. If null, this Offer will never expire.
	EndAt *time.Time `json:"endAt"`
	// The type of the gift offer (will be omitted if the Offer is not a gift).
	GiftType *GiftType `json:"giftType"`
	// Unique identifier for an Offer.
	ID string `json:"id"`
	// A listing describing the charge model and cancellation policy for the Offer.
	Listing *OfferListing `json:"listing"`
	// The platform on which the Offer is eligible for purchase.
	Platform OfferPlatform `json:"platform"`
	// A Promotion object describes the promotion to be applied on an Offer (if any).
	Promotion *OfferPromotion `json:"promotion"`
	// Quantity is the configured purchase quantity restrictions.
	Quantity *Range `json:"quantity"`
	// The authenticated user's relationship with the Offer.
	Self *OfferSelfEdge `json:"self"`
	// The time at which this Offer becomes valid for purchase.
	StartAt time.Time `json:"startAt"`
	// Tag bindings provide static and dynamic bindings of the attributes on an Offer.
	TagBindings []*OfferTagBinding `json:"tagBindings"`
	// Tenant product line registry to which this Offer belongs.
	Tplr string `json:"tplr"`
}

// Contains an offer ID and offer status.
type OfferAndStatus struct {
	// Unique Identifier for an offer.
	OfferID string `json:"offerID"`
	// The status to set the offer to for the specified user.
	Status string `json:"status"`
}

// OfferEligibility describes user's eligibility to purchase an Offer.
type OfferEligibility struct {
	// If the user is eligible for the Offer, then this is set to the
	// time at which the user's benefits would expire if the
	// Offer is purchased. If null, the benefits never expire.
	BenefitsEndAt *time.Time `json:"benefitsEndAt"`
	// If the user is eligible for the Offer, then this is set to the
	// time at which the user's benefits would become available if the
	// Offer is purchased.
	BenefitsStartAt *time.Time `json:"benefitsStartAt"`
	// A boolean that is true when the user is eligible for the Offer.
	IsEligible bool `json:"isEligible"`
	// Allows tenants to override the maximum purchasable quantity for an offer
	// within a checkout session (used in purchase velocity cases).
	MaxQuantityOverride *int `json:"maxQuantityOverride"`
	// Provides extra contextual details for the type of purchase.
	PurchaseType OfferPurchaseType `json:"purchaseType"`
	// If the user is ineligible for the Offer, then this code is set
	// as the reason why the user is ineligible.
	ReasonCode *OfferIneligibilityReasonCode `json:"reasonCode"`
}

// OfferListing defines the charge model for a given listing.
type OfferListing struct {
	// The conditions around a user's cancellation of their purchase (e.g. refund policy).
	CancellationPolicy CancellationPolicyType `json:"cancellationPolicy"`
	// FIAT/non-FIAT based charge model OR 3P managed SKU.
	ChargeModel *ChargeModel `json:"chargeModel"`
}

// Promotion is a modifier to an Offer.
type OfferPromotion struct {
	// End time of a promotion (empty if evergreen promotion).
	EndAt *time.Time `json:"endAt"`
	// Unique identifier for a Promotion.
	ID string `json:"id"`
	// The OfferListing associated with this Promotion.
	Listing *OfferListing `json:"listing"`
	// Unique name for a Promotion.
	Name string `json:"name"`
	// Describes the priority of the Promotion (the higher the priorty, the more important the promo).
	Priority int `json:"priority"`
	// Describe the Promotions metadata to display to the client.
	PromoDisplay *PromotionDisplay `json:"promoDisplay"`
	// Start time of a promotion.
	StartAt time.Time `json:"startAt"`
}

// The authenticated user's relationship with the offer.
type OfferSelfEdge struct {
	// Returns any fraud-related checkout actions that the client must invoke.
	CheckoutActions []CheckoutAction `json:"checkoutActions"`
	// Configs that initiate the user's checkout flow for this Offer.
	CheckoutConfiguration *CheckoutConfiguration `json:"checkoutConfiguration"`
	// Provides a list of eligible payment methods that the user can select for this offer.
	EligiblePaymentMethods []*EligiblePaymentMethod `json:"eligiblePaymentMethods"`
}

// OfferTagBinding defines a key-value pair.
type OfferTagBinding struct {
	// The key of the tag.
	Key string `json:"key"`
	// The value of the tag.
	Value string `json:"value"`
}

// OfferTagBindingInput defines a key-value pair.
type OfferTagBindingInput struct {
	// The key of the tag.
	Key string `json:"key"`
	// The value of the tag.
	Value string `json:"value"`
}

// Current state of the user in the onboarding process.
type Onboarding struct {
	// Retrieves a list of streams that have been selected for onboarding based on a user's followed games.
	// `first` is the number of streams PER FOLLOWED GAME to fetch.
	// `locale` is a language code that will filter streams by if there are viewers with that language code (ex. "en-US", "es-ES", or "de-AT").
	// `languages` is list of language codes that will be used to filter streams by the broadcaster language. (ex. [EN, KO]).
	// `games` are a list of game ids that would replace the user's followed games for fetching the streams.
	OnboardingStreams []*Stream `json:"onboardingStreams"`
	// List of channel IDs skipped by a user during onboarding.
	SkippedChannelIDs []string `json:"skippedChannelIDs"`
}

type OnsiteNotification struct {
	// Actions of the notification.
	Actions []*OnsiteNotificationAction `json:"actions"`
	// Body of the notification in Markdown format.
	Body string `json:"body"`
	// Category of the notification (only for dart ones).
	Category *string `json:"category"`
	// When this notification was created.
	CreatedAt time.Time `json:"createdAt"`
	// List of users that created this notification.
	Creators []*User `json:"creators"`
	// Destination type to route users to when they interact with the notification on non-web clients.
	// Values include Homepage, ChannelPage, NotificationSettingsPage, and BroadcasterDashboard.
	DestinationType *string `json:"destinationType"`
	// Determines where the notification will be displayed at front end.
	DisplayType OnsiteNotificationDisplayType `json:"displayType"`
	// Optional extra notification content.
	// When type is "vodupload", extra is Video.
	// When type is "hotclipfollower", extra is Clip.
	// When type is "hotclip", extra is Clip.
	// When type is "subgiftreceived", extra is User.
	// When type is "vodcomment", extra is VideoComment.
	// When type is "vodcommentmod", extra is VideoComment.
	// When type is "vodcommentreply", extra is VideoComment.
	// When destination is "ChannelPage", extra is User.
	// When destination is "BrowseGame", extra is Game.
	// When destination is "ExternalLink", extra is OnsiteNotificationExternalLink.
	Extra OnsiteNotificationContent `json:"extra"`
	// ID of the notification.
	ID string `json:"id"`
	// Whether this notification is read.
	IsRead bool `json:"isRead"`
	// Type of onsite render style.
	RenderStyle OnsiteNotificationRenderStyle `json:"renderStyle"`
	// A URL to a thumbnail image.
	ThumbnailURL string `json:"thumbnailURL"`
	// Type of notification.
	Type string `json:"type"`
	// When notification was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

type OnsiteNotificationAction struct {
	// Body of the notification action in plain text.
	Body string `json:"body"`
	// ID of the action.
	ID string `json:"id"`
	// Label of the action.
	Label string `json:"label"`
	// ID of the modal that will open on click, if it is a modal CTA.
	ModalID string `json:"modalID"`
	// Type of the notification action.
	Type string `json:"type"`
	// URL of the notification action.
	URL string `json:"url"`
}

type OnsiteNotificationConnection struct {
	// List of notifications.
	Edges []*OnsiteNotificationEdge `json:"edges"`
	// Information about pagination in this connection.
	PageInfo *PageInfo `json:"pageInfo"`
	// Notifications summary.
	Summary *OnsiteNotificationsSummary `json:"summary"`
}

type OnsiteNotificationEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor *string `json:"cursor"`
	// The notification.
	Node *OnsiteNotification `json:"node"`
}

// Extra onsite notification content returned when the notification links to an external site.
type OnsiteNotificationExternalLink struct {
	// The link that the notification opens when clicked.
	URL string `json:"url"`
}

func (OnsiteNotificationExternalLink) IsOnsiteNotificationContent() {}

type OnsiteNotificationsSummary struct {
	// Unread summary for creator display type.
	CreatorUnreadSummary *OnsiteNotificationsUnreadSummary `json:"creatorUnreadSummary"`
	// Last time notifications were seen.
	LastSeenAt *time.Time `json:"lastSeenAt"`
	// Number of unseen notifications.
	UnseenCount int `json:"unseenCount"`
	// Unread summary for viewer display type.
	ViewerUnreadSummary *OnsiteNotificationsUnreadSummary `json:"viewerUnreadSummary"`
}

// Contains summary for unread infomation.
type OnsiteNotificationsUnreadSummary struct {
	// Last time user marked all as read.
	LastReadAllAt *time.Time `json:"lastReadAllAt"`
	// Number of unread notifications.
	UnreadCount int `json:"unreadCount"`
}

type OrderPanelsInput struct {
	Ids []string `json:"ids"`
}

type OrderPanelsPayload struct {
	// List of panels in their new order.
	Panels []Panel `json:"panels"`
}

// A developer organization.
type Organization struct {
	// The bounty board campaigns that the company owns.
	BountyCampaigns *BountyCampaignConnection `json:"bountyCampaigns"`
	// The brand portal settings for the company.
	BrandPortalSettings *BrandPortalSettings `json:"brandPortalSettings"`
	// ID of the Company in the CurseForge Infrastructure.
	CurseCompanyID *string `json:"curseCompanyID"`
	// Drop Campaigns developed by the organization.
	DropCampaigns []*DropCampaign `json:"dropCampaigns"`
	// Drop 2.0 Campaigns and Benefits configured for the organization.
	Drops *OrganizationDrops `json:"drops"`
	// The estimated viewer reach for the pool of broadcasters this company is considering targeting.
	EstimatedBroadcasterViewerReach *BroadcasterViewerReach `json:"estimatedBroadcasterViewerReach"`
	// The games associated with the company. Optionally include games that a company can use for Bounty Board
	// campaigns (ie. "Just Chatting" for trailer campaigns).
	Games []*Game `json:"games"`
	// The company's unique identifier.
	ID string `json:"id"`
	// List of pending invites.
	Invites *OrganizationInviteConnection `json:"invites"`
	// Legacy Companies need to agree to the Drops Terms.
	IsCampaignsEnabled bool `json:"isCampaignsEnabled"`
	// Legacy Companies are required to sign the Contract.
	IsContractSigned bool `json:"isContractSigned"`
	// Indicates if the Company is a Legacy Company from the first iteration of the DevSite.
	IsLegacy bool `json:"isLegacy"`
	// A list of rbac users who are apart of an organization.
	Members *OrganizationMemberConnection `json:"members"`
	// The human-readable name of the company.
	Name string `json:"name"`
	// Attributes related to the current user.
	Self *OrganizationSelfEdge `json:"self"`
	// Indicates if company is a developer, publisher or other.
	Type OrganizationType `json:"type"`
	// The Company URL for their Corporate Website.
	URL string `json:"url"`
}

// OrganizationApplication is the application for requesting an organization be added to Twitch Developer Organizations.
type OrganizationApplication struct {
	// Email of the person creating the application.
	// Deprecated as we are no longer collecting contact email. Using TwitchID and Dart to send notifications instead.
	ContactEmail *string `json:"contactEmail"`
	// The name of applying organization.
	OrganizationName string `json:"organizationName"`
	// Current status of the company application.
	Status OrganizationAppilcationStatus `json:"status"`
}

// OrganizationDrop links organizations to the campaigns it has configured
// and the benefits that it has created.
type OrganizationDrops struct {
	// The benefits created for this organization that can be added to the organization's drops.
	Benefits []*DropBenefit `json:"benefits"`
	// The campaigns configued for this organizaiton.
	Campaigns []*DropCampaign `json:"campaigns"`
}

// An invitation to join a developer organization under a given role.
type OrganizationInvite struct {
	// When the invitation was created.
	CreatedAt time.Time `json:"createdAt"`
	// The date and time the invite will expire.
	ExpiresAt time.Time `json:"expiresAt"`
	// The invites's unique identifier.
	ID string `json:"id"`
	// User the invitation if for.
	Invitee *User `json:"invitee"`
	// User who created the invitation.
	Inviter *User `json:"inviter"`
	// ID of the organization the invitation is for.
	OrganizationID string `json:"organizationID"`
	// Name of the organization the invitation is for.
	OrganizationName string `json:"organizationName"`
	// Role the invitation is for.
	Role OrganizationMemberRole `json:"role"`
}

// Paginated list of organization invites in an organization.
type OrganizationInviteConnection struct {
	// The elements of the paginated list.
	Edges []*OrganizationInviteEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of Organization invites.
	TotalCount int `json:"totalCount"`
}

// An element in a paginated list of organization invites.
// Contains metadata about the organization invites.
type OrganizationInviteEdge struct {
	// An opaque cursor identifying the edge's position in the paginted list.
	Cursor string `json:"cursor"`
	// The organization invite.
	Node *OrganizationInvite `json:"node"`
}

// Paginated list of organization invites for in a user.
type OrganizationInviteUserConnection struct {
	// The elements of the paginated list.
	Edges []*OrganizationInviteEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of Organization invites.
	TotalCount int `json:"totalCount"`
	// Whether or not the user is under the limit of allowed organization memberships.
	IsWithinOrganizationMembershipLimit *bool `json:"isWithinOrganizationMembershipLimit"`
}

// A RBAC user.
type OrganizationMember struct {
	// Users email.
	Email string `json:"email"`
	// Users first name.
	FirstName string `json:"firstName"`
	// Twitch user id.
	ID string `json:"id"`
	// Users last name.
	LastName string `json:"lastName"`
	// Users role.
	Role OrganizationMemberRole `json:"role"`
	// Users title.
	Title string `json:"title"`
	// The Twitch user associated with the RBAC user.
	User *User `json:"user"`
}

// A paginated list of organization member relationships.
type OrganizationMemberConnection struct {
	// The elements of the paginated list.
	Edges []*OrganizationMemberEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of Organization members.
	TotalCount int `json:"totalCount"`
}

// An element in a paginated list of organization member relationships.
// Contains metadata about the follow relationship between two users.
type OrganizationMemberEdge struct {
	// An opaque cursor identifying the edge's position in the paginted list.
	Cursor string `json:"cursor"`
	// Date user joined organization.
	JoinedAt time.Time `json:"joinedAt"`
	// The user who is organization members.
	Node *OrganizationMember `json:"node"`
}

// Parameters for filtering OrganizationMembers.
type OrganizationMembersInput struct {
	// Filter members with this role.
	Role *OrganizationMemberRole `json:"role"`
}

// The relationship between the authenticated user and a game.
type OrganizationSelfEdge struct {
	// Whether or not the current user is able to add another to the organization.
	CanAddMember bool `json:"canAddMember"`
	// Whether or not the current user is able to leave the organization.
	CanLeaveOrganization bool `json:"canLeaveOrganization"`
	// Whether or not the current user is able to remove a member from the organization.
	CanRemoveMember bool `json:"canRemoveMember"`
	// Date user joined organization.
	JoinedAt time.Time `json:"joinedAt"`
	// The current users role in the organization.
	Role OrganizationMemberRole `json:"role"`
}

// Friend requests sent from this user to other users.
type OutgoingFriendRequestConnection struct {
	// The friend request elements of this list.
	Edges []*OutgoingFriendRequestEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of outgoing friend requests.
	TotalCount int `json:"totalCount"`
}

// A friend request sent from this user to another user.
type OutgoingFriendRequestEdge struct {
	// The time at which the friend request was sent.
	CreatedAt time.Time `json:"createdAt"`
	// An opaque cursor identifying the edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// The user to whom the friend request was sent.
	Node *User `json:"node"`
}

func (OutgoingFriendRequestEdge) IsFriendRelationship() {}

// Contains Overwatch League Team preferences.
type OverwatchLeagueTeamPreference struct {
	// Set of available teams for selection.
	AvailableTeamsSet []*OverwatchTeamPreferenceOption `json:"availableTeamsSet"`
	// Unique identifier for this set of Overwatch team preferences.
	ID string `json:"id"`
	// The preferred team.
	SelectedTeam *OverwatchTeamPreferenceOption `json:"selectedTeam"`
}

// Moment Details specific to the overwatch game.
type OverwatchMomentDetails struct {
	// One of "game_start" or "hero_change".
	Event string `json:"event"`
	// The hero the broadcaster is playing.
	HeroName string `json:"heroName"`
	// The role the broadcaster is playing.
	Role string `json:"role"`
}

func (OverwatchMomentDetails) IsVideoMomentDetails() {}

// Contains an Overwatch team option to choose as the preferred team.
type OverwatchTeamPreferenceOption struct {
	// Unique identifier for this Overwatch team preference.
	ID string `json:"id"`
	// The rewards associated with this team preference.
	Rewards []*TournamentReward `json:"rewards"`
	// The name of the team.
	TeamName string `json:"teamName"`
}

// OwnerChanletAttributes store configuration flags for child chanlets the channel owns.
type OwnerChanletAttributes struct {
	// Whether to show the child chanlets.
	IsChanletFeatureEnabled bool `json:"isChanletFeatureEnabled"`
}

// Moment Details specific to the PUBG game.
type PUBGMomentDetails struct {
	// bucket is the player count bucket for aggregations.
	Bucket int `json:"bucket"`
	// One of "game_start" or "player_count".
	Event string `json:"event"`
	// The game mode for the moment.
	GameMode string `json:"gameMode"`
	// The maximum player count in this period.
	MaxPlayerCount int `json:"maxPlayerCount"`
	// The minimum player count in this period.
	MinPlayerCount int `json:"minPlayerCount"`
}

func (PUBGMomentDetails) IsVideoMomentDetails() {}

// PageInfo is a special field which contains information about the page,
// specifically the cursors which the page starts and ends, and whether or
// not the client can forward-paginate or backward-paginate.
//
// This is part of the Relay Cursor Connections Specification:
// https://facebook.github.io/relay/graphql/connections.htm.
type PageInfo struct {
	HasNextPage     bool `json:"hasNextPage"`
	HasPreviousPage bool `json:"hasPreviousPage"`
}

// Data about a paid upgrade for a subscription.
// ie. a user upgrades a 1-month gift to a recurring subscription.
type PaidUpgrade struct {
	// The id of the paid upgrade purchase. Used to cancel the paid upgrade.
	OriginID string `json:"originID"`
	// The formatted price of the paid upgrade in USD.
	Price string `json:"price"`
	// PriceInfo holds the paid upgrade's pricing information such as currency, cost, and tax information.
	PriceInfo *PriceInfo `json:"priceInfo"`
	// The date the paid upgrade begins.
	StartsAt time.Time `json:"startsAt"`
	// Tier of upgraded product.
	Tier string `json:"tier"`
}

// The required configuration to activate a panel extension.
type PanelActivationInput struct {
	// The slot name of where the component extension should be displayed.
	Slot string `json:"slot"`
}

// PanelView holds the view configuration of an extension if the panel anchor is supported.
type PanelView struct {
	// Specifies whether or not the extension has the ability to link to external websites.
	CanLinkExternalContent bool `json:"canLinkExternalContent"`
	// The extension developer configured height of the panel extension.
	Height int `json:"height"`
	// Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
	ViewerPath string `json:"viewerPath"`
	// The URL which should be loaded in for the extension.
	ViewerURL string `json:"viewerURL"`
}

func (PanelView) IsExtensionView() {}

// PanelViewInput holds the view configuration of an extension if the panel anchor is supported.
type PanelViewInput struct {
	// The extension developer configured height of the panel extension.
	Height int `json:"height"`
	// Relative path of the HTML file to load for this view.
	ViewerPath string `json:"viewerPath"`
}

// DEPRECATED.
type Partnership struct {
	IsPartner *bool `json:"isPartner"`
}

// PartnershipApplication is a submitted partnership application.
type PartnershipApplication struct {
	// ID of the user that submitted the application,
	// provided purely for the convenience of invalidating GraphQL client caches.
	ID string `json:"id"`
	// A submitted application currently can only be unresolved or resolved:
	//
	// - A null resolvedAt timestamp means that the application is unresolved and may be under review.
	//
	// - A non-null resolvedAt means that the application has been resolved, either approved or rejected.
	//   A user with an approved application may now start the partnership on-boarding flow.
	ResolvedAt *time.Time `json:"resolvedAt"`
}

// Associated metrics for the "Path to Affiliate" quest.
type PathToAffiliate struct {
	// Average viewers needed to complete the quest.
	AverageViewers *QuestGoalFloat `json:"averageViewers"`
	// Image URL for the quest's badge.
	BadgeURL *string `json:"badgeURL"`
	// Time that this quest was completed.
	CompletedAt *time.Time `json:"completedAt"`
	// Number of followers needed to complete the quest. Evaluated at a 6 month period. All other metrics are evaluated in 30 day periods.
	Followers *QuestGoalInt `json:"followers"`
	// Number of hours streamed needed to complete the quest.
	HoursStreamed *QuestGoalFloat `json:"hoursStreamed"`
	// Time period that's being evaluated for the metrics/goals.
	QuestEvaluationInterval *QuestEvaluationInterval `json:"questEvaluationInterval"`
	// Number of unique days needed to complete the quest.
	UniqueDaysStreamed *QuestGoalInt `json:"uniqueDaysStreamed"`
}

// Associated metrics for the "Path to Partner" quest.
type PathToPartner struct {
	// Average viewers needed to complete the quest.
	AverageViewers *QuestGoalFloat `json:"averageViewers"`
	// Image URL for the quest's badge.
	BadgeURL *string `json:"badgeURL"`
	// Time that this quest was completed.
	CompletedAt *time.Time `json:"completedAt"`
	// Number of hours streamed needed to complete the quest.
	HoursStreamed *QuestGoalFloat `json:"hoursStreamed"`
	// Time period that's being evaluated for the metrics/goals.
	QuestEvaluationInterval *QuestEvaluationInterval `json:"questEvaluationInterval"`
	// Number of unique days needed to complete the quest.
	UniqueDaysStreamed *QuestGoalInt `json:"uniqueDaysStreamed"`
}

type PayWithAmazonConfigs struct {
	// Used to configure PWA gateway and identify requests to Amazon.
	ClientID string `json:"clientID"`
	// Frontend only has access to production PWA environment so this helps QA.
	IsProduction bool `json:"isProduction"`
	// Also known as merchant ID, which identifies the account accepting payments.
	SellerID string `json:"sellerID"`
}

// Payout Status is the payout status of the creator for all non-earnings related issues.
type PayableStatus struct {
	// Whether or not the user is able to be paid out.
	IsPayable bool `json:"isPayable"`
}

// A monthly rollup of metrics that are relevant to incentive-based contracts for
// some partnered streamers.
type PaymentIncentiveMetricsRollup struct {
	// A measure of how much advertising time broadcasters have during their live
	// streams.
	AdvertisingDensity float64 `json:"advertisingDensity"`
	// The number of live hours the user streamed for the month.
	LiveHoursBroadcast float64 `json:"liveHoursBroadcast"`
	// The number of live minutes watched for the month.
	LiveMinutesWatched float64 `json:"liveMinutesWatched"`
	// The start time for the monthly rollup. These times are in the Pacific Time
	// Zone and the monthly rollups begin in this time zone. Rather than
	// converting to local time, clients should inform end users of this timing
	// quirk and perform custom parsing on these values to show the current year
	// and month in Pacific Time.
	Timestamp *time.Time `json:"timestamp"`
	// The number of VOD minutes watched the user has for the month.
	VodMinutesWatched float64 `json:"vodMinutesWatched"`
}

// Type of payment method a user has used to buy products on Twitch, such as subs.
type PaymentMethod struct {
	// Country (ISO-3166) associated to the billing info for the customer's payment method.
	BillingCountry *string `json:"billingCountry"`
	// Email associated with customer's Amazon/Paypal account.
	BillingEmail *string `json:"billingEmail"`
	// If payment type is card, then the type of card used is shown here.
	CardType *PaymentCardType `json:"cardType"`
	// ID of the payment method that can be referenced by other systems.
	ChargeInstrumentID string `json:"chargeInstrumentID"`
	// Credit card expiration month, if paymentType is CREDIT_CARD.
	ExpirationMonth *int `json:"expirationMonth"`
	// Credit card expiration year, if paymentType is CREDIT_CARD.
	ExpirationYear *int `json:"expirationYear"`
	// External payment method ID (the ID recorded by the payment provider)
	// We can guarantee its uniqueness since it is external from our systems.
	ExtMethodID *string `json:"extMethodID"`
	// Whether or not payment method has restrictions.
	IsRestricted bool `json:"isRestricted"`
	// Credit card last four digits, if paymentType is CREDIT_CARD.
	LastFour *string `json:"lastFour"`
	// The payment scheme used by this payment method.
	PaymentScheme *PaymentScheme `json:"paymentScheme"`
	// Payment type used via the payment provider.
	PaymentType PaymentInstrumentType `json:"paymentType"`
	// One of the payment providers that Twitch currently supports.
	Provider PaymentProvider `json:"provider"`
	// List of purchase profiles associated with this payment method.
	PurchaseProfiles []*PurchaseProfile `json:"purchaseProfiles"`
	// List of recurring payments associated with this payment method.
	// New schema to eventually replace purchase profiles.
	RecurringPaymentDetails []*RecurringPaymentDetail `json:"recurringPaymentDetails"`
}

type PaymentProviderConfigs struct {
	// Configs to initiate Recurly library for the user for purchase checkout or payment method update.
	Recurly *RecurlyConfigs `json:"recurly"`
	// Xsolla configs include the iframe URL for purchase checkout or payment method update.
	Xsolla *XsollaConfigs `json:"xsolla"`
	// Configs for initiating Zuora credit card payments or payment method update.
	Zuora *ZuoraConfigs `json:"zuora"`
}

// Inputs for PaymentSession.
type PaymentSession struct {
	// Payment's Tracking Checkout ID.
	CheckoutSessionID *string `json:"checkoutSessionID"`
	// User's device ID.
	DeviceID *string `json:"deviceID"`
	// Twilight's storage device ID.
	LocalStorageDeviceID *string `json:"localStorageDeviceID"`
	// Offer Session ID.
	OfferSessionID *string `json:"offerSessionID"`
	// Twilight's Page Session ID.
	PageSessionID *string `json:"pageSessionID"`
	// Twilight's Tab Session ID.
	TabSessionID *string `json:"tabSessionID"`
}

// There are legacy and new data sources that contain similar payment transaction data. This type aims to merge several
// data sources into one to expose a consistent payment history for each Twitch user.
type PaymentTransaction struct {
	// Currency for the price.
	Currency *string `json:"currency"`
	// Price in smallest subunit for the currency, such as 499.
	GrossAmount *int `json:"grossAmount"`
	// The divisor used to derive the gross amount.
	GrossAmountDivisor *int `json:"grossAmountDivisor"`
	// Payment ID such as PPT321281 or POPT3278183712.
	ID string `json:"id"`
	// Whether this payment transaction was made to purchase a gift for someone else or not.
	IsGift bool `json:"isGift"`
	// The payment method that was used to generate this payment transaction.
	PaymentMethod *PaymentMethod `json:"paymentMethod"`
	// Payment transaction purchased product details.
	Product *PaymentTransactionProduct `json:"product"`
	// PurchaseOrderID for the payment.
	PurchaseOrderID *string `json:"purchaseOrderID"`
	// Time the purchase payment was recognized at.
	PurchasedAt time.Time `json:"purchasedAt"`
	// Quantity of the purchase.
	Quantity int `json:"quantity"`
	// The recipient Twitch user of the product purchased by the payment transaction, if applicable.
	Recipient *User `json:"recipient"`
}

// A paginated list of payment transactions, and its metadata.
type PaymentTransactionConnection struct {
	// The list of payment transactions on this page.
	Edges []*PaymentTransactionEdge `json:"edges"`
	// The payment date of the earliest PaymentTransaction among all possible pages.
	FirstPurchasedAt *time.Time `json:"firstPurchasedAt"`
	// The payment date of the latest PaymentTransaction among all possible pages.
	LastPurchasedAt *time.Time `json:"lastPurchasedAt"`
	// Information about this page of payment transactions.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of payment transactions in the overall collection.
	TotalCount *int `json:"totalCount"`
}

// Filter and sorting options for querying all transactions for a Twitch purchaser.
type PaymentTransactionConnectionCriteriaInput struct {
	// Only show transactions purchased after this date.
	PurchasedAfter *time.Time `json:"purchasedAfter"`
	// Only show transactions purchased before this date.
	PurchasedBefore *time.Time `json:"purchasedBefore"`
	// Sort transactions by... defaults to date desc.
	SortBy *PaymentTransactionSort `json:"sortBy"`
	// Only show transactions that purchased products of a certain type, defaults to ALL.
	Type *PaymentTransactionTypeFilter `json:"type"`
	// Purchaser ID.
	UserID string `json:"userID"`
}

// An element in a paginated list of payment transactions, and its metadata.
type PaymentTransactionEdge struct {
	// Offset acting as a cursor.
	Cursor string `json:"cursor"`
	// The element node.
	Node *PaymentTransaction `json:"node"`
}

// Payment transaction purchased product details.
type PaymentTransactionProduct struct {
	// Number of digital goods wrapped into a product.
	BundleSize int `json:"bundleSize"`
	// The name of the product.
	Name string `json:"name"`
	// Some products have owners. For example, the owner of the `Lirik - Tier 1 Subscription` product is Lirik.
	Owner *User `json:"owner"`
	// Some products have tiers, such as subs.
	Tier *string `json:"tier"`
	// What type of product the payment was made for.
	Type PaymentTransactionType `json:"type"`
}

// Payout Information.
type Payout struct {
	// Payout History Information.
	History *PayoutHistory `json:"history"`
}

// Payout Balance is the amount accrued by the user since their last Payout.
type PayoutBalance struct {
	// Currency for the user.
	Currency string `json:"currency"`
	// Amount of total earnings accrued since last payout for user.
	CurrentPayoutBalanceAmount float64 `json:"currentPayoutBalanceAmount"`
	// Month for the current payout balance.
	Month int `json:"month"`
	// Year for the current payout balance.
	Year int `json:"year"`
}

// Payout History Information.
type PayoutHistory struct {
	// Url for Tipalti payout history iframe.
	IframeURL *string `json:"iframeURL"`
}

// PayoutInvite describes a user's invite to a payout program.
type PayoutInvite struct {
	// The payout program category the user has been invited to.
	Category *PayoutOnboardingCategory `json:"category"`
	// A PayoutInvite's unique ID.
	ID string `json:"id"`
	// Whether or not this payout invite is for the affiliate program.
	IsForAffiliate bool `json:"isForAffiliate"`
	// Whether or not this payout invite is for the extensions developer program.
	IsForExtensionsDeveloper bool `json:"isForExtensionsDeveloper"`
	// Whether or not this payout invite is for the partner program.
	IsForPartner bool `json:"isForPartner"`
	// Whether or not the payout invite was created through the legacy onboarding flow.
	IsLegacy bool `json:"isLegacy"`
	// The payout onboarding workflow for this payout invite.
	Workflow *PayoutOnboardingWorkflow `json:"workflow"`
}

// PayoutOnboardingWorkflow describes the workflow details while a user is onboarding into a payout program.
type PayoutOnboardingWorkflow struct {
	// The current step at which this workflow is at.
	CurrentStep PayoutOnboardingStep `json:"currentStep"`
	// A PayoutOnboardingWorkflow's unique ID.
	ID string `json:"id"`
	// The URL for a user to update their payout settings. A redirectURL is the URL
	// where the user will be redirected to after updating their payout settings.
	PayoutSettingsURL string `json:"payoutSettingsURL"`
	// The registration information submitted by the user for this workflow.
	Registration *PayoutRegistration `json:"registration"`
	// Describes a user's tax interview information while completing their payout onboarding.
	TaxInterview *TaxInterview `json:"taxInterview"`
	// Lists the fields that were mismatched during the registration and tax interview steps.
	TaxMismatchErrors []TaxMismatchError `json:"taxMismatchErrors"`
	// The timestamp when the workflow was most recently updated.
	Timestamp time.Time `json:"timestamp"`
}

// Describes the payout plan a user has when enrolled into a payout program.
type PayoutPlan struct {
	// The category applied for this payout plan.
	Category PayoutCategory `json:"category"`
	// Describes whether or not this payout plan is receiving revenue.
	IsReceivingRevenue bool `json:"isReceivingRevenue"`
	// Lists tags to further describe this type of payout plan.
	Tags []PayoutPlanTag `json:"tags"`
}

// PayoutRegistration describes the personal information a user submitted while onboarding into a payout program.
type PayoutRegistration struct {
	// Birthdate submitted by the user while registering into a payout program.
	Birthdate time.Time `json:"birthdate"`
	// City submitted by the user while registering into a payout program.
	City string `json:"city"`
	// Company Name submitted by the user while registering into a payout program.
	CompanyName *string `json:"companyName"`
	// Country Code (ISO-3166) submitted by the user while registering into a payout program.
	CountryCode string `json:"countryCode"`
	// Email submitted by the user while registering into a payout program.
	Email string `json:"email"`
	// First Name submitted by the user while registering into a payout program.
	FirstName string `json:"firstName"`
	// Last Name submitted by the user while registering into a payout program.
	LastName string `json:"lastName"`
	// Middle Name submitted by the user while registering into a payout program.
	MiddleName *string `json:"middleName"`
	// Parent Email submitted by the under age user while registering into a payout program.
	ParentEmail *string `json:"parentEmail"`
	// Parent Name submitted by the under age user while registering into a payout program.
	ParentName *string `json:"parentName"`
	// Postal submitted by the user while registering into a payout program.
	Postal *string `json:"postal"`
	// State Code submitted by the user while registering into a payout program.
	StateCode *string `json:"stateCode"`
	// Primary Address submitted by the user while registering into a payout program.
	StreetAddress string `json:"streetAddress"`
	// Secondary Address submitted by the user while registering into a payout program.
	StreetAddress2 *string `json:"streetAddress2"`
}

// Data about a pending future subscription.
// ie. a user turns a 1-month gift into a recurring subscription.
type PendingSubscription struct {
	// Whether the pending sub is cancelable.
	IsCancelable bool `json:"isCancelable"`
	// The id of the pending subscription purchase. Used to cancel the paid upgrade.
	OriginID string `json:"originID"`
	// The formatted price of the pending subscription in USD.
	Price string `json:"price"`
	// PriceInfo holds the pending subscription's pricing information such as currency, cost, and tax information.
	PriceInfo *PriceInfo `json:"priceInfo"`
	// The date the pending subscription begins.
	StartsAt time.Time `json:"startsAt"`
	// Tier of pending subscription.
	Tier string `json:"tier"`
	// The type of pending subscription. Ie GIFT_TO_PAID for a gift to paid conversion.
	Type PendingSubType `json:"type"`
}

// Describes the section(follows, recommendation ...) for a current user in the navigation bar.
type PersonalSection struct {
	// Returns the list of contents in this section, nil if there is an error.
	Items []PersonalSectionItem `json:"items"`
	// The localized title for the personal section.
	Title *PersonalSectionTitle `json:"title"`
	// Describes the section (FOLLOWED, RECOMMENDED, POPULAR ...).
	Type PersonalSectionType `json:"type"`
}

// Describes the personal channel for the current user.
type PersonalSectionChannel struct {
	// Either live stream or vod depending on whether the stream in live.
	Content PersonalSectionChannelContent `json:"content"`
	// Describes how to label channels, if a label is necessary.
	Label PersonalSectionChannelLabel `json:"label"`
	// Unique id per channel used in client tracking.
	TrackingID string `json:"trackingID"`
	// The channel (user object of channel).
	User *User `json:"user"`
}

func (PersonalSectionChannel) IsPersonalSectionItem() {}

// Input to personal section query.
type PersonalSectionInput struct {
	// Name of the channel the user is watching. Used to present similar channels.
	ContextChannelName *string `json:"contextChannelName"`
	// Provides additional context used to influence recommendations.
	RecommendationContext *RecommendationsContext `json:"recommendationContext"`
	// Requested sections eg: follows, recommendation, popular.
	SectionInputs []PersonalSectionType `json:"sectionInputs"`
}

// A personal section token type that contains text.
type PersonalSectionTextToken struct {
	// The text to display for this token.
	Value string `json:"value"`
}

func (PersonalSectionTextToken) IsPersonalSectionTitleToken() {}

// The title for the personal section.
type PersonalSectionTitle struct {
	// The localizedFallback title, only to be used if localizedTokens is nil.
	LocalizedFallback string `json:"localizedFallback"`
	// The localized section title in the form of a list of tokens. [Maximum of 2 tokens].
	LocalizedTokens []PersonalSectionTitleToken `json:"localizedTokens"`
}

type PhotoOEmbed struct {
	AuthorName   *string          `json:"authorName"`
	AuthorURL    *string          `json:"authorURL"`
	CacheAge     *int             `json:"cacheAge"`
	Height       int              `json:"height"`
	InputURL     string           `json:"inputURL"`
	ProviderName *string          `json:"providerName"`
	ProviderURL  *string          `json:"providerURL"`
	Thumbnail    *ThumbnailOEmbed `json:"thumbnail"`
	Title        *string          `json:"title"`
	Type         string           `json:"type"`
	URL          string           `json:"url"`
	Version      string           `json:"version"`
	Width        int              `json:"width"`
}

func (PhotoOEmbed) IsPostEmbed() {}
func (PhotoOEmbed) IsOEmbed()    {}
func (PhotoOEmbed) IsFeedEmbed() {}

type PlatformEventSetting struct {
	// Whether the setting is enabled for the given platform.
	IsEnabled bool `json:"isEnabled"`
	// The name of the platform. ("email", "push", etc..).
	PlatformName string `json:"platformName"`
	// The exact state of the setting. ("on", "off", "friends_only", etc).
	SettingState string `json:"settingState"`
}

// Stream metadata for PlayStation.
type PlayStation struct {
	Platform  *string    `json:"platform"`
	Title     *SCETitle  `json:"title"`
	UpdatedAt *time.Time `json:"updatedAt"`
	User      *SCEUser   `json:"user"`
}

func (PlayStation) IsPlatform() {}

// Access token that determines playback experience for a video.
type PlaybackAccessToken struct {
	// The signature of the token.
	Signature string `json:"signature"`
	// Token that encodes information about the user's access to a video.
	Value string `json:"value"`
}

// Optional parameters to pass in when fetching a playback access token.
type PlaybackAccessTokenParams struct {
	// If the video should not be loaded over HTTPS.
	DisableHTTPS *bool `json:"disableHTTPS"`
	// If the user has adblock enabled.
	HasAdblock *bool `json:"hasAdblock"`
	// The platform the user is watching the video on.
	Platform string `json:"platform"`
	// The player backend being used to serve video.
	PlayerBackend *string `json:"playerBackend"`
	// The type of player the user is watching from.
	PlayerType string `json:"playerType"`
}

type Playing struct {
	// The game being played.
	Game *Game `json:"game"`
	// This activity's type, i.e. "PLAYING".
	Type *ActivityType `json:"type"`
}

func (Playing) IsActivity() {}

// A poll users can vote in.
type Poll struct {
	// A choice specified by a choice id.
	Choice *PollChoice `json:"choice"`
	// A list of choices users can vote for.
	Choices []*PollChoice `json:"choices"`
	// User that created the poll.
	// Mods and editors can make polls on behalf of a broadcaster.
	CreatedBy *User `json:"createdBy"`
	// Amount of seconds from when the poll starts to when it ends.
	// Since a broadcaster can end a poll early ("terminate a poll"), it may be possible for endedAt - startedAt != duration.
	DurationSeconds int `json:"durationSeconds"`
	// Time when the poll ended.
	// Null if the poll is still active.
	EndedAt *time.Time `json:"endedAt"`
	// User that ended the poll. Mods and editors can end polls on behalf of a broadcaster.
	// Null if no user manually ended the poll.
	EndedBy *User `json:"endedBy"`
	// ID of poll.
	ID string `json:"id"`
	// Whether the poll is viewable by other users.
	IsViewable bool `json:"isViewable"`
	// User who owns this poll. The poll will appear on their channel.
	OwnedBy *User `json:"ownedBy"`
	// Amount of milliseconds before the poll ends.
	// 0 when the polls is ended.
	RemainingDurationMilliseconds int `json:"remainingDurationMilliseconds"`
	// The authenticated user's relationship with this poll.
	// Main use case is to check if the user has voted in the poll already.
	// Null if un-authenticated user is making this query.
	Self *PollSelfEdge `json:"self"`
	// A map of poll settings.
	Settings *PollSettings `json:"settings"`
	// Time when poll started.
	StartedAt time.Time `json:"startedAt"`
	// The status of the poll.
	Status PollStatus `json:"status"`
	// Title of poll.
	Title string `json:"title"`
	// A breakdown of the different tokens used in this poll.
	Tokens *PollTokenBreakdown `json:"tokens"`
	// The top Bits contributor for the poll.
	TopBitsContributor *PollTopBitsContributor `json:"topBitsContributor"`
	// The top Community Points contributor for the poll.
	TopCommunityPointsContributor *PollTopCommunityPointsContributor `json:"topCommunityPointsContributor"`
	// The top Bits contributor for the poll.
	TopContributor *PollTopContributor `json:"topContributor"`
	// Total number of unique voters that have voted in this poll.
	TotalVoters int `json:"totalVoters"`
	// A breakdown of the different votes cast in this poll.
	Votes *PollVoteBreakdown `json:"votes"`
}

// A choice in a poll that users can vote for.
type PollChoice struct {
	// ID of choice.
	ID string `json:"id"`
	// The authenticated user's relationship with this choice.
	Self *PollChoiceSelfEdge `json:"self"`
	// The title of the choice.
	Title string `json:"title"`
	// A breakdown of the different tokens used for this choice.
	Tokens *PollTokenBreakdown `json:"tokens"`
	// Total number of unique voters that have voted for this choice.
	TotalVoters int `json:"totalVoters"`
	// A list of voters for this choice.
	// Only the poll's ownerID and their mods/editors can search for this.
	Voters *PollChoiceVoterConnection `json:"voters"`
	// A breakdown of the different votes cast for this choice.
	Votes *PollVoteBreakdown `json:"votes"`
}

// A connection between poll choice and the authenticated user.
type PollChoiceSelfEdge struct {
	// The voter object pertaining to the authenticated user.
	Voter *PollVoter `json:"voter"`
}

// A connection between poll and voters and metadata.
type PollChoiceVoterConnection struct {
	// The list of voters in this poll / choice.
	Nodes []*PollVoterConnectionEdge `json:"nodes"`
}

// A connection between poll and metadata.
type PollConnection struct {
	// The list of polls for the user.
	Edges []*PollEdge `json:"edges"`
	// Information about pagination in this connection.
	PageInfo *PageInfo `json:"pageInfo"`
}

// A page entry, that contains the Poll item and a cursor to return from the query to allow pagination.
type PollEdge struct {
	// Cursor used for next query.
	Cursor string `json:"cursor"`
	// The underlying poll voter.
	Node *Poll `json:"node"`
}

// A connection between a poll and the authenticated user.
type PollSelfEdge struct {
	// The voter object pertaining to the authenticated user.
	Voter *PollVoter `json:"voter"`
}

// Poll Settings.
type PollSettings struct {
	// Bits votes poll settings.
	BitsVotes *PollSettingsBitsVotes `json:"bitsVotes"`
	// Channel Points votes poll settings.
	CommunityPointsVotes *PollSettingsCommunityPointsVotes `json:"communityPointsVotes"`
	// ID of poll settings.
	ID string `json:"id"`
	// Multichoice voting poll settings.
	Multichoice *PollSettingsMultichoice `json:"multichoice"`
	// Subscriber multiplier poll settings.
	SubscriberMultiplier *PollSettingsSubscriberMultiplier `json:"subscriberMultiplier"`
	// Subscriber only poll settings.
	SubscriberOnly *PollSettingsSubscriberOnly `json:"subscriberOnly"`
}

// Bits votes poll settings.
type PollSettingsBitsVotes struct {
	// Cost of bits for a vote.
	Cost int `json:"cost"`
	// Whether the poll allows for users to use bits for votes.
	IsEnabled bool `json:"isEnabled"`
}

// Channel Points votes poll settings.
type PollSettingsCommunityPointsVotes struct {
	// Cost of channel points for a vote.
	Cost int `json:"cost"`
	// Whether the poll allows for users to use channel points for votes.
	IsEnabled bool `json:"isEnabled"`
}

// Multichoice voting enabled poll setting.
type PollSettingsMultichoice struct {
	// Whether the poll has multichoice voting enabled.
	IsEnabled bool `json:"isEnabled"`
}

// Subscriber multiplier poll settings.
// Deprecated: subscriber multipliers are no longer supported.
type PollSettingsSubscriberMultiplier struct {
	// Whether the poll has a subscriber multipler.
	IsEnabled bool `json:"isEnabled"`
}

// Subscriber only poll settings.
// Deprecated: subscriber-only polls are no longer supported.
type PollSettingsSubscriberOnly struct {
	// Whether the poll is subscriber only.
	IsEnabled bool `json:"isEnabled"`
}

// A breakdown of tokens used/by for this poll/choice/user.
type PollTokenBreakdown struct {
	// Total number of bits used.
	Bits int `json:"bits"`
	// Total number of community points used.
	CommunityPoints int `json:"communityPoints"`
	// ID of token breakdown.
	ID string `json:"id"`
}

// Top contributor to the poll and the bits they contributed.
type PollTopBitsContributor struct {
	// Bits amount contributed.
	BitsAmount int `json:"bitsAmount"`
	// Top contributor to the poll.
	User *User `json:"user"`
}

// Top contributor to the poll and the community points they contributed.
type PollTopCommunityPointsContributor struct {
	// Community Points amount contributed.
	CommunityPointsAmount int `json:"communityPointsAmount"`
	// Top contributor to the poll.
	User *User `json:"user"`
}

// Top contributor to the poll and the bits they contributed.
// Deprecated: use PollTopBitsContributor instead.
type PollTopContributor struct {
	// Bits amount contributed.
	BitsAmount int `json:"bitsAmount"`
	// Top contributor to the poll.
	User *User `json:"user"`
}

// A breakdown of votes cast for/by this poll/choice/user.
type PollVoteBreakdown struct {
	// Total number of base votes.
	Base int `json:"base"`
	// Total number of votes due to bits contributions.
	Bits int `json:"bits"`
	// Total number of votes due to Community Points contributions.
	CommunityPoints int `json:"communityPoints"`
	// ID of vote breakdown.
	ID string `json:"id"`
	// Total number of votes across all different vote types.
	Total int `json:"total"`
}

// The tokens that are used on a vote.
type PollVoteTokensInput struct {
	// The amount of bits used for this vote.
	Bits int `json:"bits"`
	// The amount of channel points used for this vote.
	ChannelPoints int `json:"channelPoints"`
}

// A voter taking part in a poll and associated information.
type PollVoter struct {
	// The Choices this voter voted for.
	Choices []*PollVoterChoice `json:"choices"`
	// id of the voter in the poll.
	ID string `json:"id"`
	// The Poll this voter voted in.
	Poll *Poll `json:"poll"`
	// A breakdown of the different tokens used by the voter in the poll.
	Tokens *PollTokenBreakdown `json:"tokens"`
	// The User object relating to this voter.
	User *User `json:"user"`
	// A breakdown of the different votes this voter used in the poll.
	Votes *PollVoteBreakdown `json:"votes"`
}

// A choice a voter made taking part in a poll.
type PollVoterChoice struct {
	// The id of the PollVoterChoice.
	ID string `json:"id"`
	// The poll choice.
	PollChoice *PollChoice `json:"pollChoice"`
	// A breakdown of the different tokens used by the voter.
	Tokens *PollTokenBreakdown `json:"tokens"`
	// A breakdown of the different votes this voter used.
	Votes *PollVoteBreakdown `json:"votes"`
}

// A connection between poll and voters and metadata.
type PollVoterConnection struct {
	// The list of voters in this poll / choice.
	Nodes []*PollVoterConnectionEdge `json:"nodes"`
}

// A page entry, that contains the PollVoter item and a cursor to return from the query to allow pagination.
type PollVoterConnectionEdge struct {
	// Cursor used for next query.
	Cursor string `json:"cursor"`
	// The underlying poll voter.
	Node *PollVoter `json:"node"`
}

type Post struct {
	// The user that created this post.
	Author *User `json:"author"`
	// The content of the post as entered by the user and annotated with links and emotes.
	Body *MessageBody `json:"body"`
	// Time the post was created by the user.
	CreatedAt *time.Time `json:"createdAt"`
	// Collection of embedable content attached to this post.
	Embeds []PostEmbed `json:"embeds"`
	// This Post's unique feeds ID.
	ID string `json:"id"`
	// Is this post deleted.
	IsDeleted *bool `json:"isDeleted"`
	// The reactions associated with this post.
	Reactions []*Reaction `json:"reactions"`
	// Data related to the current user.
	Self *PostSelfConnection `json:"self"`
}

func (Post) IsShareTarget()      {}
func (Post) IsReactableContent() {}
func (Post) IsFeedItemContent()  {}

type PostPermissionSet struct {
	// True if the current user is allowed to delete this post.
	CanDelete bool `json:"canDelete"`
}

type PostSelfConnection struct {
	// Permissions that the current user has on this post.
	Permissions *PostPermissionSet `json:"permissions"`
}

// A single Prediction made by a user on a Prediction Event.
type Prediction struct {
	// The Event that this Prediction relates to.
	Event *PredictionEvent `json:"event"`
	// The unique identifier of the Prediction.
	ID string `json:"id"`
	// Whether the Prediction's results have been acknowledged by the user. Null if the Prediction has not been resolved yet.
	IsResultAcknowledged *bool `json:"isResultAcknowledged"`
	// The Outcome that was Predicted.
	Outcome *PredictionOutcome `json:"outcome"`
	// The number of points that the user spent on this Prediction.
	Points int `json:"points"`
	// The number of points won by the user for this Prediction. Null if the Prediction has not been resolved yet.
	PointsWon *int `json:"pointsWon"`
	// The timestamp of when the user initially made this Prediction.
	PredictedAt time.Time `json:"predictedAt"`
	// The result of this Prediction. Null if the Prediction has not been resolved or refunded yet.
	Result *PredictionResult `json:"result"`
	// The timestamp of when the user most recently updated this Prediction.
	UpdatedAt time.Time `json:"updatedAt"`
	// The user that made this Prediction.
	User *User `json:"user"`
}

// An Event that users can make Predictions on.
type PredictionEvent struct {
	// The channel that the Prediction Event belongs to. Null if this is Event is not tied to a channel.
	Channel *Channel `json:"channel"`
	// The timestamp of when the Event was created.
	CreatedAt time.Time `json:"createdAt"`
	// The creator of the Event. Null if the Event was created by an automatic process or an admin.
	CreatedBy PredictionEventActor `json:"createdBy"`
	// The timestamp of when the Event was resolved or canceled. Null if the Event is not resolved or canceled yet.
	EndedAt *time.Time `json:"endedAt"`
	// The user or extension that resolved or canceled the Event. Null if this was triggered by an automatic process or
	// by an admin, or if the Event is not resolved or canceled yet.
	EndedBy PredictionEventActor `json:"endedBy"`
	// Unique identifier of the Prediction Event.
	ID string `json:"id"`
	// The timestamp of when the Event was locked. Null if the Event is still active.
	LockedAt *time.Time `json:"lockedAt"`
	// The user or extension that locked the Event. Null if this was triggered by an automatic process or by an admin,
	// or if the Event is stillactive.
	LockedBy PredictionEventActor `json:"lockedBy"`
	// The Outcomes available for predicting in this Event.
	Outcomes []*PredictionOutcome `json:"outcomes"`
	// The length of the prediction window (the duration that the Event accepts predictions) in seconds.
	PredictionWindowSeconds int `json:"predictionWindowSeconds"`
	// The current status of the Event.
	Status PredictionEventStatus `json:"status"`
	// The title of the Event.
	Title string `json:"title"`
	// The Outcome that ended up being selected as the "correct" Outcome. Null if the Event has not been resolved yet.
	// This Outcome will also be present as one of the outcomes in the "outcomes" field.
	WinningOutcome *PredictionOutcome `json:"winningOutcome"`
}

// Paginated list of Prediction Events for a channel.
type PredictionEventConnection struct {
	// The elements in the list.
	Edges []*PredictionEventEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Element in a list of Prediction Events.
type PredictionEventEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// The Prediction Event.
	Node *PredictionEvent `json:"node"`
}

// A single Outcome that users can choose in a Prediction Event.
type PredictionOutcome struct {
	// The color of this Outcome.
	Color PredictionOutcomeColor `json:"color"`
	// The unique identifier of the Prediction Outcome.
	ID string `json:"id"`
	// The title of the Event.
	Title string `json:"title"`
	// The top predictors (sorted by most points spent) of this Outcome. Empty if no users have predicted this Outcome.
	TopPredictors []*Prediction `json:"topPredictors"`
	// The total number of points that have been spent predicting this Outcome.
	TotalPoints int `json:"totalPoints"`
	// The total number of users that have predicted this Outcome.
	TotalUsers int `json:"totalUsers"`
}

// DEPRECATED.
type Premiere struct {
	// The Premiere’s identifier.
	ID string `json:"id"`
	// The paginated items in the premiere. At this time, they will all be VoDs.
	// A maximum of 100 items will be returned per request.
	Items *PremiereConnection `json:"items"`
	// The archived video. Only populated if the premiere is in state SUCCESS.
	PastPremiere *Video `json:"pastPremiere"`
	// Status of the premiere.
	Status PremiereStatus `json:"status"`
	// The user who this premiere belongs to.
	User *User `json:"user"`
}

// DEPRECATED.
// Paginated list of videos.
type PremiereConnection struct {
	// The list of items in this page.
	Edges []*PremiereItemEdge `json:"edges"`
	// Information about this page of videos.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of items in the premiere.
	TotalCount *int `json:"totalCount"`
}

// DEPRECATED.
// A page entry, that contains a premiere item and a cursor to return
// from the query to allow pagination.
// NOTE: this should have been named PremiereEdge.
type PremiereItemEdge struct {
	// Cursor is a cursor.
	Cursor string `json:"cursor"`
	// Node is a node.
	Node PremiereItem `json:"node"`
}

// Input for presignDevInsightsReportURL mutation.
type PresignDevInsightsReportURLInput struct {
	// Domain of report, for a GAME or EXTENSION or DROP.
	Domain PresignDevInsightsReportURLDomain `json:"domain"`
	// Game ID or Extension ID or Drops Campaign ID/Reward ID.
	ID string `json:"id"`
	// Type of report, default is OVERVIEW_V2.
	Type *PresignDevInsightsReportURLReportType `json:"type"`
}

// URL info that can be used to upload the image.
type PresignDevInsightsReportURLPayload struct {
	// URL to be used by the client to download the CSV report.
	// Expires in 5 minutes.
	URL *string `json:"url"`
}

// Generic Price Information that supports taxing and multi region pricing.
// LONG-TERM NOTE: using Int (32 bit) as a price field can cause issue when we sell products locally
// e.g. 2147483648 (2^31) Lao Att = 253132 USD cent
// Therefor, if we sell product which price more than $2500 in Laos currency. We will need to fix this.
type PriceInfo struct {
	// The currency associated with the price of a subscription product.
	Currency Currency `json:"currency"`
	// The description associated with pricing information.
	Description string `json:"description"`
	// The discounted total also broken down by price and tax.
	Discount *DiscountBreakdown `json:"discount"`
	// The ISO-4217 wording of deriving price.
	Exponent int `json:"exponent"`
	// Identifier used for caching.
	ID string `json:"id"`
	// If the tax is already included in price.
	IsTaxInclusive bool `json:"isTaxInclusive"`
	// The numerical price of a subscription product.
	Price int `json:"price"`
	// The tax rate of localized product.
	Tax int `json:"tax"`
	// The total price given price and tax.
	Total int `json:"total"`
}

// Wrapper around standard Emoticons for Prime Smilies Emoticons.
type PrimeEmoticons struct {
	// Name for the currently enabled Emoticon set selected by the user.
	CurrentSetName PrimeEmoticonsSetName `json:"currentSetName"`
	// All Prime Emoticon Sets of emote values (id, token, setId).
	EmoticonSets []*SmiliesSet `json:"emoticonSets"`
}

// Prime Digital Content Offers are displayed to users on Twitch via Offers in the top nav.
type PrimeOffer struct {
	// Instructions string in Markdown displayed after offer is claimed to use or redeem.
	ClaimInstructions string `json:"claimInstructions"`
	// Content metadata for the given offer.
	Content *PrimeOfferContent `json:"content"`
	// The method of offer entitlement.
	DeliveryMethod OfferDeliveryMethod `json:"deliveryMethod"`
	// Description string in Markdown used in info block for Offer.
	Description string `json:"description"`
	// Unique Identifier for an offer.
	ID string `json:"id"`
	// Offer image asset URL.
	ImageURL string `json:"imageURL"`
	// Ranking for which the offer should be displayed, ordered ASC -1 through 99 where -1 value indicates top priority.
	Priority int `json:"priority"`
	// The connection for whether the user is entitled to the offer.
	Self *PrimeOfferSelfConnection `json:"self"`
	// Tags related to the offer such as Free Games with Prime (FGWP).
	Tags []string `json:"tags"`
	// Primary Title for Offer.
	Title string `json:"title"`
	// Hint describing the current availability state of the claim for the user.
	ClaimHint ClaimHint `json:"claimHint"`
}

// An Object containing metadata for Digital Content.
type PrimeOfferContent struct {
	// Content Categories for the game, displayed in info.
	Categories []string `json:"categories"`
	// If the content has an external marketing page (Blizzard, Retail, etc), some offers will have no external URL.
	ExternalURL *string `json:"externalURL"`
	// The Game metadata.
	Game *Game `json:"game"`
	// The publisher of the content.
	Publisher string `json:"publisher"`
	// Content SKU list for the offer.
	Skus []string `json:"skus"`
}

// The connection between the user and their offer entitlement state.
type PrimeOfferSelfConnection struct {
	// The data (link, text, or claim code) for the entitlement that was created.
	ClaimData string `json:"claimData"`
	// Indicates whether the user has the entitlement to the offer.
	HasEntitlement bool `json:"hasEntitlement"`
	// The visual status of the offer to the user, UNSEEN, SEEN, CLAIMED, DISMISSED, OVERRIDDEN.
	Status string `json:"status"`
}

// PrimePayoutDetail shows the detailed breakdown of the prime payouts for a given user.
type PrimePayoutDetail struct {
	// currency for the payout number above.
	Currency Currency `json:"currency"`
	// currentPrimePayout is the payout that will be made in this specific payout cycle.
	CurrentPrimePayout *CurrentPrimePayout `json:"currentPrimePayout"`
	// deferredPrimePayout is part of the earning that was earned this month but will not be paid out this month.
	DeferredPrimePayout *DeferredPrimePayout `json:"deferredPrimePayout"`
	// month when this payout will be made.
	Month int `json:"month"`
	// year when this payout will be made.
	Year int `json:"year"`
}

// PrimePayoutDetails shows the history of prime payout detail.
type PrimePayoutDetails struct {
	// primePayoutHistory is the history of prime payout details for a user.
	PrimePayoutHistory []*PrimePayoutDetail `json:"primePayoutHistory"`
}

// Metadata relevant to Prime copy or marketing that needs to be scheduled.
type PrimePromotion struct {
	// externalURL is a string with the destination URL.
	ExternalURL *string `json:"externalURL"`
	// id is the unique identifier for the PrimePromotion.
	ID string `json:"id"`
	// isExternalLink is boolean that indicates whether the text should be a link.
	IsExternalLink bool `json:"isExternalLink"`
	// text is a string field containing the user visible text for a dynamic/changing string.
	Text string `json:"text"`
}

// Prime Settings related data for a given user.
type PrimeSettings struct {
	// This type's unique identifier.
	ID string `json:"id"`
	// If true, chat notifications will be sent on Prime Credit Token Channel Subscriptions.
	IsSubCreditChatNotificationEnabled bool `json:"isSubCreditChatNotificationEnabled"`
	// The currently chosen Emoticon Set for the Prime User that are Smilies.
	PrimeEmoticons *PrimeEmoticons `json:"primeEmoticons"`
}

// Information about the authenticated user's Prime subscription credit benefit.
type PrimeSubCreditBenefit struct {
	// Checks when the authenticated user's Prime subscription credit will renew.
	RenewalDate *time.Time `json:"renewalDate"`
	// Checks if the authenticated user has the Prime benefit for 30-day subscription credit renewals.
	WillRenew *bool `json:"willRenew"`
}

// Information about the Amazon user's Prime Video benefit.
type PrimeVideoBenefit struct {
	// Error when the authentication token is expired.
	Error *WatchPartyError `json:"error"`
	// True if the user has valid access.
	IsValid *bool `json:"isValid"`
}

// Contains rating information for Prime Video content.
type PrimeVideoRating struct {
	// Number of votes.
	Count int `json:"count"`
	// Fractional number of stars.
	Stars float64 `json:"stars"`
}

// Contains the product's checkout price and tax info for a purchase and error if a final price cannot be determined.
type ProductPurchase struct {
	// The price and tax breakdown for the purchase.
	CheckoutPriceSummary *CheckoutPriceSummary `json:"checkoutPriceSummary"`
	// Error when the final price could not be retrieved for a product.
	ErrorCode *ProductPurchaseErrorCode `json:"errorCode"`
	// The region from which the tax was calculated.
	TaxRegion *TaxRegion `json:"taxRegion"`
}

// ProgramAgreement describes the End User License Agreement associated with a user's current payout plan.
type ProgramAgreement struct {
	// Agreement body in HTML.
	Body string `json:"body"`
	// Agreement type accepted by the user.
	Type PayoutOnboardingCategory `json:"type"`
	// Agreement version (e.g. "v1").
	Version string `json:"version"`
}

// Data used to display promotional discounts to the client.
type PromotionDisplay struct {
	// Describes the discount percent to display to the client.
	DiscountPercent *float64 `json:"discountPercent"`
	// Describes the type of discount that will be applied to the client.
	DiscountType PromoDiscountType `json:"discountType"`
}

// PublishClipError is an error associated with the publishClip mutation.
type PublishClipError struct {
	Message *string `json:"message"`
}

// PublishClipInput edits the clip with the provided slug via segments.
type PublishClipInput struct {
	// The number of seconds into the clip's raw media the preview image is set to.
	PreviewOffsetSeconds *float64 `json:"previewOffsetSeconds"`
	// The segments describing the desired changes to apply to the newly edited clip.
	Segments []*ClipSegmentInput `json:"segments"`
	// The slug uniquely identifying the clip to edit.
	Slug string `json:"slug"`
	// The new title this clip will be updated to.
	Title *string `json:"title"`
}

// PublishClipPayload returns the edited clip or an error.
type PublishClipPayload struct {
	// The clip with its updated properties.
	Clip *Clip `json:"clip"`
	// The error when the clip fails to publish.
	Error *PublishClipError `json:"error"`
}

// Publish a Competition.
type PublishCompetitionInput struct {
	// ID of the Competition we want to update.
	ID string `json:"id"`
}

// Data that was mutated after the competition was updated.
type PublishCompetitionPayload struct {
	// The competition which was updated.
	Competition *Competition `json:"competition"`
}

// Errors for publishing subscription emotes.
type PublishSubscriptionEmoteError struct {
	// The associated error code.
	Code PublishSubscriptionEmoteErrorCode `json:"code"`
}

// The data needed to finalize the creation of a Subscription Emote.
type PublishSubscriptionEmoteInput struct {
	// The type of image asset for the emote.
	AssetType *EmoteAssetType `json:"assetType"`
	// The custom suffix of the emote code. When appended to the channel's emote prefix this will form the full emote code.
	CodeSuffix string `json:"codeSuffix"`
	// A list containing the image IDs for all assets needed for the emote.
	ImageAssets []*EmoteImageAssetInput `json:"imageAssets"`
	// The ID of the 28x28px emote ("1x") image file previously uploaded to upload service.
	ImageID1x string `json:"imageID1x"`
	// The ID of the 56x56px emote ("2x") image file previously uploaded to upload service.
	ImageID2x string `json:"imageID2x"`
	// The ID of the 112x112px emote ("4x") image file previously uploaded to upload service.
	ImageID4x string `json:"imageID4x"`
	// The ProductID of the subscription product which this emote will be associated with.
	ProductID string `json:"productID"`
}

// Results of the subscription emote publish.
type PublishSubscriptionEmotePayload struct {
	// The newly created emote if successful.
	Emote *Emote `json:"emote"`
	// Service error, if any.
	Error *PublishSubscriptionEmoteError `json:"error"`
}

// Parameters to get details about a purchasable offer for the current logged in user.
type PurchasableOfferParams struct {
	// List of gift recipient IDs if the offer is giftable.
	GiftRecipientIDs []string `json:"giftRecipientIDs"`
	// The ID of the Offer.
	OfferID string `json:"offerID"`
	// The ID of the Promotion attached to a Purchasable Offer (optional).
	PromotionID *string `json:"promotionID"`
	// The static and dynamic bindings of the attributes on an Offer.
	TagBindings []*OfferTagBindingInput `json:"tagBindings"`
}

// PurchaseOfferInput contains the necessary fields to purchase an offer.
type PurchaseOfferInput struct {
	// Data to facilitate the Fraud analysis.
	BillingAuthInfo *BillingAuthInfo `json:"billingAuthInfo"`
	// User IDs of the gift purchase recipients (if the Offer is a gift).
	GiftRecipientUserIDs []string `json:"giftRecipientUserIDs"`
	// The ID of the Offer.
	OfferID string `json:"offerID"`
	// Payments' session tracking.
	PaymentSession *PaymentSession `json:"paymentSession"`
	// The ID of the user making the purchase.
	PurchasingUserID string `json:"purchasingUserID"`
	// The number of units purchased.
	Quantity int `json:"quantity"`
	// The static and dynamic bindings of the attributes on an Offer.
	TagBindings []*OfferTagBindingInput `json:"tagBindings"`
	// Tenant-specific tracking params.
	TenantTracking *string `json:"tenantTracking"`
}

// PurchaseOfferPayload returns the order created for the purchase.
type PurchaseOfferPayload struct {
	// Reason why a Purchase Order failed to be created if an error occurred.
	Error *PurchaseOfferErrorCode `json:"error"`
	// The Purchase Order created for this purchase attempt.
	PurchaseOrder *PurchaseOrder `json:"purchaseOrder"`
}

// PurchaseOrder is the record of a purchase made by a user.
type PurchaseOrder struct {
	// The action token ID used to facilitate the 3D Secure flow.
	ActionTokenID *string `json:"actionTokenID"`
	// The reason for a purchase order failure, if it failed.
	FailureReason *PurchaseOrderFailureReason `json:"failureReason"`
	// The ID of the Purchase Order.
	ID string `json:"id"`
	// The state of the Purchase Order.
	State PurchaseOrderState `json:"state"`
}

// Purchase profile of a recurring or non-recurring subscription that a user bought.
type PurchaseProfile struct {
	// Cancels the entitled benefit and refunds if isRefundable is true.
	CancelledAt *time.Time `json:"cancelledAt"`
	// Date this purchase profile was created.
	CreatedAt time.Time  `json:"createdAt"`
	ExpiresAt *time.Time `json:"expiresAt"`
	// Usually the Twitch user's ID, but recorded by the payment provider.
	ExtPurchaserID *string `json:"extPurchaserID"`
	// The external subscription ID recorded by the payment provider.
	ExtSubscriptionID *string `json:"extSubscriptionID"`
	// ID of the Purchase Profile in Payments team database.
	ID        string `json:"id"`
	IsExpired *bool  `json:"isExpired"`
	// Whether this purchase profile was gifted.
	IsGift *bool `json:"isGift"`
	// Whether this purchase profile is being paid for.
	IsPaying     bool       `json:"isPaying"`
	IsRecurring  bool       `json:"isRecurring"`
	IsRefundable *bool      `json:"isRefundable"`
	PaidAt       *time.Time `json:"paidAt"`
	// Product type of the purchase.
	ProductType SubscriptionProductType `json:"productType"`
	PurchasedAt *time.Time              `json:"purchasedAt"`
	// Twitch purchaser's email.
	PurchaserEmail string `json:"purchaserEmail"`
	// Twitch purchaser's user ID.
	PurchaserID string `json:"purchaserID"`
	// Twitch purchaser's real name.
	PurchaserName *string `json:"purchaserName"`
	// Currency for the renewalPrice, e.g. "USD".
	RenewalCurrency *string `json:"renewalCurrency"`
	// Expected renewal price of the product in the smallest subunit of the currency, e.g. "499".
	RenewalPrice *int `json:"renewalPrice"`
	// Different from cancellation in that it stops renewal but let's user keep the benefit until it expires.
	RenewalStoppedAt *time.Time `json:"renewalStoppedAt"`
	// State of the purchase profile. i.e. cancelling the purchase profile can set state to 'cancelled'.
	State PurchaseProfileState `json:"state"`
	// Subscription benefit associated with this purchase profile, if still active.
	SubscriptionBenefit *SubscriptionBenefit `json:"subscriptionBenefit"`
	// Date this purchase profile was last updated.
	UpdatedAt *time.Time `json:"updatedAt"`
	// Whether this purchase profile will renew in the future and charge the user's payment method.
	WillRenew bool `json:"willRenew"`
}

// Interval that a quest is being evaluated for.
type QuestEvaluationInterval struct {
	// Duration of the interval (in days).
	DurationInDays int `json:"durationInDays"`
	// End time of the interval.
	EndTime time.Time `json:"endTime"`
	// Start time of the interval.
	StartTime time.Time `json:"startTime"`
}

// Progress towards a particular quest goal.
type QuestGoalFloat struct {
	// Current progress towards quest goal.
	Current float64 `json:"current"`
	// Number needed to complete the quest goal.
	Goal float64 `json:"goal"`
}

// Progress towards a particular quest goal.
type QuestGoalInt struct {
	// Current progress towards quest goal.
	Current int `json:"current"`
	// Number needed to complete the quest goal.
	Goal int `json:"goal"`
}

// The quests associated with a user.
type Quests struct {
	// "Build a Community" quest.
	BuildACommunity *BuildACommunity `json:"buildACommunity"`
	// "It Begins" quest.
	ItBegins *ItBegins `json:"itBegins"`
	// "Path to Affiliate" quest.
	PathToAffiliate *PathToAffiliate `json:"pathToAffiliate"`
	// "Path to Partner" quest.
	PathToPartner *PathToPartner `json:"pathToPartner"`
}

// Represents a single quick action.
type QuickAction struct {
	// Category name of QA for client side store sections.
	Category QuickActionCategory `json:"category"`
	// If the user currently has this QA enabled.
	IsEnabled bool `json:"isEnabled"`
	// The name of the item. Quick action IDs are represented by their canonical names.
	Name QuickActionName `json:"name"`
	// Scope can be "local" or "global".
	Scope QuickActionScope `json:"scope"`
}

func (QuickAction) IsQuickActionLayoutItem() {}

// Represents a folder of quick actions.
type QuickActionFolder struct {
	// A list of quick action IDs in the folder.
	Items []QuickActionLayoutItem `json:"items"`
	// The name of the folder.
	Name string `json:"name"`
}

func (QuickActionFolder) IsQuickActionLayoutItem() {}

// Contains the quick action layout.
type QuickActionLayout struct {
	// The ID of the layout.
	ID string `json:"id"`
	// A list of items in the layout.
	Items []QuickActionLayoutItem `json:"items"`
}

// Represents a list of quick actions for the store.
type QuickActionStore struct {
	// A list of quick actions available for the user's store.
	QuickActions []*QuickAction `json:"quickActions"`
}

// RTMPSession is metadata related to the RTMP data sent by the broadcaster.
type RTMPSession struct {
	// Audio codecs of RTMP session.
	AudioCodecs string `json:"audioCodecs"`
	// H.264 advanced video codec.
	AvcLevel *int `json:"avcLevel"`
	// Staff-only field. The IP address of the broadcaster of the RTMP session.
	ClientIP *string `json:"clientIP"`
	// Name of the broadcaster's encoder.
	Encoder string `json:"encoder"`
	// H.264 encoder Instantaneous Decoder Refresh interval.
	IdrInterval *int `json:"idrInterval"`
	// rtmpExitReason tells how the stream session was terminated.
	RtmpExitReason *string `json:"rtmpExitReason"`
	// RTMP request parameters sent by the broadcaster.
	RtmpFlags string `json:"rtmpFlags"`
	// A full list of RTMP header sent by the broadcaster.
	RtmpMetadata string `json:"rtmpMetadata"`
	// Duration of each video frame segment in seconds.
	SegmentDurationSeconds int `json:"segmentDurationSeconds"`
	// Video codecs of RTMP session.
	VideoCodecs string `json:"videoCodecs"`
	// Video resolution height in pixel.
	VideoResolutionHeight int `json:"videoResolutionHeight"`
	// Video resolution width in pixel.
	VideoResolutionWidth int `json:"videoResolutionWidth"`
}

// Twitch Radio access.
type Radio struct {
	// Twitch Radio account information for the user.
	Account *RadioAccount `json:"account"`
	// Fetch the requesting user's currently playing radio content.
	CurrentlyPlaying *RadioCurrentlyPlaying `json:"currentlyPlaying"`
	// Fetch a radio playlist by ID. Tracks can be requested here, but can be slow to respond.
	Playlist *RadioPlaylist `json:"playlist"`
	// Fetch all, or filtered subset of, radio playlists. Cannot request track data from this query.
	Playlists []*RadioPlaylist `json:"playlists"`
	// Fetch the requesting user's recently played radio content ids. Optionally filtered by type.
	RecentlyPlayed []*RadioRecentlyPlayed `json:"recentlyPlayed"`
	// Fetch a radio station by ID. Returns the initial queue with a token to get the next tracks if no pageToken is passed.
	Station *RadioStation `json:"station"`
	// Fetch all radio stations.
	Stations []*RadioStation `json:"stations"`
}

// Amazon Music user information for a Twitch user using Twitch Radio.
type RadioAccount struct {
	// The Twitch user's ID as known in Amazon Music.
	CustomerID string `json:"customerID"`
	// The unique Amazon client device identifier for this user and service.
	DeviceID string `json:"deviceID"`
	// ISO 3166-1 alpha-2 country code territory of the user in Amazon Music.
	MusicTerritory string `json:"musicTerritory"`
	// User token to authenticate with Amazon services
	AmazonAccessToken string    `json:"amazonAccessToken"`
	TokenExpiresAt    time.Time `json:"tokenExpiresAt"`
}

// A Twitch Radio Album.
type RadioAlbum struct {
	// The album's unique id (an Amazon Standard Identification Number).
	ID string `json:"id"`
	// URL to the album's main image.
	ImageURL string `json:"imageURL"`
	// The album name.
	Name string `json:"name"`
}

// A Twitch Radio artist.
type RadioArtist struct {
	// The creator channel.
	Channel *Channel `json:"channel"`
	// The creator channel id.
	CreatorChannelID *string `json:"creatorChannelID"`
	// The artist's unique id (an Amazon Standard Identification Number).
	ID string `json:"id"`
	// The artist name.
	Name string `json:"name"`
}

// A container for Twitch Radio content request results.
type RadioContent struct {
	// The requested playlists.
	Items []RadioContentItem `json:"items"`
}

// A Twitch Radio LinkFire Input Response for Content Promotion.
type RadioContentPromotion struct {
	// Text on the redirect button.
	ButtonText string `json:"buttonText"`
	// Icon for the media service having dark/light theme assets. Formats supported: PNG, SVG. Default value is SVG.
	Icon *RadioIconThemeAssets `json:"icon"`
	// IconURL for the media service. Formats supported: PNG, SVG. Default value is SVG.
	IconURL string `json:"iconURL"`
	// Rank to order the icons.
	Rank int `json:"rank"`
	// Title of the service.
	Title string `json:"title"`
	// URL to redirect to the service.
	URL string `json:"url"`
}

// The currently playing radio track addition result.
type RadioCurrentTrackResponse struct {
	// Radio currently Playing Track is added Successfully or not.
	IsSuccess bool `json:"isSuccess"`
}

// Content currently playing in the client for a user.
type RadioCurrentlyPlaying struct {
	// The radio content promotion json data.
	ContentPromotions []*RadioContentPromotion `json:"contentPromotions"`
	// Whether the track is currently playing or not.
	IsCurrentlyPlaying bool `json:"isCurrentlyPlaying"`
	// The Track Details of the currently playing track.
	Track *RadioTrack `json:"track"`
}

// Theme for the media service assets.
type RadioIconThemeAssets struct {
	// Dark theme Asset URL.
	DarkURL string `json:"darkURL"`
	// Light theme Asset URL.
	LightURL string `json:"lightURL"`
}

// A Twitch Radio playlist.
type RadioPlaylist struct {
	// Curator of the playlist.
	Curator string `json:"curator"`
	// Playlist's Description.
	Description string `json:"description"`
	// The playlist's unique id (an Amazon Standard Identification Number).
	ID string `json:"id"`
	// URL to the playlist's main image.
	ImageURL string `json:"imageURL"`
	// Is the playlist featured.
	IsFeatured bool `json:"isFeatured"`
	// The playlist's title.
	Title string `json:"title"`
	// List of tracks in the playlist.
	Tracks []*RadioTrack `json:"tracks"`
}

func (RadioPlaylist) IsRadioContentItem() {}

// Content recently played in the client.
type RadioRecentlyPlayed struct {
	// The type of content the ID maps to.
	ContentType RadioRecentlyPlayedType `json:"contentType"`
	// The id of the recently played item.
	ID string `json:"id"`
	// Recently played playlist metadata.
	Playlist *RadioPlaylist `json:"playlist"`
	// Recently played station metadata.
	Station *RadioStation `json:"station"`
	// The time this ID was last recently played by the current user.
	UpdatedAt time.Time `json:"updatedAt"`
}

func (RadioRecentlyPlayed) IsRadioContentItem() {}

// A Twitch Radio station.
type RadioStation struct {
	// The station's unique id (an Amazon Standard Identification Number).
	ID string `json:"id"`
	// URL to the station's main image.
	ImageURL string `json:"imageURL"`
	// Is the station featured.
	IsFeatured bool `json:"isFeatured"`
	// Page token to be passed back to the Client Gateway when requesting additional tracks.
	PageToken *string `json:"pageToken"`
	// The station's title.
	Title string `json:"title"`
	// List of tracks in the station.
	Tracks []*RadioTrack `json:"tracks"`
}

// A Twitch Radio track.
type RadioTrack struct {
	// The track album.
	Album *RadioAlbum `json:"album"`
	// The track artists.
	Artists []*RadioArtist `json:"artists"`
	// The duration of the track in seconds.
	Duration int `json:"duration"`
	// Track's Genre.
	Genre string `json:"genre"`
	// The track's unique id (an Amazon Standard Identification Number).
	ID string `json:"id"`
	// Industry standard track's unique id.
	Isrc string `json:"isrc"`
	// The title of the track.
	Title string `json:"title"`
}

// A raid represents a broadcaster directing their viewers to another channel
// in a synchronized "raid" on the channel after a countdown during which
// each viewer has a chance to opt out of the raid.
//
// Raids are created by a broadcaster from their dashbboard where they can search
// and select the channel they wish to target. Once selected the raid takes counts
// down to prepare after which the broadcaster can tell the raid to "Go", redirecting
// all joined raiders to the target channel.
type Raid struct {
	// Timestamp of raid announcement.
	AnnounceAt *time.Time `json:"announceAt"`
	// Timestamp of raid go time.
	GoAt *time.Time `json:"goAt"`
	// The ID of the raid.
	ID string `json:"id"`
	// Channel hosting the raid.
	SourceChannel *User `json:"sourceChannel"`
	// Target of the raid.
	TargetChannel *User `json:"targetChannel"`
	// Number of viewers in raid.
	ViewerCount *int `json:"viewerCount"`
}

// A user's raid settings.
type RaidSettings struct {
	// Determines what other channels can raid this channel.
	IncomingRaidsPolicy IncomingRaidsPolicy `json:"incomingRaidsPolicy"`
}

// An integer range with a minimum and a maximum.
type Range struct {
	// The maximum value of the Range.
	Max int `json:"max"`
	// The minimum value of the Range.
	Min int `json:"min"`
}

// RateExtensionInput submits a user's rating and feedback on a Twitch extension.
type RateExtensionInput struct {
	// The ID of the extension being rated.
	ExtensionClientID string `json:"extensionClientID"`
	// The version of the extension being rated.
	ExtensionVersion string `json:"extensionVersion"`
	// Whether the user recommends the extension or not.
	IsRecommended bool `json:"isRecommended"`
	// Indicates from where the user submitted the rating.
	Location ExtensionRatingLocation `json:"location"`
	// The ID of the user performing the rating.
	UserID string `json:"userID"`
}

// The result of a rateExtension mutation.
type RateExtensionPayload struct {
	// The error if the mutation fails to submit the extension rating.
	Error *RateExtensionError `json:"error"`
	// The resulting ExtensionRating record.
	Rating *ExtensionRating `json:"rating"`
}

type Reaction struct {
	// count of users that reacted with a particular Emote.
	Count int `json:"count"`
	// The Emote associated with the Reaction.
	Emote *Emote `json:"emote"`
	// The authenticated user's relationship with this reaction.
	Self *ReactionSelfConnection `json:"self"`
}

type ReactionSelfConnection struct {
	// Did the authenticated user react.
	HasReacted bool `json:"hasReacted"`
}

type ReadNotificationsInput struct {
	// IDs of the notifications to set as read. The minimum number is 1 and the maximum is 100.
	Ids []string `json:"ids"`
}

type ReadNotificationsPayload struct {
	// The amount of notifications that were set to read.
	Count int `json:"count"`
	// The notifications that were set to read. Only ID and isRead are accessible.
	Notifications []*OnsiteNotification `json:"notifications"`
}

// Feedback from a user about a piece of content.
type RecommendationFeedback struct {
	// Reason for feedback.
	Category RecommendationFeedbackCategory `json:"category"`
	// Feedback target.
	Content RecommendationFeedbackContent `json:"content"`
	// Recommendation Feedback ID. Generated from the type, category, content id, and user id.
	ID string `json:"id"`
	// Last time this feedback was given.
	LastUpdated time.Time `json:"lastUpdated"`
	// Feedback target type.
	Type RecommendationFeedbackType `json:"type"`
	// Feedback giver.
	User *User `json:"user"`
}

// Connection between a user and recommendation feedback.
type RecommendationFeedbackConnection struct {
	// Contains the edges for the recommendation feedback.
	Edges []*RecommendationFeedbackEdge `json:"edges"`
	// Contains pagination metadata.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Edge containing the node and cursor for recommendation feedback items.
type RecommendationFeedbackEdge struct {
	// Cursor for the feedback edge.
	Cursor string `json:"cursor"`
	// Node for the feedback edge.
	Node *RecommendationFeedback `json:"node"`
}

type Recommendations struct {
	// The recommended community gifting quantities to display to the user when they intend to gift subscriptions.
	// The trackingID is not a unique ID for the recommendations, but a passthrough value for backend logging to link to purchases made by the user after being shown these recommendations.
	CommunityGiftQuantities []int `json:"communityGiftQuantities"`
	// A list of recommended friends.
	Friends []*RecommendedFriend `json:"friends"`
	// Live recommendations.
	// recRequestID is a tracking id created by the caller. Should be unique per request.
	LiveRecommendations *LiveRecommendationConnection `json:"liveRecommendations"`
	// Stream recommendations.
	Streams *RecommendedStreamConnection `json:"streams"`
	// A list of recommended VODs.
	Videos *RecommendedVideoConnection `json:"videos"`
}

// RecommendationsContext define parameters which can control recommendations logic.
// Clients should strive to fill in as many fields as possible for the highest quality recommendaitons.
// Many of these fields should be identical to what is sent in pageview events: https://blueprint.di.xarth.tv/#/schema/pageview.
type RecommendationsContext struct {
	// The 'app_window_height' field sent in pageview events.
	AppWindowHeight *int `json:"appWindowHeight"`
	// The 'app_window_width' field sent in pageview events.
	AppWindowWidth *int `json:"appWindowWidth"`
	// The 'client_app' field sent in pageview events.
	ClientApp *string `json:"clientApp"`
	// Optional ISO country code, defaults to use the country code from the geoip of the request.
	Country *string `json:"country"`
	// The 'location' field sent in pageview events (signifying the location on the site or app).
	Location *string `json:"location"`
	// Web, ios, android, etc.
	Platform *string `json:"platform"`
	// The 'referrer_host' field sent in pageview events.
	ReferrerHost *string `json:"referrerHost"`
	// The 'viewport_height' field sent in pageview events.
	ViewportHeight *int `json:"viewportHeight"`
	// The 'viewport_width' field sent in pageview events.
	ViewportWidth *int `json:"viewportWidth"`
}

type RecommendedFriend struct {
	// Reason why this recommendation was made.
	Reason *string `json:"reason"`
	// The user recommended to be a friend of the source user.
	User *User `json:"user"`
}

// The response of a recommended games request which contains a list of recommended games.
type RecommendedGamesConnection struct {
	// A list of recommended games.
	Edges []*RecommendedGamesEdge `json:"edges"`
	// Per-generation tracking id for identifying a recommendation model.
	GenerationID string `json:"generationID"`
	// As pagination is currently not supported by the backend, this will always be the zero value.
	PageInfo *PageInfo `json:"pageInfo"`
	// Unique tracking id per response.
	ResponseID string `json:"responseID"`
}

// The content to render from a recommended game.
type RecommendedGamesEdge struct {
	// As pagination is currently not supported by the backend, this will always be the zero value.
	Cursor string `json:"cursor"`
	// The underlying game content to render.
	Node *Game `json:"node"`
	// Globally unique id per category used in client tracking.
	TrackingID string `json:"trackingID"`
}

// NOTE: this type will soon be removed.
type RecommendedStreamConnection struct {
	// This field is deprecated.
	Nodes []RecommendedStream `json:"nodes"`
}

// The response of a recommended streams request which contains a list of recommended streams.
type RecommendedStreamsConnection struct {
	// A list of recommended streams.
	Edges []*RecommendedStreamsEdge `json:"edges"`
	// Per-generation tracking id for identifying a recommendation model.
	GenerationID string `json:"generationID"`
	// As pagination is currently not supported by the backend, this will always be the zero value.
	PageInfo *PageInfo `json:"pageInfo"`
	// Unique tracking id per response.
	ResponseID string `json:"responseID"`
}

// The content to render from a recommended stream.
type RecommendedStreamsEdge struct {
	// As pagination is currently not supported by the backend, this will always be the zero value.
	Cursor string `json:"cursor"`
	// The underlying stream content to render.
	Node *Stream `json:"node"`
	// Globally unique id per stream used in client tracking.
	TrackingID string `json:"trackingID"`
}

type RecommendedVideoConnection struct {
	Edges    []*RecommendedVideoEdge `json:"edges"`
	PageInfo *PageInfo               `json:"pageInfo"`
	// A unique ID for this generated list of recommendations.
	SetID *string `json:"setID"`
}

type RecommendedVideoEdge struct {
	Cursor *string `json:"cursor"`
	Node   *Video  `json:"node"`
}

// Record ad event error.
type RecordAdEventError struct {
	// Error from recording ad event.
	Code RecordAdEventErrorCode `json:"code"`
}

// The input for recording an ad event.
type RecordAdEventInput struct {
	// The ad event name.
	EventName string `json:"eventName"`
	// Ad details JSON encoded as a string.
	EventPayload string `json:"eventPayload"`
	// The RAd service token used for validation.
	RadToken string `json:"radToken"`
}

// The payload returned after recording an ad event.
type RecordAdEventPayload struct {
	// Error from mutation, if one exists.
	Error *RecordAdEventError `json:"error"`
}

type RecurlyConfigs struct {
	// For interacting with the Braintree gateway and Paypal (supported by Recurly).
	BraintreeClientAuthorization string `json:"braintreeClientAuthorization"`
	// For interacting with Pay With Amazon gateway (supported by Recurly).
	PayWithAmazonConfigs *PayWithAmazonConfigs `json:"payWithAmazonConfigs"`
	// Sent to Recurly to identify requests.
	PublicKey string `json:"publicKey"`
}

// Payment Method information for a recurring payment.
// An abstraction for a set of Payments models, existing here to surface to the Payments Management Page.
type RecurringPaymentDetail struct {
	// Time that the payment will attempt to renew.
	ExpiresAt *time.Time `json:"expiresAt"`
	// Product type of the purchase.
	ProductType SubscriptionProductType `json:"productType"`
	// Currency for the renewalPrice, e.g. "USD".
	RenewalCurrency *string `json:"renewalCurrency"`
	// Expected renewal price of the product in the smallest subunit of the currency, e.g. "499".
	RenewalPrice *int `json:"renewalPrice"`
	// Divisor for renewalPrice for display: e.g. "100" for USD.
	RenewalPriceDivisor *int `json:"renewalPriceDivisor"`
	// Subscription benefit, if still active.
	SubscriptionBenefit *SubscriptionBenefit `json:"subscriptionBenefit"`
	// Twitch user ID, owner of the entitlement benefit.
	TicketOwnerID *string `json:"ticketOwnerID"`
	// Twitch user ID, owner of the channel that was subscribed to.
	// Can be null if product type is Turbo.
	TicketProductOwnerID *string `json:"ticketProductOwnerID"`
	// Whether this subscription will renew in the future and charge the user's payment method.
	WillRenew bool `json:"willRenew"`
}

// Redeem claimable error.
type RedeemClaimableError struct {
	// Error code while redeeming.
	Code RedeemClaimableErrorCode `json:"code"`
}

// The input for claiming a key code.
type RedeemClaimableInput struct {
	// Optional param for user's self-declared country of residence.
	// Currently only used for Gift Card Redemptions.
	CountryOfResidence *string `json:"countryOfResidence"`
	// The key code that needs to be claimed.
	KeyCode string `json:"keyCode"`
}

// The payload returned after claiming a key code.
type RedeemClaimablePayload struct {
	// Possible errors returned from the service for this mutation.
	Error *RedeemClaimableError `json:"error"`
	// The updated key information.
	Key Claimable `json:"key"`
}

// An error from redeeming a custom Community Points reward in a channel.
type RedeemCommunityPointsCustomRewardError struct {
	// An identifier for the error that occurred.
	Code *RedeemCommunityPointsCustomRewardErrorCode `json:"code"`
}

// Input for redeeming a custom Community Points reward in a channel.
type RedeemCommunityPointsCustomRewardInput struct {
	// The channel ID that the reward is being redeemed in.
	ChannelID string `json:"channelID"`
	// The cost that the client expects this reward to cost.
	// If this cost is different from the reward's true cost, the request will fail.
	Cost int `json:"cost"`
	// The prompt that the client expects this reward to have.
	// If this prompt is different from the reward's true prompt, the request will fail.
	// Should be null if the reward does not have a prompt.
	Prompt *string `json:"prompt"`
	// The unique reward ID.
	RewardID string `json:"rewardID"`
	// For rewards that require text input, this is the user-supplied text.
	// Discarded if the reward does not require text input.
	TextInput *string `json:"textInput"`
	// The title that the client expects this reward to have.
	// If this title is different from the reward's true title, the request will fail.
	Title string `json:"title"`
	// Client-set identifier for the transaction. This ID should be universally unique.
	TransactionID string `json:"transactionID"`
}

// The response from redeeming a custom Community Points reward in a channel.
type RedeemCommunityPointsCustomRewardPayload struct {
	// An error that occurred while redeeming a custom Community Points reward in a channel.
	Error *RedeemCommunityPointsCustomRewardError `json:"error"`
	// The newly created redemption.
	Redemption *CommunityPointsCustomRewardRedemption `json:"redemption"`
}

// RedeeemCreatorGiftsInput the input for redeeming subscriptions from a creator's balance.
type RedeemCreatorGiftsInput struct {
	// The amount of balance to redeem. This value must be greater than 0 and less than the creator's
	// standing balance.
	Amount int `json:"amount"`
}

// RedeemCreatorGiftsPayload the output of redeeming subscriptions from a creator's balance.
type RedeemCreatorGiftsPayload struct {
	// The container for creator gifts the creator has.
	CreatorGifting *CreatorGifting `json:"creatorGifting"`
}

type RedeemRitualTokenError struct {
	Code RedeemRitualTokenErrorCode `json:"code"`
}

// RedeemRitualTokenInput is the input when redeeming a ritual token.
type RedeemRitualTokenInput struct {
	// The channel to redeem the token in.
	ChannelID string `json:"channelID"`
	// User-specified text to send with the token redemption.
	MessageText *string `json:"messageText"`
	// The type of ritual to be redeemed.
	Type RitualTokenType `json:"type"`
}

// RedeemRitualTokenPayload is the response when redeeming a ritual token.
type RedeemRitualTokenPayload struct {
	Error *RedeemRitualTokenError `json:"error"`
	Token *RitualToken            `json:"token"`
}

// RedeemSubscriptionInput creates a new subscription redemption input.
type RedeemSubscriptionInput struct {
	// The channelID to which the user is currently subscribed to and is allowing to redeem a subscription.
	FromChannelID string `json:"fromChannelID"`
	// The channelID to which the user wants to redeem their subscription to.
	TargetChannelID string `json:"targetChannelID"`
	// The User who is trying to redeem the subscription.
	UserID string `json:"userID"`
}

// RedeemSubscriptionPayload returns a status code indicating whether the update was successful or not.
type RedeemSubscriptionPayload struct {
	// A code indicating why the redemption of subscription failed, if it did.
	ErrorCode *RedeemSubscriptionResponseErrorCode `json:"errorCode"`
	// The Subscription Product that the user has been entitled to.
	Product *SubscriptionProduct `json:"product"`
}

type RedeemTrueXAdInput struct {
	// args are parameters describing the engagement the user just completed for bits.
	Args string `json:"args"`
	// signature is a digital signature protecting the integrity of `args`.
	Signature string `json:"signature"`
	// targetID is the `User.id` of the channel where the user is watching the ad.
	TargetID *string `json:"targetID"`
	// trueXAd is descriptive information about the engagement that was just shown.
	// This information is useful for logging errors on the server-side.
	TrueXAd *TrueXAd `json:"trueXAd"`
}

type RedeemTrueXAdPayload struct {
	// currentUser is the authenticated user object which includes the updated `Wallet` info after the message bits have been spent.
	CurrentUser *User `json:"currentUser"`
	// grantedBits is the number of bits the user earned from this engagement.
	GrantedBits int `json:"grantedBits"`
}

// The required input for an RefreshExtensionToken mutation.
type RefreshExtensionTokenInput struct {
	// The id of the channel the extension is currently installed on.
	ChannelID string `json:"channelID"`
	// The ID of the extension that the user is refreshing their token for.
	ExtensionID string `json:"extensionID"`
	// The current extension jwt being refreshed.
	Jwt *string `json:"jwt"`
}

// The result of a RefreshExtensionToken mutation.
type RefreshExtensionTokenPayload struct {
	// Error from an RefreshExtensionToken Call.
	Error *string `json:"error"`
	// The user's new token.
	Token *ExtensionToken `json:"token"`
}

// RegenerateStreamKeyInput is input required to regenerate a broadcaster's stream key.
type RegenerateStreamKeyInput struct {
	// channelID of the broadcaster.
	ChannelID string `json:"channelID"`
}

// RegenerateStreamKeyPayload contains the VideoStreamSettings with updated stream key.
type RegenerateStreamKeyPayload struct {
	// The updated video stream for channel.
	Channel *Channel `json:"channel"`
}

// RegenerateVerificationCodeInput is input required to regenerate a user's verification code in EVS.
type RegenerateVerificationCodeInput struct {
	// Address that the user is verifying. This will most likely be an email address or phone number.
	Address string `json:"address"`
	// Key for the entity associated with the address. This is generally the Twitch ID of the user.
	Key string `json:"key"`
}

// RegenerateVerificationCodePayload is the VerificationRequest document returned from EVS on success.
type RegenerateVerificationCodePayload struct {
	// The updated verification request.
	Request *VerificationRequest `json:"request"`
}

// RegisterPayoutInformationError describes the error that occured when registering a user's payout information during payout onboarding.
type RegisterPayoutInformationError struct {
	// Code to describe error that occurred while registering payout information.
	Code RegisterPayoutInformationErrorCode `json:"code"`
	// Lists any field names that have an invalid format.
	InvalidFields []RegisterPayoutInformationFieldName `json:"invalidFields"`
}

// RegisterPayoutInformationInput is the input required to register a user's payout information during payout onboarding.
type RegisterPayoutInformationInput struct {
	// Birthdate submitted by the user while registering into a payout program.
	Birthdate time.Time `json:"birthdate"`
	// City submitted by the user while registering into a payout program.
	City string `json:"city"`
	// Company Name submitted by the user while registering into a payout program.
	CompanyName *string `json:"companyName"`
	// Country Code (ISO-3166) submitted by the user while registering into a payout program.
	CountryCode string `json:"countryCode"`
	// Email submitted by the user while registering into a payout program.
	Email string `json:"email"`
	// First Name submitted by the user while registering into a payout program.
	FirstName string `json:"firstName"`
	// Last Name submitted by the user while registering into a payout program.
	LastName string `json:"lastName"`
	// Middle Name submitted by the user while registering into a payout program.
	MiddleName *string `json:"middleName"`
	// Parent Email submitted by the under age user while registering into a payout program.
	ParentEmail *string `json:"parentEmail"`
	// Parent Name submitted by the under age user while registering into a payout program.
	ParentName *string `json:"parentName"`
	// Postal submitted by the user while registering into a payout program.
	Postal *string `json:"postal"`
	// State Code submitted by the user while registering into a payout program.
	StateCode *string `json:"stateCode"`
	// Primary Address submitted by the user while registering into a payout program.
	StreetAddress string `json:"streetAddress"`
	// Secondary Address submitted by the user while registering into a payout program.
	StreetAddress2 *string `json:"streetAddress2"`
	// TargetUserID is the ID of the user whose payout information will be registered.
	TargetUserID string `json:"targetUserID"`
}

// RegisterPayoutInformationPayload is the updated workflow after registration is accepted.
type RegisterPayoutInformationPayload struct {
	// Describes error that occured when registering payout information.
	Error *RegisterPayoutInformationError `json:"error"`
	// New workflow state.
	Workflow *PayoutOnboardingWorkflow `json:"workflow"`
}

// Error returned during a invalid user request.
type RegisterTwoFactorConfirmationError struct {
	// Error code returned by the backend.
	Code RegisterTwoFactorConfirmationErrorCode `json:"code"`
	// The localized external error message.
	Message string `json:"message"`
}

// The required input for a registerTwoFactorConfirmation mutation.
type RegisterTwoFactorConfirmationInput struct {
	// The one time password required to complete two factor registration.
	OneTimePassword string `json:"oneTimePassword"`
	// The ID of the user that is requesting to complete registration of two factor authentication.
	UserID string `json:"userID"`
}

// The result of a registerTwoFactorConfirmationPayload mutation.
type RegisterTwoFactorConfirmationPayload struct {
	// New access token returned for clients to use after turning on 2FA.
	AccessToken *string `json:"accessToken"`
	// error code and localized error.
	Error *RegisterTwoFactorConfirmationError `json:"error"`
}

// Error returned during a invalid user request.
type RegisterTwoFactorError struct {
	// Error code returned by the backend.
	Code RegisterTwoFactorErrorCode `json:"code"`
	// The localized external error message.
	Message string `json:"message"`
}

// The required input for a registerTwoFactor mutation.
type RegisterTwoFactorInput struct {
	// The phone number used for two factor registration.
	PhoneNumber string `json:"phoneNumber"`
	// The ID of the user that is requesting to register for two factor authentication.
	UserID string `json:"userID"`
}

// The result of a registerTwoFactorPayload mutation.
type RegisterTwoFactorPayload struct {
	// error code and localized error.
	Error *RegisterTwoFactorError `json:"error"`
}

type RejectFriendRequestInput struct {
	// The authenticated user will reject the friend request sent by the user with an ID equal to targetID.
	TargetID string `json:"targetID"`
}

type RejectFriendRequestPayload struct {
	// The user whose friend request was just rejected.
	User *User `json:"user"`
}

// Errors from rejectSquadStreamInvitation mutation.
type RejectSquadStreamInvitationError struct {
	// Error from request to reject invitation.
	Code RejectSquadStreamInvitationErrorCode `json:"code"`
}

// Inputs to the rejectSquadStreamInvitation mutation.
type RejectSquadStreamInvitationInput struct {
	// ID of the invitation to be rejected.
	InvitationID string `json:"invitationID"`
}

// Outputs from the rejectSquadStreamInvitation mutation.
type RejectSquadStreamInvitationPayload struct {
	// Error from mutation if exists.
	Error *RejectSquadStreamInvitationError `json:"error"`
	// The rejected invitation.
	Invitation *SquadStreamInvitation `json:"invitation"`
}

// RejectSquadStreamOutOfNetworkInvitationsError is the error associated with a rejectSquadStreamOutOfNetworkInvitations.
type RejectSquadStreamOutOfNetworkInvitationsError struct {
	// The associated error code.
	Code RejectSquadStreamOutOfNetworkInvitationsErrorCode `json:"code"`
}

// Inputs to the rejectSquadStreamOutOfNetworkInvitations mutation.
type RejectSquadStreamOutOfNetworkInvitationsInput struct {
	// ID of the user whose out of network invitations will be rejected.
	RecipientID string `json:"recipientID"`
}

// Outputs from the rejectSquadStreamOutOfNetworkInvitations mutation.
type RejectSquadStreamOutOfNetworkInvitationsPayload struct {
	// The possible error returned from the service.
	Error *RejectSquadStreamOutOfNetworkInvitationsError `json:"error"`
}

type RejectedChatMessage struct {
	// Original message's raw body.
	Body *string `json:"body"`
	// Optional list of fragments from the messages's body that lead to the message rejection.
	FailedFragments []*string `json:"failedFragments"`
	// The ID of the message.
	ID *string `json:"id"`
	// Specifies if a action by a moderator has been taken on the message.
	IsResolved *bool `json:"isResolved"`
	// The extracted caught message.
	Message *Message `json:"message"`
	// The user that created the message.
	Sender *User `json:"sender"`
	// The channel where the message was originally sent.
	Target *User `json:"target"`
}

// RemoveAutohostChannelsInput remove channelIDs from a user's list to autohost.
type RemoveAutohostChannelsInput struct {
	// ChannelIDs that will be removed from the list to autohost.
	ChannelIDs []string `json:"channelIDs"`
	// UserID to update autohost list for.
	UserID string `json:"userID"`
}

// RemoveAutohostChannelsPayload returns the user whose autohostChannels field had been updated.
type RemoveAutohostChannelsPayload struct {
	// User whose autohostChannels field had been updated.
	User *User `json:"user"`
}

// RemoveCollectionItemInput accepts a collectionID and item ID and parameters to remove the item from a collection.
type RemoveCollectionItemInput struct {
	// The id of the collection.
	CollectionID string `json:"collectionID"`
	// The id of the item of which will be added to the collection.
	ItemID string `json:"itemID"`
	// The type of item ie. video.
	ItemType string `json:"itemType"`
}

// The response from removing an item from a collection.
type RemoveCollectionItemPayload struct {
	// The newly updated collection.
	Collection *Collection `json:"collection"`
}

// RemoveCompetitionPhaseInput contains the inputs required to remove a phase.
type RemoveCompetitionPhaseInput struct {
	// The competition id of the competition.
	CompetitionID string `json:"competitionID"`
	// The id of the competition phase.
	PhaseID string `json:"phaseID"`
}

// RemoveCompetitionPhasePayload is the success response for removing a phase.
type RemoveCompetitionPhasePayload struct {
	// The new state of competition after removing a phase.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// Remove a player from a Competition. If you remove a player that is part of a team, the player will removed from the team as well. If that player is a captain of the team, the team will no longer have a captain.
type RemoveCompetitionPlayerInput struct {
	// Unique Competition ID.
	CompetitionID string `json:"competitionID"`
	// Twitch user id of the player.
	UserID string `json:"userID"`
}

// Indication that the player was removed.
type RemoveCompetitionPlayerPayload struct {
	// The new state of competition after removing a competition player from the competition.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// Inputs for removing a competition team from a competition.
type RemoveCompetitionTeamInput struct {
	// ID of the competition.
	CompetitionID string `json:"competitionID"`
	// ID of the team.
	TeamID string `json:"teamID"`
}

// RemoveCompetitionTeamPayload is the success response removing a competition team from the competition.
type RemoveCompetitionTeamPayload struct {
	// The new state of competition after removing a competition team from the competition.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// RemoveEditorError contains details about a client error that occurred.
type RemoveEditorError struct {
	// The type of error that occurred when revoking a user's editor status.
	Code RemoveEditorErrorCode `json:"code"`
}

// RemoveEditorInput contains the parameters to revoke the editor status from a user for a channel.
type RemoveEditorInput struct {
	// The channel from which the editor status of the user will be revoked.
	ChannelID string `json:"channelID"`
	// The ID of the user whose editor status will be revoked.
	// Either targetUserID or targetUserLogin must be provided.
	TargetUserID *string `json:"targetUserID"`
	// The login of the user whose editor status will be revoked.
	// Either targetUserID or targetUserLogin must be provided.
	TargetUserLogin *string `json:"targetUserLogin"`
}

// RemoveEditorPayload is the response after attempting to revoke the editor status of a user.
type RemoveEditorPayload struct {
	// The channel for which the editor status of the target user is removed.
	Channel *User `json:"channel"`
	// The client error that has occurred.
	// Null if the operation is successful.
	Error *RemoveEditorError `json:"error"`
	// The user whose editor status was revoked.
	TargetUser *User `json:"targetUser"`
}

// RemoveOrganizationMemberError is the error associated with a RemoveOrganizationMember.
type RemoveOrganizationMemberError struct {
	// The associated error code.
	Code RemoveOrganizationMemberErrorCode `json:"code"`
}

// Inputs to the removeOrganizationMember mutation.
type RemoveOrganizationMemberInput struct {
	// The ID of the organization.
	OrganizationID string `json:"organizationID"`
	// The twitch ID of the organization member.
	UserID string `json:"userID"`
}

// Outputs from the removeOrganizationMember mutation.
type RemoveOrganizationMemberPayload struct {
	// The possible error returned from the service.
	Error *RemoveOrganizationMemberError `json:"error"`
	// The user who is removed from organization.
	TargetUser *User `json:"targetUser"`
}

type RemoveReactionInput struct {
	EmoteID  string `json:"emoteID"`
	EntityID string `json:"entityID"`
}

type RemoveReactionPayload struct {
	Content ReactableContent `json:"content"`
}

// RemoveSquadStreamMemberError is the error associated with a removeSquadStreamMember.
type RemoveSquadStreamMemberError struct {
	// The associated error code.
	Code RemoveSquadStreamMemberErrorCode `json:"code"`
}

// Inputs to the removeSquadStreamMember mutation.
type RemoveSquadStreamMemberInput struct {
	// The user ID of the member that should be removed from the squad stream.
	MemberUserID string `json:"memberUserID"`
	// The ID of the squad stream.
	SquadStreamID string `json:"squadStreamID"`
}

// Outputs from the removeSquadStreamMember mutation.
type RemoveSquadStreamMemberPayload struct {
	// The possible error returned from the service.
	Error *RemoveSquadStreamMemberError `json:"error"`
	// The updated squad stream.
	SquadStream *SquadStream `json:"squadStream"`
}

// Inputs for removing a stucco (from the library).
// - Active stuccos cannot be removed, they have to be inactive first (not part of a stucco pack).
type RemoveStuccoInput struct {
	// ID of the channel the stucco is removed from.
	ChannelID string `json:"channelID"`
	// Unique ID of the stucco to be removed.
	StuccoID string `json:"stuccoID"`
}

// The output payload for removing a stucco, returns the library of stuccos after removal.
type RemoveStuccoPayload struct {
	// The list of stuccos available in the channel's library after removal.
	Stuccos []*Stucco `json:"stuccos"`
}

// ReorderCollectionItemInput accepts a collectionID and item ID and parameters to update the item order of a collection.
type ReorderCollectionItemInput struct {
	// The id of the collection.
	CollectionID string `json:"collectionID"`
	// The id of the item of which will be moved in the collection.
	ItemID string `json:"itemID"`
	// The type of item ie. video.
	ItemType string `json:"itemType"`
	// The new position of the item.
	Position int `json:"position"`
}

// The response from reordering an item in a collection.
type ReorderCollectionItemPayload struct {
	// The newly updated collection.
	Collection *Collection `json:"collection"`
}

type ReportContentInput struct {
	// Content type being reported.
	Content ReportContentType `json:"content"`
	// ID of the content being reported.
	ContentID string `json:"contentID"`
	// The description of the report.
	Description string `json:"description"`
	// Extra (content specific) data for the report.
	Extra string `json:"extra"`
	// Extra arguments required for NetzDG reporting.
	NetzDGArgs *ReportContentNetzDGInput `json:"netzDGArgs"`
	// The reason ID for the report.
	Reason string `json:"reason"`
	// ID of the user being reported.
	TargetID string `json:"targetID"`
	// The path taken through the report wizard.
	WizardPath []string `json:"wizardPath"`
}

// Extra fields that are required for NetzDG reporting.
type ReportContentNetzDGInput struct {
	// Who the reporter thinks the offending content is directed to.
	ContentDirectedTo ReportContentNetzDGContentDirectedTo `json:"contentDirectedTo"`
	// The email address of the reporter.
	ReporterEmail string `json:"reporterEmail"`
	// Who the reporter is reporting on behalf of.
	ReportingFor ReportContentNetzDGReportingFor `json:"reportingFor"`
}

type ReportContentPayload struct {
	// Content type that was reported.
	Content ReportContentType `json:"content"`
	// ID of the content that was reported.
	ContentID string `json:"contentID"`
}

// A valid reason for a report.
type ReportReason struct {
	// The unique ID of the reason.
	ID string `json:"id"`
	// Whether or not this report reason is in-scope for a country-specific law.
	IsApplicableToCountryRegulations bool `json:"isApplicableToCountryRegulations"`
	// The displayed text for this reason localized based on Accept-Language.
	Text string `json:"text"`
}

// A valid country and ToS reasons for a report.
type ReportToSAndCountryReasons struct {
	// The countryCode of the country-specific reporting flow that applies to the user.
	// If null then there is no relevant country-specific reporting flow for the user.
	CountryCode *string `json:"countryCode"`
	// Localized string that should be displayed to the user as a disclosure that their report.
	// Falls under given legislation, and may be viewed by legal authorities.
	DisclosureText *string `json:"disclosureText"`
	// The list of report reasons that apply for the content type.
	ToSAndCountryReasons []*ReportReason `json:"toSAndCountryReasons"`
}

// Input to the reportWhisper mutation.
type ReportWhisperInput struct {
	// The description of the report.
	Description string `json:"description"`
	// The reason option for the report.
	Reason string `json:"reason"`
	// ID of the user being reported.
	TargetID string `json:"targetID"`
	// The path taken through the report wizard.
	WizardPath []string `json:"wizardPath"`
}

// Payload returned from the reportWhisper mutation.
type ReportWhisperPayload struct {
	// Reports aren't queryable in GQL, so only an error is returned.
	Error *ReportWhisperPayloadError `json:"error"`
}

// Error type that may be returned returned from the reportWhisper mutation.
type ReportWhisperPayloadError struct {
	// Reason that the report wasn't created.
	Reason ReportWhisperErrorReason `json:"reason"`
}

type ReportWhisperThreadInput struct {
	// Reason why the user is reporting the thread.
	Reason *string `json:"reason"`
	// ID of user being reported.
	TargetUserID string `json:"targetUserID"`
	// ID of thread to report.
	ThreadID string `json:"threadID"`
}

type ReportWhisperThreadPayload struct {
	Thread *WhisperThread `json:"thread"`
}

// Metadata about a GraphQL request.
type RequestInfo struct {
	// The country code where the request originated. Defaults to "US" if geoip lookup fails.
	CountryCode string `json:"countryCode"`
	// Whether the request came from a country belonging to the European Union.
	FromEu bool `json:"fromEU"`
	// The IP address where the request originated.
	IPAddress *string `json:"ipAddress"`
	// Whether the request came from a country belonging to the European Economic Area.
	IsFromEea bool `json:"isFromEEA"`
}

type RequestRitualTokenError struct {
	Code RequestRitualTokenErrorCode `json:"code"`
}

// RequestRitualTokenInput is the input when requesting a ritual token.
type RequestRitualTokenInput struct {
	// The channel to request a ritual token in.
	ChannelID string `json:"channelID"`
	// The type of ritual token to request.
	Type RitualTokenType `json:"type"`
}

// RequestRitualTokenPayload is the response when requesting a ritual token.
type RequestRitualTokenPayload struct {
	Error *RequestRitualTokenError `json:"error"`
	Token *RitualToken             `json:"token"`
}

// ResendVerificationEmailInput is input required to resend the verification email.
type ResendVerificationEmailInput struct {
	// ID of the user to resend a verification email to.
	UserID string `json:"userID"`
}

// ResendVerificationEmailPayload is the output after resending a verification email.
type ResendVerificationEmailPayload struct {
	// The modified user.
	User *User `json:"user"`
}

// Error returned during an invalid username reset request.
type ResetUsernameCodeError struct {
	// Error code returned by the backend.
	Code ResetUsernameErrorCode `json:"code"`
}

// Input for a username reset.
type ResetUsernameInput struct {
	// The new login for the user.
	Login string `json:"login"`
	// The authorization token for the username reset.
	ResetUsernameToken string `json:"resetUsernameToken"`
}

// The result of a username reset.
type ResetUsernamePayload struct {
	// Error code for error from returned the username reset.
	Error *ResetUsernameCodeError `json:"error"`
	// The modified username for the user.
	Login *string `json:"login"`
}

// An error returned from the resolvePredictionEvent mutation.
type ResolvePredictionEventError struct {
	// Code describing the error.
	Code ResolvePredictionEventErrorCode `json:"code"`
}

// Input for resolving a Prediction Event (and paying out all of the users who predicted correctly).
type ResolvePredictionEventInput struct {
	// The unique identifier of the Prediction Event to resolve.
	EventID string `json:"eventID"`
	// The unique identifier of the Prediction Outcome to select as the winner.
	OutcomeID string `json:"outcomeID"`
}

// Payload for resolving a prediciton event.
type ResolvePredictionEventPayload struct {
	// If present, there was an error with the request.
	Error *ResolvePredictionEventError `json:"error"`
	// The resolved Prediction Event.
	PredictionEvent *PredictionEvent `json:"predictionEvent"`
}

// A restriction for a specific resource.
type ResourceRestriction struct {
	// The list of exemptions for a given resource restriction.
	Exemptions []*ResourceRestrictionExemption `json:"exemptions"`
	// The restriction's unique identifier.
	ID string `json:"id"`
	// The list of options that were applied at time of creation for a given resource restriction.
	Options []ResourceRestrictionOption `json:"options"`
	// The type of restriction on this resource.
	Type ResourceRestrictionType `json:"type"`
}

// Exemption information for a specific resource restriction.
type ResourceRestrictionExemption struct {
	// The list of description data a user make take to become exempt for the given restriction.
	Actions []*ResourceRestrictionExemptionAction `json:"actions"`
	// The time that the restriction is no longer active.
	EndsAt *time.Time `json:"endsAt"`
	// The keys needed for a given restriction.
	Keys []string `json:"keys"`
	// The time that the restriction becomes active.
	StartsAt *time.Time `json:"startsAt"`
	// The type of exemption.
	Type ResourceRestrictionExemptionType `json:"type"`
}

// Description data for clients to get for user actions to get exempt.
type ResourceRestrictionExemptionAction struct {
	// Name of the action need. e.g. Ticket Product short name.
	Name string `json:"name"`
	// The human readable title of the restriction.
	Title string `json:"title"`
}

// Inputs to the respondToTeamInvitation mutation.
type RespondToTeamInvitationInput struct {
	// Whether the user accepts or declines the team invite.
	Accepted bool `json:"accepted"`
	// The team whose invite the user will be responding to.
	TeamID string `json:"teamID"`
	// The authenticated user who will respond to the team invitation with an ID equal to userID.
	UserID string `json:"userID"`
}

// Outputs from the respondToTeamInvitation mutation.
type RespondToTeamInvitationPayload struct {
	// The user who just accepted a team invitation.
	User *User `json:"user"`
}

// A recent resub token to use for sending a special message.
type ResubNotification struct {
	// The number of months of total subbing.
	CumulativeTenureMonths int `json:"cumulativeTenureMonths"`
	// A unique ID for the resub notification.
	ID string `json:"id"`
	// The number of months of consecutive subbing.
	Months int `json:"months"`
	// The number of months of consecutive subbing.
	StreakTenureMonths int `json:"streakTenureMonths"`
	// The token to use when submitting a sub/resub message.
	Token string `json:"token"`
	// If the resub notification is caused by a gift or not
	IsGiftSubscription bool `json:"isGiftSubscription"`
	// Gifter who gave the gift, null if no gifter or anon
	Gifter *User `json:"gifter"`
}

// The input to resume a schedule.
type ResumeScheduleInput struct {
	// The id of the schedule.
	ScheduleID string `json:"scheduleID"`
}

// The returned payload when resuming a schedule.
type ResumeSchedulePayload struct {
	// The possible error.
	Error *ResumeScheduleError `json:"error"`
	// The updated schedule input.
	Schedule *Schedule `json:"schedule"`
}

// Revenue configuration data related to a subscription product.
type RevenueConfig struct {
	// Unique identifier for the revenue configuration.
	ID string `json:"id"`
	// 0-100 percent value of revenue the broadcaster will earn.
	SplitPercent int `json:"splitPercent"`
	// Start time of when the revenue split configuration takes effect.
	StartAt *time.Time `json:"startAt"`
}

// RevokeVIPError contains details about a client error that occurred.
type RevokeVIPError struct {
	// The type of error that occurred when revoking a user's VIP status.
	Code RevokeVIPErrorCode `json:"code"`
}

// RevokeVIPInput contains the parameters to revoke the VIP status of a user from a channel.
type RevokeVIPInput struct {
	// The channel from which the VIP status of the user will be revoked.
	ChannelID string `json:"channelID"`
	// The ID of the user whose VIP status will be revoked.
	// Either revokeeID or revokeeLogin must be provided.
	RevokeeID *string `json:"revokeeID"`
	// The login of the user whose VIP status will be revoked.
	// Either revokeeID or revokeeLogin must be provided.
	RevokeeLogin *string `json:"revokeeLogin"`
}

// RevokeVIPPayload is the response after attempting to revoke the VIP status of a user.
type RevokeVIPPayload struct {
	// The channel that the user is revoked as a VIP to.
	Channel *User `json:"channel"`
	// The client error that has occurred.
	// Null if the operation is successful.
	Error *RevokeVIPError `json:"error"`
	// The user whose VIP status is revoked.
	Revokee *User `json:"revokee"`
}

// Rewarded Video information.
type RewardedVideo struct {
	// A flag indicating if the user is eligible for rewarded videos.
	IsEligible bool `json:"isEligible"`
	// A flag indicating if the user needs to do a captcha in order to use rewarded videos.
	ShouldCaptcha bool `json:"shouldCaptcha"`
}

type RichOEmbed struct {
	AuthorName   *string          `json:"authorName"`
	AuthorURL    *string          `json:"authorURL"`
	CacheAge     *int             `json:"cacheAge"`
	Height       int              `json:"height"`
	HTML         string           `json:"html"`
	InputURL     string           `json:"inputURL"`
	ProviderName *string          `json:"providerName"`
	ProviderURL  *string          `json:"providerURL"`
	Thumbnail    *ThumbnailOEmbed `json:"thumbnail"`
	Title        *string          `json:"title"`
	Type         string           `json:"type"`
	Version      string           `json:"version"`
	Width        int              `json:"width"`
}

func (RichOEmbed) IsPostEmbed() {}
func (RichOEmbed) IsFeedEmbed() {}
func (RichOEmbed) IsOEmbed()    {}

// A ritual is an opportunity for a viewer to better connect with a streamer's
// community by announcing when they reach milestones in the channel.
// A ritual token is issued when a user is eligible for the ritual, and can be
// redeemed to send the announcement in a channel.
type RitualToken struct {
	// The channel that the user can redeem the ritual token in.
	Channel *User `json:"channel"`
	// The time after which the ritual is considered expired and can no longer be
	// redeemed. Clients should dismiss the ritual UI if it's still shown after
	// this time. Null if the ritual never expires.
	ExpiresAt *time.Time `json:"expiresAt"`
	// A unique ID for the ritual token.
	ID string `json:"id"`
	// The status of the ritual token.
	Status *RitualTokenStatus `json:"status"`
	// The type of the ritual to be redeemed.
	Type *RitualTokenType `json:"type"`
	// The user that owns the ritual token.
	User *User `json:"user"`
}

// DEPRECATED.
// A chatroom associated with a channel where members of the room can exchange messages.
type Room struct {
	// UUID of the room.
	ID string `json:"id"`
	// Whether the room can be read by non-members and logged out users.
	IsPreviewable bool `json:"isPreviewable"`
	// Paginated list of members of the chatroom.
	Members *RoomMemberConnection `json:"members"`
	// List of messages to the room, in reverse chronological order. If fromTime is used, that time is used
	// as the cursor instead of after/before.
	Messages *RoomMessageConnection `json:"messages"`
	// Minimum role required to join the room. For example, in a sub room, subs can join,
	// but also the broadcaster, mods, and staff.
	MinimumAllowedRole RoomRole `json:"minimumAllowedRole"`
	// Room modes (e.g. slow mode).
	Modes *RoomModes `json:"modes"`
	// The name of the room (e.g. subs-only).
	Name string `json:"name"`
	// The user the room belongs to.
	Owner *User `json:"owner"`
	// rolePermissions describes the role necessary to perform actions in the room.
	RolePermissions *RoomRolePermissions `json:"rolePermissions"`
	// Returns the current user's settings for the room.
	Self *RoomView `json:"self"`
	// The room topic (e.g. "serious discussion only").
	Topic *string `json:"topic"`
}

// DEPRECATED
// Paginated list of room members (users).
type RoomMemberConnection struct {
	// The elements of the list.
	Edges []*RoomMemberEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Element in a list of room members.
type RoomMemberEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// The user who is a member of the room.
	Node *User `json:"node"`
	// Type of user for grouping users in the rooms member list.
	Type RoomMemberType `json:"type"`
}

// DEPRECATED
// A message sent from a user to a room.
type RoomMessage struct {
	// The text and emoticon content of a message.
	Content *RoomMessageContent `json:"content"`
	// Time the message was deleted or purged. Null if the message is not deleted.
	DeletedAt *time.Time `json:"deletedAt"`
	// UUID of the message.
	ID string `json:"id"`
	// The room the message was sent in.
	Room *Room `json:"room"`
	// The user that sent the message.
	Sender *User `json:"sender"`
	// Time the message was sent.
	SentAt time.Time `json:"sentAt"`
}

func (RoomMessage) IsRoomMessageItem() {}

// DEPRECATED
// Paginated list of messages in a room.
type RoomMessageConnection struct {
	// The elements of the list.
	Edges []*RoomMessageEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// DEPRECATED
// The content of a user's message to a room.
type RoomMessageContent struct {
	// Parsed list of fragments in the message, include emotes, mentions, and plaintext.
	Fragments []*RoomMessageFragment `json:"fragments"`
	// String representation of the user message.
	Text string `json:"text"`
}

// Element in a list of messages.
type RoomMessageEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// The message.
	Node RoomMessageItem `json:"node"`
}

// DEPRECATED
// One parsed part of a message, which may be an emote, mention, or plaintext.
type RoomMessageFragment struct {
	// Contains an emote or a mentioned user depending on the text of the fragment.
	Content FragmentContent `json:"content"`
	// Plaintext representation of the fragment.
	Text string `json:"text"`
}

// DEPRECATED
// RoomMessageGroupMention represents a group mention, such as @here.
type RoomMessageGroupMention struct {
	// The type of mention.
	Type RoomMessageMentionType `json:"type"`
}

func (RoomMessageGroupMention) IsFragmentContent() {}

// Modes that have been enabled for the room.
type RoomModes struct {
	// If enabled, messages to the room must contain only emotes.
	EmotesOnlyModeEnabled bool `json:"emotesOnlyModeEnabled"`
	// If enabled, messages to the room must be unique.
	R9kModeEnabled bool `json:"r9kModeEnabled"`
	// The number of seconds users must wait between messages. If 0, slow mode is disabled.
	SlowModeDurationSeconds int `json:"slowModeDurationSeconds"`
}

// DEPRECATED
// Represents the permissions a user has in a room.
type RoomPermissions struct {
	// Whether the user can moderate the room.
	Moderate bool `json:"moderate"`
	// Whether the user can read messages in the room.
	ReadMessages bool `json:"readMessages"`
	// Whether the user can send messages in the room.
	SendMessages bool `json:"sendMessages"`
}

// DEPRECATED
// RoomRolePermissions describes the role necessary to perform actions in a room.
type RoomRolePermissions struct {
	// Read describes the role necessary to read messages in the room.
	Read RoomRole `json:"read"`
	// Send describes the role necessary to send messages in the room.
	Send RoomRole `json:"send"`
}

// DEPRECATED
// A RoomView represents the authenticated user's self connection to a room, and includes the user's
// settings and permissions.
type RoomView struct {
	// Whether the user has archived the room.
	IsArchived bool `json:"isArchived"`
	// Whether the user has muted the room.
	IsMuted bool `json:"isMuted"`
	// Whether the user has unread messages in the room.
	IsUnread bool `json:"isUnread"`
	// Last time the user read a message in the room.
	LastReadAt *time.Time `json:"lastReadAt"`
	// The permissions the authenticated user has in the room.
	Permissions *RoomPermissions `json:"permissions"`
	// The room the room view belongs to.
	Room *Room `json:"room"`
	// The number of mentions for the user in the room that the user has not read.
	UnreadMentionCount int `json:"unreadMentionCount"`
}

// RotateExtensionSecretsInput includes the necessary parameters for creating a new extension secrets.
type RotateExtensionSecretsInput struct {
	// Delay is the time delay in seconds between creation & activation of the secret.
	DelaySeconds int `json:"delaySeconds"`
	// extensionID to generate a the secret for.
	ExtensionID string `json:"extensionID"`
}

// RotateExtensionSecretsPayload returns the new extension secrets information.
type RotateExtensionSecretsPayload struct {
	// A user-friendly error, should one occur.
	Error *RotateExtensionSecretsError `json:"error"`
	// All the existing secrets for the extension.
	Secrets []*ExtensionSecret `json:"secrets"`
}

// Inputs for running multiplayer ads.
type RunMultiplayerAdsInput struct {
	// ID of the channel the ads will run on.
	ChannelID string `json:"channelID"`
	// The ID of the ad offers to run.
	OfferIDs []string `json:"offerIDs"`
}

// The response after running multiplayer ads.
type RunMultiplayerAdsPayload struct {
	// The error that has occurred.
	// Null if the operation is successful.
	Error *RunMultiplayerAdErrorCode `json:"error"`
}

// Sony Computer Entertainment (SCE) title properties.
// Used as part of stream metadata for PlayStation.
type SCETitle struct {
	AgeRating             *int      `json:"ageRating"`
	Attribute             *string   `json:"attribute"`
	Genre                 *string   `json:"genre"`
	ID                    *string   `json:"id"`
	IsPreset              *bool     `json:"isPreset"`
	Language              *string   `json:"language"`
	Metadata              *string   `json:"metadata"`
	Name                  *string   `json:"name"`
	PresetText            []*string `json:"presetText"`
	PresetTextDescription *string   `json:"presetTextDescription"`
	ProductID             *string   `json:"productID"`
	SessionID             *string   `json:"sessionID"`
	ShortName             *string   `json:"shortName"`
	StoreURL              *string   `json:"storeURL"`
}

// Sony Computer Entertainment (SCE) user properties.
// Used as part of stream metadata for PlayStation.
type SCEUser struct {
	Country  *string `json:"country"`
	NpID     *string `json:"npID"`
	OnlineID *string `json:"onlineID"`
}

// A link between a single sign-on (SSO) app and a Twitch account.
// SSO apps are the Twitch apps on console and smart TV.
type SSOLink struct {
	// The name of the SSO app that is linked to the authenticated user's Twitch account.
	App *string `json:"app"`
	// The identifier of the device or user account on XboxLive, PSN, etc.
	// that is linked to the authenticated user's Twitch account.
	SsoID *string `json:"ssoID"`
}

// The view configuration of an extension if the component anchor is supported.
type SaveComponentViewInput struct {
	// The developer configured height of the extension as a ratio relative to it's width.
	AspectHeight *int `json:"aspectHeight"`
	// Specifies the width of a component extension in relation to it's targetHeight and aspectRatioY.
	//
	// NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth.
	//        however, since both will be used for a short time during the rollout of the new UI,
	//        aspectWidth and aspectHeight will not be deprecated until later.
	AspectRatioX int `json:"aspectRatioX"`
	// Specifies the height of a component extension in relation to it's targetHeight and aspectRatioX.
	//
	// NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
	//        however, since both will be used for a short time during the rollout of the new UI,
	//        aspectWidth and aspectHeight will not be deprecated until later.
	AspectRatioY int `json:"aspectRatioY"`
	// The developer configured width of the extension as a ratio relative to it's height.
	AspectWidth *int `json:"aspectWidth"`
	// Specifies whether to automatically scale the extension iframe using css zoom as the video
	// player dimensions change.
	HasAutoscale *bool `json:"hasAutoscale"`
	// Specifies whether CSS zooming should be applied to the CE container, creating a consistent
	// size of 1024 pixels along the long edge of the component. Default: true.
	HasZoom *bool `json:"hasZoom"`
	// If Autoscale is true, this indicates the baseline width of the extension.
	// This fields is optional, but is required if hasAutoscale is true.
	ScalePixels *int `json:"scalePixels"`
	// Size of the long edge of the Component Extension, relative to the length of the corresponding
	// interactable dimension of the video.
	Size *float64 `json:"size"`
	// The percentage of the available space (0-100) (between the top and bottom player controls)
	// that the extension aims to consume.
	//
	// NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
	//        however, since both will be used for a short time during the rollout of the new UI,
	//        aspectWidth and aspectHeight will not be deprecated until later.
	TargetHeight int `json:"targetHeight"`
	// Relative path of the HTML file to load for this view.
	ViewerPath string `json:"viewerPath"`
	// If hasZoom is set to true, specify the effective CSS zoom to apply to the long edge of the CE.
	// Default: 1024.
	ZoomPixels *int `json:"zoomPixels"`
}

// ConfigViewInput holds the view configuration of an extension if the config page is supported.
type SaveConfigViewInput struct {
	// Relative path of the HTML file to load for this view.
	ViewerPath string `json:"viewerPath"`
}

// ExtensionAssetManifestInput is data related to the assets of an extension.
type SaveExtensionAssetManifestInput struct {
	// Hash of the asset zip file.
	AssetHash string `json:"assetHash"`
}

// ExtensionCapabilitiesInput contains data about what an Extension can do, in general, and at the time of interaction.
type SaveExtensionCapabilitiesInput struct {
	// The bits support level required by the broadcaster for the extension to operate. Defaults to "NONE".
	BitsSupportLevel *ExtensionBitsSupportLevel `json:"bitsSupportLevel"`
	// Location of configuration.
	ConfigurationLocation ExtensionConfigurationLocation `json:"configurationLocation"`
	// Does this extension use bits.
	HasBitsSupport bool `json:"hasBitsSupport"`
	// Does this extension support chat.
	HasChatSupport bool `json:"hasChatSupport"`
	// Required configuration string.
	RequiredConfiguration string `json:"requiredConfiguration"`
	// The subscription support level required by the broadcaster for the extension to operate. Defaults to "NONE".
	SubscriptionsSupportLevel *ExtensionSubscriptionsSupportLevel `json:"subscriptionsSupportLevel"`
	// Whitelists for restricting extension access and behavior.
	Whitelists *ExtensionWhitelistsInput `json:"whitelists"`
	// Will this extension request an identity link.
	WillRequestIdentityLink bool `json:"willRequestIdentityLink"`
}

// ExtensionDeveloperManifestInput is the developer specific extension data.
type SaveExtensionDeveloperManifestInput struct {
	// Author email.
	AuthorEmail string `json:"authorEmail"`
	// Testing uri for extension development.
	TestingBaseURI string `json:"testingBaseURI"`
}

// Extension metadata used for discovery.
type SaveExtensionDiscoveryManifestInput struct {
	// Name of the extension author.
	AuthorName string `json:"authorName"`
	// Extension categories.
	Categories []string `json:"categories"`
	// Extension descriprion. 1024 character limit.
	Description string `json:"description"`
	// games an extension is associated with.
	Games []string `json:"games"`
	// name of the extension.
	Name string `json:"name"`
	// Url to an extensions privacy policy.
	PrivacyPolicyURL string `json:"privacyPolicyURL"`
	// Extension summary. 140 character limit.
	Summary string `json:"summary"`
	// Extension developers support email.
	SupportEmail string `json:"supportEmail"`
	// Extension eula/tos url.
	TermsURL string `json:"termsURL"`
	// A summary of the extension's functionality from a viewer's perspective.
	ViewerSummary string `json:"viewerSummary"`
}

// SaveExtensionManifestInput updates the manifest.
type SaveExtensionManifestInput struct {
	// ExtensionAssetManifest is data related to the assets of an extension.
	AssetManifest *SaveExtensionAssetManifestInput `json:"assetManifest"`
	// Data about what an Extension can do, in general, and at the time of interaction.
	Capabilities *SaveExtensionCapabilitiesInput `json:"capabilities"`
	// ExtensionDeveloperManifest is the developer specific extension data.
	DeveloperManifest *SaveExtensionDeveloperManifestInput `json:"developerManifest"`
	// Extension metadata used for discovery.
	DiscoveryManifest *SaveExtensionDiscoveryManifestInput `json:"discoveryManifest"`
	// The extension ID of the manifest to update.
	ID string `json:"id"`
	// The extension version to update.
	Version string `json:"version"`
	// Extension views.
	Views *SaveExtensionViewsInput `json:"views"`
}

// SaveExtensionManifestPayload returns the update Extension manifest.
type SaveExtensionManifestPayload struct {
	// The error when the mutation fails to update an extension.
	Error *SaveExtensionManifestError `json:"error"`
	// The updated extension manifest.
	Manifest *ExtensionManifest `json:"manifest"`
}

// The potential anchor-specific configurations and extension can have.
type SaveExtensionViewsInput struct {
	// The developer configuration of the extension as a component extension, if supported.
	Component *SaveComponentViewInput `json:"component"`
	// The developer configuration of the extension's configuration view, if supported.
	Config *SaveConfigViewInput `json:"config"`
	// The developer configuration of the extension's live configuration dashboard view, if supported.
	LiveConfig *SaveLiveConfigViewInput `json:"liveConfig"`
	// The developer configuration of the extension as a mobile extension, if supported.
	Mobile *SaveMobileViewInput `json:"mobile"`
	// The developer configuration of the extension as a panel extension, if supported.
	Panel *SavePanelViewInput `json:"panel"`
	// The developer configuration of the extension as a video overlay extension, if supported.
	VideoOverlay *SaveVideoOverlayViewInput `json:"videoOverlay"`
}

// ExtensionWhitelistsInput contains whitelists for restricting extension access and behavior.
type SaveExtensionWhitelistsInput struct {
	// List of broadcaster account IDs allowed to install an extension after release.
	// If this is empty or missing, all broadcasters can use this extension.
	Broadcasters []string `json:"broadcasters"`
	// URLs which are permitted to be opened from the configuration dialog.
	ConfigURLs []string `json:"configURLs"`
	// URLs which are permitted to be opened from an extension set as a panel.
	PanelURLs []string `json:"panelURLs"`
	// List of account IDs which should have access to a version of an extension.
	// Users in this list are ignored by the broadcaster whitelist check.
	Testers []string `json:"testers"`
}

// HiddenView holds the view configuration of an extension if it is a hidden load test extension.
type SaveHiddenViewInput struct {
	// Relative path of the HTML file to load for this view.
	ViewerPath string `json:"viewerPath"`
}

// LiveConfigViewInput holds the view configuration of an extension if the live config dashboard page is supported.
type SaveLiveConfigViewInput struct {
	// Relative path of the HTML file to load for this view.
	ViewerPath string `json:"viewerPath"`
}

// MobileViewInput holds the view configuration of an extension if mobile is supported.
type SaveMobileViewInput struct {
	// Relative path of the HTML file to load for this view.
	ViewerPath string `json:"viewerPath"`
}

// PanelViewInput holds the view configuration of an extension if the panel anchor is supported.
type SavePanelViewInput struct {
	// The extension developer configured height of the panel extension.
	Height int `json:"height"`
	// Relative path of the HTML file to load for this view.
	ViewerPath string `json:"viewerPath"`
}

// VideoOverlayViewInput holds the view configuration of an extension if the videoOverlay anchor is supported.
type SaveVideoOverlayViewInput struct {
	// Relative path of the HTML file to load for this view.
	ViewerPath string `json:"viewerPath"`
}

// The channel schedule.
type Schedule struct {
	// The ID of the schedule.
	ID string `json:"id"`
	// A period during which scheduled events temporarily cease.
	Interruption *ScheduleInterruption `json:"interruption"`
	// The next segment of the schedule. This will prepend 'next-' to the segmentID because it has different behavior from segments returned in the 'segments' field.
	NextSegment *ScheduleSegment `json:"nextSegment"`
	// The segments of the schedule.
	Segments []*ScheduleSegment `json:"segments"`
}

// The interruption of a schedule.
type ScheduleInterruption struct {
	// The end time when the schedule will no longer be disabled.
	EndAt time.Time `json:"endAt"`
	// The reason the schedule is disabled.
	Reason ScheduleInterruptionReason `json:"reason"`
	// The start time when the schedule will be disabled.
	StartAt time.Time `json:"startAt"`
}

// The segment of a schedule.
type ScheduleSegment struct {
	// The game categories tied to this segment.
	Categories []*Game `json:"categories"`
	// The end time of the segment.
	EndAt *time.Time `json:"endAt"`
	// Whether or not the current user has a reminder set for the segment.
	HasReminder bool `json:"hasReminder"`
	// The ID of the segment.
	ID string `json:"id"`
	// If this segment is cancelled or not.
	IsCancelled bool `json:"isCancelled"`
	// A count of users who have a reminder set, available only to the schedule owner.
	ReminderCount *int `json:"reminderCount"`
	// The start time of the segment.
	StartAt time.Time `json:"startAt"`
	// The title of the segment.
	Title string `json:"title"`
}

// Contains categories search results.
type SearchCategoriesConnection struct {
	// List of matching game results.
	Edges []*SearchCategoriesEdge `json:"edges"`
	// Information about this page of categories.
	PageInfo *PageInfo `json:"pageInfo"`
	// Total number of results.
	TotalCount int `json:"totalCount"`
}

// An element in the categories result, and its metadata.
type SearchCategoriesEdge struct {
	// Cursor represents the position of the current edge/node.
	Cursor string `json:"cursor"`
	// Node represents the extension for the current edge.
	Node *Game `json:"node"`
}

// Contains results for a searchFor query.
type SearchFor struct {
	// Contains results for channels.
	Channels *SearchForResultUsers `json:"channels"`
	// Contains results for games.
	Games *SearchForResultGames `json:"games"`
	// Contains results for live channels.
	LiveChannels *SearchForResultUsers `json:"liveChannels"`
	// Contains results for related live channels.
	RelatedLiveChannels *SearchForResultRelatedLiveChannels `json:"relatedLiveChannels"`
	// Contains results for users.
	Users *SearchForResultUsers `json:"users"`
	// Contains results for videos.
	Videos *SearchForResultVideos `json:"videos"`
}

// SearchForOptions allows the user to target specific result types.
type SearchForOptions struct {
	// List of indices to run a user's query against.
	Targets []*SearchForTarget `json:"targets"`
}

// Contains game search results.
type SearchForResultGames struct {
	// Cursor for fetching the next page of results.
	Cursor *string `json:"cursor"`
	// List of matching game results.
	Items []*Game `json:"items"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
	// Order in which the result should be displayed.
	Score int `json:"score"`
	// Total number of results.
	TotalMatches int `json:"totalMatches"`
}

// Contains results for related live channels.
type SearchForResultRelatedLiveChannels struct {
	// List of matching user results.
	Items []*User `json:"items"`
	// Optional score associated with the related live section.
	Score *int `json:"score"`
}

// Contains user search results.
type SearchForResultUsers struct {
	// Cursor for fetching the next page of results.
	Cursor *string `json:"cursor"`
	// List of matching user results.
	Items []*User `json:"items"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
	// Order in which the result should be displayed.
	Score int `json:"score"`
	// Total number of results.
	TotalMatches int `json:"totalMatches"`
}

// Contains video search results.
type SearchForResultVideos struct {
	// Cursor for fetching the next page of results.
	Cursor *string `json:"cursor"`
	// List of matching video results.
	Items []*Video `json:"items"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
	// Order in which the result should be displayed.
	Score int `json:"score"`
	// Total number of results.
	TotalMatches int `json:"totalMatches"`
}

// Specify which index to run a user's search.
type SearchForTarget struct {
	// Pagination cursor for user to optionally provide to request a specific page of results.
	Cursor *string `json:"cursor"`
	// Search index to run a user's query against.
	Index SearchIndex `json:"index"`
	// Limit the number of results returned.
	Limit *int `json:"limit"`
}

// SearchOptions to customize results returned by the search query.
type SearchOptions struct {
	// List of indices to run a user's query against. If no targets are specified, the query is run against all the indices listed in SearchIndex.
	Targets []*SearchTarget `json:"targets"`
}

// Contains the result returned by the search engine for a particular query.
type SearchResult struct {
	// JSON encoded as a string.
	Result string `json:"result"`
}

// List of users.
type SearchStreamConnection struct {
	// List of matching channels results.
	Edges []*SearchStreamEdge `json:"edges"`
	// Information about this page of videos.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of items in the collection.
	TotalCount int `json:"totalCount"`
}

// An element in a paginated list of videos, and its metadata.
type SearchStreamEdge struct {
	// The cursor of the channel record list. This is same for one page.
	Cursor string `json:"cursor"`
	// The channel result returned.
	Node *Stream `json:"node"`
}

// A search suggestion.
type SearchSuggestion struct {
	// Extra data for category or channel type of search suggestion.
	Content SearchSuggestionContent `json:"content"`
	// The part of the suggestion that matches the search query.
	Highlight *SearchSuggestionHighlight `json:"highlight"`
	// The search suggestion's unique identifier.
	ID string `json:"id"`
	// The part of the suggestion that matches the search query.
	MatchingCharacters *SearchSuggestionHighlight `json:"matchingCharacters"`
	// The search suggestion string.
	Text string `json:"text"`
}

// A category search suggestion.
type SearchSuggestionCategory struct {
	// The boxart URL for the category, provided by the endpoint.
	// Use this field for lower latency.
	//
	// The image dimensions are specifiable via the `height` and `width` parameters.
	// If `height` or `width` are not specified, the URL will contain
	// the template strings `{height}` and/or `{width}` in their respective places.
	BoxArtURL string `json:"boxArtURL"`
	// The category.
	Game *Game `json:"game"`
	// The category's unique identifier.
	ID string `json:"id"`
}

func (SearchSuggestionCategory) IsSearchSuggestionContent() {}

// A channel search suggestion.
type SearchSuggestionChannel struct {
	// The channel's unique identifier.
	ID string `json:"id"`
	// Whether or not the channel is verified, provided by the endpoint.
	// Use this field for lower latency.
	IsVerified bool `json:"isVerified"`
	// The login of the channel, provided by the endpoint.
	// Use this field for lower latency.
	Login string `json:"login"`
	// The profile image URL for the channel, provided by the endpoint.
	// Use this field for lower latency.
	//
	// Valid widths are 28, 50, 70, 150, 300, and 600.
	// The image height will be the same as the given width.
	ProfileImageURL *string `json:"profileImageURL"`
	// The user of the channel.
	User *User `json:"user"`
}

func (SearchSuggestionChannel) IsSearchSuggestionContent() {}

// A list of search suggestions and related tracking data.
type SearchSuggestionConnection struct {
	// The list of search suggestions.
	Edges []*SearchSuggestionEdge `json:"edges"`
	// As pagination is currently not supported by the backend, this will always be the zero value.
	PageInfo *PageInfo `json:"pageInfo"`
	// Tracking data for the search suggestions.
	Tracking *SearchSuggestionTracking `json:"tracking"`
}

// Edge containing the search suggestion.
type SearchSuggestionEdge struct {
	// As pagination is currently not supported by the backend, this will always be the zero value.
	Cursor string `json:"cursor"`
	// The search suggestion.
	Node *SearchSuggestion `json:"node"`
}

// A range that matches the search query.
type SearchSuggestionHighlight struct {
	// The end of the match.
	End int `json:"end"`
	// The start of the match.
	Start int `json:"start"`
}

// An object containing tracking data for a search suggestion.
type SearchSuggestionTracking struct {
	// The unique identifier of the model instance.
	ModelTrackingID string `json:"modelTrackingID"`
	// The unique identifier generated for every response.
	ResponseID string `json:"responseID"`
}

// Specify which index to run a user's search.
type SearchTarget struct {
	// When true, response will return  the total number of matching documents in index for a given query. The value for limit is ignored and assumed to be zero.
	CountTotalMatches *bool `json:"countTotalMatches"`
	// Search index to run a user's query against.
	Index SearchIndex `json:"index"`
	// Max number of matching documents that will be returned.
	Limit int `json:"limit"`
}

// A list of user returned from forage by user query.
type SearchUserConnection struct {
	// List of matching user results.
	Edges []*SearchUserEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
	// Total number of results.
	TotalCount int `json:"totalCount"`
}

// Element in a list of users returned from forage.
type SearchUserEdge struct {
	// Cursor for fetching the next page of results(only on last edge of current connection).
	Cursor string `json:"cursor"`
	// The information about user.
	Node *User `json:"node"`
}

// Season metadata.
type SeasonDetails struct {
	// Number of episodes.
	EpisodeCount *int `json:"episodeCount"`
	// The season number.
	Season *int `json:"season"`
}

func (SeasonDetails) IsWatchPartyItemDetails() {}

// Inputs for seeding a competition participant.
type SeedCompetitionParticipantInput struct {
	// ID of the competition.
	CompetitionID string `json:"competitionID"`
	// ID of the competition player or competition team.
	ParticipantID string `json:"participantID"`
	// The assigned seed value.
	SeedValue int `json:"seedValue"`
}

// SeedCompetitionParticipantPayload is the success response for seeding a competition player or competition team.
type SeedCompetitionParticipantPayload struct {
	// The new state of competition after seeding a competition player or competition team.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// The segment start time input.
type SegmentStartTimeInput struct {
	// The day of the segment.
	Day ScheduleSegmentDay `json:"day"`
	// The hour of the segment 0-23.
	Hour int `json:"hour"`
	// The minute of the segment 0-59.
	Minute int `json:"minute"`
}

// Inputs for selecting a channel badge.
type SelectChannelBadgeInput struct {
	// Set ID of the badge to select.
	BadgeSetID string `json:"badgeSetID"`
	// Optional Version of the Badge to select.
	BadgeSetVersion *string `json:"badgeSetVersion"`
	// ID of the channel this badge is selected on.
	ChannelID string `json:"channelID"`
}

// The output for the select channel badge mutation.
type SelectChannelBadgePayload struct {
	// Indicates if selecting the badge was successful.
	IsSuccessful *bool `json:"isSuccessful"`
	// The channel (user object of channel) this badge is selected on.
	User *User `json:"user"`
}

// Inputs for selecting a global badge.
type SelectGlobalBadgeInput struct {
	// Set ID of the badge to select.
	BadgeSetID string `json:"badgeSetID"`
	// Optional Version of the Badge to select.
	BadgeSetVersion *string `json:"badgeSetVersion"`
}

// The output for the select global badge mutation.
type SelectGlobalBadgePayload struct {
	// Indicates if selecting the badge was successful.
	IsSuccessful *bool `json:"isSuccessful"`
	// The user of the selected badge.
	User *User `json:"user"`
}

// Input for sending a chat message through subscriber-only mode with Channel Points.
type SendChatMessageThroughSubscriberModeInput struct {
	// The channel the message is being sent to.
	ChannelID string `json:"channelID"`
	// The client's perception of the reward's cost.
	Cost int `json:"cost"`
	// The user's message.
	Message string `json:"message"`
	// Client-set identifier for the transaction. This ID should be universally unique.
	TransactionID string `json:"transactionID"`
}

// The response from redeeming the skip subs only chat message reward.
type SendChatMessageThroughSubscriberModePayload struct {
	// The user's new Channel Points balance.
	Balance *int `json:"balance"`
	// The error that occurred during redemption, if any.
	Error *SendCopoMessageError `json:"error"`
	// Whether the message was flagged by Automod and held for review.
	IsHeldByAutomod *bool `json:"isHeldByAutomod"`
}

type SendCheerInput struct {
	// bits is the number of bits the message will spend (as parsed by the client).
	Bits int `json:"bits"`
	// content is the text to process and forward to the chat system.
	Content string `json:"content"`
	// Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
	// The server will reject any request with an ID that has already been used.
	ID string `json:"id"`
	// Optional field that dictates the user wants their cheer to appear anonymously (i.e. unassociated with their username).
	IsAnonymous *bool `json:"isAnonymous"`
	// Optional field that dictates whether automod should be enabled for the cheer or not.
	IsAutoModEnabled *bool `json:"isAutoModEnabled"`
	// Optional field that dictates the cheer message was sent from a room, as this provides the context for what room
	// it was sent from.
	RoomID *string `json:"roomID"`
	// Optional field that dictates that the user want to cheer anyways, even though they know it will be automodded.
	ShouldCheerAnyway *bool `json:"shouldCheerAnyway"`
	// targetID is the `User.id` of the channel to send the cheer to.
	TargetID string `json:"targetID"`
}

type SendCheerPayload struct {
	// currentUser is the authenticated user object which includes the updated `Wallet` info after the message bits have been spent.
	CurrentUser *User `json:"currentUser"`
	// id is the client-generated value passed in as part of the request.
	ID string `json:"id"`
	// If any validation errors occur, this will not be nil.
	ValidationError *SendCheerValidationError `json:"validationError"`
}

// Resolver for validation errors that occur on send cheer.
type SendCheerValidationError struct {
	// Error code that describes the validation error.
	Code SendCheerValidationErrorCode `json:"code"`
	// Error message that is returned from the backend service.
	Message string `json:"message"`
	// Optional rejected message for when the error requires frontend message changes, like AutoMod'd messages.
	MessageContent *RoomMessageContent `json:"messageContent"`
}

// An error from redeeming a chat message Channel Points reward.
type SendCopoMessageError struct {
	// The error code.
	Code *SendCopoMessageErrorCode `json:"code"`
}

// Error type.
type SendExtensionMessageError struct {
	// Error code.
	Code SendExtensionMessageErrorCode `json:"code"`
}

// Input to the sendExtensionMessage mutation.
type SendExtensionMessageInput struct {
	// The channelID the extension is active on.
	ChannelID string `json:"channelID"`
	// The type of the content.
	ContentType string `json:"contentType"`
	// A JWT token signed with the shared secret for this extension.
	ExtAuthToken string `json:"extAuthToken"`
	// The ID of the extension which is sending the message.
	ExtensionID string `json:"extensionID"`
	// The content of the message to be sent.
	Message string `json:"message"`
	// The set of target message receievers to send to, e.g. "broadcast".
	Targets []string `json:"targets"`
}

// Payload returned from the sendExtensionMessage mutation.
type SendExtensionMessagePayload struct {
	// error, if any.
	Error *SendExtensionMessageError `json:"error"`
	// Information about what rate limits, if any, were applied to this send.
	RateLimitsApplied []*SendExtensionMessageThrottleData `json:"rateLimitsApplied"`
}

// Information about a rate limit throttle.
type SendExtensionMessageThrottleData struct {
	// Was the rate limit exceeded.
	IsLimitExceeded bool `json:"isLimitExceeded"`
	// The limit itself.
	Limit string `json:"limit"`
	// Name of the rate limiter applied.
	RateLimiterName string `json:"rateLimiterName"`
	// How much quota remains.
	RemainingQuota int `json:"remainingQuota"`
	// Time when this rate limit will reset.
	ResetsAt *time.Time `json:"resetsAt"`
}

// Input for sending a highlighted chat message with Channel Points.
type SendHighlightedChatMessageInput struct {
	// The channel the message is being sent to.
	ChannelID string `json:"channelID"`
	// The client's perception of the reward's cost.
	Cost int `json:"cost"`
	// The user's message.
	Message string `json:"message"`
	// Client-set identifier for the transaction. This ID should be universally unique.
	TransactionID string `json:"transactionID"`
}

// The response from redeeming the highlighted chat message reward.
type SendHighlightedChatMessagePayload struct {
	// The user's new Channel Points balance.
	Balance *int `json:"balance"`
	// The error that occurred during redemption, if any.
	Error *SendCopoMessageError `json:"error"`
	// Whether the message was flagged by Automod and held for review.
	IsHeldByAutomod *bool `json:"isHeldByAutomod"`
}

type SendRoomMessageError struct {
	Code SendRoomMessageErrorCode `json:"code"`
	// On SLOW_MODE_ENFORCEMENT_FAILED, USER_CHAT_TIMED_OUT: the number of remaining seconds user must wait before sending another message.
	RemainingDurationSeconds *int `json:"remainingDurationSeconds"`
	// On SLOW_MODE_ENFORCEMENT_FAILED: the number of seconds users must wait in between sending messages.
	SlowModeDurationSeconds *int `json:"slowModeDurationSeconds"`
}

type SendRoomMessageInput struct {
	Message string `json:"message"`
	// Optional nonce which will be included in the pubsub event for this message.
	Nonce  *string `json:"nonce"`
	RoomID string  `json:"roomID"`
}

type SendRoomMessagePayload struct {
	Error   *SendRoomMessageError `json:"error"`
	Message *RoomMessage          `json:"message"`
}

// Error code for when a mutation fails.
type SendWhisperError struct {
	// Error code for the failed whisper send.
	Code SendWhisperErrorCode `json:"code"`
}

type SendWhisperInput struct {
	// Message to send to user.
	Message string `json:"message"`
	// Random string generated by the client and should be unique across messages.
	Nonce string `json:"nonce"`
	// User to send a whisper to.
	RecipientUserID string `json:"recipientUserID"`
}

type SendWhisperPayload struct {
	// If an error occurred, the error code. Otherwise null.
	Error *SendWhisperError `json:"error"`
	// The message that was sent, or null if there was an error.
	Message *WhisperMessage `json:"message"`
}

// Series metadata.
type SeriesDetails struct {
	// Number of seasons.
	SeasonCount *int `json:"seasonCount"`
}

func (SeriesDetails) IsWatchPartyItemDetails() {}

// Sets the auto ad density for the channel.
type SetAutoAdDensityInput struct {
	// Input for auto ad length seconds.
	AutoAdLengthSeconds int `json:"autoAdLengthSeconds"`
	// Input for auto ad period minutes.
	AutoAdPeriodMinutes int `json:"autoAdPeriodMinutes"`
	// Input for target ID of channel.
	TargetChannelID string `json:"targetChannelID"`
}

// Shows the newly updated values for autoad settings.
type SetAutoAdDensityPayload struct {
	// The user whose channels ad density was set.
	AutoAdLengthSeconds *int `json:"autoAdLengthSeconds"`
	// Auto ad period minutes.
	AutoAdPeriodMinutes *int `json:"autoAdPeriodMinutes"`
	// Input for target ID of channel.
	TargetChannelID *string `json:"targetChannelID"`
}

// Input for setting auto refill settings.
type SetAutoRefillSettingsInput struct {
	// The charge instrument information for starting a purchase.
	ChargeInstrument *ChargeInstrumentInput `json:"chargeInstrument"`
	// The currency this should be charged in.
	Currency Currency `json:"currency"`
	// The gross amount (of currency) that can be charged on the charge instrument.
	GrossAmount int `json:"grossAmount"`
	// Optional id of the auto refill settings that are being modified.
	ID *string `json:"id"`
	// Indicates if the profile is active.
	IsEnabled bool `json:"isEnabled"`
	// Id of the refill offer used on auto refill.
	OfferID string `json:"offerID"`
	// The threshold amount a balance must go below to trigger a reload.
	Threshold int `json:"threshold"`
}

// The payload for the set auto refill settings mutation.
type SetAutoRefillSettingsPayload struct {
	// The changed auto refill profile.
	AutoRefillProfile *AutoRefillProfile `json:"autoRefillProfile"`
}

// SetAutohostChannelsInput sets the user's list to autohost.
type SetAutohostChannelsInput struct {
	// ChannelIDs that will be on the list to autohost.
	ChannelIDs []string `json:"channelIDs"`
	// UserID to update autohost list for.
	UserID string `json:"userID"`
}

// SetAutohostChannelsPayload returns the user whose autohostChannels field had been updated.
type SetAutohostChannelsPayload struct {
	// User whose autohostChannels field had been updated.
	User *User `json:"user"`
}

// Input for the set bits user settings mutation.
type SetBitsUserSettingsInput struct {
	// Optional field that dictates whether a user has exited out of the first cheer tutorial by clicking out of the experience.
	AbandonedFirstCheerTutorial *bool `json:"abandonedFirstCheerTutorial"`
	// Optional field that dictates whether a user has skipped the first cheer tutorial by clicking the skip button.
	SkippedFirstCheerTutorial *bool `json:"skippedFirstCheerTutorial"`
}

// Payload for set bits user settings mutation.
type SetBitsUserSettingsPayload struct {
	// currentUser is the authenticated user object which includes the updated `Wallet` info after the message bits have been spent.
	CurrentUser *User `json:"currentUser"`
}

type SetChannelFeedEnabledInput struct {
	// The new desired value for channel_feed_enabled.
	Enabled bool `json:"enabled"`
}

type SetChannelFeedEnabledPayload struct {
	// The user whose channel feed setting was toggled.
	User *User `json:"user"`
}

type SetChannelNotificationSettingInput struct {
	Category     string `json:"category"`
	ChannelID    string `json:"channelID"`
	Platform     string `json:"platform"`
	SettingState string `json:"settingState"`
}

type SetChannelNotificationSettingPayload struct {
	SettingState string `json:"settingState"`
}

// Inputs to the setChannelTrailer mutation.
type SetChannelTrailerInput struct {
	// The channel whose trailer should be updated.
	ChannelID string `json:"channelID"`
	// The ID of the video that should be used as the channel's trailer,
	// or null if the trailer should be cleared.
	TrailerVideoID *string `json:"trailerVideoID"`
}

// Output of the setChannelTrailer mutation.
type SetChannelTrailerPayload struct {
	// The channel whose trailer vod was modified.
	Channel *Channel `json:"channel"`
	// The error if the mutation failed in an expected way, or null if the mutation was successful.
	Error *SetChannelTrailerErrorCode `json:"error"`
}

// The required input to set a user's chat pause setting.
type SetChatPauseSettingInput struct {
	// The desired method for a user to pause chat.
	ChatPauseSetting ChatPauseSetting `json:"chatPauseSetting"`
}

// Result of a setChatPauseSetting mutation.
type SetChatPauseSettingPayload struct {
	// The newly saved chat pause setting.
	ChatPauseSetting *ChatPauseSetting `json:"chatPauseSetting"`
}

// Update tags associated with CLIP, STREAM, or VOD with contentID.
type SetContentTagsInput struct {
	// ID of the channel owning the content.
	AuthorID string `json:"authorID"`
	// ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs.
	ContentID string `json:"contentID"`
	// Type of content being returned. Can only be of values CLIP, STREAM, or VOD.
	ContentType ContentType `json:"contentType"`
	// List of tag IDs to be replaced from the content.
	TagIDs []string `json:"tagIDs"`
}

// Result of mutation is the contentID.
type SetContentTagsPayload struct {
	// Content which tags have been updated.
	Content TaggedContent `json:"content"`
}

// The input to be provided to the SetCreatorBadgeFlair mutation.
type SetCreatorBadgeFlairInput struct {
	// ID for channel to apply setting for
	ChannelID string `json:"channelID"`
	// Setting to apply to channel setting for badge flair
	CreatorBadgeFlair CreatorBadgeFlairSetting `json:"creatorBadgeFlair"`
}

type SetCreatorBadgeFlairPayload struct {
	// Channel whose badge flair setting was updated
	Channel *Channel `json:"channel"`
}

// SetDashboardAlertQueueActivityStatusError is the error associated with SetDashboardAlertQueueActivityStatus.
type SetDashboardAlertQueueActivityStatusError struct {
	// The associated error code.
	Code SetDashboardAlertQueueActivityStatusErrorCode `json:"code"`
}

// Inputs to the SetDashboardAlertQueueActivityStatus mutation.
type SetDashboardAlertQueueActivityStatusInput struct {
	// The ID corresponding to the activity whose alert queue activity status should be updated.
	ActivityID string `json:"activityID"`
	// The value to set the status to.
	AlertStatus DashboardActivityFeedActivityAlertStatus `json:"alertStatus"`
	// The ID corresponding to the user whose alert queue activity status should be updated.
	UserID string `json:"userID"`
}

// Outputs from the SetDashboardAlertQueueActivityStatus mutation.
type SetDashboardAlertQueueActivityStatusPayload struct {
	// The updated activity.
	Activity DashboardActivityFeedActivity `json:"activity"`
	// The possible error returned from the service.
	Error *SetDashboardAlertQueueActivityStatusError `json:"error"`
}

// SetDashboardAlertQueuePreferenceError is the error associated with SetDashboardAlertQueuePreference.
type SetDashboardAlertQueuePreferenceError struct {
	// The associated error code.
	Code SetDashboardAlertQueuePreferenceErrorCode `json:"code"`
}

// Inputs to the SetDashboardAlertQueuePreference mutation. Only one of the boolean settings should be set at once.
type SetDashboardAlertQueuePreferenceInput struct {
	// If true, cannot publish alerts to the user.
	ShouldEnableDNDMode *bool `json:"shouldEnableDNDMode"`
	// If true, cannot publish bits alerts to the user.
	ShouldHideBits *bool `json:"shouldHideBits"`
	// If true, cannot publish follows alerts to the user.
	ShouldHideFollows *bool `json:"shouldHideFollows"`
	// If true, cannot publish subscription gift alerts to the user.
	ShouldHideGiftSubscriptions *bool `json:"shouldHideGiftSubscriptions"`
	// If true, cannot publish hosts alerts to the user.
	ShouldHideHosts *bool `json:"shouldHideHosts"`
	// If true, cannot publish raids alerts to the user.
	ShouldHideRaids *bool `json:"shouldHideRaids"`
	// If true, cannot publish regular subscriptions alerts to the user (gift subs are still shown).
	ShouldHideSubscriptions *bool `json:"shouldHideSubscriptions"`
	// The ID corresponding to the user whose alert queue preference should be updated.
	UserID string `json:"userID"`
}

// Outputs from the SetDashboardAlertQueuePreference mutation.
type SetDashboardAlertQueuePreferencePayload struct {
	// The possible error returned from the service.
	Error *SetDashboardAlertQueuePreferenceError `json:"error"`
	// The updated preferences for dashboard alert queue.
	Preferences *DashboardAlertQueuePreferences `json:"preferences"`
}

// The input to be provided to the setDefaultPaymentMethod mutation.
type SetDefaultPaymentMethodInput struct {
	// Country (ISO-3166) associated to the billing info for the customer's payment method.
	BillingCountry *string `json:"billingCountry"`
	// Payment type used via the payment provider.
	PaymentType PaymentInstrumentType `json:"paymentType"`
	// The payment provider we're updating the payment method on.
	Provider PaymentProvider `json:"provider"`
	// The token used to verify the selected payment method.
	Token string `json:"token"`
	// The user to set default payment method for.
	UserID string `json:"userID"`
}

// The result of the setDefaultPaymentMethod mutation.
type SetDefaultPaymentMethodPayload struct {
	// Code to describe error that occurred while setting the default payment method.
	ErrorCode *SetDefaultPaymentMethodErrorCode `json:"errorCode"`
	// User who had their payment method updated.
	User *User `json:"user"`
}

// The required input to set a user's deleted message display setting.
type SetDeletedMessageDisplaySettingInput struct {
	// The desired deleted message display setting to be saved.
	DeletedMessageDisplaySetting DeletedMessageDisplaySetting `json:"deletedMessageDisplaySetting"`
}

// Result of a setDeletedMessageDisplaySetting mutation.
type SetDeletedMessageDisplaySettingPayload struct {
	// The newly saved deleted message display setting.
	DeletedMessageDisplaySetting *DeletedMessageDisplaySetting `json:"deletedMessageDisplaySetting"`
}

// SetDropBenefitsOnDropInput has fields required to update a drop's list of benefits.
type SetDropBenefitsOnDropInput struct {
	// The benefits that should be awarded when this drop is claimed.
	BenefitIDs []string `json:"benefitIDs"`
	// The drop to update.
	DropID string `json:"dropID"`
}

// SetDropBenefitsOnDropPayload returns the result of the creation/update.
type SetDropBenefitsOnDropPayload struct {
	// Returns the updated Campaign.
	DropCampaign *DropCampaign `json:"dropCampaign"`
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// SetDropCampaignAccessInput has fields required to update a campaign's access.
type SetDropCampaignAccessInput struct {
	// A list of channels that are allowed for this campaign.
	AllowedChannels []string `json:"allowedChannels"`
	// A list of channels that are blocked from this campaign.
	BlockedChannels []string `json:"blockedChannels"`
	// The campaign ID.
	CampaignID string `json:"campaignID"`
	// Is the allowedChannels list in effect. Just having allowedChannels present does not mean the access list should be enabled.
	IsAllowedChannelsEnabled bool `json:"isAllowedChannelsEnabled"`
	// Is the blockedChannels list in effect. Just having blockedChannels present does not mean the block list should be enabled.
	IsBlockedChannelsEnabled bool `json:"isBlockedChannelsEnabled"`
	// A list of users that are able to view this campaign and functionalities while the campaign is in the testing state.
	TestViewers []string `json:"testViewers"`
}

// SetDropCampaignAccessPayload returns the result of the update.
type SetDropCampaignAccessPayload struct {
	// Returns the updated Campaign.
	DropCampaign *DropCampaign `json:"dropCampaign"`
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// SetDropCampaignStatusInput has fields required to update a campaign's status.
type SetDropCampaignStatusInput struct {
	// The campaign ID.
	CampaignID string `json:"campaignID"`
	// The status the campaign should receive.
	Status DropCampaignStatus `json:"status"`
}

// SetDropCampaignStatusPayload returns the result of the creation/update.
type SetDropCampaignStatusPayload struct {
	// Returns the updated Campaign.
	DropCampaign *DropCampaign `json:"dropCampaign"`
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// SetDropCampaignSummaryInput has fields required to update a campaign summary.
type SetDropCampaignSummaryInput struct {
	// The redirect URL where a user can link their account.
	AccountLinkURL string `json:"accountLinkURL"`
	// The campaign ID.
	CampaignID string `json:"campaignID"`
	// The type of a campaign defines what type of drops are allowed to be added to the campaign.
	CampaignType *CampaignType `json:"campaignType"`
	// The description of this campaign.
	Description string `json:"description"`
	// The URL that links to the details / marketing page for this drop.
	DetailsURL string `json:"detailsURL"`
	// The date at which this campaign ends and all contained drops end at the latest.
	EndAt time.Time `json:"endAt"`
	// The game associated with this campaign.
	GameID string `json:"gameID"`
	// The name of the campaign.
	Name string `json:"name"`
	// This is the Organization ID (RBAC) to determine access / ownership of the campaign and attached drops.
	OwnerID string `json:"ownerID"`
	// The date at which this campaign starts and all contained drops start the earliest.
	StartAt time.Time `json:"startAt"`
}

// SetDropCampaignSummaryPayload returns the result of the creation/update.
type SetDropCampaignSummaryPayload struct {
	// Returns the created/updated Campaign.
	DropCampaign *DropCampaign `json:"dropCampaign"`
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// SetDropEventRuleInput has the fields required to set an event based rule on a drop.
type SetDropEventRuleInput struct {
	// How long the viewer has to claim their reward.
	ClaimDurationSeconds int `json:"claimDurationSeconds"`
	// The associated drop for the rule to update.
	DropID string `json:"dropID"`
	// The in-game conditions that must be met for the drop to trigger.
	EventRules []*DropEventConditionInput `json:"eventRules"`
	// A textual description of what has to occur for the drop to trigger.
	QuestDescription string `json:"questDescription"`
	// Name of the drop.
	QuestName string `json:"questName"`
}

// SetDropRulePayload returns the result of the rule creation.
type SetDropEventRulePayload struct {
	// Returns the updated Campaign.
	DropCampaign *DropCampaign `json:"dropCampaign"`
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// SetDropManualTriggerRuleInput has the fields required to set a manual trigger based rule on a drop.
type SetDropManualTriggerRuleInput struct {
	// How long the viewer has to claim their reward.
	ClaimDurationSeconds int `json:"claimDurationSeconds"`
	// The associated drop for the rule to update.
	DropID string `json:"dropID"`
}

// SetDropManualTriggerRulePayload returns the result of the rule creation.
type SetDropManualTriggerRulePayload struct {
	// Returns the updated Campaign.
	DropCampaign *DropCampaign `json:"dropCampaign"`
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// SetDropSummaryInput has fields required to update a drop's summary.
type SetDropSummaryInput struct {
	// The associated drop for the summary to update.
	DropID string `json:"dropID"`
	// The date at which this drop can no longer occur.
	EndAt *time.Time `json:"endAt"`
	// The friendly name of this drop.
	Name string `json:"name"`
	// The date at which this drop can start to occur.
	StartAt *time.Time `json:"startAt"`
}

// SetDrop2BenefitPayload returns the result of the creation/update.
type SetDropSummaryPayload struct {
	// Returns the created/updated Campaign.
	DropCampaign *DropCampaign `json:"dropCampaign"`
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// SetDropTimeBasedRuleInput has fields required to update a drop's rule to a minutes watched based rule.
type SetDropTimeBasedRuleInput struct {
	// The associated drop for the rule to update.
	DropID string `json:"dropID"`
	// The ID of the drop that must be claimed before you can make progress on this drop.
	PreconditionDropID string `json:"preconditionDropID"`
	// The amount of minutes a viewer must have watched before they can claim this drop.
	RequiredMinutesWatched int `json:"requiredMinutesWatched"`
}

// SetDropTimeBasedRulePayload returns the result of the rule update.
type SetDropTimeBasedRulePayload struct {
	// Returns the updated Campaign.
	DropCampaign *DropCampaign `json:"dropCampaign"`
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// The required input to set a user's emote animations setting.
type SetEmoteAnimationsEnabledInput struct {
	// Whether emote animations should be enabled for the current user.
	IsEmoteAnimationsEnabled bool `json:"isEmoteAnimationsEnabled"`
}

// Result of a setEmoteAnimationsEnabled mutation.
type SetEmoteAnimationsEnabledPayload struct {
	// Whether emote animations are enabled for the current user.
	IsEmoteAnimationsEnabled *bool `json:"isEmoteAnimationsEnabled"`
}

// Possible errors from this mutation.
type SetEmoteModifierGroupsError struct {
	// Error code from the mutation.
	Code SetEmoteModifierGroupsErrorCode `json:"code"`
}

// SetEmoteModifierGroupsInput is the input required when a creator sets their emote modifiers.
type SetEmoteModifierGroupsInput struct {
	// Emote modifier groups to set.
	Groups []*EmoteModifierGroupInput `json:"groups"`
}

// The result of setting emote modifier groups for a user.
type SetEmoteModifierGroupsPayload struct {
	// Error from the mutation if it exists.
	Error *SetEmoteModifierGroupsError `json:"error"`
	// The modified emote groups that were set.
	Groups []*EmoteModifierGroupPayload `json:"groups"`
}

// SetExtensionConfigurationError returns an error code for the frontend to handle.
type SetExtensionConfigurationError struct {
	// The standardized code used by the frontend.
	Code SetExtensionConfigurationErrorCode `json:"code"`
}

// The required input for a setExtensionConfiguration mutation.
type SetExtensionConfigurationInput struct {
	// The channel to which this configuration applies to.
	ChannelID string `json:"channelID"`
	// The version of the configuration.
	ConfigVersion string `json:"configVersion"`
	// The configuration string to post.
	Content string `json:"content"`
	// The extension ID.
	ExtensionID string `json:"extensionID"`
}

// SetExtensionConfiguration returns the Input as the extensions configuration endpoint returns a 204.
type SetExtensionConfigurationPayload struct {
	// The channel to which this configuration applies to.
	ChannelID *string `json:"channelID"`
	// The version of the configuration.
	ConfigVersion *string `json:"configVersion"`
	// The configuration string to post.
	Content *string `json:"content"`
	// Error code for the frontend to handle.
	Error *SetExtensionConfigurationError `json:"error"`
	// The extension ID.
	ExtensionID *string `json:"extensionID"`
}

// SetExtensionFeatureFlagsError is wrapper for error associated with the setExtensionFeatureFlags mutation.
type SetExtensionFeatureFlagsError struct {
	// Error code.
	Code SetExtensionFeatureFlagsErrorCode `json:"code"`
	// The missing installation id if got EXTENSION_NOT_INSTALLED error.
	MissingInstallationID *string `json:"missingInstallationID"`
}

// The required input to set feature flags for an installation.
type SetExtensionFeatureFlagsInput struct {
	// Optional value to enable/disable chat for the specified installation.
	CanSendChat *bool `json:"canSendChat"`
	// Optional value to enable/disable bits for the specified installation.
	CanUseBits *bool `json:"canUseBits"`
	// Optional value for dynamicManagement flag on games.
	DynamicManagement []*ExtensionDynamicManagementInput `json:"dynamicManagement"`
	// The ID of the extension installation to set feature flags for.
	ID string `json:"id"`
}

// The result of setting feature flags on an installation.
type SetExtensionFeatureFlagsPayload struct {
	// The error when the mutation fails to set feature flags.
	Error *SetExtensionFeatureFlagsError `json:"error"`
	// The new state of the installation after the setExtensionFeatureFlags mutation.
	InstalledExtension *ExtensionInstallation `json:"installedExtension"`
}

// The required input to set oauth on an installation.
type SetExtensionInstallationOAuthInput struct {
	// The installation ID we're setting the oauth token for.
	ID string `json:"id"`
	// The OAuth token created for the extension.
	OauthToken string `json:"oauthToken"`
}

// The resulting installedExtension state after setting OAuth.
type SetExtensionInstallationOAuthPayload struct {
	// The new state of the installation after the setExtensionInstallationOAuth mutation.
	InstalledExtension *ExtensionInstallation `json:"installedExtension"`
}

// SetGameDropAccountLinkClientInput has fields necessary to update a game's account link
// client ID used to verify a user has connected their in-game account.
type SetGameDropAccountLinkClientInput struct {
	// The client ID used to verify that users have linked their accounts properly.
	ClientID string `json:"clientID"`
	// The ID of the game to link the client ID to.
	GameID string `json:"gameID"`
}

// SetGameDropAccountLinkClientPayload returns the result of the update.
type SetGameDropAccountLinkClientPayload struct {
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
	// The updated game record.
	Game *Game `json:"game"`
}

// The required input to set a role's moderator logs' access.
type SetModLogsAccessInput struct {
	// The access level to moderator logs to be given to the role.
	AccessLevel ModLogsAccessLevel `json:"accessLevel"`
	// The Channel for which to set moderator log access.
	ChannelID string `json:"channelID"`
	// The user role for which to set the moderator log access permission.
	ChannelRole ChannelUserRole `json:"channelRole"`
}

// Result of a setModLogsAccess mutation.
type SetModLogsAccessPayload struct {
	// The access level of the role set.
	ModLogsAccess *ModLogsAccess `json:"modLogsAccess"`
}

// The required input to set a user's mod view settings relating to turorial.
type SetModViewSettingsInput struct {
	// The time the tutorial on the mod view page was seen.
	TutorialSeenAt time.Time `json:"tutorialSeenAt"`
	// The viewed state of the tutorial on the mod view page.
	TutorialState TutorialState `json:"tutorialState"`
}

// Result of a setModViewSettings mutation.
type SetModViewSettingsPayload struct {
	// The newly resolved modviewsettings resolver.
	ModViewSettings *ModViewSettings `json:"modViewSettings"`
}

type SetNotificationSettingInput struct {
	Category     string `json:"category"`
	Platform     string `json:"platform"`
	SettingState string `json:"settingState"`
}

type SetNotificationSettingPayload struct {
	SettingState string `json:"settingState"`
}

// SetOverwatchLeagueTeamPreferenceInput contains the OverwatchLeagueTeamPreference ID to set.
type SetOverwatchLeagueTeamPreferenceInput struct {
	// The channelID from the channel this event is taking place on.
	OverwatchTeamPreferenceOptionID string `json:"OverwatchTeamPreferenceOptionID"`
}

// SetOverwatchLeagueTeamPreferencePayload is the success response for setting an Overwatch League Team preference, and
// the corresponding updated OverwatchLeagueTeamPreference struct.
type SetOverwatchLeagueTeamPreferencePayload struct {
	// A possible error returned from the service.
	Error *SetOverwatchTeamPreferenceError `json:"error"`
	// The updated OverwatchLeagueTeamPreference struct.
	OverwatchLeagueTeamPreference *OverwatchLeagueTeamPreference `json:"overwatchLeagueTeamPreference"`
}

// Error code for an error that occurs while claiming the bounty.
type SetOverwatchTeamPreferenceError struct {
	// Error code for error that occurred while claiming the bounty.
	Code SetOverwatchTeamPreferenceErrorCode `json:"code"`
}

// The required input for a setPreferredLanguageTag mutation.
type SetPreferredLanguageTagInput struct {
	// The preferred language tag to set onto the user.
	PreferredLanguageTag LanguageTag `json:"preferredLanguageTag"`
	// The user to modify.
	UserID string `json:"userID"`
}

// The result of a setPreferredLanguageTag mutation.
type SetPreferredLanguageTagPayload struct {
	// The user whose preferred language tag was changed.
	User *User `json:"user"`
}

// Possible errors associated with the SetQuickActionLAyout mutation.
type SetQuickActionLayoutError struct {
	// The error code of a possible error when setting a layout.
	Code *SetQuickActionLayoutErrorCode `json:"code"`
}

// Represents a folder input.
type SetQuickActionLayoutFolderInput struct {
	// A list of quick action inputs in the folder. This can include nested folders.
	// A max nesting level is implemented in the resolver and the service.
	Items []*SetQuickActionLayoutItemInput `json:"items"`
	// The name of the folder.
	Name string `json:"name"`
}

// Inputs to the SetQuickActionLayout mutation.
type SetQuickActionLayoutInput struct {
	// The ID corresponding to the stream manager owner in which the layout appears.
	ChannelID string `json:"channelID"`
	// Quick action items, input in the order they should appear on the quick actions panel.
	Layout []*SetQuickActionLayoutItemInput `json:"layout"`
	// The ID corresponding to the owner of the layout.
	OwnerID string `json:"ownerID"`
}

// Each input item in the input array. Only one of these fields can
// be specified at the same time (a layout item can only be a folder or
// a quick action).
type SetQuickActionLayoutItemInput struct {
	// The input folder.
	Folder *SetQuickActionLayoutFolderInput `json:"folder"`
	// The input quick action.
	QuickAction *SetQuickActionLayoutQuickActionInput `json:"quickAction"`
}

// Outputs from the SetQuickActionLayout mutation.
type SetQuickActionLayoutPayload struct {
	// The possible error returned from the layout service.
	Error *SetQuickActionLayoutError `json:"error"`
	// Available quick actions, returned in the order they should be rendered.
	Layout *QuickActionLayout `json:"layout"`
}

// Represents a quick action input.
type SetQuickActionLayoutQuickActionInput struct {
	// The ID of the item. Quick action IDs are represented by their canonical names.
	Name QuickActionName `json:"name"`
}

// Error from a failed currently playing track mutation.
type SetRadioCurrentlyPlayingError struct {
	// Mutation error code.
	Code *SetRadioCurrentlyPlayingErrorCode `json:"code"`
}

// The required input to set radio track information currently being played.
type SetRadioCurrentlyPlayingInput struct {
	// The type of content the ID maps to.
	ContentType *RadioCurrentlyPlayingType `json:"contentType"`
	// Whether the track is currently playing or not.
	IsCurrentlyPlaying bool `json:"isCurrentlyPlaying"`
	// The ID of the source.
	SourceID *string `json:"sourceID"`
	// The ID of the currently playing track.
	TrackID *string `json:"trackID"`
}

// Result of a setRadioCurrentlyPlaying mutation.
type SetRadioCurrentlyPlayingPayload struct {
	// The currently playing radio track addition result.
	CurrentTrack *RadioCurrentTrackResponse `json:"currentTrack"`
	// Error code.
	Error *SetRadioCurrentlyPlayingError `json:"error"`
}

// The required input to set a user's readable chat colors setting.
type SetReadableChatColorsEnabledInput struct {
	// Whether readable chat colors should be enabled for the current user.
	IsReadableChatColorsEnabled bool `json:"isReadableChatColorsEnabled"`
}

// Result of a setReadableChatColorsEnabled mutation.
type SetReadableChatColorsEnabledPayload struct {
	// Whether readable chat colors are enabled for the current user.
	IsReadableChatColorsEnabled bool `json:"isReadableChatColorsEnabled"`
}

// SetResourceRestrictionInput sets a restriction for the given resourceID.
type SetResourceRestrictionInput struct {
	// The ID of the resource to set the restriction on.
	ResourceID string `json:"resourceID"`
	// The type of resource that will be restricted.
	ResourceType RestrictionResource `json:"resourceType"`
	// The restriction options, if any, to apply to the restriction being created.
	RestrictionOptions []ResourceRestrictionOption `json:"restrictionOptions"`
	// The type of restriction that should be placed onto the channel. If empty, the restriction will be deleted.
	RestrictionType *ResourceRestrictionType `json:"restrictionType"`
}

// SetResourceRestrictionPayload returns the updated restriction for a channel.
type SetResourceRestrictionPayload struct {
	// The channel if a live resource restriction was updated.
	Channel *Channel `json:"channel"`
	// The stream if a live resource restriction was updated.
	Stream *Stream `json:"stream"`
	// The video if a video resource restriction was updated.
	Video *Video `json:"video"`
}

// An error that has been mapped from a Reminder service twirp error. Can sometimes include messages.
type SetScheduleReminderError struct {
	// The error code.
	Code SetScheduleReminderErrorCode `json:"code"`
	// The error message string.
	Message *string `json:"message"`
}

// SetScheduleReminderInput has fields required to set a schedule event reminder.
type SetScheduleReminderInput struct {
	// The ID of the segment to set a reminder for.
	SegmentID string `json:"segmentID"`
	// Whether the reminder should be enabled or disabled.
	ShouldEnable bool `json:"shouldEnable"`
}

// SetScheduleReminderPayload returns the result of the creation/update.
type SetScheduleReminderPayload struct {
	// A mapped error returned by the Reminder service.
	Error *SetScheduleReminderError `json:"error"`
	// The new reminder state, if operation completed with no error.
	IsEnabled *bool `json:"isEnabled"`
}

// SetSessionStatusInput represents a user's status within a single session (browser tab, game, desktop application,
// mobile application, etc.).
type SetSessionStatusInput struct {
	// activity is the action the user is performing in your application. The purpose of an activity is to allow the user's
	// friends and related users to join in on whatever the user is doing. If the user is not performing any action that
	// other users can join in on (e.g. watching a VOD, browsing their settings page) or is not performing any action at
	// all, this should be set to null.
	Activity *ActivityInput `json:"activity"`
	// availability is the state of the user's session in your application. You should set it to ONLINE if the user is
	// known to be at their device, IDLE if they are not, and OFFLINE if your application is currently terminating.
	//
	// Note that if your application fails to send an OFFLINE heartbeat before terminating, the session will automatically
	// expire after some time without a heartbeat.
	Availability AvailabilityInput `json:"availability"`
	// sessionID must be supplied and can be any string unique to this session. Generating a random UUID when your
	// application starts and sending it for each setSessionStatus is a good idea.
	//
	// Each instance of your application should send the same ID for each of its setSessionStatus calls, but two instances
	// of your application running at the same time should never have the same session ID.
	SessionID string `json:"sessionID"`
}

type SetSessionStatusPayload struct {
	// The number of seconds your application should wait before sending another setSessionStatus. If your application does
	// not call setSessionStatus again within roughly this duration, it will be assumed to have terminated unexpectedly and
	// its session status for this user will expire.
	SetAgainInSeconds int `json:"setAgainInSeconds"`
	// The modified user.
	User *User `json:"user"`
}

// Inputs to the setSquadStreamPrimaryPlayer mutation.
type SetSquadStreamPrimaryPlayerInput struct {
	// ID of the device viewing squad stream.
	DeviceID string `json:"deviceID"`
	// ID of the channel as the current primary player.
	PrimaryPlayerID string `json:"primaryPlayerID"`
	// ID of the squad stream.
	SquadID string `json:"squadID"`
}

// Outputs to the setSquadStreamPrimaryPlayer mutation.
type SetSquadStreamPrimaryPlayerPayload struct {
	// The current primary player of the squad stream.
	PrimaryPlayer *User `json:"primaryPlayer"`
}

// Error from set unban requests settings mutation.
type SetUnbanRequestsSettingsError struct {
	// Error code from the set unban requests settings mutation.
	Code SetUnbanRequestsSettingsErrorCode `json:"code"`
}

// Required input to set unban requests settings on a channel.
type SetUnbanRequestsSettingsInput struct {
	// The channel on which to update settings for.
	ChannelID string `json:"channelID"`
	// The amount of time after a ban before an unban request can be made.
	CooldownMinutes int `json:"cooldownMinutes"`
	// Whether unban requests are allowed to be created on the channel.
	IsEnabled bool `json:"isEnabled"`
}

// Result of setting a channel's unban requests settings.
type SetUnbanRequestsSettingsPayload struct {
	// Error from attempting to set unban requests settings.
	Error *SetUnbanRequestsSettingsError `json:"error"`
	// The updated settings on the channel.
	Settings *UnbanRequestsSettings `json:"settings"`
}

// SetUserResidenceInput is input required to set a user's residence.
type SetUserResidenceInput struct {
	// User's country in ISO alpha-2.
	CountryCode string `json:"countryCode"`
	// Target user for setting residence.
	UserID string `json:"userID"`
	// User's zip code.
	ZipCode *string `json:"zipCode"`
}

// SetUserResidencePayload is the response from the SetUserResidence mutation.
type SetUserResidencePayload struct {
	// User whose residence was set for.
	User *User `json:"user"`
}

type Share struct {
	// The user that created this share.
	Author *User `json:"author"`
	// Time the share was created by the user.
	CreatedAt *time.Time `json:"createdAt"`
	// Share ID.
	ID string `json:"id"`
	// The item that was shared.
	Target ShareTarget `json:"target"`
}

func (Share) IsFeedItemContent() {}

// An ordered list of content to render with metadata on the content.
type Shelf struct {
	// The ordered content for the shelf.
	Content *ShelfContentConnection `json:"content"`
	// How to present the content in the shelf.
	DisplayType string `json:"displayType"`
	// A unique identifier for the shelf for use in tracking and pagination.
	ID string `json:"id"`
	// The title for the shelf.
	Title *ShelfTitle `json:"title"`
	// Information used for recommendation tracking.
	TrackingInfo *TrackingInfo `json:"trackingInfo"`
}

// Paginated list of Shelves. (pagination not yet implemented)
// Implements the Relay cursor connections specification.
// See: https://facebook.github.io/relay/graphql/connections.htm.
type ShelfConnection struct {
	// The list of shelves to display.
	Edges []*ShelfEdge `json:"edges"`
	// As pagination is currently not supported by the backend, this will always be the zero value.
	PageInfo *PageInfo `json:"pageInfo"`
}

// The list of content to render in a shelf.
type ShelfContentConnection struct {
	// The list of content to display.
	Edges []*ShelfContentEdge `json:"edges"`
	// As pagination is currently not supported by the backend, this will always be the zero value.
	PageInfo *PageInfo `json:"pageInfo"`
}

// The content to render in a shelf.
type ShelfContentEdge struct {
	// As pagination is currently not supported by the backend, this will always be the zero value.
	Cursor string `json:"cursor"`
	// The metadata to show for each content edge.
	Metadata *ShelfContentMetadata `json:"metadata"`
	// The underlying content to render.
	Node ShelfContent `json:"node"`
	// Used to associate promotions for tracking.
	PromotionsCampaignID string `json:"promotionsCampaignID"`
	// Used to determine what the source of the shelf content is from.
	SourceType SourceType `json:"sourceType"`
	// Used in client tracking.
	TrackingID string `json:"trackingID"`
}

// The metadata for content to render in a shelf.
type ShelfContentMetadata struct {
	// Whether the content has a live event.
	HasLive bool `json:"hasLive"`
	// The localized subtitle for a content item in a shelf.
	Subtitle *ShelfTitle `json:"subtitle"`
	// The localized title for a content item in a shelf.
	Title *ShelfTitle `json:"title"`
}

// Contains information about a Shelf's relationship to a given page (connection),
// and the Shelf itself.
type ShelfEdge struct {
	// As pagination is currently not supported by the backend, this will always be the zero value.
	Cursor string `json:"cursor"`
	// The shelf.
	Node *Shelf `json:"node"`
}

// The title for the shelf.
type ShelfTitle struct {
	// A resource to interpolate into the title string.
	Context ShelfTitleContext `json:"context"`
	// The fallback localized title, only to be used if client fails to parse the localizedTitleTokens.
	FallbackLocalizedTitle string `json:"fallbackLocalizedTitle"`
	// The name of the shelf being presented, used for backwards compatibility. Allows for localization and interpolation.
	Key string `json:"key"`
	// The localized shelf title in the form of a list of tokens.
	LocalizedTitleTokens []*TitleTokenEdge `json:"localizedTitleTokens"`
}

// A set of options for configuring which shelf data to return to the user.
type ShelvesAvailableOptions struct {
	// The ID of the collection. Only valid when shelfType is set to
	// VideoShelfType.COLLECTION.
	CollectionID *string `json:"collectionID"`
	// The ID of the game shelf to query. Only valid when shelfType is set to
	// VideoShelfType.GAME_VIDEOS.
	GameID *string `json:"gameID"`
	// Which shelf type to query. Currently required.
	// In future, omitting this option returns all valid shelves.
	ShelfType *VideoShelfType `json:"shelfType"`
}

// A set of options to configuring how the shelves data is returned to the consumer.
type ShelvesOptions struct {
	// Should indicate whether the response includes empty shelves.
	IncludeEmpty *bool `json:"includeEmpty"`
}

// A short video from a ShortVideoFeed and its relevant metadata.
type ShortVideo struct {
	// The actual short form video content to display.
	Content ShortVideoContent `json:"content"`
	// The ID of the short form video.
	ID string `json:"id"`
	// All of the reactions on this short form video.
	Reactions []*ShortVideoReaction `json:"reactions"`
}

// A paginated list of short videos.
type ShortVideoFeedConnection struct {
	// The list edges contain ShortVideoFeedEdges with pagination information.
	Edges []*ShortVideoFeedEdge `json:"edges"`
	// Information about pagination in this connection.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An element in a paginated list of short videos.
type ShortVideoFeedEdge struct {
	// Uniquely identifies this item's position in a connection.
	Cursor string `json:"cursor"`
	// The short video.
	Node *ShortVideo `json:"node"`
}

// Options used to determine the content returned in the short video feed.
type ShortVideoFeedOptions struct {
	// The platform of the viewer -- used to curate content in the feed.
	Platform *ShortVideoFeedPlatform `json:"platform"`
	// The type of short video feed to return.
	Type *ShortVideoFeedType `json:"type"`
}

// An aggregated counter for the contained emote to display how many reactions to a ShortVideo there have been.
type ShortVideoReaction struct {
	// The number of times this emote has been used to react to this video.
	Count int `json:"count"`
	// The emote that was used to react.
	Emote *Emote `json:"emote"`
	// The ID is the same as emote.ID.
	ID string `json:"id"`
}

// The type representing Community Points Smart Costs Acknowledgements.
type SmartCostsAcknowledgement struct {
	// The last acknowledged cost.
	LastAcknowledgedCost int `json:"lastAcknowledgedCost"`
	// The type of automatic reward the smart costs acknowledgement is for.
	RewardType CommunityPointsAutomaticRewardType `json:"rewardType"`
}

// The input representing Community Points Smart Costs Acknowledgements.
type SmartCostsAcknowledgementInput struct {
	// The last acknowledged cost.
	LastAcknowledgedCost int `json:"lastAcknowledgedCost"`
	// The type of automatic reward the smart costs acknowledgement is for.
	RewardType CommunityPointsAutomaticRewardType `json:"rewardType"`
}

// Wrapper around the standard emoticon groups for Prime Emoticons.
type SmiliesSet struct {
	// The list of emotes which belong to this set.
	Emotes []*Emote `json:"emotes"`
	// ID for the current smilies set.
	ID *string `json:"id"`
}

// A social media item that is an attribute of Channel.
type SocialMedia struct {
	// The social media's unique identifier.
	ID string `json:"id"`
	// The name of the domain which will be used to determine which favicon to render.
	Name *string `json:"name"`
	// The label displayed to the client.
	Title string `json:"title"`
	// The web address to a social media website.
	URL string `json:"url"`
}

type SocialStream struct {
	// The friend who generated the recommendation.
	Friend *User `json:"friend"`
	// The recommended stream.
	Stream *Stream `json:"stream"`
	// The type of recommendation. Different types contain different metadata about why the recommendation was made.
	Type *StreamRecommendationType `json:"type"`
}

func (SocialStream) IsRecommendedStream() {}

// Error returned when attempting to spend subscription credit.
type SpendSubscriptionCreditError struct {
	// Error code for error that occured while attempting to spend subscription credit.
	Code SpendSubscriptionCreditErrorCode `json:"code"`
}

// Input requires the broadcaster to be payed and user to deduct credit.
type SpendSubscriptionCreditInput struct {
	// The user id of streamer being subscribed to.
	BroadcasterID string `json:"broadcasterID"`
	// Twitch user ID.
	UserID string `json:"userID"`
}

// Mutated data after spending the subscription credit.
type SpendSubscriptionCreditPayload struct {
	// Possible error returned from the service.
	Error *SpendSubscriptionCreditError `json:"error"`
	// The modified subscription benefit data.
	SubscriptionBenefit *SubscriptionBenefit `json:"subscriptionBenefit"`
	// Twitch user ID.
	UserID string `json:"userID"`
}

// The connection of sponsored cheermote channel settings to user.
type SponsoredCheermoteChannelSettingsConnection struct {
	// The list of key pool edges associated with the user.
	Edges []*SponsoredCheermoteChannelSettingsEdge `json:"edges"`
	// The metadata about having more key pools to fetch, or if there is a previous page of key pools.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of key pools for the given user.
	TotalCount int `json:"totalCount"`
}

// The sponsored cheermote channel settings edge which contains our cursor and node.
type SponsoredCheermoteChannelSettingsEdge struct {
	// The cursor of the edge, which is also the key pool ID.
	Cursor string `json:"cursor"`
	// The node of the edge, which contains all information about the key pool.
	Node *SponsoredCheermoteChannelSettingsNode `json:"node"`
}

// The information associated with a given sponsored cheermote channel setting.
type SponsoredCheermoteChannelSettingsNode struct {
	// Brand's image to display, in the form of a URL.
	BrandImageURL string `json:"brandImageURL"`
	// Brand name to display.
	BrandName string `json:"brandName"`
	// Time the campaign ends.
	EndTime time.Time `json:"endTime"`
	// The campaign ID, which is unique.
	ID string `json:"id"`
	// The opt in status of the campaign.
	IsOptedIn bool `json:"isOptedIn"`
	// Time the campaign starts.
	StartTime time.Time `json:"startTime"`
	// Thresholds for matching on sponsored cheering.
	Thresholds []*CheermoteCampaignThreshold `json:"thresholds"`
}

// A squad stream represents a group of broadcasters that are streaming together.  When a squad
// stream is live, viewers can opt to watch the streams of all its members together from a
// single view.
//
// Squad streams are created by a broadcaster who invites other broadcasters to participate.
// Each broadcaster who accepts an invitation becomes a member of the squad stream and can also
// invite other broadcasters to participate.  At the moment, a squad stream can have up to
// four members and a broadcaster can only belong to a single squad stream.
//
// A squad stream ends when all its members leave or stop streaming.
type SquadStream struct {
	// The ID of the squad stream.
	ID string `json:"id"`
	// The invitations with the given status that have been sent by members to other users to join to squad stream.
	Invitations []*SquadStreamInvitation `json:"invitations"`
	// Broadcasters who are currently participating in the squad stream.
	Members []*User `json:"members"`
	// The owner can remove members from the squad stream.
	Owner *User `json:"owner"`
	// The current status of the squad stream.
	Status SquadStreamStatus `json:"status"`
}

// SquadStreamInvitation represents an invitation sent by a member of a squad stream to another user to
// join the squad stream.
type SquadStreamInvitation struct {
	// When the invitation was created.
	CreatedAt time.Time `json:"createdAt"`
	// ID of the invitation.
	ID string `json:"id"`
	// Network type of the invitation. This field is only non nil when the invitation is fetched for User.IncomingSquadStreamInvitations.
	NetworkType *SquadStreamInvitationNetworkType `json:"networkType"`
	// If the invitation's status is rejected, the reason for the rejection.
	ReasonRejected *SquadStreamInvitationRejectedReason `json:"reasonRejected"`
	// The user that the invitation is sent to.
	Recipient *User `json:"recipient"`
	// The user that sent the invitation.
	Sender *User `json:"sender"`
	// The squad stream that the recipient is invited to join.
	SquadStream *SquadStream `json:"squadStream"`
	// The status of the invitation.
	Status SquadStreamInvitationStatus `json:"status"`
}

// List of Squad Stream invitations.
type SquadStreamInvitationConnection struct {
	// The elements of the list.
	Nodes []*SquadStreamInvitation `json:"nodes"`
	// The total count of invitations.
	TotalCount *int `json:"totalCount"`
}

// A user's squad stream settings.
type SquadStreamSettings struct {
	// Denotes whether or not a user can access squad management features like
	// accepting/receiving invites and viewing the Squad Stream dashboard widget.
	CanAccessSquads bool `json:"canAccessSquads"`
	// Determines who can send the user invitations to join a squad stream.
	// Resolves for anyone who can access the user's dashboard (editors, staff, etc.).
	IncomingInvitePolicy *SquadStreamIncomingInvitePolicy `json:"incomingInvitePolicy"`
}

// StartAdError ...
type StartAdError struct {
	// code is the code for the error that occurs while trying to run an ad break.
	Code StartAdErrorCode `json:"code"`
}

// StartAdInput ...
type StartAdInput struct {
	// channelID is the ID of the channel the ad will run on.
	ChannelID string `json:"channelID"`
	// lengthSeconds is the requested ad break length in seconds (30s ad, 60s ad, etc).
	LengthSeconds *int `json:"lengthSeconds"`
}

// StartAdPayload ...
type StartAdPayload struct {
	// adSession is the response object from an ad request.
	AdSession *AdSession `json:"adSession"`
	// error is the StartAdError object from a failed request.
	Error *StartAdError `json:"error"`
}

// Error code for an error that occurs while starting the bounty.
type StartBountyError struct {
	// Error code for error that occurred while starting the bounty.
	Code StartBountyErrorCode `json:"code"`
}

// StartBountyInput includes the bounty a user is trying to start.
type StartBountyInput struct {
	// Unique Identifier for the bounty.
	BountyID string `json:"bountyID"`
	// Title of the stream for the bounty. Must start with #sponsored.
	Title string `json:"title"`
	// UserID of the user that will start the bounty.
	UserID string `json:"userID"`
}

// Data that was mutated after starting the bounty.
type StartBountyPayload struct {
	// The possible error returned from the service.
	Error *StartBountyError `json:"error"`
	// The started bounty with the updated status.
	StartedBounty *Bounty `json:"startedBounty"`
	// The user that now has the started bounty.
	User *User `json:"user"`
}

// Error associated with a failed attempt to start a cloud broadcast.
type StartCloudBroadcastError struct {
	// The cause of the error.
	Cause StartCloudBroadcastErrorCause `json:"cause"`
	// An optional error message associated with the error.
	Message *string `json:"message"`
}

// Input for remotely and asynchronously starting a cloud broadcast for the given channelID.
type StartCloudBroadcastInput struct {
	// The desired framerate of the broadcast.
	Framerate *int `json:"framerate"`
	// The desired height of the broadcast.
	Height *int `json:"height"`
	// The cloud provider to send a start cloud broadcast request to..
	ProviderID string `json:"providerID"`
	// The desired width of the broadcast.
	Width *int `json:"width"`
}

// Response to start a cloud broadcast.
type StartCloudBroadcastPayload struct {
	// If the broadcast was successfully started, properties of that broadcast.
	Broadcast *CloudBroadcast `json:"broadcast"`
	// An optional error if the mutation failed, contaning actionable errors.
	Error *StartCloudBroadcastError `json:"error"`
}

// StartPayoutOnboardingWorkflowInput returns the required input when starting a new workflow for payout onboarding.
type StartPayoutOnboardingWorkflowInput struct {
	// TargetUserID is the ID of the user whose workflow will be started.
	TargetUserID string `json:"targetUserID"`
}

// StartPayoutOnboardingWorkflowPayload returns a new workflow when starting payout onboarding.
type StartPayoutOnboardingWorkflowPayload struct {
	// A new workflow status.
	Workflow *PayoutOnboardingWorkflow `json:"workflow"`
}

// Input for starting a PV Watch Party.
type StartWatchPartyInput struct {
	// Amazon LWA access token.
	AccessToken string `json:"accessToken"`
	// Channel ID of the creator.
	ChannelID string `json:"channelID"`
	// Catalog GTI to use.
	WatchPartyItemID string `json:"watchPartyItemID"`
}

// Returns the new Watch Party and all decoration/details.
type StartWatchPartyPayload struct {
	// Error if the user's token expired.
	Error *WatchPartyError `json:"error"`
	// The watch party that was started.
	WatchParty *WatchParty `json:"watchParty"`
}

// Error code for an error that occurs while stopping the bounty.
type StopBountyError struct {
	// Error code for error that occurred while stopping the bounty.
	Code StopBountyErrorCode `json:"code"`
}

// StopBountyInput includes the bounty a user is trying to stop.
type StopBountyInput struct {
	// Unique Identifier for the bounty.
	BountyID string `json:"bountyID"`
	// UserID of the user that will stop the bounty.
	UserID string `json:"userID"`
}

// Data that was mutated after stopping the bounty.
type StopBountyPayload struct {
	// The possible error returned from the service.
	Error *StopBountyError `json:"error"`
	// The stopped bounty with the updated status.
	StoppedBounty *Bounty `json:"stoppedBounty"`
	// The user that now has the stopped bounty.
	User *User `json:"user"`
}

// An error associated with a failed call to stopCloudBroadcast.
type StopCloudBroadcastError struct {
	// The cause of the error.
	Cause StopCloudBroadcastErrorCause `json:"cause"`
	// Optional message associated with an error.
	Message *string `json:"message"`
}

// Input for remotely stoping a Cloud broadcast for the given channelID.
type StopCloudBroadcastInput struct {
	// The the broadcast id to use when stopping a broadcast.
	ID string `json:"id"`
}

// Response to stop a Cloud broadcast.
type StopCloudBroadcastPayload struct {
	// If the broadcast was successfully stopped, properties of that broadcast.
	Broadcast *CloudBroadcast `json:"broadcast"`
	// Optional error associated with a failed attempt to stop a cloud broadcast.
	Error *StopCloudBroadcastError `json:"error"`
}

// Input for stopping a PV Watch Party.
type StopWatchPartyInput struct {
	// Amazon LWA access token.
	AccessToken string `json:"accessToken"`
	// Channel ID of the creator.
	ChannelID string `json:"channelID"`
}

// Returns LWA authentication errors.
type StopWatchPartyPayload struct {
	// Error if the user's token expired.
	Error *WatchPartyError `json:"error"`
	// The watch party that was stopped.
	WatchParty *WatchParty `json:"watchParty"`
}

// A live stream.
type Stream struct {
	// The associated archive of the stream.
	ArchiveVideo *Video   `json:"archiveVideo"`
	AverageFps   *float64 `json:"averageFPS"`
	Bitrate      *float64 `json:"bitrate"`
	// The language the stream is being broadcasted in.
	BroadcastLanguage *Language `json:"broadcastLanguage"`
	// The user who is broadcasting the live stream.
	Broadcaster *User `json:"broadcaster"`
	// Software being used for the broadcast.
	BroadcasterSoftware *string  `json:"broadcasterSoftware"`
	Channel             *Channel `json:"channel"`
	// Number of clips created since stream start.
	ClipCount *int    `json:"clipCount"`
	Codec     *string `json:"codec"`
	// The time streaming started.
	CreatedAt *time.Time `json:"createdAt"`
	// The stream delay in seconds.
	DelayLengthSeconds *int `json:"delayLengthSeconds"`
	// Information about what directories the stream is categorized in.
	Directories []Directory `json:"directories"`
	// Information about the game being streamed.
	Game *Game `json:"game"`
	// The height of the stream's video, in pixels.
	Height *int `json:"height"`
	// The stream's unique identifier.
	ID string `json:"id"`
	// Whether the stream is hidden from its directory.
	IsDirectoryHidden *bool `json:"isDirectoryHidden"`
	// Information about whether the channel is encrypted.
	IsEncrypted *bool `json:"isEncrypted"`
	// Whether the broadcaster has indicated the stream is intended for mature audiences only.
	IsMature *bool `json:"isMature"`
	// Whether the broadcaster is partnered with Twitch.
	IsPartner *bool `json:"isPartner"`
	// Whether or not viewers of this stream can receive drops.
	// Note: Actually earning drops additionally requires that the game have an
	// active drops campaign and is done at the discretion of the developer.
	IsStreamDropsEnabled *bool `json:"isStreamDropsEnabled"`
	// The lanugage setting of the streaming user.
	Language *Language `json:"language"`
	// When the stream was last updated.
	LastUpdatedAt *time.Time `json:"lastUpdatedAt"`
	// The maximum height of the stream's video, in pixels.
	MaxHeight *int `json:"maxHeight"`
	// Platform-specific (e.g. Xbox, PlayStation) metadata.
	Platform Platform `json:"platform"`
	// The playback access token that determines whether the user can watch the stream.
	// Fetched for both authed and unauthed users.
	PlaybackAccessToken *PlaybackAccessToken `json:"playbackAccessToken"`
	// A URL to a dynamically sized image.
	// If either `height` or `width` are not given, a templated value will be present instead.
	PreviewImageURL *string `json:"previewImageURL"`
	// The restriction that is currently active on the channel for restricting a user's access to it.
	Restriction *ResourceRestriction `json:"restriction"`
	// The list of restriction options that were applied in addition to the restriction type for this stream.
	RestrictionOptions []ResourceRestrictionOption `json:"restrictionOptions"`
	// The type of restriction this stream currently has.
	RestrictionType *string `json:"restrictionType"`
	// self contains information on the relationship between the current user (anonymous or authenticated) and this stream.
	Self *StreamSelfConnection `json:"self"`
	// Tags are used as a discovery and search mechanism for tags and tagged content.
	// The tag data may not be updated immediately after streamers update their tags.
	// Please use User.tags instead if you want real time data from Graffiti.
	// For example, you should use Stream.tags for the channel page and the browse page, but use User.tags for the dashboard.
	Tags []*Tag `json:"tags"`
	// A user-defined title describing the stream.
	Title *string `json:"title"`
	// What type of stream this is (e.g. live, playlist, watch_party).
	Type *string `json:"type"`
	// The number of viewers currently watching the stream.
	ViewersCount *int `json:"viewersCount"`
	// The width of the stream's video, in pixels.
	Width *int `json:"width"`
}

func (Stream) IsTaggedContent()                 {}
func (Stream) IsPersonalSectionChannelContent() {}
func (Stream) IsShareTarget()                   {}
func (Stream) IsReactableContent()              {}
func (Stream) IsShelfContent()                  {}
func (Stream) IsFeedItemContent()               {}
func (Stream) IsFeaturedItemContent()           {}

// StreamBitrate represents the bitrate of stream session by time.
type StreamBitrate struct {
	// Time of recorded bitrate.
	RecordedAt time.Time `json:"recordedAt"`
	// Bitrate of video stream in Kbps.
	ValueKbps float64 `json:"valueKbps"`
}

// Paginated list of Streams.
type StreamConnection struct {
	Edges []*StreamEdge `json:"edges"`
	// Used for tracking.
	GenerationID *string   `json:"generationID"`
	PageInfo     *PageInfo `json:"pageInfo"`
	// Used for tracking.
	ResponseID *string `json:"responseID"`
}

// Contains information about a Streams's relationship to a given page (connection),
// and the Stream itself.
type StreamEdge struct {
	Cursor *string `json:"cursor"`
	Node   *Stream `json:"node"`
	// Unique id per stream response item, used by clients to attribute displays/clicks to items.
	TrackingID *string `json:"trackingID"`
}

// StreamFramerate represents the framerate of strem session by time.
type StreamFramerate struct {
	// Time of recorded bitrate.
	RecordedAt time.Time `json:"recordedAt"`
	// Framerate of video stream in Frame Per Second.
	ValueFps float64 `json:"valueFPS"`
}

// StreamKey represents a RTMP stream key with its expiration date.
type StreamKey struct {
	// Stream key expiration date.
	ExpiresAt *time.Time `json:"expiresAt"`
	// RTMP stream key value.
	Value string `json:"value"`
}

func (StreamKey) IsStreamKeyResult() {}

// StreamKeyError represents the error code and its translated error message response that explains why the broadcaster can't start a stream.
type StreamKeyError struct {
	// code is the error code for why the broadcaster is not allow to broadcast.
	Code string `json:"code"`
	// Link is the url link that is associated from the translated message.
	Links []string `json:"links"`
	// message is the translated message for why the broadcaster is not allow to broadcast.
	Message string `json:"message"`
}

func (StreamKeyError) IsStreamKeyResult() {}

// Query to let consumers filter streams that have specific metadata.
// e.g. return only those hearthstone streams that have broadcasterheroclass as mage.
// FE uses these parameters to implemtent filters.
type StreamMetadataFilterInput struct {
	// Filter streams by CSGO Map.
	CounterStrikeMap *string `json:"counterStrikeMap"`
	// Filter streams by CSGO skill.
	CounterStrikeSkill *string `json:"counterStrikeSkill"`
	// Filter streams by Hearthstone hero class e.g "Mage".
	HearthstoneBroadcasterHeroClass *string `json:"hearthstoneBroadcasterHeroClass"`
	// Filter streams by Hearthstone hero name e.g "Jaina".
	HearthstoneBroadcasterHeroName *string `json:"hearthstoneBroadcasterHeroName"`
	// Filter streams by Hearthstone game mode e.g "arena" or "rank" etc.
	HearthstoneGameMode *string `json:"hearthstoneGameMode"`
	// Filter streams by League Of Legends champion id.
	LeagueOfLegendsChampionID *string `json:"leagueOfLegendsChampionID"`
	// The maximum AVC level of the stream. e.g "4.1".
	MaxAVCLevel *string `json:"maxAVCLevel"`
	// The maximum AVC profile of the stream.
	MaxAVCProfile *AVCProfile `json:"maxAVCProfile"`
	// The maximum height of the stream.
	MaxHeight *int `json:"maxHeight"`
	// Filter streams by Overwatch broadcaster's character e.g "Widowmaker".
	OverwatchBroadcasterCharacter *string `json:"overwatchBroadcasterCharacter"`
	// Filter streams by PUBG game mode.
	PubgGameMode *string `json:"pubgGameMode"`
	// Filter streams by PUBG max number of players alive in game.
	PubgPlayerAliveMax *string `json:"pubgPlayerAliveMax"`
	// Filter streams by PUBG min number of players alive in game.
	PubgPlayerAliveMin *string `json:"pubgPlayerAliveMin"`
}

// Optional inputs to filter streams
// add additional optional fields for filtering streams to the StreamOptions input type.
type StreamOptions struct {
	// Filter streams based on restriction types.
	IncludeRestricted []StreamRestrictionType `json:"includeRestricted"`
	// Broadcaster languages to filter the streams by.
	// Deprecated: use language tags instead.
	Languages []Language `json:"languages"`
	// The locale of the user.
	Locale *string `json:"locale"`
	// The platform to filter streams by.
	PlatformType *PlatformType `json:"platformType"`
	// If sorted by relevance, this provides additional context used to influence recommendations.
	RecommendationsContext *RecommendationsContext `json:"recommendationsContext"`
	// A GUID that is created by the caller for tracking. This should be globally unique per request and is required if sort=RELEVANCE.
	RequestID *string `json:"requestID"`
	// The sort param can be used to change the default sorting.
	Sort *StreamSort `json:"sort"`
	// List of tags to filter by.
	Tags []string `json:"tags"`
}

// The content to render in a live recommendation item.
type StreamRecommendationEdge struct {
	// As pagination is currently not supported by the backend, this will always be the zero value.
	Cursor string `json:"cursor"`
	// The underlying stream content to render.
	Node *Stream `json:"node"`
	// Unique id per stream used in client tracking.
	TrackingID string `json:"trackingID"`
}

// StreamRecommendationsFilters defines parameters which filter down stream recommendation results.
type StreamRecommendationsFilters struct {
	// Stream recommendation results will only include streams with these category ids.
	// Clients can use this filtering option for flows where a user can select categories to filter on.
	// The category IDs should be available from queries in the previous step of the user flow.
	// Example: categoryIDs: ["513143", "33214"] where "513143" and "33214" are coming from categories selected by the user in the previous page.
	CategoryIDs []string `json:"categoryIDs"`
}

// The relationship between the authenticated user and a stream.
type StreamSelfConnection struct {
	// Whether or not the requesting user is authorized to view the channel's stream.
	CanWatch bool `json:"canWatch"`
	// Whether the stream is restricted.
	IsRestricted bool `json:"isRestricted"`
	// If the stream is restricted, the type indicates how the stream is restricted.
	RestrictionType *string `json:"restrictionType"`
}

// The start and end time of a stream session for a user.
type StreamSession struct {
	// The associated archive of the stream.
	ArchiveVideo *Video `json:"archiveVideo"`
	// The end time for the stream session.
	EndedAt time.Time `json:"endedAt"`
	// The start time for the stream session.
	StartedAt time.Time `json:"startedAt"`
}

// Analytics information for a streaming session.
type StreamSummary struct {
	// The associated archive of the stream.
	ArchiveVideo *Video `json:"archiveVideo"`
	// The associated archives of the stream.
	ArchiveVideos []*Video `json:"archiveVideos"`
	// Average viewers for the time period.
	AverageViewers float64 `json:"averageViewers"`
	// The ID for the streaming channel.
	ChannelID string `json:"channelID"`
	// Unique chatters for the time period.
	Chatters int `json:"chatters"`
	// The number of clips created during the stream summary.
	ClipsCreated int `json:"clipsCreated"`
	// The time that the stream session ended.
	EndedAt time.Time `json:"endedAt"`
	// Number of follows for the time period.
	Follows int `json:"follows"`
	// Notification information for a given stream session.
	GoLiveNotification *GoLiveNotification `json:"goLiveNotification"`
	// Live views for the time period.
	LiveViews int `json:"liveViews"`
	// Max viewers for the time period.
	MaxViewers int `json:"maxViewers"`
	// New subscriptions for the time period.
	NewSubscriptions int `json:"newSubscriptions"`
	// The time that the stream session started.
	StartedAt time.Time `json:"startedAt"`
	// Unique chatters for the time period.
	UniqueChatters int `json:"uniqueChatters"`
	// Unique viewers for the time period.
	UniqueViewers int `json:"uniqueViewers"`
}

type Streaming struct {
	// The stream being broadcasted.
	Stream *Stream `json:"stream"`
	// This activity's type, i.e. "STREAMING".
	Type *ActivityType `json:"type"`
}

func (Streaming) IsActivity() {}

// A stucco (wide emote) represents an image that can be used for user interaction in specific cases.
type Stucco struct {
	// The description is used to describe the stucco (e.g. for screenreaders).
	Description string `json:"description"`
	// The unique ID of this stucco.
	ID string `json:"id"`
	// The set of URLS to images related to this stucco, contains URLS for 1x, 2x and 4x images.
	ImageSet *StuccoImageSet `json:"imageSet"`
	// Indicates if this stucco does not belong to a single channel (available to all channels).
	IsGlobal bool `json:"isGlobal"`
	// The owner of this stucco, usually the channel this has been uploaded to.
	OwnerID string `json:"ownerID"`
	// The state of the stucco.
	State StuccoState `json:"state"`
	// The textCode used to represent and identify this stucco, consists of channel prefix + stucco prefix + code.
	TextCode string `json:"textCode"`
}

// Image set of different sizes of the stucco.
type StuccoImageSet struct {
	// Image url of the 92x28px stucco ("1x") image asset.
	Image1xURL string `json:"image1xURL"`
	// Image url of the 182x56px stucco ("2x") image asset.
	Image2xURL string `json:"image2xURL"`
	// Image url of the 368x112px stucco ("4x") image asset.
	Image4xURL string `json:"image4xURL"`
}

// A Stucco pack is a collection of stuccos, the pack can be activated to be used by viewers of that channel.
type StuccoPack struct {
	// The ID of the stucco pack.
	ID string `json:"id"`
	// User id of the owner of this pack (usually a channel).
	OwnerID string `json:"ownerID"`
	// The stuccos contained in this pack, represented as slots, containing the slot index and the stucco.
	Slots []*StuccoPackSlot `json:"slots"`
}

// A stucco pack slot represents a single ordered slot in a pack of stuccos.
type StuccoPackSlot struct {
	// The index of this slot (used for ordering).
	Index int `json:"index"`
	// The stucco in this slot.
	Stucco *Stucco `json:"stucco"`
}

// Sub Count Series shows a user's sub counts broken down by type, tier, and date.
type SubCountSeries struct {
	// The duration each datapoint spans (ex: Day).
	Period TimeSeriesPeriod `json:"period"`
	// The datapoints in the timeseries, ordered ascending order by timestamp.
	SubCountSeriesDataPoints []*SubCountSeriesDataPoint `json:"subCountSeriesDataPoints"`
	// The total number of subscriptions for the given time period (ex: 957).
	TotalCount int `json:"totalCount"`
}

// A single data point in the time series.
type SubCountSeriesDataPoint struct {
	// The breakdown of which tiers contributed how much to the total gift sub count.
	GiftSubTierBreakdown []*SubCountTierDataPoint `json:"giftSubTierBreakdown"`
	// The breakdown of which tiers contributed how much to the total multi month sub count.
	MultiMonthSubTierBreakdown []*SubCountTierDataPoint `json:"multiMonthSubTierBreakdown"`
	// The breakdown of which tiers contributed how much to the total paid sub count.
	PaidSubTierBreakdown []*SubCountTierDataPoint `json:"paidSubTierBreakdown"`
	// The timestamp associated with this data point.
	TimeStamp time.Time `json:"timeStamp"`
	// The total number of gifted subscriptions captured during this period.
	TotalGiftSubCount int `json:"totalGiftSubCount"`
	// The total number of multi month subscriptions captured during this period.
	TotalMultiMonthSubCount int `json:"totalMultiMonthSubCount"`
	// The number of paid subscriptions captured during this period.
	TotalPaidSubCount int `json:"totalPaidSubCount"`
	// The number of Prime subscriptions captured during this period.
	TotalPrimeSubCount int `json:"totalPrimeSubCount"`
}

// SubCountTierDataPoint shows the breakdown of subcount by tier.
type SubCountTierDataPoint struct {
	// How many of this type of subscription were captured in this time period.
	Count int `json:"count"`
	// The type of subscription, i.e. Tier 1, Tier 2, Tier 3.
	Tier string `json:"tier"`
}

// Wrapper for errors associated with submitCSATFeedback mutation.
type SubmitCSATFeedbackError struct {
	// The code associated with the error from submitCSATFeedback mutation.
	Code SubmitCSATFeedbackErrorCode `json:"code"`
}

// SubmitCSATFeedbackInput creates or updates a currently authenticated user's rating/feedback of Twitch Developer Products.
type SubmitCSATFeedbackInput struct {
	// The action that prompted the CSAT callout to appear.
	ActionPrompted *CSATActionPrompted `json:"actionPrompted"`
	// The company ID, if the user is submitting the feedback through an organization's console.
	CompanyID *string `json:"companyID"`
	// The additional feedback that the user submits after the rating.
	Feedback *string `json:"feedback"`
	// The GUID used when updating a CSAT Feedback entry with additional feedback or changes.
	GUID *string `json:"guid"`
	// The rating that the user submits.
	Rating *CSATRating `json:"rating"`
	// The page in Twilight that the user responds to the CSAT callout from.
	Source string `json:"source"`
}

// The result of a submitCSATFeedback mutation.
type SubmitCSATFeedbackPayload struct {
	// The error from a failed submitCSATFeedback mutation.
	Error *SubmitCSATFeedbackError `json:"error"`
	// The response of the mutation.
	Response *SubmitCSATFeedbackResponse `json:"response"`
}

// The response of a successful submitCSATFeedback mutation.
type SubmitCSATFeedbackResponse struct {
	// Unique identifier returned in the response.
	GUID string `json:"guid"`
}

// SubmitEmotePrefix creates a new emoticon prefix for a channel.
type SubmitEmotePrefixInput struct {
	// The channel ID whose emote prefix will be updated.
	ChannelID string `json:"channelID"`
	// The new emote prefix.
	Name string `json:"name"`
}

// SubmitEmotePrefixPayload returns a status code indicating whether the update was successful or not.
type SubmitEmotePrefixPayload struct {
	// A code indicating why the prefix submit failed, if it did.
	ErrorCode *SubmitEmotePrefixResponseCode `json:"errorCode"`
	// The newly submitted prefix.
	Prefix *EmoticonPrefix `json:"prefix"`
}

// SubmitEmoticonPrefix creates a new emoticon prefix for a channel.
type SubmitEmoticonPrefixInput struct {
	// The channel ID.
	ChannelID string `json:"channelID"`
	// Emoticon prefix.
	Name string `json:"name"`
}

// SubmitEmoticonPrefixPayload returns the updated emoticon prefix.
type SubmitEmoticonPrefixPayload struct {
	// The response doesn't return the real state of the prefix. Querying the emoticon
	// prefix is required to get the most accurate state.
	Response *EmoticonPrefix `json:"response"`
}

// SubmitExtensionFeedbackInput submits a user's feedback for a related rating on a Twitch extension.
type SubmitExtensionFeedbackInput struct {
	// Feedback that the broadcaster can write.
	Comment string `json:"comment"`
	// The ID of the extension the feedback applies to.
	ExtensionClientID string `json:"extensionClientID"`
	// The version of the extension the feedback applies to.
	ExtensionVersion string `json:"extensionVersion"`
	// ID of the user submitting the feedback for the extension.
	UserID string `json:"userID"`
}

// The result of a submitExtensionFeedback mutation.
type SubmitExtensionFeedbackPayload struct {
	// The ExtensionRating record that the feedback was attached to.
	Comment *ExtensionComment `json:"comment"`
	// The error when the mutation fails to submit the extension feedback.
	Error *SubmitExtensionFeedbackError `json:"error"`
}

// A list of channels subscribed to by a user.
type SubscribedChannelConnection struct {
	// The subscribed channels.
	Edges []*SubscribedChannelEdge `json:"edges"`
	// Pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of subscribed channels.
	TotalCount *int `json:"totalCount"`
}

// A broadcaster user with cursor.
type SubscribedChannelEdge struct {
	// Cursor represents the position of the current edge/node.
	Cursor string `json:"cursor"`
	// Node represents the user for the current edge.
	Node *User `json:"node"`
}

// SubscriberBadgeProgress contains progress information for subscription badges based on a user's tenure.
type SubscriberBadgeProgress struct {
	// The ID is a composite of channel_id (owner of badge) / user_id (viewer requesting badge) / version
	ID string `json:"id"`
	// URL of 18x18 asset.
	Image1xURL string `json:"image1xURL"`
	// URL of 36x36 asset.
	Image2xURL string `json:"image2xURL"`
	// URL of 72x72 asset.
	Image4xURL string `json:"image4xURL"`
	// The percentage of tenure already earned towards this badge.
	PercentCompleted float64 `json:"percentCompleted"`
	// The total tenure in months required to earn this badge.
	RequiredTenureMonths int `json:"requiredTenureMonths"`
	// Metadata about how a subscriber badge is stored & fetched.
	Version string `json:"version"`
}

// Breakdown of number of subscriptions by tier.
type SubscriberCountBreakdown struct {
	// The number of subscriptions to the product.
	Count int `json:"count"`
	// The tier of the product.
	Tier string `json:"tier"`
}

// Information pertaining to user's subscriber score.
// Contains subscription count, sub points, emote limits, and information about the next subscriber level.
type SubscriberScore struct {
	// Breakdown of subscriber score by product tier.
	Breakdown []*SubscriberScoreBreakdown `json:"breakdown"`
	// Current subscriber count.
	Count int `json:"count"`
	// Breakdown of total subs by product tier.
	CountBreakdown []*SubscriberCountBreakdown `json:"countBreakdown"`
	// Current subscriber score.
	Current int `json:"current"`
	// Current number of emotes unlocked.
	CurrentEmoteLimit int `json:"currentEmoteLimit"`
	// Next goal to unlock more emotes.
	// Will be null if max score already reached.
	Next *int `json:"next"`
	// Emote limit after reaching nextScoreGoal.
	// Will be null if max emote limit reached.
	NextEmoteLimit *int `json:"nextEmoteLimit"`
}

// Breakdown of score by tier.
type SubscriberScoreBreakdown struct {
	// The score of the product.
	Score int `json:"score"`
	// The tier of the product.
	Tier string `json:"tier"`
}

// Data about a user's subscription to a broadcaster.
type SubscriptionBenefit struct {
	// The date that the subscription benefit ends.
	EndsAt *time.Time `json:"endsAt"`
	// gift resolves gift info about a SubscriptionBenefit.
	Gift *SubscriptionGift `json:"gift"`
	// The unique identifier.
	ID string `json:"id"`
	// For a recurring subscription, the price is charged at every interval i months.
	IntervalNumber int `json:"intervalNumber"`
	// Whether the sub is set to "do not renew".
	IsDNRd bool `json:"isDNRd"`
	// Whether this subscription has been extended. This means that a non-recurring subscription has been extended with additional months.
	IsExtended bool `json:"isExtended"`
	// Whether the subscription is in the grace period to be cancelled and refunded.
	IsRefundable bool `json:"isRefundable"`
	// The id of where the subscription originated from. Used when DNRing a recurring subscription.
	OriginID *string `json:"originID"`
	// If the subscriptionBenefit has a future dated paid upgrade. (ie. a user has upgraded a 1-month gift to a recurring subscription).
	PaidUpgrade *PaidUpgrade `json:"paidUpgrade"`
	// If the subscriptionBenefit has a pending future dated paid subscription.
	PendingSubscription *PendingSubscription `json:"pendingSubscription"`
	// The platform the subscription was purchased on.
	Platform SubscriptionPlatform `json:"platform"`
	// Resolves the product that the subscription benefit is to.
	Product *SubscriptionProduct `json:"product"`
	// Whether this benefit was achieved using a Twitch Prime subscription.
	PurchasedWithPrime bool `json:"purchasedWithPrime"`
	// The date that the subscription benefit will renew. Will be nil if the subscription benefit
	// is not going to renew.
	RenewsAt *time.Time `json:"renewsAt"`
	// The states this benefit has transitioned through. Captures both user-initiated states
	// such as initiating a DNR request, as well as system-initiated states such as completing a DNR request.
	States []*SubscriptionBenefitStateHistory `json:"states"`
	// Exposes the third party SKU for managing third party subscriptions from the client.
	// Will be nil if there is not a thirdPartySKU associated with this subscription benefit.
	ThirdPartySku *string `json:"thirdPartySKU"`
	// The subscription tier.
	Tier string `json:"tier"`
	// The user who is subscribed to.
	User *User `json:"user"`
}

// A paginated list of subscription benefits.
type SubscriptionBenefitConnection struct {
	// The list of subscription benefits on this page.
	Edges []*SubscriptionBenefitEdge `json:"edges"`
	// Information about this page of payment transactions.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Criteria for building paginated list of user's all active subscriptions.
type SubscriptionBenefitCriteriaInput struct {
	// Only return subscription benefits for a given filter value.
	Filter *SubscriptionBenefitFilter `json:"filter"`
	// Platform where subscriptions were purchased.
	Platform *SubscriptionPlatform `json:"platform"`
}

// An element in a paginated list of subscription benefits.
type SubscriptionBenefitEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// The element node.
	Node *SubscriptionBenefit `json:"node"`
}

// Data about the states a Subscription Benefit has transitioned through. Captures both user-initiated states
// such as initiating a DNR request, as well as system-initiated states such as completing a DNR request.
type SubscriptionBenefitStateHistory struct {
	// When the benefit transitioned to this state.
	CreatedAt *time.Time `json:"createdAt"`
	// The logical state the benefit occupied.
	State SubscriptionBenefitState `json:"state"`
}

// Configs that help initiate the subscription checkout flow.
type SubscriptionCheckoutConfigs struct {
	// Lists any additional actions for a subscription checkout session.
	Actions []CheckoutAction `json:"actions"`
	// Whether the initiated checkout flow can complete/succeed and gift the recipient the product.
	CanGift bool `json:"canGift"`
	// Whether the initiated checkout flow can proceed with a purchase.
	CanPurchase bool `json:"canPurchase"`
	// Whether the purchaser is eligible for a one-time promotion in the subscription purchase checkout flow.
	IsOneMonthFreeEligible bool `json:"isOneMonthFreeEligible"`
	// Holds configuration necessary for initializing payment provider client libraries and facilitate checkout flow.
	PaymentProviderConfigs *PaymentProviderConfigs `json:"paymentProviderConfigs"`
	// Purchase Ineligibility reason details.
	PurchaseIneligibilityReason PurchaseIneligibilityReason `json:"purchaseIneligibilityReason"`
}

// An Offer for purchasing community gift subscriptions with associated metadata about the Offer.
// Composes the "model" (Offer) with the "view" metadata about the offer.
type SubscriptionCommunityGifting struct {
	// The image assets for this offer.
	Assets *SubscriptionCommunityGiftingAssets `json:"assets"`
	// The Offer document for this Community Gift offer.
	Offer *Offer `json:"offer"`
	// The default number of subscriptions that this offer is offering.
	Quantity int `json:"quantity"`
	// The type of this community gifting offer.
	Type SubscriptionCommunityGiftingType `json:"type"`
}

// Groups image assets related to the community gifting Offer.
type SubscriptionCommunityGiftingAssets struct {
	// The link to the 1x pixel density image asset for this community gifting offer.
	ImageURL1x string `json:"imageURL1x"`
	// The link to the 2x pixel density image asset for this community gifting offer.
	ImageURL2x string `json:"imageURL2x"`
	// The link to the 3x pixel density image asset for this community gifting offer.
	ImageURL3x string `json:"imageURL3x"`
	// The link to the 4x pixel density image asset for this community gifting offer.
	ImageURL4x string `json:"imageURL4x"`
}

// Gift information for a subscription benefit.
type SubscriptionGift struct {
	// giftDate is the date that the gift was given.
	GiftDate *time.Time `json:"giftDate"`
	// Gifter is the user who sent the gift. Will be nil if isGift is false or is the gift is anonymous.
	Gifter *User `json:"gifter"`
	// isGift says whether the subscription benefit is a gift or not.
	IsGift bool `json:"isGift"`
}

// A gift offer that is available on a particular subscription based
// on gift type and platform.
type SubscriptionGiftOffer struct {
	// Unique identifier of a subscription gift offer.
	ID string `json:"id"`
	// The subscription gift offer price info which contains information about currency, cost and tax information.
	PriceInfo *PriceInfo `json:"priceInfo"`
	// The available promotions on this gift offer.
	Promotion *SubscriptionGiftPromotion `json:"promotion"`
	// The amount of gifts in this offer.
	Quantity int `json:"quantity"`
	// thirdPartySKU represents the purchasable third party SKU of the gift the user will purchase.
	// Will return an nil if the user has no purchasable skus.
	// Will return nil if not on a platform with an external subscription gift offer or if the country is not supported.
	ThirdPartySku *string `json:"thirdPartySKU"`
	// The type of gift this offer is for.
	Type SubscriptionGiftType `json:"type"`
}

// The promotion offer on a subscription gift offer.
type SubscriptionGiftPromotion struct {
	// The subscription gift's discount type for this promotion(e.g. "PERCENT_OFF").
	DiscountType SubscriptionPromotionDiscountType `json:"discountType"`
	// The discount value of the subscription gift product (e.g. "50").
	DiscountValue string `json:"discountValue"`
	// Unique identifier of a subscription gift promotion.
	ID string `json:"id"`
	// The subscription gift offer price info which contains information about currency, cost and tax information.
	PriceInfo *PriceInfo `json:"priceInfo"`
	// The quantity of gifts this promotion is for(ex: 11 gifts for a promotion on 10 gifts).
	Quantity int `json:"quantity"`
	// Promotion consumable SKU used by third party that the user will purchase.
	ThirdPartySku *string `json:"thirdPartySKU"`
}

// A parent field for grouping the different types of gift subscriptions.
type SubscriptionGifting struct {
	// Offers and associated metadata for purchasing community gift subscriptions.
	Community []*SubscriptionCommunityGifting `json:"community"`
	// Offers for purchasing a gift subscription to the given user.
	// This will prefer the ID if both login and ID are provided.
	// If neither are provided, this will return null.
	Standard []*SubscriptionStandardGifting `json:"standard"`
}

// Represents the interval of a subscription product.
type SubscriptionInterval struct {
	// The unit-less amount of time a subscription lasts for.
	Duration int `json:"duration"`
	// Denotes the unit of the interval.
	Unit SubscriptionIntervalUnit `json:"unit"`
}

// Subscription pricing information.
type SubscriptionOffer struct {
	// Currency the offer is for.
	Currency string `json:"currency"`
	// Exponent to use when shifting the currency.
	Exponent int `json:"exponent"`
	// Id for offer on subscription product.
	ID string `json:"id"`
	// Price for the offer.
	Price int `json:"price"`
	// Promotion description.
	PromoDescription *string `json:"promoDescription"`
}

// A subscription that is purchasable by users.
// Once purchased, the subscription entitles the user to use special emote sets on Twitch.
type SubscriptionProduct struct {
	// The subscription product's display name.
	DisplayName *string `json:"displayName"`
	// The maximum number of Emotes that can be associated with this product.
	EmoteLimit *int `json:"emoteLimit"`
	// The emote modifiers associated with the product.
	EmoteModifiers []*EmoteModifier `json:"emoteModifiers"`
	// The identifier of an EmoteSet that a user gains access to use on Twitch,
	// when they purchase this product.
	EmoteSetID *string `json:"emoteSetID"`
	// A list of Emotes the user gains access to use on Twitch when they purchase
	// this product.
	Emotes []*Emote `json:"emotes"`
	// A list of GiftOffers that are available on this subscription product
	// depending on which platform and gift type is given
	// Used by clients to display different gift prices, quantities and gift promotion information.
	GiftOffers []*SubscriptionGiftOffer `json:"giftOffers"`
	// The subscription product's promotion if it is active.
	GiftPromotion *SubscriptionPromotion `json:"giftPromotion"`
	// The different types of gift subscriptions ("Community" vs "Standard").
	Gifting *SubscriptionGifting `json:"gifting"`
	// Whether the subscription hides ads for the channel.
	HasAdFree bool `json:"hasAdFree"`
	// Whether the subscribers of this product are affected by slow chat mode.
	HasFastChat *bool `json:"hasFastChat"`
	// Whether the channel has sub only chatroom restriction.
	HasSubOnlyChat *bool `json:"hasSubOnlyChat"`
	// Whether the subscribers of this product are able to see the subs-only video archive.
	HasSubonlyVideoArchive *bool `json:"hasSubonlyVideoArchive"`
	// The subscription product's identifier.
	ID string `json:"id"`
	// The interval that the product lasts for. Includes unit + duration.
	Interval *SubscriptionInterval `json:"interval"`
	// The subscription product's name.
	Name string `json:"name"`
	// Available offers for a subscription product.
	Offers []*Offer `json:"offers"`
	// The Twitch user that is the owner of the channel associated with this subscription product.
	// This is null for SubscriptionProducts like 'turbo' that are not associated with any user.
	Owner *User `json:"owner"`
	// The subscription's USD-formatted price, e.g. "$9.99".
	Price string `json:"price"`
	// PriceInfo holds the products pricing information such as currency, cost, and tax information.
	PriceInfo *PriceInfo `json:"priceInfo"`
	// The subscription product's promotion if it is active.
	Promotion *SubscriptionPromotion `json:"promotion"`
	// The currently active revenue configuration record for the subscription product.
	RevenueConfig *RevenueConfig `json:"revenueConfig"`
	// The connection for user to the subscription product.
	Self *SubscriptionProductSelfConnection `json:"self"`
	// The avaliability state of the product. e.g. "active" or "inactive".
	State SubscriptionState `json:"state"`
	// ThirdPartytemplateSKU is used by the frontend to retrieve third party product information such
	// as price. templateSKU is exposed separately from purchaseSKU since retrieving purchaseSKU is a
	// more expensive operation. A user may not be able to purchase the templateSKU. Use purchaseSKU
	// when the user has indiciated they want to purchase.
	// Uses Client-ID to determine platform information and IP address to determine location.
	ThirdPartyTemplateSku *string `json:"thirdPartyTemplateSKU"`
	// The tier of the product.
	Tier string `json:"tier"`
	// The type of subscription, e.g. "chansub" or "teamsub".
	Type SubscriptionProductType `json:"type"`
	// The URL for this subscription's purchase page.
	URL string `json:"url"`
}

// The connection between the user and subscription product.
type SubscriptionProductSelfConnection struct {
	// This user's subscription benefit information for the subscription product.
	Benefit *SubscriptionBenefit `json:"benefit"`
	// True if the user in this connection is allowed to gift the product in this connection.
	CanGiftInChannel bool `json:"canGiftInChannel"`
	// True if the user in this connection can gift the product in this connection to the user with the supplied user ID.
	CanGiftTo bool `json:"canGiftTo"`
	// True if the user in this connection can gift the product in this connection to the user with the supplied login.
	// Since this requires an additonal lookup to get the user ID from the login, this is less preferable than canGift.
	CanGiftToLogin bool `json:"canGiftToLogin"`
	// Holds configuration necessary to start subscription purchase checkout flow for this product for current user.
	CheckoutConfiguration *SubscriptionCheckoutConfigs `json:"checkoutConfiguration"`
	// The subscription's discount type (e.g. "percent_off").
	DiscountType DiscountType `json:"discountType"`
	// The discount value of the subscription product (e.g. "50").
	DiscountValue string `json:"discountValue"`
	// A list of GiftOffers that are available on this subscription product
	// depending on which platform, giftType and user that is authenticated.
	// Exposed on the self connection as well since user based promotions can be given in the future
	// Used by clients to display different gift prices, quantities and user based gift promotion information.
	GiftOffers []*SubscriptionGiftOffer `json:"giftOffers"`
	// If the product is eligible for a discount.
	IsEligibleForDiscount bool `json:"isEligibleForDiscount"`
	// The subscription's USD-formatted price after discount (e.g. "$2.49").
	NewPrice string `json:"newPrice"`
	// The subscription's USD-formatted price before discount (e.g. "$4.99").
	OldPrice string `json:"oldPrice"`
	// If the subscription product is eligible for a paid upgrade promotion.
	PaidUpgradePromotion *SubscriptionPromotion `json:"paidUpgradePromotion"`
	// Contains information on the final checkout price of this subscription product.
	ProductPurchase *ProductPurchase `json:"productPurchase"`
	// The subscription product's promotion for user if eligible.
	Promotion *SubscriptionPromotion `json:"promotion"`
	// This user's subscription purchase details for the subscription product. If this user is not
	// subscribed to the product, then the result's state is 'inactive'. If a compatible purchase exists,
	// then the result's "compatiblePurchase" field is present.
	Purchase *SubscriptionPurchase `json:"purchase"`
	// Subscription tenure data for the user to this subscription product.
	SubscriptionTenure *SubscriptionTenure `json:"subscriptionTenure"`
	// ThirdPartyPurchaseSKU is different from templateSKU since it represents the SKU of the exact item the
	// user will purchase. It is more expensive to retrieve purchaseSKU than templateSKU, so only
	// use purchaseSKU when the user has indicated they want to checkout. Use templateSKU on channel
	// page load to retrieve product information.
	//
	// Will return an error if the user has no purchasable skus. Will return nil if not on a platform
	// with an external subscription product or if the country is not supported.
	// Uses Client-ID to determine platform information and IP address to determine location.
	ThirdPartyPurchaseSku *string `json:"thirdPartyPurchaseSKU"`
}

// A set of subscription products.
type SubscriptionProductsConnection struct {
	// The resolved subscription products.
	Nodes []*SubscriptionProduct `json:"nodes"`
}

func (SubscriptionProductsConnection) IsSubscriptionProductsResult() {}

// A subscription products error.
type SubscriptionProductsError struct {
	// A code representing the error state.
	Code SubscriptionProductsErrorCode `json:"code"`
}

func (SubscriptionProductsError) IsSubscriptionProductsResult() {}

// The promotion offer on subscription product.
type SubscriptionPromotion struct {
	// Contains information on the final checkout price for this promotion.
	CheckoutPrice *ProductPurchase `json:"checkoutPrice"`
	// The subscription's discount type (e.g. "PERCENT_OFF").
	DiscountType SubscriptionPromotionDiscountType `json:"discountType"`
	// The discount value of the subscription product (e.g. "50").
	DiscountValue string `json:"discountValue"`
	// The subscription's USD-formatted price after discount (e.g. "$2.49").
	NewPrice string `json:"newPrice"`
	// The subscription's USD-formatted price before discount (e.g. "$4.99").
	OldPrice string `json:"oldPrice"`
	// The price for the promotion.
	PreviewPrice *PriceInfo `json:"previewPrice"`
}

// A user's subscription purchase details, part of the Subscription Checkout workflow.
type SubscriptionPurchase struct {
	// A compatible purchase exists if this user bought a subscription product of a different tier for the
	// channel in question.
	//
	// i.e. this user doesn't have this subscription purchase for the $4.99 sub but they do have a
	//      compatible purchase for the $9.99 subscription.
	CompatiblePurchases []*SubscriptionPurchaseDetails `json:"compatiblePurchases"`
	// The purchase details for a Twitch purchaser - Subscription product combination.
	Details *SubscriptionPurchaseDetails `json:"details"`
}

// The receipt details for a subscription purchase.
type SubscriptionPurchaseDetails struct {
	// Date the purchase was cancelled at, if applicable, else null.
	CancelledAt *time.Time `json:"cancelledAt"`
	// Currency for the price, e.g. "USD".
	Currency string `json:"currency"`
	// Divisor for the price based on the currency. e.g. Divisor for USD is 100.
	Divisor int `json:"divisor"`
	// Purchase's payment provider.
	PaymentProvider PaymentProvider `json:"paymentProvider"`
	// Price in smallest subunit of currency, e.g. "499" cents.
	Price int `json:"price"`
	// The tier of the subscription purchase product.
	ProductTier *string `json:"productTier"`
	// The type of subscription purchase.
	ProductType SubscriptionProductType `json:"productType"`
	// Purchase state.
	State SubscriptionPurchaseState `json:"state"`
}

// An Offer for purchasing a Standard (AKA "single" or "targetted") gift subscription for a specific user.
// This type exists as a futureproofing measure as gifting will evolve over time.
type SubscriptionStandardGifting struct {
	// The Offer document for this Standard Gift offer.
	Offer *Offer `json:"offer"`
}

// Simple summary of subscription product.
type SubscriptionSummary struct {
	// Emotes included with subscription.
	Emotes []*Emote `json:"emotes"`
	// Subscription product id, for now is the same as the ticket product id.
	ID string `json:"id"`
	// Emote modifiers available at this tier.
	Modifiers []*EmoteModifier `json:"modifiers"`
	// Channel's custom name for their subscription.
	Name string `json:"name"`
	// Pricing information about subscription, filtered to what is available for user.
	Offers []*SubscriptionOffer `json:"offers"`
	// Info specific to the user.
	Self *SubscriptionSummarySelf `json:"self"`
	// Tier of subscription, either 1, 2, or 3.
	Tier SubscriptionSummaryTier `json:"tier"`
	// URL for checkout page.
	URL string `json:"url"`
}

// Most of the user specific fields for SubscriptionSummary.
type SubscriptionSummarySelf struct {
	// What is the cumulative tenure for this user.
	CumulativeTenure int `json:"cumulativeTenure"`
	// Is the user subscribed to this tier.
	IsSubbed bool `json:"isSubbed"`
}

// Tenure to a subscription product.
type SubscriptionTenure struct {
	// The days remaining in a user's current tenure period.
	DaysRemaining int `json:"daysRemaining"`
	// The days elapsed in a user's current tenure period.
	ElapsedDays int `json:"elapsedDays"`
	// The ending date of a user's tenure.
	End *time.Time `json:"end"`
	// The method used to calculate the user's tenure.
	Method SubscriptionTenureMethod `json:"method"`
	// The total duration of a user's tenure.
	Months int `json:"months"`
	// The starting date of a user's tenure.
	Start *time.Time `json:"start"`
}

// Token that a User uses for redeeming Subscriptions.
type SubscriptionToken struct {
	// Current token balance of user.
	Balance *int `json:"balance"`
}

// A SubscriptionTokenBundleProduct can contain multiple Offers.
// ex) A Bundle of size 3 tokens, can have 3 other offers such as:
//   - Normal offer: "Pay $16.99 for the bundle
//   - Discounted, one-time buy offer: "Pay $14.99 for the bundle, but a one-time purchase only"
//   - Bits: Use X amount of Bits to purchase this Bundle.
type SubscriptionTokenBundleProduct struct {
	// Assets assocaited with a certain Token Bundle Product.
	Assets []*TokenBundleAsset `json:"assets"`
	// Subscription token bundle product's identifier.
	ID string `json:"id"`
	// List of available offers for this bundle product.
	// Displays the cheapest offer to the user, if there are promotions to be applied.
	Offers []*Offer `json:"offers"`
	// Quantity of tokens the bundle.
	Quantity int `json:"quantity"`
}

// Describes configurable values for the token product line.
type SubscriptionTokenProductConfig struct {
	// Max token balance a user can have.
	MaxBalance *int `json:"maxBalance"`
}

// The individual swap participant input.
type SwapCompetitionLobbyParticipantInput struct {
	// The id of the lobby where the lobby participant currently is.
	LobbyID string `json:"lobbyID"`
	// The id of the lobby participant, which can be competition player id or competition team id, we are swapping with.
	ParticipantID string `json:"participantID"`
}

// SwapCompetitionLobbyParticipantsInput exchanges the lobby placements of the two participants within the same phase.
type SwapCompetitionLobbyParticipantsInput struct {
	// The id of the competition.
	CompetitionID string `json:"competitionID"`
	// The participantID and lobbyID of the first lobby participant to be swapped.
	First *SwapCompetitionLobbyParticipantInput `json:"first"`
	// The id of the phase.
	PhaseID string `json:"phaseID"`
	// The participantID and lobbyID of the second lobby participant to be swapped.
	Second *SwapCompetitionLobbyParticipantInput `json:"second"`
}

// SwapCompetitionLobbyParticipantsPayload is the success response for swapping lobby participants.
type SwapCompetitionLobbyParticipantsPayload struct {
	// The new state of competition after swapping participants.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// SyncGameOnDropCampaignPayload contains the campaign ID that needs to be synced.
type SyncGameOnDropCampaignInput struct {
	// The ID of the campaign to sync.
	CampaignID string `json:"campaignID"`
}

// SyncGameOnDropCampaignPayload returns the result of the sync.
type SyncGameOnDropCampaignPayload struct {
	// The campaign after the sync.
	DropCampaign *DropCampaign `json:"dropCampaign"`
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// Tag(s) are used as a discovery and search mechanism for tagged content, including Streams, Clips, and VODs.
type Tag struct {
	// Timestamp of the creation of this tag.
	CreatedAt *time.Time `json:"createdAt"`
	// This tag's unique identifier.
	ID string `json:"id"`
	// Whether this tag is auto generated.
	IsAutomated bool `json:"isAutomated"`
	// Whether this tag is a language tag.
	IsLanguageTag bool `json:"isLanguageTag"`
	// Localized description of this tag.
	LocalizedDescription string `json:"localizedDescription"`
	// Localized Name of this tag.
	LocalizedName string `json:"localizedName"`
	// Scope of the Tag.
	Scope TagScope `json:"scope"`
	// Official Name of this tag in English.
	TagName string `json:"tagName"`
}

func (Tag) IsTitleTokenNode()         {}
func (Tag) IsVerticalContentContext() {}

// The frequency of a tag used as filter for a channel.
type TagAnalytic struct {
	// A decimal that shows how often a Tag is used.
	Percentage float64 `json:"percentage"`
	// The tag for the analytic.
	Tag *Tag `json:"tag"`
}

// A paginated list of tags, and its metadata.
type TagConnection struct {
	// The list of tags in this page.
	Edges []*TagEdge `json:"edges"`
	// Information about this page of tags.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An element in a paginated tags, and its metadata.
type TagEdge struct {
	// Cursor represents the position of the current edge/node.
	Cursor string `json:"cursor"`
	// Node represents the extension for the current edge.
	Node *Tag `json:"node"`
}

// TargetedModerationAction is a ModLogs entry of a chat ban,timeout, or unban.
type TargetedModActionDetails struct {
	// Timestamp when user was banned/timed-out.
	BannedAt *time.Time `json:"bannedAt"`
	// Duration of the chat timeout (in seconds).
	DurationSeconds *int `json:"durationSeconds"`
	// Timestamp when the chat timeout expires.
	ExpiresAt *time.Time `json:"expiresAt"`
	// Reason of the action.
	Reason *string `json:"reason"`
}

// TaxInterview describes the information for a user's Amazon tax interview during payout onboarding.
type TaxInterview struct {
	// Amazon tax interview account ID.
	AccountID string `json:"accountID"`
	// Amazon tax interview client ID.
	ClientID string `json:"clientID"`
	// Legal name of the user completing the Amazon tax interview.
	GovernmentAlias string `json:"governmentAlias"`
	// The preferred locale for user in the accepted format to initate the Amazon tax interview (e.g. "en_US").
	Locale string `json:"locale"`
	// List of key value pairs that were used to generate the signature.
	Options []*TaxInterviewOption `json:"options"`
	// Unique signature to initiate the Amazon tax interview.
	Signature string `json:"signature"`
	// The type of Amazon tax interview.
	Type TaxInterviewType `json:"type"`
	// The URL for user to begin their Amazon tax interview.
	URL string `json:"url"`
}

// TaxInterviewOption is a key value pair type used by the tax interview.
// Each option represents a form value that musted be passed to the argon website.
type TaxInterviewOption struct {
	// The name of the option.
	Key string `json:"key"`
	// The option value.
	Value string `json:"value"`
}

// Represents a tax jurisdiction from which a final price was calculated.
type TaxRegion struct {
	// Tax country, required for the TaxRegion object type.
	CountryCode string `json:"countryCode"`
	// Tax state if applicable.
	State *string `json:"state"`
	// Tax zip code if applicable.
	ZipCode *string `json:"zipCode"`
}

// Team represents a Twitch Team.
// Teams are collections of streaming channels, and are owned by a Twitch user.
// Teams have landing pages, e.g. https://www.twitch.tv/team/clg.
type Team struct {
	// ID to an image meant to be the background of the Team's landing page.
	BackgroundImageID *string `json:"backgroundImageID"`
	// URL to an image meant to be the background of the Team's landing page.
	BackgroundImageURL *string `json:"backgroundImageURL"`
	// ID to the Team's banner image.
	BannerID *string `json:"bannerID"`
	// URL to the Team's banner image.
	BannerURL *string `json:"bannerURL"`
	// Retrieves team stats within the start and end time broken down by granularity.
	// Default end time will be the current time (now).
	// Granularity defaults to 5 minutes.
	// ChannelIDs defaults to all team members.
	CreatorTimeseriesMetrics *CreatorTimeseriesMetrics `json:"creatorTimeseriesMetrics"`
	// Information about the team, formatted in Markdown.
	Description *string `json:"description"`
	// Display version of the team name.
	DisplayName string `json:"displayName"`
	// The Team's ID.
	ID string `json:"id"`
	// Channels that the Team owner have opted to highlight that are currently live.
	// These channels may or may not also be members of the Team.
	// They will be returned in the order configured by the Team admin.
	LiveFeaturedChannels *UserConnection `json:"liveFeaturedChannels"`
	// Users that belong to the team that are currently live.
	// They will be returned in the order configured by the Team admin.
	LiveMembers *UserConnection `json:"liveMembers"`
	// ID to the Team's logo image.
	LogoID *string `json:"logoID"`
	// URL to the Team's logo image.
	LogoURL *string `json:"logoURL"`
	// The list of users that belong to this team.
	// They will be returned in the order configured by the Team admin.
	// metricsRevealed allows the client to return all `none`, `statsRevealed`, or `revenueRevealed` members.
	// Defaults to all members to avoid breaking changes.
	Members *UserConnection `json:"members"`
	// The alphanumeric Twitch name of the team.
	Name string `json:"name"`
	// Owner is the User that owns and manages the Team.
	Owner *User `json:"owner"`
	// Aggregated analytics for several video referral sources, for use in teams dashboard.
	// ChannelIDs defaults to all team members.
	VideoPlayReferrals *VideoPlayReferrals `json:"videoPlayReferrals"`
}

// Inputs for terminating a poll.
type TerminatePollInChannelInput struct {
	// The id of the channel with the poll to terminate.
	ChannelID string `json:"channelID"`
}

// Outputs from the terminate poll mutation.
type TerminatePollInChannelPayload struct {
	// The terminated poll.
	Poll *Poll `json:"poll"`
}

// Inputs for terminating a poll.
type TerminatePollInput struct {
	// The id of the poll to terminate.
	PollID string `json:"pollID"`
}

// Outputs from the create poll mutation.
type TerminatePollPayload struct {
	// The created poll.
	Poll *Poll `json:"poll"`
}

// A shelf title token type that contains text with various formatters.
type TextToken struct {
	// If this title token should be emphasized or not.
	HasEmphasis bool `json:"hasEmphasis"`
	// The location that this shelf title token should link to.
	Location LinkType `json:"location"`
	// The text to display for this token.
	Text string `json:"text"`
}

func (TextToken) IsTitleTokenNode() {}

type ThumbnailOEmbed struct {
	Height int    `json:"height"`
	URL    string `json:"url"`
	Width  int    `json:"width"`
}

// A drop triggered by accummulating minutes watched.
type TimeBasedDrop struct {
	// The rewards for this drop and how often those rewards can be awarded.
	BenefitEdges []*DropBenefitEdge `json:"benefitEdges"`
	// The campaign this drop belongs to.
	Campaign *DropCampaign `json:"campaign"`
	// The time at which this drop becomes unavailable.
	EndAt time.Time `json:"endAt"`
	// A unique identifier.
	ID string `json:"id"`
	// The name of this drop.
	Name string `json:"name"`
	// The drops that must have been claimed before this drop can be claimed / made progress for.
	PreconditionDrops []*TimeBasedDrop `json:"preconditionDrops"`
	// The number of minutes a user has to watch in order to claim the reward.
	RequiredMinutesWatched int `json:"requiredMinutesWatched"`
	// User specific data associated with the TimeBasedDrop.
	Self *TimeBasedDropSelfEdge `json:"self"`
	// The time at which this drop becomes available.
	StartAt time.Time `json:"startAt"`
}

func (TimeBasedDrop) IsDropType() {}

// User specific data associated with this drop.
type TimeBasedDropSelfEdge struct {
	// The current progress for a given user towards this drop.
	CurrentMinutesWatched int `json:"currentMinutesWatched"`
	// The ID of the drop reward granted to the user if the drop is claimable, returns null otherwise.
	DropInstanceID *string `json:"dropInstanceID"`
	// Indicates whether or not all preconditions have been met, and the drop is available to get progress.
	HasPreconditionsMet bool `json:"hasPreconditionsMet"`
	// Whether the user has already claimed their reward for this drop.
	IsClaimed bool `json:"isClaimed"`
}

// Single item of stats for the time series.
type TimeseriesItem struct {
	// Deprecated: Number of follows during this timestamp.
	Follows *int `json:"follows"`
	// Streamed duration (in minutes).
	MinutesStreamed int `json:"minutesStreamed"`
	// Timestamp of the broken down time series.
	Timestamp time.Time `json:"timestamp"`
	// Value at the timestamp.
	Value float64 `json:"value"`
}

// Stats within a time frame broken down by granularity.
// This is used for per channel stats, per team stats use "CreatorTimeseriesMetrics".
type TimeseriesStats struct {
	// Seconds of ads played per time chunk.
	AdBreaksInSeconds []*TimeseriesItem `json:"adBreaksInSeconds"`
	// Ad time (in seconds) per hour per time chunk.
	AdTimePerHour []*TimeseriesItem `json:"adTimePerHour"`
	// Average number of viewers per time chunk.
	AverageViewers []*TimeseriesItem `json:"averageViewers"`
	// Number of chat messages per time chunk.
	ChatMessages []*TimeseriesItem `json:"chatMessages"`
	// Number of clip views per time chunk.
	ClipViews []*TimeseriesItem `json:"clipViews"`
	// Number of clips created per time chunk.
	ClipsCreated []*TimeseriesItem `json:"clipsCreated"`
	// Number of follows during this timestamp.
	Follows []*TimeseriesItem `json:"follows"`
	// Granularity of the time series, default unit is five minutes.
	Granularity Granularity `json:"granularity"`
	// Host/Raid viewers per time chunk.
	HostRaidViewers []*TimeseriesItem `json:"hostRaidViewers"`
	// Deprecated: List of the number of follows within a time period, broken up by granularity.
	Items []*TimeseriesItem `json:"items"`
	// Live number of views per time chunk.
	LiveViews []*TimeseriesItem `json:"liveViews"`
	// Max viewers per time chunk.
	MaxViewers []*TimeseriesItem `json:"maxViewers"`
	// Minutes watched per time chunk.
	MinutesWatched []*TimeseriesItem `json:"minutesWatched"`
	// Number of subscriptions per time chunk.
	NewSubscriptions []*TimeseriesItem `json:"newSubscriptions"`
	// Number of new viewers per time chunk.
	NewViewerPercentage []*TimeseriesItem `json:"newViewerPercentage"`
	// Promotion clicks for the time period.
	PromotionClick []*TimeseriesItem `json:"promotionClick"`
	// Promotion displays for the time period.
	PromotionDisplay []*TimeseriesItem `json:"promotionDisplay"`
	// Time streamed per time chunk.
	TimeStreamed []*TimeseriesItem `json:"timeStreamed"`
	// Number of people chatting per time chunk.
	UniqueChatters []*TimeseriesItem `json:"uniqueChatters"`
	// Number of unique people watching per time chunk.
	UniqueViewers []*TimeseriesItem `json:"uniqueViewers"`
}

// A piece of the shelf title in the form of a token.
type TitleTokenEdge struct {
	// The token.
	Node TitleTokenNode `json:"node"`
}

type ToggleRitualsEnabledInput struct {
	ChannelID string `json:"channelID"`
	IsEnabled bool   `json:"isEnabled"`
}

type ToggleRitualsEnabledPayload struct {
	// Whether the rituals feature is enabled for a channel.
	IsEnabled bool  `json:"isEnabled"`
	User      *User `json:"user"`
}

// Assets for a TokenBundleProduct.
// Each asset will have a 1x, 2x, 3x sizing w/ their respective URLs.
// Different sizing is required for mobile clients.
type TokenBundleAsset struct {
	// URL of asset of size 1x.
	ImageURL1x string `json:"imageURL1x"`
	// URL of asset size 2x.
	ImageURL2x string `json:"imageURL2x"`
	// URL of asset size 3x.
	ImageURL3x string `json:"imageURL3x"`
	// Key identifier for an asset.
	// ex) "bundleImg", "promoImg", etc.
	Key string `json:"key"`
}

// Tournament is an object that contains all information about a tournament
// managed within Bits for a specific event tied to cheering.
// NOTE: Should have been named CheeringTournament.
type Tournament struct {
	// Leaderboard of all users who have cheered in the tournament.
	GlobalLeaderboard *BitsLeaderboard `json:"globalLeaderboard"`
	// Event ID of the tournament.
	ID string `json:"id"`
	// The list of global milestones that can be claimed in the tournament.
	// For a given threshold, this milestone is reached when cheers from all users on the channel
	// is greater than or equal to the threshold. This unlocks a reward for all users who have cheered.
	Progress *TournamentProgress `json:"progress"`
	// The list of rewards that are a part of the tournament. This is separated out into global, participant, and individual
	// rewards that can be claimed if the user is logged in.
	Rewards *TournamentRewards `json:"rewards"`
	// The list of individual milestones that can be claimed in the tournament.
	// for a given threshold, this milestone is reached when an individual user's total cheers in
	// the channel is greater than or equal to the threshold. This unlocks a reward
	// for the individual user who cheered.
	Self *TournamentSelfEdge `json:"self"`
	// Leaderboard of all teams who have been cheered for in the tournament. This leaderboard contains how much each team
	// in the tournament was cheered for.
	TeamLeaderboard *BitsLeaderboard `json:"teamLeaderboard"`
	// The list of teams participating in the tournament.
	Teams []*TournamentTeam `json:"teams"`
}

// Contains all rewards information about the Insider rewards.
type TournamentInsiderRewards struct {
	// Twitch chat badge rewards.
	Badges []*TournamentReward `json:"badges"`
	// Bits rewards.
	Bits []*TournamentReward `json:"bits"`
	// Hero skin rewards.
	HeroSkins []*TournamentReward `json:"heroSkins"`
	// In Game Content rewards, like sprays and avatars (non-hero skin rewards).
	InGameContent []*TournamentReward `json:"inGameContent"`
}

// Describes the amount of progress that has been made in a tournament, with corresponding milestones about said progress.
type TournamentProgress struct {
	// The amount of progress that has been made in the tournament. This is not exclusive to cheering in the channel.
	Amount int `json:"amount"`
	// The milestones associated with the progress made. This is a list of rewards the progress value will unlock.
	Milestones []*Milestone `json:"milestones"`
}

// Type containing information about a Reward and claiming information.
type TournamentReward struct {
	// The campaign ID associated with the reward.
	CampaignID string `json:"campaignID"`
	// Can this reward be entitled to the user.
	CanBeFulfilled bool `json:"canBeFulfilled"`
	// Number representing quantity of the reward that user can claim (but not entitled yet) at the time the request is made.
	CanBeFulfilledQuantity int `json:"canBeFulfilledQuantity"`
	// The reward's description.
	Description string `json:"description"`
	// Number representing quantity of the reward that user already claimed and can find in his inventory. If the type is In Game Content, Twitch already handed off to the game through the fulfiller.
	EntitledQuantity int `json:"entitledQuantity"`
	// The ID of the reward.
	ID string `json:"id"`
	// The reward's display image URL.
	ImageURL string `json:"imageURL"`
	// The state of the reward is entitled to the user.
	IsEntitled bool `json:"isEntitled"`
	// Whether the reward is for prime users only.
	IsPrimeOnly bool `json:"isPrimeOnly"`
	// Whether the reward can be earned multiple times (e.g. in game consumables).
	IsRepeatable bool `json:"isRepeatable"`
	// Metadata attached to the reward.
	Metadata *CampaignRewardMetadata `json:"metadata"`
	// The display name of the reward.
	Name string `json:"name"`
	// Amount of reward (e.g. amount for bits).
	Quantity int `json:"quantity"`
	// A number presenting the rarity of this reward (the higher the rarer).
	Rarity int `json:"rarity"`
	// The type of reward (ex. Twitch Emote, In Game Content).
	Type string `json:"type"`
}

// This type holds all information about rewards that are associated with a tournament. The struct parses out
// which rewards are Global, Team, and Individual, as well as if you're logged in that status if you can claim the reward.
type TournamentRewards struct {
	// The list of Cheerbomb rewards. If the user is logged in, this will also show the claim status of the reward.
	Cheerbomb []*TournamentReward `json:"cheerbomb"`
	// The list of Global rewards. If the user is logged in, this will also show the claim status of the reward.
	Global []*TournamentReward `json:"global"`
	// The list of Individual rewards. If the user is logged in, this will also show the claim status of the reward.
	Individual []*TournamentReward `json:"individual"`
	// The list of Insider rewards, which are granted when one subscribes to the insider pass.
	Insider *TournamentInsiderRewards `json:"insider"`
	// The list of Team rewards. If the user is logged in, this will also show the claim status of the reward.
	Team []*TournamentReward `json:"team"`
}

// Tournament progress related to a user.
type TournamentSelfEdge struct {
	// The leaderboard entry of the user. Gives the current position and score.
	GlobalLeaderboardItem *BitsLeaderboardItem `json:"globalLeaderboardItem"`
	// Amount of progress a user had made towards the tournament personally. This could be a combination of factors,
	// including bits cheered in the channel.
	Progress *TournamentProgress `json:"progress"`
	// A list of the amount of bits a user has cheered for a certain team, as well as the
	// list of milestones that the user could claim with their claim status.
	Teams []*TournamentTeam `json:"teams"`
}

// Team is a construct that contains metadata about a team participating in the tournament,
// as well as the milestones associated with cheering for them.
type TournamentTeam struct {
	// The division of the team. This string is set by the tournament organizer. (NA, CN, Atlantic League, etc.).
	Division string `json:"division"`
	// The ID of the team.
	ID string `json:"id"`
	// The image URL of the team.
	LogoURL string `json:"logoURL"`
	// Name of the team.
	Name string `json:"name"`
}

// Information used to track recommendation events.
type TrackingInfo struct {
	// The target object for the shelf, if it exists.
	ReasonTarget *string `json:"reasonTarget"`
	// The type of the target object, if it exists.
	ReasonTargetType *string `json:"reasonTargetType"`
	// The reason why this shelf has been recommended.
	ReasonType string `json:"reasonType"`
	// The name of the shelf.
	RowName string `json:"rowName"`
}

// A tracking pixel is used to measure impressions or demographics.
type TrackingPixel struct {
	// Where this pixel came from.
	Origin *string `json:"origin"`
	// What service will be using the pixel.
	Service string `json:"service"`
	// How long a client needs to view the content before firing the pixel.
	TimeOffsetSeconds *int `json:"timeOffsetSeconds"`
	// The type of tracker.
	Type *TrackingPixelType `json:"type"`
	// The URL that is requested when the pixel is fired.
	URL string `json:"url"`
}

// The tracking pixel that will be created as part of this campaign.
type TrackingPixelInput struct {
	// How long a client needs to view the content before firing the pixel.
	TimeOffsetSeconds *int `json:"timeOffsetSeconds"`
	// The type of tracker.
	Type *TrackingPixelType `json:"type"`
	// The URL that is requested when the pixel is fired.
	URL string `json:"url"`
}

// A trailer is a video meant to introduce viewers to the creator and the type
// of content they produce.
type Trailer struct {
	// The trailer video. This may be null if the channel has no trailer.
	Video *Video `json:"video"`
}

// TranscodeSession is session metadata related to transcode.
type TranscodeSession struct {
	// Transcoded audio codecs.
	AudioCodecs string `json:"audioCodecs"`
	// Staff-only field. Hostname of which transcode was processed.
	Host *string `json:"host"`
	// Staff-only field. The location of transcode origin.
	IngestOrigin *string `json:"ingestOrigin"`
	// Staff-only field. Profile of transcode.
	Profile *string `json:"profile"`
	// Transcoded video codecs.
	VideoCodecs string `json:"videoCodecs"`
}

// TransitionExtesnsionManifest updates the state of an existing extension.
type TransitionExtensionStateInput struct {
	// The extension ID of the extension to update.
	ID string `json:"id"`
	// Notes provided to the moderation team while reviewing the extension.
	// Required when transitioning to READY_FOR_REVIEW.
	ReviewNotes *string `json:"reviewNotes"`
	// The State to transition the extension to.
	State ExtensionState `json:"state"`
	// URL to a test channel, provided to the moderation team while reviewing the extension.
	// Required when transitioning to READY_FOR_REVIEW.
	TestChannel *string `json:"testChannel"`
	// The extension version to update.
	Version string `json:"version"`
}

// TransitionExtensionStatePayload returns any errors that occur during update.
type TransitionExtensionStatePayload struct {
	// The error when the mutation fails to update an extension.
	Error *TransitionExtensionStateError `json:"error"`
	// The updated extension manifest.
	Manifest *ExtensionManifest `json:"manifest"`
}

// A result of a try to trigger a drop on a channel.
type TriggerResult struct {
	// The channel the drop was tried to be triggered on.
	Channel *Channel `json:"channel"`
	// The drop instance id in case the drop was successfully triggered.
	DropInstanceID *string `json:"dropInstanceID"`
	// The status result of the try to trigger the drop.
	Status ManuallyTriggerDropResultStatus `json:"status"`
}

// TrueXAd is descriptive information about an engagement that was show for bits.
// Used as input on the redeem trueXAd mutation.
type TrueXAd struct {
	// campaignID is the ID of the campaign this ad belongs to.
	CampaignID string `json:"campaignID"`
	// creativeID is the ID of the particular ad experience displayed to the user.
	CreativeID string `json:"creativeID"`
	// currencyAmount is the suggested amount of "currency" to provide to the user based on this ad.
	CurrencyAmount string `json:"currencyAmount"`
	// name is the name of the ad campaign.
	Name string `json:"name"`
}

// Used to provide info on the subscription events that might have happened in another device
// and not acknowledged in the current device.
type UnacknowledgedSubscriptionEvent struct {
	// The user of the channel the subscription was for.
	Channel *User `json:"channel"`
	// The time that the subscription benefits will expire.
	EndDate *time.Time `json:"endDate"`
	// The external product id.
	ExternalProductID string `json:"externalProductID"`
	// The current status of the subscription. One of "active", "will_not_renew", or "canceled".
	Status UnacknowledgedSubscriptionEventState `json:"status"`
	// The UUID of the subscription.
	SubscriptionID string `json:"subscriptionID"`
}

// A request from a channel-banned user to the channel moderators to be unbanned
// from the channel.
type UnbanRequest struct {
	// The channel on which the banned user is appealing a ban.
	Channel *Channel `json:"channel"`
	// The time at which the unban request was created.
	CreatedAt time.Time `json:"createdAt"`
	// UUID of the Unban Request.
	ID string `json:"id"`
	// The banned user appealing the ban.
	Requester *User `json:"requester"`
	// Custom message provided by the requester.
	RequesterMessage *string `json:"requesterMessage"`
	// The time at which the unban request was resolved (approved or denied).
	ResolvedAt *time.Time `json:"resolvedAt"`
	// The moderator that has taken action on the user.
	ResolvedBy *User `json:"resolvedBy"`
	// Custom message provided by the resolver.
	ResolverMessage *string `json:"resolverMessage"`
	// The status of the unban request.
	Status UnbanRequestStatus `json:"status"`
}

// Paginated list of Unban Requests.
type UnbanRequestConnection struct {
	// The elements of the list.
	Edges []*UnbanRequestEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Element in a list of Unban Requests.
type UnbanRequestEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// The unban request.
	Node *UnbanRequest `json:"node"`
}

// Error returned from an update mutation.
type UnbanRequestError struct {
	// The error code returned from an update mutation.
	Code UnbanRequestErrorCode `json:"code"`
}

// Optional filters that can be applied to an unban requests query.
type UnbanRequestsOptions struct {
	// The order of the results, either oldest first or newest first.
	Order *UnbanRequestsSortOrder `json:"order"`
	// Filter results to only requests of this status.
	Status *UnbanRequestStatus `json:"status"`
	// Filter results to only requests from this user.
	UserID *string `json:"userID"`
}

// Set of preferences set by the channel owner regarding unban requests.
type UnbanRequestsSettings struct {
	// The number of minutes after being banned before users can request an unban.
	CooldownMinutes int `json:"cooldownMinutes"`
	// Whether users can create requests on the channel or not.
	IsEnabled bool `json:"isEnabled"`
}

type UnbanUserFromChatRoomError struct {
	Code UnbanUserFromChatRoomErrorCode `json:"code"`
}

type UnbanUserFromChatRoomInput struct {
	BannedUserLogin string `json:"bannedUserLogin"`
	ChannelID       string `json:"channelID"`
}

type UnbanUserFromChatRoomPayload struct {
	// The new ban status of this user regarding the specified channel.
	Ban *ChatRoomBanStatus `json:"ban"`
	// Mutation error caused by the user input.
	Error *UnbanUserFromChatRoomError `json:"error"`
}

type UnblockUserInput struct {
	// ID of user to unblock.
	TargetUserID string `json:"targetUserID"`
}

type UnblockUserPayload struct {
	// User that was unblocked.
	TargetUser *User `json:"targetUser"`
}

// Data required to undo recommendation feedback.
type UndoRecommendationFeedbackInput struct {
	// The id of the feedback.
	FeedbackID string `json:"feedbackID"`
	// The page this event was fired from.
	SourceItemPage string `json:"sourceItemPage"`
	// The unique id given to this request.
	SourceItemRequestID string `json:"sourceItemRequestID"`
	// The unique tracking id of the shelf / shelf card.
	SourceItemTrackingID string `json:"sourceItemTrackingID"`
}

// Returns the created feedback item back to the client.
type UndoRecommendationFeedbackPayload struct {
	// The id of the feedback you just undid.
	FeedbackID string `json:"feedbackID"`
}

// UnfollowGameInput contains just the game ID of the game to unfollow.
type UnfollowGameInput struct {
	GameID string `json:"gameID"`
}

// UnfollowGamePayload is the response from unfollowing a game.
type UnfollowGamePayload struct {
	// The deleted follow relationship, if one existed beforehand.
	Follow *GameFollow `json:"follow"`
	// The game that was unfollowed
	// game.self.follow should now be null.
	Game *Game `json:"game"`
}

type UnfollowUserInput struct {
	TargetID string `json:"targetID"`
}

type UnfollowUserPayload struct {
	// The deleted follow relationship.
	Follow *Follow `json:"follow"`
}

type UnfriendUserInput struct {
	// The authenticated user will no longer be friends with the user whose ID is equal to targetID.
	TargetID string `json:"targetID"`
}

type UnfriendUserPayload struct {
	// The user whose friend relationship was just destroyed by the authenticated user.
	User *User `json:"user"`
}

// UnhostInput contains the necessary inputs to unhost a channel.
type UnhostInput struct {
	// Channel ID to unhost from.
	ChannelID string `json:"channelID"`
}

// UnhostPayload is the response after attempting to unhost.
type UnhostPayload struct {
	// The channel that just unhosted.
	Channel *User `json:"channel"`
}

// UninstallExtensionError is wrapper for error associated with the uninstallExtension mutation.
type UninstallExtensionError struct {
	// Error code.
	Code UninstallExtensionErrorCode `json:"code"`
}

// The required input for an uninstallExtension mutation.
type UninstallExtensionInput struct {
	// The composite ID of an extension installation <extensionID:version:channelID>.
	ExtensionInstallationID string `json:"extensionInstallationID"`
}

// The resulting payload of an uninstallExtension mutation.
type UninstallExtensionPayload struct {
	// The error when the mutation fails to set feature flags.
	Error *UninstallExtensionError `json:"error"`
	// The id of the extension which was uninstalled.
	ID string `json:"id"`
}

// UnlinkAmazonConnectionInput represent the parameters necessary to unlink an amazon connection.
type UnlinkAmazonConnectionInput struct {
	// Id of the user that wishes to unlink his amazon connection.
	UserID *string `json:"userID"`
}

// UnlinkAmazonConnectionPayload indicates whether the unlinking was successful or not.
type UnlinkAmazonConnectionPayload struct {
	// Whether or not the unlink operation was successful. Only reports if the underlying call was successful, as such will return true even if no unlinking occured (such as when as user doesn't have a linked amazon account, for instance).
	IsSuccess *bool `json:"isSuccess"`
}

// User ID input of the connection being deleted.
type UnlinkRiotConnectionInput struct {
	// Twitch User ID to delete.
	UserID string `json:"userID"`
}

// Contains a struct of all current accounts connections.
type UnlinkRiotConnectionPayload struct {
	// The complete account connections list where Riot will be null.
	Connections *AccountConnectionSet `json:"connections"`
}

type UnlinkSSOInput struct {
	// The single sign-on (SSO) app that should be unlinked from the authenticated user's account.
	App string `json:"app"`
	// The token that identifies the user on the linked SSO app.
	Token *string `json:"token"`
}

type UnlinkSSOPayload struct {
	// The deleted SSO links.
	Links []*SSOLink `json:"links"`
}

// Input for unlocking a chosen modified subscriber emote with Community Points.
type UnlockChosenModifiedSubscriberEmoteInput struct {
	// The channel the emote is being redeemed on.
	ChannelID string `json:"channelID"`
	// The client's perception of the reward's cost.
	Cost int `json:"cost"`
	// The modified emote to unlock.
	EmoteID string `json:"emoteID"`
	// Client-set identifier for the transaction. This ID should be universally unique.
	TransactionID string `json:"transactionID"`
}

// The response from redeeming the unlock a chosen modified subscriber emote reward.
type UnlockChosenModifiedSubscriberEmotePayload struct {
	// The user's new Community Points balance.
	Balance *int `json:"balance"`
	// The error that occurred during redemption, if any.
	Error *CommunityPointsUnlockEmoteError `json:"error"`
}

// Input for unlocking a chosen subscriber emote with Community Points.
type UnlockChosenSubscriberEmoteInput struct {
	// The channel the emote is being redeemed on.
	ChannelID string `json:"channelID"`
	// The client's perception of the reward's cost.
	Cost int `json:"cost"`
	// The emote to unlock.
	EmoteID string `json:"emoteID"`
	// Client-set identifier for the transaction. This ID should be universally unique.
	TransactionID string `json:"transactionID"`
}

// The response from redeeming the unlock a chosen subscriber emote reward.
type UnlockChosenSubscriberEmotePayload struct {
	// The user's new Community Points balance.
	Balance *int `json:"balance"`
	// The error that occurred during redemption, if any.
	Error *CommunityPointsUnlockEmoteError `json:"error"`
}

// Input for unlocking a random subscriber emote with Community Points.
type UnlockRandomSubscriberEmoteInput struct {
	// The channel the emote is being redeemed on.
	ChannelID string `json:"channelID"`
	// The client's perception of the reward's cost.
	Cost int `json:"cost"`
	// Client-set identifier for the transaction. This ID should be universally unique.
	TransactionID string `json:"transactionID"`
}

// The response from redeeming the unlock a random subscriber emote reward.
type UnlockRandomSubscriberEmotePayload struct {
	// The user's new Community Points balance.
	Balance *int `json:"balance"`
	// The random emote that was unlocked.
	Emote *CommunityPointsEmote `json:"emote"`
	// The error that occurred during redemption, if any.
	Error *CommunityPointsUnlockEmoteError `json:"error"`
}

// ModUserError contains details about a client error that occurred.
type UnmodUserError struct {
	// The enum indicating what error has occurred.
	Code UnmodUserErrorCode `json:"code"`
}

// UnmodUserInput contains the parameters to remove a user as a moderator to a channel.
type UnmodUserInput struct {
	// The channel that the user will be removed as a moderator to.
	ChannelID string `json:"channelID"`
	// The ID of the user that will be removed as a moderator.
	// Either targetID or targetLogin must be provided.
	TargetID *string `json:"targetID"`
	// The login of the user that will be removed as a moderator.
	// Either targetID or targetLogin must be provided.
	TargetLogin *string `json:"targetLogin"`
}

// UnmodUserPayload is the response when remove a user as a moderator.
type UnmodUserPayload struct {
	// The channel that the user is removed as a moderator to.
	Channel *User `json:"channel"`
	// The client error that has occurred.
	// Null if the operation is successful.
	Error *UnmodUserError `json:"error"`
	// The user that is removed as a moderator.
	Target *User `json:"target"`
}

// UnsetHypeTrainConfigInput takes series of optional config settings and unsets the custom value for the default..
type UnsetHypeTrainConfigInput struct {
	// Custom emote to be rendered in Hype Train messaging.
	CalloutEmote *bool `json:"calloutEmote"`
	// Length of the cooldown period after a hype train ends.
	CooldownPeriodMinutes *bool `json:"cooldownPeriodMinutes"`
	// The difficulty of hype train levels.
	Difficulty *bool `json:"difficulty"`
	// Hype Train kickoff settings.
	EventsThreshold *bool `json:"eventsThreshold"`
	// Whether hype train should be enabled.
	IsEnabled *bool `json:"isEnabled"`
	// A boolean flag that indicates if the hype train settings should be personalized by Twitch.
	ShouldUsePersonalizedSettings *bool `json:"shouldUsePersonalizedSettings"`
	// Use creator color as base color of the Hype Train progress bar.
	WillUseCreatorColor *bool `json:"willUseCreatorColor"`
}

// UnsetHypeTrainConfigPayload is the response that contains the Unsetd config.
type UnsetHypeTrainConfigPayload struct {
	// The hype train config for the channel.
	Config *HypeTrainConfig `json:"config"`
}

// Input to the unsubscribe mutation. One of "channel" or "type" fields must be provided.
type UnsubscribeEmailInput struct {
	// The unique ID of the origin email.
	SourceEmailID string `json:"sourceEmailID"`
	// The email type of the origin email.
	SourceEmailType string `json:"sourceEmailType"`
	// ID of the channel whose notifications should be blocked.
	TargetChannelID *string `json:"targetChannelID"`
	// The email type from which the user is unsubscribing.
	TargetEmailType *string `json:"targetEmailType"`
	// ID of the user requesting the unsubscribe action.
	UserID string `json:"userID"`
	// Server signature to verify authenticity of the link author.
	ValidatingHash string `json:"validatingHash"`
}

// Output from the unsubscribe mutation.
type UnsubscribeEmailPayload struct {
	// Specifies whether the action was successful.
	IsSuccess bool `json:"isSuccess"`
}

// Inputs to the updateAdProperties mutation.
type UpdateAdPropertiesInput struct {
	// Toggle for disable prerolls for midrolls feature.
	HasDisablePrerollsAbilityEnabled *bool `json:"hasDisablePrerollsAbilityEnabled"`
	// Toggle for disable prerolls for midrolls notifcations.
	// The "Disable Prerolls" product is a way for streamers to disable preroll ads by running midroll ads.
	// The streamer can choose to enable notifications (ie. "Preroll Ads are now disabled for X minutes") for this product.
	HasDisablePrerollsNotificationsEnabled *bool `json:"hasDisablePrerollsNotificationsEnabled"`
	// Toggle for enable multiplayer ads for subs.
	IsMultiplayerAdsForSubsEnabled *bool `json:"isMultiplayerAdsForSubsEnabled"`
	// User the update belongs to.
	TargetUserID string `json:"targetUserID"`
}

// Output from the updateAdProperties mutation.
type UpdateAdPropertiesPayload struct {
	// User/channel to update the ad settings.
	TargetUser *User `json:"targetUser"`
}

type UpdateAllWhisperThreadsInput struct {
	MarkAllAsRead *bool `json:"markAllAsRead"`
}

type UpdateAllWhisperThreadsPayload struct {
	Count int `json:"count"`
}

type UpdateAutoModPropertiesInput struct {
	// These fields should be values between 0 and 4 inclusive.
	AggressiveLevel int `json:"aggressiveLevel"`
	// String ID of the channel AutoModProperties are being updated for.
	ChannelID      string `json:"channelID"`
	IdentityLevel  int    `json:"identityLevel"`
	ProfanityLevel int    `json:"profanityLevel"`
	SexualLevel    int    `json:"sexualLevel"`
}

type UpdateAutoModPropertiesPayload struct {
	// The new properties after applying the mutation.
	AutoModProperties *AutoModProperties `json:"autoModProperties"`
}

// UpdateAutohostSettingsInput update a user's autohost settings.
type UpdateAutohostSettingsInput struct {
	// True if this channel has the autohost feature turned on.
	IsEnabled *bool `json:"isEnabled"`
	// The strategy to use when choosing channels to autohost.
	Strategy *AutohostSettingsStrategy `json:"strategy"`
	// UserID to update settings for.
	UserID string `json:"userID"`
	// True if this user autohosts their team members.
	WillAutohostTeam *bool `json:"willAutohostTeam"`
	// True if this channels prefers autohost over vodcast.
	WillPrioritizeAutohost *bool `json:"willPrioritizeAutohost"`
}

// UpdateAutohostSettingsPayload returns the user whose settings had been updated.
type UpdateAutohostSettingsPayload struct {
	// User whose autohost settings has been updated.
	User *User `json:"user"`
}

// UpdateBitsBadgeTierNotificationInput is the input required when updating a bits badge tier notification.
type UpdateBitsBadgeTierNotificationInput struct {
	// Optional message to send when sharing notification. If supplied, will accompany user notice.
	Message *string `json:"message"`
	// Unique Identifier for the notification.
	NotificationID string `json:"notificationID"`
	// New state for notification.
	NotificationState BitsBadgeTierNotificationState `json:"notificationState"`
}

// UpdateBitsBadgeTierNotificationPayload is the payload returned after updating a bits badge tier notification.
type UpdateBitsBadgeTierNotificationPayload struct {
	// The user that updated the bits badge tier notification.
	User *User `json:"user"`
}

// Errors for updating bits badges.
type UpdateBitsBadgeTiersError struct {
	// The associated error code.
	Code UpdateBitsBadgeTiersErrorCode `json:"code"`
}

// Settings related to bits badges.
type UpdateBitsBadgeTiersInput struct {
	// A list of bits badge tiers to be modified.
	Tiers []*BitsBadgeTierInput `json:"tiers"`
	// The owner ID of the channel that the badge tiers belong to.
	UserID string `json:"userID"`
}

// Results of bits badge tier updates.
type UpdateBitsBadgeTiersPayload struct {
	// Whether or not the broadcaster is enabled to upload bits badge tier emote rewards.
	CanUploadBadgeTierEmoticons *bool `json:"canUploadBadgeTierEmoticons"`
	// Service error, if any.
	Error *UpdateBitsBadgeTiersError `json:"error"`
	// Updated bits badge tiers.
	Tiers []*BitsBadgeTier `json:"tiers"`
}

// Error code for an error that occurs while updating boost settings.
type UpdateBoostSettingsError struct {
	// Error code for error that occurred while updating boost settings.
	Code UpdateBoostSettingsErrorCode `json:"code"`
}

// The required input for a updateBoostSettings mutation.
type UpdateBoostSettingsInput struct {
	// The Id of the channel where we want to update the boost enable/disable settings.
	ChannelID string `json:"channelID"`
	// Whether the channel has enabled boost challenges.
	IsEarnedEnabled *bool `json:"isEarnedEnabled"`
	// Whether the channel has enabled boosts.
	IsEnabled *bool `json:"isEnabled"`
	// Whether the channel has enabled boosts paid for by the community.
	IsPaidEnabled *bool `json:"isPaidEnabled"`
}

// The result of an updateBoostSettings mutation.
type UpdateBoostSettingsPayload struct {
	// The updated channel.
	Channel *Channel `json:"channel"`
	// The possible error returned from the service.
	Error *UpdateBoostSettingsError `json:"error"`
}

// The required input for a updateBroadcastSettings mutation.
type UpdateBroadcastSettingsInput struct {
	// Indicate broadcaster's streaming language.
	BroadcasterLanguage *string `json:"broadcasterLanguage"`
	// The title of the game that the broadcaster is playing.
	Game *string `json:"game"`
	// The isMature boolean to set onto the user broadcast.
	IsMature *bool `json:"isMature"`
	// Channel's streaming Status.
	Status *string `json:"status"`
	// The Id of the user whose broadcast setting is being updated.
	UserID string `json:"userID"`
}

// The result of a updateBroadcastSettings mutation.
type UpdateBroadcastSettingsPayload struct {
	// The modified broadcast settings.
	BroadcastSettings *BroadcastSettings `json:"broadcastSettings"`
	// Error from updating broadcast settings, if any.
	Error *UpdateBroadcastSettingsErrorCode `json:"error"`
}

// Inputs for updating the user's celebration config.
type UpdateCelebrationConfigInput struct {
	// ID of channel to update the celebration config.
	ChannelID string `json:"channelID"`
	// If turn, celebrations are enabled on the channel.
	IsEnabled bool `json:"isEnabled"`
}

// Outputs from the update celebration config mutation.
type UpdateCelebrationConfigPayload struct {
	// The updated celebration config.
	CelebrationConfig *CelebrationConfig `json:"celebrationConfig"`
	// If present, there was an error with the request.
	Error *CelebrationError `json:"error"`
}

// Inputs for creating a new celebration.
type UpdateCelebrationInput struct {
	// Where on the channel page the celebration will show.
	Area *CelebrationArea `json:"area"`
	// ID of celebration to update.
	CelebrationID string `json:"celebrationID"`
	// ID of channel where the celebration to update exists.
	ChannelID string `json:"channelID"`
	// Length the celebration will play.
	DurationMilliseconds *int `json:"durationMilliseconds"`
	// Effect which will show when the celebration triggers (ex Fireworks).
	Effect *CelebrationEffect `json:"effect"`
	// Threshold which will trigger the celebration (ex: Cheering 100 Bits).
	EventThreshold *int `json:"eventThreshold"`
	// Event type which will trigger the celebration (ex: Cheering Bits).
	EventType *CelebrationEventType `json:"eventType"`
	// Intensity of the celebration.
	// Should be bounded (TBA) value which will determine the spectacle of the celebration.
	Intensity *int `json:"intensity"`
	// If true, the celebration is enabled.
	IsEnabled *bool `json:"isEnabled"`
}

// Outputs from the Update celebration mutation.
type UpdateCelebrationPayload struct {
	// The updated celebration.
	Celebration *Celebration `json:"celebration"`
	// If present, there was an error with the request.
	Error *CelebrationError `json:"error"`
}

// Inputs for updating the user's celebration product config.
type UpdateCelebrationProductConfigInput struct {
	// List of celebrations products for purchase in the channel.
	CelebrationProducts []*CelebrationProductConfigInput `json:"celebrationProducts"`
	// ID of channel to update the celebration product config.
	ChannelID string `json:"channelID"`
}

// Outputs from the updated celebration product config mutation.
type UpdateCelebrationProductConfigPayload struct {
	// The updated celebration products.
	CelebrationProducts []*CelebrationProduct `json:"celebrationProducts"`
	// If present, there was an error with the request.
	Error *CelebrationError `json:"error"`
}

// Inputs for updating the user's celebration user settings.
type UpdateCelebrationUserSettingsInput struct {
	// If true, celebrations are disabled for the user to see.
	IsOptedOut *bool `json:"isOptedOut"`
}

// Outputs from the update celebration config mutation.
type UpdateCelebrationUserSettingsPayload struct {
	// The updated logged in user.
	CurrentUser *User `json:"currentUser"`
}

// The result of a UpdateChangelogReadTimePayload mutation.
type UpdateChangelogReadTimePayload struct {
	// The user whose changelog was marked as read.
	User *User `json:"user"`
}

// Mutation input for updating chanlet content attributes.
type UpdateChanletContentAttributesInput struct {
	// Identifier of the chanlet.
	ChanletID string `json:"chanletID"`
	// A list of multi-view content attribute IDs.
	// The provided list will override the list of IDs currently stored.
	ContentAttributeIDs []string `json:"contentAttributeIDs"`
}

// Response payload.
type UpdateChanletContentAttributesPayload struct {
	// Updated chanlet.
	Chanlet *Channel `json:"chanlet"`
}

// The required input for a updateChannelClipsSetting mutation.
type UpdateChannelClipsSettingInput struct {
	// The Id of the channel where we want to update the clips enable/disable setting.
	ChannelID string `json:"channelID"`
	// If isClipsEnabled is true, allow the following roles to create Clips on the channel.
	CreationRestrictedTo *ChannelClipsCreationRestrictedToInput `json:"creationRestrictedTo"`
	// If there are clip creation restrictions, use the following to add options to those restrictions.
	CreationRestrictionOptions *ChannelClipsCreationAuthRestrictionOptionsInput `json:"creationRestrictionOptions"`
	// Set whether or not users can create Clips on this channel.
	IsClipsEnabled bool `json:"isClipsEnabled"`
}

// The result of a updateChannelClipsSetting mutation.
type UpdateChannelClipsSettingPayload struct {
	// The updated channel.
	Channel *Channel `json:"channel"`
}

// The input to update a channel's category shelf content.
type UpdateChannelHomePreferencesInput struct {
	// A list of category IDs to hide from the category shelf.
	CategoryIDsToHide []string `json:"categoryIDsToHide"`
	// A list of category IDs to unhide from the category shelf.
	CategoryIDsToUnhide []string `json:"categoryIDsToUnhide"`
	// The ID of the channel whose category shelf is being updated.
	ChannelID string `json:"channelID"`
	// The hero preset.
	HeroPreset *HeroPreset `json:"heroPreset"`
	// The type of streamer shelf to display.
	StreamerShelfType *StreamerShelfType `json:"streamerShelfType"`
}

// The result of an update to the category shelf.
type UpdateChannelHomePreferencesPayload struct {
	// The channel with the modified category shelf.
	Channel *Channel `json:"channel"`
	// The possible error returned.
	Error *UpdateChannelCategoryShelfError `json:"error"`
}

// An error returned from the updateChannelPredictionSettings mutation.
type UpdateChannelPredictionSettingsError struct {
	// Code describing the error.
	Code UpdateChannelPredictionSettingsErrorCode `json:"code"`
}

// Update a channel's Prediction Settings.
// All fields other than channelID are nullable; only specify fields that you wish to update.
type UpdateChannelPredictionSettingsInput struct {
	// Whether channel moderators are allowed to create and resolve Prediction Events.
	CanModeratorsManagePredictions *bool `json:"canModeratorsManagePredictions"`
	// The ID of the channel to update the settings of.
	ChannelID string `json:"channelID"`
}

// Payload for updating a channel's Prediction Settings.
type UpdateChannelPredictionSettingsPayload struct {
	// If present, there was an error with the request.
	Error *UpdateChannelPredictionSettingsError `json:"error"`
	// The updated settings.
	Settings *ChannelPredictionSettings `json:"settings"`
}

type UpdateChatColorInput struct {
	// Named color for normal users (e.g. "Blue"  or "Coral", see https://help.twitch.tv/customer/portal/articles/659095-twitch-chat-and-moderation-commands)
	// or a hex color for Turbo users (e.g. "#001122").
	Color string `json:"color"`
}

type UpdateChatColorPayload struct {
	// The user whose chat color was set.
	User *User `json:"user"`
}

// Possible chat settings modifiable for the channel specified via ChannelID.
//
// NOTE: Subscribers-only chat mode settings are in the UpdateSubscriptionProduct
// mutation.
type UpdateChatSettingsInput struct {
	// autoModLevel is an integer from 0-4 representing the level of automoderation of chat
	// 0 is off, 4 is the highest level of moderation.
	//
	// Deprecated: No longer used.
	AutoModLevel *int `json:"autoModLevel"`
	// ID of the channel for which chat settings are being updated.
	ChannelID string `json:"channelID"`
	// chatDelayInMs is the delay before non-mods see a message.
	ChatDelayInMs *int `json:"chatDelayInMs"`
	// followersOnlyDurationMinutes is the number of minutes a user must have
	// followed the broadcaster before being able to chat.
	FollowersOnlyDurationMinutes *int `json:"followersOnlyDurationMinutes"`
	// hideLinks indicates if links should be deleted from non-mod messages.
	HideLinks *bool `json:"hideLinks"`
	// isBroadcasterLanguageModeEnabled indicates if the broadcaster requires chat messages to
	// match their language.
	//
	// Deprecated: No longer used.
	IsBroadcasterLanguageModeEnabled *bool `json:"isBroadcasterLanguageModeEnabled"`
	// Indicates whether chat is currently enforcing that messages may only contain
	// emotes.
	IsEmoteOnlyModeEnabled *bool `json:"isEmoteOnlyModeEnabled"`
	// If isOptedOutOfGlobalBannedWordsList is true, the legacy twitch banned words list will
	// be inserted into automod if the channel has automod enabled.
	//
	// Deprecated: No longer used.
	IsOptedOutOfGlobalBannedWordsList *bool `json:"isOptedOutOfGlobalBannedWordsList"`
	// Indicates whether chat is currently enforcing that messages must be
	// reasonably unique from recent messages. Previously known as "r9k mode".
	IsUniqueChatModeEnabled *bool `json:"isUniqueChatModeEnabled"`
	// requireVerifiedAccount indicates if users must be verified to chat.
	RequireVerifiedAccount *bool `json:"requireVerifiedAccount"`
	// A list of chat rules to display to users when joining a chat channel.
	Rules []string `json:"rules"`
	// The number of seconds a user must wait in between sending chat messages
	// If value is null, slow mode is not enabled.
	SlowModeDurationSeconds *int `json:"slowModeDurationSeconds"`
}

// Result of mutation is the updated ChatSettings object.
type UpdateChatSettingsPayload struct {
	// The new chatSettings after applying the mutation.
	ChatSettings *ChatSettings `json:"chatSettings"`
}

// Partner settings related to chat badges with bits.
type UpdateCheerPartnerSettingsBadgesInput struct {
	// A list of tiers to modify.
	Tiers []*BitsBadgeTierInput `json:"tiers"`
}

// Partner settings related to chat messages with bits.
type UpdateCheerPartnerSettingsChatMessageInput struct {
	// The setting that controls if the user has project v enabled on their channel.
	IsOptedOutOfProjectV *bool `json:"isOptedOutOfProjectV"`
	// The minimnm setting that controls the minimum bits that must be part of a cheer emote.
	MinBitsPerEmote *int `json:"minBitsPerEmote"`
	// The minimum setting that controls the minimum amount a user must cheer in the channel.
	MinBitsToCheer *int `json:"minBitsToCheer"`
}

// Settings related to bits cheer bomb events.
type UpdateCheerPartnerSettingsCheerBombInput struct {
	// Flag that is true if the user has opted out of the cheer bomb event.
	IsOptedOut *bool `json:"isOptedOut"`
}

// Partner settings related to the custom cheermote prefix.
type UpdateCheerPartnerSettingsCustomPrefixInput struct {
	// Flag that is set if the user has the custom cheermote prefix enabled.
	IsEnabled *bool `json:"isEnabled"`
}

// Mutation input for updating Bits partner channel settings.
type UpdateCheerPartnerSettingsInput struct {
	// Partner settings related to chat badges with bits.
	Badges *UpdateCheerPartnerSettingsBadgesInput `json:"badges"`
	// Partner settings related to chat messages with bits.
	ChatMessage *UpdateCheerPartnerSettingsChatMessageInput `json:"chatMessage"`
	// Partner settings related to cheer bomb events.
	CheerBombEvent *UpdateCheerPartnerSettingsCheerBombInput `json:"cheerBombEvent"`
	// Partner settings related to the custom cheermote prefix.
	CustomPrefix *UpdateCheerPartnerSettingsCustomPrefixInput `json:"customPrefix"`
	// Whether to onboard or offboard the user with bits.
	IsOnboarded *bool `json:"isOnboarded"`
	// Partner settings related to the bits leaderboard.
	Leaderboard *UpdateCheerPartnerSettingsLeaderboardInput `json:"leaderboard"`
	// Partner settings related to the recent cheer message.
	RecentCheer *UpdateCheerPartnerSettingsRecentCheerInput `json:"recentCheer"`
	// Partner settings related to sponsored cheermote campaigns.
	SponsoredCheermote *UpdateCheerPartnerSettingsSponsoredCheermoteInput `json:"sponsoredCheermote"`
	// The user ID to update channel settings.
	UserID string `json:"userID"`
}

// Partner settings related to the bits leaderboard.
type UpdateCheerPartnerSettingsLeaderboardInput struct {
	// Flag that is true if the user has bits leaderboards turned on.
	IsEnabled *bool `json:"isEnabled"`
	// The time period the user wants the leaderboard to be displayed as.
	TimePeriod *string `json:"timePeriod"`
}

// Result of mutation is the updated UserSettings object.
type UpdateCheerPartnerSettingsPayload struct {
	// The updated user settings object.
	Cheer *CheerPartnerSettings `json:"cheer"`
}

// Partner settings related to the recent cheer message.
type UpdateCheerPartnerSettingsRecentCheerInput struct {
	// Flag that when true pins the recent cheer to their channel.
	CanPin *bool `json:"canPin"`
	// The minimum bits a user must cheer to show their cheer on the chat header.
	MinimumBits *int `json:"minimumBits"`
	// The amount of time a recent cheer is shown before being dismissed.
	TimeoutMilliseconds *int `json:"timeoutMilliseconds"`
}

// Settings related to sponsored cheermote campaigns.
type UpdateCheerPartnerSettingsSponsoredCheermoteInput struct {
	// The campaign ID we are modifying for the user.
	ID string `json:"id"`
	// Flag that is true if the user has opted in of the sponsored cheermote campaign.
	IsOptedIn bool `json:"isOptedIn"`
}

// UpdateClipError is an error associated with the updateClip mutation.
type UpdateClipError struct {
	// The error when the clip fails to update a clip.
	Message *string `json:"message"`
}

// UpdateClipInput updates the title of the clip with the provided slug.
type UpdateClipInput struct {
	// The slug of the clip to update.
	Slug string `json:"slug"`
	// The new title of the clip.
	Title *string `json:"title"`
}

// UpdateClipPayload returns the updated clip.
type UpdateClipPayload struct {
	// The clip with its updated properties.
	Clip *Clip `json:"clip"`
	// The error when the clip fails to update a clip.
	Error *UpdateClipError `json:"error"`
}

// UpdateClipViewCountInput increments the viewcount of the provided slug.
type UpdateClipViewCountInput struct {
	// The slug of the clip to increment viewcount on.
	Slug string `json:"slug"`
}

// UpdateClipViewCount returns the clip that was updated.
type UpdateClipViewCountPayload struct {
	// The clip that was updated.
	// The views field is the only field that is updated, and the change is not reflected immediately.
	Clip *Clip `json:"clip"`
}

// UpdateCollectionInput accepts a collection ID and parameters to update a collection.
type UpdateCollectionInput struct {
	// The id of the collection to be updated.
	CollectionID string `json:"collectionID"`
	// The updated description of the collection.
	Description *string `json:"description"`
	// The itemID of the item whose thumbnail will be collection's thumbnail.
	ThumbnailInput *UpdateCollectionThumbnailInput `json:"thumbnailInput"`
	// The updated title of the collection.
	Title *string `json:"title"`
	// The updated type of the collection.
	Type *CollectionType `json:"type"`
}

// UpdateCollectionPayload resolves the updated collection.
type UpdateCollectionPayload struct {
	// The collection that was just updated.
	Collection *Collection `json:"collection"`
}

// UpdateCollectionThumbnailInput accepts a item ID and item Type for the new collection's thumbnail.
type UpdateCollectionThumbnailInput struct {
	// The id of the item whose thumbnail will be collection's thumbnail.
	ID string `json:"id"`
	// The type of the item whose thumbnail will be collection's thumbnail.
	Type string `json:"type"`
}

// An error from updating an automatic Community Points reward in a channel.
type UpdateCommunityPointsAutomaticRewardError struct {
	// An identifier for the error that occurred.
	Code *UpdateCommunityPointsAutomaticRewardErrorCode `json:"code"`
	// On COST_TOO_LOW, the minimum cost that can be set.
	MinimumCost *int `json:"minimumCost"`
}

// Input for updating an automatic Community Points reward in a channel.
// Only the channelID and rewardType are required. All other fields are optional.
// Only set fields that are intended to be updated.
type UpdateCommunityPointsAutomaticRewardInput struct {
	// The optional custom background color for this reward.
	// Should be a hex color string, for example "FF0000".
	BackgroundColor *string `json:"backgroundColor"`
	// The channel ID that the reward is being updated in.
	ChannelID string `json:"channelID"`
	// The point cost of this reward.
	Cost *int `json:"cost"`
	// Whether the reward is enabled.
	IsEnabled *bool `json:"isEnabled"`
	// The ID of the reward being updated.
	RewardType CommunityPointsAutomaticRewardType `json:"rewardType"`
	// A flag to reset this automatic reward's background color to default.
	ShouldResetBackgroundColor *bool `json:"shouldResetBackgroundColor"`
	// A flag to reset this automatic reward's cost to default.
	ShouldResetCost *bool `json:"shouldResetCost"`
	// A flag to reset this automatic reward's image to default.
	ShouldResetImage *bool `json:"shouldResetImage"`
}

// The response from updating an automatic Community Points reward in a channel.
type UpdateCommunityPointsAutomaticRewardPayload struct {
	// An error that occurred while updating an automatic Community Points reward in a channel.
	Error *UpdateCommunityPointsAutomaticRewardError `json:"error"`
	// The newly updated reward.
	Reward *CommunityPointsAutomaticReward `json:"reward"`
}

// An error from updating a channel's Community Points channel settings.
type UpdateCommunityPointsChannelSettingsError struct {
	// An identifier for the error that occurred.
	Code *UpdateCommunityPointsChannelSettingsErrorCode `json:"code"`
}

// Input for updating Community Points channel settings..
// Only the channelID is required. All other fields are optional.
// Only set fields that are intended to be updated.
type UpdateCommunityPointsChannelSettingsInput struct {
	// The channel ID to update the settings of.
	ChannelID string `json:"channelID"`
	// Whether the channel has community points turned on.
	IsEnabled *bool `json:"isEnabled"`
	// The channel's custom community points name.
	Name *string `json:"name"`
	// A flag to reset this channel's community points image to default.
	ShouldResetImage *bool `json:"shouldResetImage"`
	// A flag to reset this channel's community points name to default.
	ShouldResetName *bool `json:"shouldResetName"`
}

// The response from updating a channel's Community Points channel settings.
type UpdateCommunityPointsChannelSettingsPayload struct {
	// The channel with the newly updated settings.
	Channel *Channel `json:"channel"`
	// An error that occurred while updating a channel's Community Points channel settings.
	Error *UpdateCommunityPointsChannelSettingsError `json:"error"`
}

// Update community goal error.
type UpdateCommunityPointsCommunityGoalError struct {
	// The error code.
	Code UpdateCommunityPointsCommunityGoalErrorCode `json:"code"`
}

// Update community goal input.
type UpdateCommunityPointsCommunityGoalInput struct {
	// The amount of community points that this goal needs to succeed.
	AmountNeeded *int `json:"amountNeeded"`
	// The background color of this goal.
	BackgroundColor *string `json:"backgroundColor"`
	// The channel.
	ChannelID string `json:"channelID"`
	// The description of this goal.
	Description *string `json:"description"`
	// The *initial* duration the streamer set for the goal.
	// Only really used during the UNSTARTED state; once the goal is started
	// the endedAt timestamp is populated (and updated for extended deadlines).
	DurationDays *int `json:"durationDays"`
	// The time the goal is scheduled to end. Used to extend a goal.
	EndsAt *time.Time `json:"endsAt"`
	// The id of the goal.
	GoalID string `json:"goalID"`
	// Reset background color to default if true.
	ResetBackgroundColor *bool `json:"resetBackgroundColor"`
	// Reset image to default if true.
	ResetImage *bool `json:"resetImage"`
	// Reset max contribution per stream to default if true.
	ResetMaxContributionPerStream *bool `json:"resetMaxContributionPerStream"`
	// The current status of this goal.
	Status *CommunityPointsCommunityGoalStatus `json:"status"`
	// The title of this goal.
	Title *string `json:"title"`
}

// Update community goal payload.
type UpdateCommunityPointsCommunityGoalPayload struct {
	// The error, if any.
	Error *UpdateCommunityPointsCommunityGoalError `json:"error"`
	// The community goal.
	Goal *CommunityPointsCommunityGoal `json:"goal"`
}

// An error from updating a custom Community Points reward in a channel.
type UpdateCommunityPointsCustomRewardError struct {
	// An identifier for the error that occurred.
	Code UpdateCommunityPointsCustomRewardErrorCode `json:"code"`
}

// Input for updating a custom Community Points reward in a channel.
// Only the channelID and rewardID are required. All other fields are optional.
// Only set fields that are intended to be updated.
type UpdateCommunityPointsCustomRewardInput struct {
	// The optional custom background color for this reward.
	// Should be a hex color string, for example "FF0000".
	BackgroundColor *string `json:"backgroundColor"`
	// The channel ID that the reward is being updated in.
	ChannelID string `json:"channelID"`
	// The point cost of this reward.
	Cost *int `json:"cost"`
	// The length of the global cooldown applied to rewards redeemed of this type.
	GlobalCooldownSetting *CommunityPointsCustomRewardGlobalCooldownSettingInput `json:"globalCooldownSetting"`
	// Whether this reward has real world value.
	HasRealWorldValue *bool `json:"hasRealWorldValue"`
	// Whether the reward is enabled.
	IsEnabled *bool `json:"isEnabled"`
	// Whether the reward is temporarily paused.
	IsPaused *bool `json:"isPaused"`
	// Whether only subscribers are allowed to redeem this reward in this channel.
	IsSubOnly *bool `json:"isSubOnly"`
	// Whether this reward requires users to enter text input.
	IsUserInputRequired *bool `json:"isUserInputRequired"`
	// The most rewards of this type that can be redeemed per stream.
	MaxPerStreamSetting *CommunityPointsCustomRewardMaxPerStreamSettingInput `json:"maxPerStreamSetting"`
	// The most rewards of this type that can be redeemed per user per stream.
	MaxPerUserPerStreamSetting *CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput `json:"maxPerUserPerStreamSetting"`
	// The optional user-facing prompt for this reward.
	Prompt *string `json:"prompt"`
	// The ID of the reward being updated.
	RewardID string `json:"rewardID"`
	// Whether redemptions for this reward should skip the broadcaster's request queue and get
	// automatically fulfilled.
	ShouldRedemptionsSkipRequestQueue *bool `json:"shouldRedemptionsSkipRequestQueue"`
	// A flag to reset this custom reward's image to the default.
	ShouldResetImage *bool `json:"shouldResetImage"`
	// The short title displayed for this reward.
	Title *string `json:"title"`
}

// The response from updating a custom Community Points reward in a channel.
type UpdateCommunityPointsCustomRewardPayload struct {
	// An error that occurred while updating a custom Community Points reward in a channel.
	Error *UpdateCommunityPointsCustomRewardError `json:"error"`
	// The newly updated reward.
	Reward *CommunityPointsCustomReward `json:"reward"`
}

// An error from acting on a Community Points redemption.
type UpdateCommunityPointsCustomRewardRedemptionStatusError struct {
	// An identifier for the error that occurred.
	Code *UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode `json:"code"`
}

// Input for acting on a Community Points redemption.
type UpdateCommunityPointsCustomRewardRedemptionStatusInput struct {
	// The channel ID the redemption was made in.
	ChannelID string `json:"channelID"`
	// The new status to set the redemption to.
	NewStatus CommunityPointsCustomRewardRedemptionStatus `json:"newStatus"`
	// The redemption ID.
	RedemptionID string `json:"redemptionID"`
}

// The response from acting on a Community Points redemption.
type UpdateCommunityPointsCustomRewardRedemptionStatusPayload struct {
	// An error that occurred while updating the redemption status.
	Error *UpdateCommunityPointsCustomRewardRedemptionStatusError `json:"error"`
	// The updated redemption.
	Redemption *CommunityPointsCustomRewardRedemption `json:"redemption"`
}

// Input for acting on all Community Points redemptions for a channel.
type UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelInput struct {
	// The channel ID the redemptions were made in.
	ChannelID string `json:"channelID"`
	// The new status to set the redemptions to.
	NewStatus CommunityPointsCustomRewardRedemptionStatus `json:"newStatus"`
	// The old status redemptions are currently set to.
	OldStatus CommunityPointsCustomRewardRedemptionStatus `json:"oldStatus"`
}

// The response from acting on all Community Points redemptions for a channel.
// Most of the work is done as an async task and redemption status changes are pushed over pubsub.
type UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelPayload struct {
	// An error that occurred while updating the redemption statuses.
	Error *UpdateCommunityPointsCustomRewardRedemptionStatusesError `json:"error"`
}

// Input for acting on the Community Points redemptions from the provided list.
type UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsInput struct {
	// The channel ID the redemptions were made in.
	ChannelID string `json:"channelID"`
	// The new status to set the redemptions to.
	NewStatus CommunityPointsCustomRewardRedemptionStatus `json:"newStatus"`
	// The old status redemptions are currently set to.
	OldStatus CommunityPointsCustomRewardRedemptionStatus `json:"oldStatus"`
	// The redemption IDs to update.
	RedemptionIDs []string `json:"redemptionIDs"`
}

// The response from acting on the Community Points redemptions from the provided list.
// Most of the work is done as an async task and redemption status changes are pushed over pubsub.
type UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsPayload struct {
	// An error that occurred while updating the redemption statuses.
	Error *UpdateCommunityPointsCustomRewardRedemptionStatusesError `json:"error"`
}

// Input for acting on all Community Points redemptions for a reward.
type UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardInput struct {
	// The channel ID the redemptions were made in.
	ChannelID string `json:"channelID"`
	// The new status to set the redemptions to.
	NewStatus CommunityPointsCustomRewardRedemptionStatus `json:"newStatus"`
	// The old status redemptions are currently set to.
	OldStatus CommunityPointsCustomRewardRedemptionStatus `json:"oldStatus"`
	// The reward ID to update all redemptions with oldStatus for.
	RewardID string `json:"rewardID"`
}

// The response from acting on all Community Points redemptions for a reward.
// Most of the work is done as an async task and redemption status changes are pushed over pubsub.
type UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardPayload struct {
	// An error that occurred while updating the redemption statuses.
	Error *UpdateCommunityPointsCustomRewardRedemptionStatusesError `json:"error"`
}

// An error from acting on a Community Points redemption.
type UpdateCommunityPointsCustomRewardRedemptionStatusesError struct {
	// An identifier for the error that occurred.
	Code *UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode `json:"code"`
}

// An error returned when updating a user's enrollment in Community Points early access.
type UpdateCommunityPointsEarlyAccessError struct {
	// The error code identifying this error.
	Code UpdateCommunityPointsEarlyAccessErrorCode `json:"code"`
}

// Requests to change a user's enrollment status in the Community Points early access program.
type UpdateCommunityPointsEarlyAccessSettingsInput struct {
	// Sets whether the user is signing up for or removing themself from the early access program.
	IsSignedUp bool `json:"isSignedUp"`
}

// Returns updated early access status for Community Points.
type UpdateCommunityPointsEarlyAccessSettingsPayload struct {
	// The channel whose Early Access preference was updated.
	Channel *Channel `json:"channel"`
	// Optionally, an error that occurred while attempting to update the user's enrollment status.
	Error *UpdateCommunityPointsEarlyAccessError `json:"error"`
}

// An error from updating the last viewed community points content timestamps on a channel.
type UpdateCommunityPointsLastViewedContentError struct {
	// An identifier for the error that occurred.
	Code *UpdateCommunityPointsLastViewedContentErrorCode `json:"code"`
}

// Input for updating the last viewed community points content timestamps on a channel.
// The global content that was viewed on the channel will also have the timestamps updated.
type UpdateCommunityPointsLastViewedContentInput struct {
	// The channelID where the content was viewed.
	ChannelID string `json:"channelID"`
	// The content types that were viewed.
	ViewedContent []CommunityPointsContentType `json:"viewedContent"`
}

// The response from updating the last viewed community points content timestamps on a channel.
type UpdateCommunityPointsLastViewedContentPayload struct {
	// An error that occurred while updating the last viewed content timestamps.
	Error *UpdateCommunityPointsLastViewedContentError `json:"error"`
	// The updated last viewed timestamps for a channels content.
	LastViewedChannelContent []*CommunityPointsLastViewedContentByType `json:"lastViewedChannelContent"`
	// The updated last viewed timestamps for global content across all of twitch.
	LastViewedGlobalContent []*CommunityPointsLastViewedContentByTypeAndID `json:"lastViewedGlobalContent"`
}

// An error from updating a Community Points Smart Costs Acknowledgements in a channel.
type UpdateCommunityPointsSmartCostsAcknowledgementsError struct {
	// An identifier for the error that occurred.
	Code *UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode `json:"code"`
}

// Input required for updating community points smart costs acknowledgements.
type UpdateCommunityPointsSmartCostsAcknowledgementsInput struct {
	// List of acknowledgements to update.
	Acknowledgements []*SmartCostsAcknowledgementInput `json:"acknowledgements"`
	// The channel ID that the reward is being updated in.
	ChannelID string `json:"channelID"`
}

// Payload returned after updating Community Points Smart Costs Acknowledgements.
type UpdateCommunityPointsSmartCostsAcknowledgementsPayload struct {
	// List of acknowledgements for community points smart costs that were updated.
	Acknowledgements []*SmartCostsAcknowledgement `json:"acknowledgements"`
	// An error that occurred while updating a Community Points Smart Costs Acknowledgements in a channel.
	Error *UpdateCommunityPointsSmartCostsAcknowledgementsError `json:"error"`
}

// The competition contact info for updates.
type UpdateCompetitionContactInfoInput struct {
	// Link to Discord server for competition contact purposes.
	DiscordURL *string `json:"discordURL"`
	// Email address point of contact for the competition.
	Email *string `json:"email"`
}

// Update a Competition.
type UpdateCompetitionInput struct {
	// Banner image for the competition event page.
	BannerImageURL *string `json:"bannerImageURL"`
	// This is the amount of time (in minutes) available for participants to check-in once competition startAt has passed.
	CheckInDurationMinutes *int `json:"checkInDurationMinutes"`
	// Long form description of the competition.
	Description *string `json:"description"`
	// The time the competition is scheduled to end.
	EndAt *time.Time `json:"endAt"`
	// The predefined structure of phases and lobbies.
	FormatType *FormatType `json:"formatType"`
	// The game being played in the competition>.
	GameID *string `json:"gameID"`
	// ID of the Competition we want to update.
	ID string `json:"id"`
	// Primary artwork for the competition.
	ImageURL *string `json:"imageURL"`
	// Specific format restrictions for a competition.
	LeaderboardDetails *UpdateCompetitionLeaderboardDetailsInput `json:"leaderboardDetails"`
	// The name of the competition.
	Name *string `json:"name"`
	// The participant-facing points of contact for the competition that only registered participants can see.
	ParticipantOnlyContactInfo *UpdateCompetitionContactInfoInput `json:"participantOnlyContactInfo"`
	// Long form text block description that explains the prizing for the competition and will be converted to Markdown client-side.
	PrizeDescription *string `json:"prizeDescription"`
	// The public points of contact for the competition that anyone can see.
	PublicContactInfo *UpdateCompetitionContactInfoInput `json:"publicContactInfo"`
	// The time the competition is scheduled to end registration.
	RegistrationEndAt *time.Time `json:"registrationEndAt"`
	// The maximum number of players in a REGISTERED state.
	RegistrationLimit *int `json:"registrationLimit"`
	// Long form text block description that explains the rules for the competition and will be converted to Markdown client-side.
	RulesDescription *string `json:"rulesDescription"`
	// The time the competition is scheduled to start.
	StartAt *time.Time `json:"startAt"`
	// The state of the tournament.
	State *CompetitionState `json:"state"`
	// The size of a team when ParticipantType is Team.
	TeamSize *int `json:"teamSize"`
	// Link URL to any additional terms and conditions.
	TermsURL *string `json:"termsURL"`
}

// Editable fields for Leaderboard competition details.
type UpdateCompetitionLeaderboardDetailsInput struct {
	// The max participant count for a lobby in phase.
	LobbyMaxSize *int `json:"lobbyMaxSize"`
	// The number of phases a competition should have.
	PhaseCount *int `json:"phaseCount"`
	// The way points are assigned to a participant in case of a tie.
	TiebreakerLabel *TiebreakerLabel `json:"tiebreakerLabel"`
}

// Data that was mutated after the competition was updated.
type UpdateCompetitionPayload struct {
	// The competition which was updated.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// Update the state of a player in a Competition.
type UpdateCompetitionPlayerInput struct {
	// Unique Competition ID.
	CompetitionID string `json:"competitionID"`
	// The discord username for the player.
	DiscordUsername *string `json:"discordUsername"`
	// The in game username for the player.
	InGameUsername *string `json:"inGameUsername"`
	// Indicates whether the player is disqualified.
	IsDisqualified *bool `json:"isDisqualified"`
	// The state a player has in the competition we want to change.
	State *CompetitionPlayerState `json:"state"`
	// Twitch user id of the player.
	UserID string `json:"userID"`
}

// Data that was mutated after the player was updated.
type UpdateCompetitionPlayerPayload struct {
	// The new state of competition after updating a competition player in the competition.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// Update a team in a Competition.
type UpdateCompetitionTeamInput struct {
	// Twitch user id of the participant to make into the TeamCaptain.
	CaptainID *string `json:"captainID"`
	// Unique Competition ID.
	CompetitionID string `json:"competitionID"`
	// Indicates whether the team is disqualified.
	IsDisqualified *bool `json:"isDisqualified"`
	// The user ids of the team members.
	Members []string `json:"members"`
	// Unique Team ID for the specified Competition.
	TeamID string `json:"teamID"`
	// The new name of the team.
	TeamName *string `json:"teamName"`
}

// Data that was mutated after the CompetitionTeam was updated.
type UpdateCompetitionTeamPayload struct {
	// The competition that was updated.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// Error associated with mutation UpdateConsent.
type UpdateConsentError struct {
	// Error code.
	Code *UpdateConsentErrorCode `json:"code"`
}

// UpdateConsentInput updates or creates a consent status for a privacy law.
type UpdateConsentInput struct {
	// Consent Session ID.
	ConsentSessionID string `json:"consentSessionID"`
	// Privacy rule set of applicable law, e.g. CCPA or GDPR.
	PrivacyLawName PrivacyLawName `json:"privacyLawName"`
	// Consent status for each vendor.
	VendorStatus []*VendorConsentStatusInput `json:"vendorStatus"`
}

// UpdateConsentPayload returns the created or updated consent status.
type UpdateConsentPayload struct {
	// The full consent status given by the user after the create request.
	Consent *Consent `json:"consent"`
	// The possible error returned from service.
	Error *UpdateConsentError `json:"error"`
}

// Update tags associated with CLIP, STREAM, or VOD with contentID.
type UpdateContentTagsInput struct {
	// List of tag IDs to be added from the content.
	AddedTagIDs []string `json:"addedTagIDs"`
	// ID of the channel owning the content.
	AuthorID string `json:"authorID"`
	// ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs.
	ContentID string `json:"contentID"`
	// Type of content being returned. Can only be of values CLIP, STREAM, or VOD.
	ContentType ContentType `json:"contentType"`
	// List of tag IDs to be removed from the content.
	RemovedTagIDs []string `json:"removedTagIDs"`
}

// Result of mutation is the contentID.
type UpdateContentTagsPayload struct {
	// Content which tags have been updated.
	Content TaggedContent `json:"content"`
}

// UpdateDropBenefitInput has fields required to update a drop benefit.
type UpdateDropBenefitInput struct {
	// The redirect URL where a user can link their account.
	AccountLinkURL string `json:"accountLinkURL"`
	// The ID of this benefit object.
	BenefitID string `json:"benefitID"`
	// The global limit of how often this benefit can be entitled to a user.
	EntitlementLimit int `json:"entitlementLimit"`
	// The game that awarded the Drop.
	GameID string `json:"gameID"`
	// Specifies if this reward is considered for a game that is available on iOS.
	IsIosAvailable *bool `json:"isIosAvailable"`
	// The display name of this benefit object.
	Name string `json:"name"`
	// The RBAC organization ID of the owner.
	OwnerID string `json:"ownerID"`
}

// UpdateDropBenefitOnDropInput has fields required to update a drop's benefit.
type UpdateDropBenefitOnDropInput struct {
	// The benefit to add to the drop.
	BenefitID string `json:"benefitID"`
	// How many times the drop can award the benefit.
	DropEntitlementLimit int `json:"dropEntitlementLimit"`
	// The drop to add the benefit to.
	DropID string `json:"dropID"`
}

// UpdateDropBenefitOnDropPayload returns the result of the update.
type UpdateDropBenefitOnDropPayload struct {
	// Returns the updated Campaign.
	DropCampaign *DropCampaign `json:"dropCampaign"`
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// UpdateDropBenefitPayload returns the result of the update.
type UpdateDropBenefitPayload struct {
	// Returns the updated Benefit.
	DropBenefit *DropBenefit `json:"dropBenefit"`
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// UpdateDropPreconditionsInput has fields required to update multiple drops and their precondition drop.
type UpdateDropPreconditionsInput struct {
	// The campaign we want to update drops for.
	CampaignID string `json:"campaignID"`
	// A list of drops and their drop precondition.
	DropPreconditions []*DropPrecondition `json:"dropPreconditions"`
}

// UpdateDropPreconditionsPayload returns the result of the update.
type UpdateDropPreconditionsPayload struct {
	// Returns the updated Campaign.
	DropCampaign *DropCampaign `json:"dropCampaign"`
	// A mapped error returned by the drops management service.
	Error *DropsError `json:"error"`
}

// The required input for a updateDropsOptOutStatus mutation.
type UpdateDropsOptOutStatusInput struct {
	// Channel's drop opt-out Status.
	IsOptedOut bool `json:"isOptedOut"`
	// The Id of the user whose broadcast setting is being updated.
	UserID string `json:"userID"`
}

// The result of a updateDropsOptOutStatus mutation.
type UpdateDropsOptOutStatusPayload struct {
	// Status is the updated status.
	IsOptedOut *bool `json:"isOptedOut"`
	// userID is the user who wishes to opt out of drops.
	UserID *string `json:"userID"`
}

// Errors for updating emote orders.
type UpdateEmoteOrdersError struct {
	// The associated error code.
	Code UpdateEmoteOrdersErrorCode `json:"code"`
}

// The required input for an updateEmoteOrders mutation.
type UpdateEmoteOrdersInput struct {
	// The list of emotes with their newly requested orders in a particular group.
	Orders []*EmoteOrder `json:"orders"`
}

// The result of an updateEmoteOrders mutation.
type UpdateEmoteOrdersPayload struct {
	// Emotes are the newly reordered emotes.
	Emotes []*Emote `json:"emotes"`
	// Service error, if any.
	Error *UpdateEmoteOrdersError `json:"error"`
}

// UpdateExtensionDiscoveryDataInput updates the discovery data of a given extension version.
type UpdateExtensionDiscoveryDataInput struct {
	// Extension metadata used for discovery.
	DiscoveryManifest *ExtensionDiscoveryManifestInput `json:"discoveryManifest"`
	// The extension ID of the manifest to update.
	ID string `json:"id"`
	// The extension version to update.
	Version string `json:"version"`
}

// UpdateExtensionDiscoveryDataPayload returns the update Extension discovery metadata.
type UpdateExtensionDiscoveryDataPayload struct {
	// The error when the mutation fails to update an extension.
	Error *UpdateExtensionDiscoveryDataError `json:"error"`
	// The updated extension discovery data.
	Manifest *ExtensionVersionDiscoveryManifest `json:"manifest"`
}

// UpdateExtensionManifestInput updates the manifest.
type UpdateExtensionManifestInput struct {
	// ExtensionAssetManifest is data related to the assets of an extension.
	AssetManifest *ExtensionAssetManifestInput `json:"assetManifest"`
	// Data about what an Extension can do, in general, and at the time of interaction.
	Capabilities *ExtensionCapabilitiesInput `json:"capabilities"`
	// ExtensionDeveloperManifest is the developer specific extension data.
	DeveloperManifest *ExtensionDeveloperManifestInput `json:"developerManifest"`
	// Extension metadata used for discovery.
	DiscoveryManifest *ExtensionDiscoveryManifestInput `json:"discoveryManifest"`
	// The extension ID of the manifest to update.
	ID string `json:"id"`
	// The extension version to update.
	Version string `json:"version"`
	// Extension views.
	Views *ExtensionViewsInput `json:"views"`
}

// UpdateExtensionManifestPayload returns the update Extension manifest.
type UpdateExtensionManifestPayload struct {
	// The error when the mutation fails to update an extension.
	Error *UpdateExtensionManifestError `json:"error"`
	// The updated extension manifest.
	Manifest *ExtensionManifest `json:"manifest"`
}

// UpdateHypeTrainConfigInput takes series of optional config settings.
type UpdateHypeTrainConfigInput struct {
	// Custom emote to be rendered in Hype Train messaging.
	CalloutEmoteID *string `json:"calloutEmoteID"`
	// Length of the cooldown period after a hype train ends.
	CooldownPeriodMinutes *int `json:"cooldownPeriodMinutes"`
	// The difficulty of hype train levels.
	Difficulty *HypeTrainDifficulty `json:"difficulty"`
	// Whether hype train should be enabled.
	IsEnabled *bool `json:"isEnabled"`
	// Hype Train kickoff settings.
	Kickoff *HypeTrainKickoffInput `json:"kickoff"`
	// A boolean flag that indicates if the hype train settings should be personalized by Twitch.
	ShouldUsePersonalizedSettings *bool `json:"shouldUsePersonalizedSettings"`
	// Use creator color as base color of the Hype Train progress bar.
	WillUseCreatorColor *bool `json:"willUseCreatorColor"`
}

// UpdateHypeTrainConfigPayload is the response that contains the updated config.
type UpdateHypeTrainConfigPayload struct {
	// The updated hype train config for the channel.
	Config *HypeTrainConfig `json:"config"`
}

// Updates the user's activity sharing setting. This must only be sent in response to a direct action by the user
// intended to change the setting.
type UpdateIsSharingActivityInput struct {
	// Determines whether or not to show the user's activity in their shared status. When false, the user will always
	// appear as if they are performing no activity.
	IsSharingActivity bool `json:"isSharingActivity"`
}

type UpdateIsSharingActivityPayload struct {
	// The modified user.
	User *User `json:"user"`
}

// Exchanges one of two auth inputs for an AccessToken and RefreshToken.
type UpdateLWATokenInput struct {
	// Either an AuthorizationCode or a RefreshToken.
	Grant string `json:"grant"`
	// The type of grant provided.
	GrantType GrantType `json:"grantType"`
}

// Returns updated tokens, or an error if a new LWA flow is required.
type UpdateLWATokenPayload struct {
	// An error in this flow means the client should redo the LWA flow.
	Error *WatchPartyError `json:"error"`
	// Contains all token information.
	Token *LWAToken `json:"token"`
}

// Mutation input for updating partner leaderboard settings.
type UpdateLeaderboardSettingsInput struct {
	// The default leaderboard the user wants to show.
	DefaultLeaderboard *LeaderboardType `json:"defaultLeaderboard"`
	// Setting for enabling bits cheering leaderboards.
	IsCheerEnabled *bool `json:"isCheerEnabled"`
	// Setting for enabling sub gifting leaderboards.
	IsSubGiftEnabled *bool `json:"isSubGiftEnabled"`
	// The time period the user wants the leaderboard to be displayed as.
	TimePeriod *LeaderboardTimePeriodType `json:"timePeriod"`
	// The user ID to update leaderboard settings.
	UserID string `json:"userID"`
}

// Result of mutation is the updated user object.
type UpdateLeaderboardSettingsPayload struct {
	// The user whose settings were updated.
	User *User `json:"user"`
}

// The required input for a updateLiveUpNotification mutation.
type UpdateLiveUpNotificationInput struct {
	// The text that will be in the notification that sends when the user starts broadcasting.
	// If updated to "", the default value of "<user> went live!" will be used/returned.
	LiveUpNotification string `json:"liveUpNotification"`
	// The ID of the user whose live up notification is being updated.
	UserID string `json:"userID"`
}

// Returned after live up notification state is mutated.
type UpdateLiveUpNotificationPayload struct {
	// The modified broadcast settings.
	BroadcastSettings *BroadcastSettings `json:"broadcastSettings"`
	// If any validation errors occur, this will not be nil.
	Error *UpdateLiveUpNotificationValidationError `json:"error"`
}

// Resolver for validation errors that occur on update live up notification.
type UpdateLiveUpNotificationValidationError struct {
	// Error code that describes the validation error.
	Code UpdateLiveUpNotificationValidationErrorCode `json:"code"`
}

// Inputs for updating the score for the lobby participant, who is a competition player or competition team, in a competition.
type UpdateLobbyParticipantScoreInput struct {
	// ID of the competition.
	CompetitionID string `json:"competitionID"`
	// ID of the competition lobby.
	LobbyID string `json:"lobbyID"`
	// ID of the competition player or competition team.
	ParticipantID string `json:"participantID"`
	// ID of the competition phase.
	PhaseID string `json:"phaseID"`
	// The assigned score value.
	Score int `json:"score"`
}

// UpdateLobbyParticipantScorePayload is the success response updating the score for the lobby participant, who is a competition player or competition team, in a competition.
type UpdateLobbyParticipantScorePayload struct {
	// The new state of competition after scoring a competition player or competition team for that lobby.
	Competition *Competition `json:"competition"`
	// Used for competition mutation errors.
	Error *CompetitionError `json:"error"`
}

// Contains a list of multi-view content attributes to be updated.
type UpdateMultiviewContentAttributesInput struct {
	// List of multi-view content attributes to be updated.
	Params []*MultiviewContentAttributeParams `json:"params"`
}

// Contains the server response payload.
type UpdateMultiviewContentAttributesPayload struct {
	// Unprocssed content attribute updates.
	FailedUpdates []*MultiviewContentAttribute `json:"failedUpdates"`
	// Processed content attribute updates.
	SucceededUpdates []*MultiviewContentAttribute `json:"succeededUpdates"`
}

// Used for mutating onboarding status.
type UpdateOnboardingSkippedChannelsInput struct {
	// List of channels the user skips during the onboarding process.
	ChannelIDs []string `json:"channelIDs"`
	// ID for the user to update.
	UserID string `json:"userID"`
}

// Returned after onboarding state is mutated.
type UpdateOnboardingSkippedChannelsPayload struct {
	// Current state of the given user.
	User *User `json:"user"`
}

// Error that may be returned by the UpdateOrganizationMemberRole mutation.
type UpdateOrganizationMemberRoleError struct {
	// Type of mutation error.
	Code UpdateOrganizationMemberRoleErrorCode `json:"code"`
}

// Inputs to the UpdateOrganizationMemberRole mutation.
type UpdateOrganizationMemberRoleInput struct {
	// ID of the organization where the user is a member.
	OrganizationID string `json:"organizationID"`
	// New role of the user in the organization.
	Role OrganizationMemberRole `json:"role"`
	// User's Twitch ID.
	UserID string `json:"userID"`
}

// Outputs from the UpdateOrganizationMemberRole mutation.
type UpdateOrganizationMemberRolePayload struct {
	// Logical error that could be returned by the mutation.
	Error *UpdateOrganizationMemberRoleError `json:"error"`
	// Updated member with the new role.
	OrganizationMember *OrganizationMember `json:"organizationMember"`
}

// UpdateOwnerChanletAttributesInput updates the owner chanlet attributes.
type UpdateOwnerChanletAttributesInput struct {
	// The ID of the owner chanlet (channel that owns chanlets).
	ChannelID string `json:"channelID"`
	// Whether the chanlets should return for the viewers.
	IsChanletFeatureEnabled bool `json:"isChanletFeatureEnabled"`
}

// UpdateOwnerChanletAttributesPayload returns the new chanlet that was created.
type UpdateOwnerChanletAttributesPayload struct {
	// Resulted OwnerChanletAttributes from the update. This is expected to match the input.
	OwnerChanletAttributes *OwnerChanletAttributes `json:"ownerChanletAttributes"`
}

type UpdatePanelInput struct {
	Description *string `json:"description"`
	ID          string  `json:"id"`
	ImageURL    *string `json:"imageURL"`
	LinkURL     *string `json:"linkURL"`
	SlotID      *string `json:"slotID"`
	Title       *string `json:"title"`
}

type UpdatePanelPayload struct {
	Panel Panel `json:"panel"`
}

// Error returned during a invalid user request.
type UpdatePhoneNumberConfirmationError struct {
	// Error code returned by the backend.
	Code UpdatePhoneNumberConfirmationErrorCode `json:"code"`
	// The localized external error message.
	Message string `json:"message"`
}

// The required input for a updatePhoneNumberConfirmation mutation.
type UpdatePhoneNumberConfirmationInput struct {
	// The one time password required to complete phone number registration. This can only be generated from the UpdatePhoneNumber mutation.
	OneTimePassword string `json:"oneTimePassword"`
	// The phone number being added to a twitch user profile.
	PhoneNumber string `json:"phoneNumber"`
	// The ID of the user that is requesting to add or modify their phone number.
	UserID string `json:"userID"`
}

// The result of a updatePhoneNumberConfirmationPayload mutation.
type UpdatePhoneNumberConfirmationPayload struct {
	// error code and localized error.
	Error *UpdatePhoneNumberConfirmationError `json:"error"`
}

// Error returned during a invalid user request.
type UpdatePhoneNumberError struct {
	// Error code returned by the backend.
	Code UpdatePhoneNumberErrorCode `json:"code"`
	// The localized external error message.
	Message string `json:"message"`
}

// The required input for a updatePhoneNumber mutation.
type UpdatePhoneNumberInput struct {
	// The phone number being added to a twitch user profile.
	PhoneNumber string `json:"phoneNumber"`
	// The ID of the user that is requesting to add or modify their phone number.
	UserID string `json:"userID"`
}

// The result of a updatePhoneNumberPayload mutation.
type UpdatePhoneNumberPayload struct {
	// error code and localized error.
	Error *UpdatePhoneNumberError `json:"error"`
}

// Error code for an error that occurs while updating prime offer status.
type UpdatePrimeOfferStatusError struct {
	// Error code for error that occurred while updating prime offer status.
	Code UpdatePrimeOfferStatusErrorCode `json:"code"`
}

// The offer id you wish to update as well as the status for the update.
type UpdatePrimeOfferStatusInput struct {
	// The list of offers and statuses to update.
	StatusChanges []*OfferAndStatus `json:"statusChanges"`
	// The user to update the offer statuses for.
	UserID string `json:"userID"`
}

// The returned value for an update prime offer status query.
type UpdatePrimeOfferStatusPayload struct {
	// The possible error returned from the service.
	Error *UpdatePrimeOfferStatusError `json:"error"`
	// The connection for the status of the offer for the user.
	Self []*PrimeOfferSelfConnection `json:"self"`
}

// UpdatePrimeSettingsInput contains boolean for setting the users preference on chat notifications,
// and the users preference on the emoticon set name to be selected.
type UpdatePrimeSettingsInput struct {
	// The Prime Emoticons Set Name for Prime Emoticons Smilies.
	PrimeEmoticonsSetName *PrimeEmoticonsSetName `json:"primeEmoticonsSetName"`
	// True or False for whether the user wants notifications enabled.
	ShouldEnableSubCreditChatNotification *bool `json:"shouldEnableSubCreditChatNotification"`
	// The ID of the user who's settings are being updated.
	UserID string `json:"userID"`
}

// Data that was mutated.
type UpdatePrimeSettingsPayload struct {
	// The mutated PrimeSettings.
	PrimeSettings *PrimeSettings `json:"primeSettings"`
}

// UpdateRaidSettingsInput update a user's raid settings.
type UpdateRaidSettingsInput struct {
	// Determines what other channels can raid this channel.
	IncomingRaidsPolicy *IncomingRaidsPolicy `json:"incomingRaidsPolicy"`
	// UserID to update settings for.
	UserID string `json:"userID"`
}

// UpdateRaidSettingsPayload returns the user whose settings had been updated.
type UpdateRaidSettingsPayload struct {
	// User whose raid settings has been updated.
	User *User `json:"user"`
}

type UpdateRoomError struct {
	Code UpdateRoomErrorCode `json:"code"`
	// On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Maximum number of characters.
	MaxLength *int `json:"maxLength"`
	// On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Minimum number of characters.
	MinLength *int `json:"minLength"`
}

type UpdateRoomInput struct {
	// Deprecated. Use minimumReadMessagesRole instead.
	IsPreviewable *bool `json:"isPreviewable"`
	// Deprecated. Use minimumReadMessagesRole and minimumSendMessagesRole instead.
	MinimumAllowedRole *RoomRole `json:"minimumAllowedRole"`
	// Minimum role required to read messages in the room.
	MinimumReadMessagesRole *RoomRole `json:"minimumReadMessagesRole"`
	// Minimum role required to send messages in the room.
	MinimumSendMessagesRole *RoomRole `json:"minimumSendMessagesRole"`
	Name                    *string   `json:"name"`
	RoomID                  string    `json:"roomID"`
	Topic                   *string   `json:"topic"`
}

type UpdateRoomModesError struct {
	Code UpdateRoomModesErrorCode `json:"code"`
	// On SLOW_MODE_DURATION_INVALID: Maximum number of seconds slow mode can be set to.
	MaximumSlowModeDurationSeconds *int `json:"maximumSlowModeDurationSeconds"`
	// On SLOW_MODE_DURATION_INVALID: Minimum number of seconds slow mode can be set to.
	MinimumSlowModeDurationSeconds *int `json:"minimumSlowModeDurationSeconds"`
}

type UpdateRoomModesInput struct {
	// Turns emotes only mode on or off.
	EnableEmotesOnlyMode *bool `json:"enableEmotesOnlyMode"`
	// Turns r9k mode on or off.
	EnableR9KMode *bool `json:"enableR9KMode"`
	// Turns slow mode on or off.
	EnableSlowMode *bool  `json:"enableSlowMode"`
	RoomID         string `json:"roomID"`
	// If slow mode enabled, the number of seconds users must wait between messages.
	SlowModeDurationSeconds *int `json:"slowModeDurationSeconds"`
}

type UpdateRoomModesPayload struct {
	Error *UpdateRoomModesError `json:"error"`
	Room  *Room                 `json:"room"`
}

type UpdateRoomPayload struct {
	Error *UpdateRoomError `json:"error"`
	Room  *Room            `json:"room"`
}

type UpdateRoomViewInput struct {
	IsArchived *bool      `json:"isArchived"`
	IsMuted    *bool      `json:"isMuted"`
	LastReadAt *time.Time `json:"lastReadAt"`
	RoomID     string     `json:"roomID"`
}

type UpdateRoomViewPayload struct {
	RoomView *RoomView `json:"roomView"`
}

// UpdateScheduleSegmentError is a wrapper for error associated with the UpdateScheduleSegment mutation.
type UpdateScheduleSegmentError struct {
	// Error code.
	Code UpdateScheduleSegmentErrorCode `json:"code"`
	// If the error is related to overlapping segments, provide the existing segment causing a conflict.
	ConflictingSegment *ScheduleSegment `json:"conflictingSegment"`
	// If the error is related to an input out of service-defined bounds, provide the maximum allowed value.
	Maximum *int `json:"maximum"`
	// If the error is related to an input out of service-defined bounds, provide the miniimum allowed value.
	Minimum *int `json:"minimum"`
}

// The input to update a schedule segment.
type UpdateScheduleSegmentInput struct {
	// The categories of the segment.
	Categories []string `json:"categories"`
	// The duration of the segment in minutes.
	DurationMinutes *int `json:"durationMinutes"`
	// Whether the segment is cancelled.
	IsCancelled *bool `json:"isCancelled"`
	// The schedule id.
	ScheduleID string `json:"scheduleID"`
	// The segment id to update.
	SegmentID string `json:"segmentID"`
	// The start time of the segment.
	Start *SegmentStartTimeInput `json:"start"`
	// The geographic timezone of the segment.
	Timezone *string `json:"timezone"`
	// The title of the segment.
	Title *string `json:"title"`
}

// The returned payload when updating a schedule segment.
type UpdateScheduleSegmentPayload struct {
	// The possible error returned.
	Error *UpdateScheduleSegmentError `json:"error"`
	// The updated schedule with the updated segment.
	Schedule *Schedule `json:"schedule"`
}

// Updates the list of streamer onboarding content that a user has seen.
type UpdateSeenCreatorOnboardingContentInput struct {
	// A list of content IDs that should be marked as seen.
	OnboardingContentIDs []string `json:"onboardingContentIDs"`
	// UserID for the user to update seen content.
	UserID string `json:"userID"`
}

// The result of an UpdateSeenCreatorOnboardingContent mutation.
type UpdateSeenCreatorOnboardingContentPayload struct {
	// The user who viewed onboarding content.
	User *User `json:"user"`
}

// UpdateSocialMediaInput updates existing a social media item under the given channelID.
type UpdateSocialMediaInput struct {
	// The unique channel identifier.
	ChannelID string `json:"channelID"`
	// The unique indentifier of the social media item.
	ID string `json:"id"`
	// The visible text of the social media item.
	Title *string `json:"title"`
	// The web address of the social media item.
	URL *string `json:"url"`
}

// UpdateSocialMediaPayload returns the updated social media.
type UpdateSocialMediaPayload struct {
	// The social media channel that was updated.
	Channel *Channel `json:"channel"`
	// The potential error when updating a social media.
	Error *UpdateSocialMediaError `json:"error"`
}

// UpdateSquadInvitePolicyError is the error associated with an updateSquadInvitePolicy.
type UpdateSquadInvitePolicyError struct {
	// The associated error code.
	Code UpdateSquadInvitePolicyErrorCode `json:"code"`
}

// The required input for an updateSquadInvitePolicy mutation.
type UpdateSquadInvitePolicyInput struct {
	// The new invite policy that will replace what is currently set for the user.
	IncomingInvitePolicy SquadStreamIncomingInvitePolicy `json:"incomingInvitePolicy"`
	// The ID corresponding to the user whose invite policy should be updated.
	UserID string `json:"userID"`
}

// Returns after the invite policy is mutated.
type UpdateSquadInvitePolicyPayload struct {
	// The possible error returned from the service.
	Error *UpdateSquadInvitePolicyError `json:"error"`
	// The modified user.
	User *User `json:"user"`
}

// UpdateSquadStreamError is the error associated with a updateSquadStream.
type UpdateSquadStreamError struct {
	// The associated error code.
	Code UpdateSquadStreamErrorCode `json:"code"`
}

// Inputs to the updateSquadStream mutation.
type UpdateSquadStreamInput struct {
	// The ID of the squad stream to be updated.
	SquadStreamID string `json:"squadStreamID"`
	// If specified, the new status of the squad stream.
	Status *SquadStreamStatus `json:"status"`
}

// Outputs from the updateSquadStream mutation.
type UpdateSquadStreamPayload struct {
	// The possible error returned from the service.
	Error *UpdateSquadStreamError `json:"error"`
	// The updated squad stream.
	SquadStream *SquadStream `json:"squadStream"`
}

// Inputs to updating a stucco.
type UpdateStuccoInput struct {
	// ID of the channel this stucco belongs to.
	ChannelID string `json:"channelID"`
	// Description representing the stucco, should be the words contained in the stucco, used by screen readers.
	Description string `json:"description"`
	// Base64 encoded binary data of the 92x28px stucco ("1x") image asset.
	ImageData1x string `json:"imageData1x"`
	// Base64 encoded binary data of the 182x56px stucco ("2x") image asset.
	ImageData2x string `json:"imageData2x"`
	// Base64 encoded binary data of the 368x112px stucco ("4x") image asset.
	ImageData4x string `json:"imageData4x"`
	// Unique ID of the stucco to update.
	StuccoID string `json:"stuccoID"`
	// Text code representing the stucco without any prefixes (prefixes are added in the backend).
	Suffix string `json:"suffix"`
}

// Inputs for updating a stucco pack (exchanging stuccos contained in the pack).
type UpdateStuccoPackInput struct {
	// Id of the channel this pack is part of.
	ChannelID string `json:"channelID"`
	// Id of the stucco pack to update.
	StuccoPackID string `json:"stuccoPackID"`
	// Updated list of stuccos for this pack.
	Stuccos []*UpdateStuccoPackItemInput `json:"stuccos"`
}

// Single item in a stuccopack, as part of the update stucco pack call, representing one stucco to be used in a certain slot.
type UpdateStuccoPackItemInput struct {
	// Slot index in the pack (used for ordering).
	SlotIndex int `json:"slotIndex"`
	// Id of the stucco.
	StuccoID string `json:"stuccoID"`
}

// Outputs from the update stucco pack mutation.
type UpdateStuccoPackPayload struct {
	// The updated stucco pack.
	StuccoPack *StuccoPack `json:"stuccoPack"`
}

// The output for the update stucco mutation.
type UpdateStuccoPayload struct {
	// The updated stucco.
	Stucco *Stucco `json:"stucco"`
}

// Inputs to the updateSubscriptionProduct mutation.
type UpdateSubscriptionProductInput struct {
	// Name of the product.
	DisplayName *string `json:"displayName"`
	// Toggle to enable add free viewing.
	HasAdFree *bool `json:"hasAdFree"`
	// Toggle to enable fast chat (or disable slow mode).
	HasFastChat *bool `json:"hasFastChat"`
	// Toggle to enable sub only chat.
	HasSubOnlyChat *bool `json:"hasSubOnlyChat"`
	// Toggle to enable sub only video.
	HasSubOnlyVideoArchive *bool `json:"hasSubOnlyVideoArchive"`
	// The id of the subscription product.
	ID string `json:"id"`
	// User the update belongs to.
	TargetUserID string `json:"targetUserID"`
}

// Output from the updateSubscriptionProduct mutation.
type UpdateSubscriptionProductPayload struct {
	// Subscription product output.
	Product *SubscriptionProduct `json:"product"`
	// User/channel to update the subscription product.
	TargetUser *User `json:"targetUser"`
}

// The possible error returned.
type UpdateUserColorsError struct {
	// The error code.
	Code UpdateUserColorsErrorCode `json:"code"`
}

// The required input for a UpdateUserColorsInput mutation.
type UpdateUserColorsInput struct {
	// The user's primary color hex string (e.g. "FFFFFF").
	PrimaryColorHex string `json:"primaryColorHex"`
	// The ID of the user whose creator colors are being updated.
	UserID string `json:"userID"`
}

// The result of a UpdateUserColorsInput mutation.
type UpdateUserColorsPayload struct {
	// The possible error returned.
	Error *UpdateUserColorsError `json:"error"`
	// The modified user.
	User *User `json:"user"`
}

// The required input for a updateUserCreateDateHidden mutation.
type UpdateUserCreateDateHiddenInput struct {
	// The hide create date boolean to set onto the user.
	IsCreateDateHidden bool `json:"isCreateDateHidden"`
	// The ID of the user whose privacy setting is being updated.
	UserID string `json:"userID"`
}

// The result of a updateUserCreateDateHidden mutation.
type UpdateUserCreateDateHiddenPayload struct {
	// The modified user.
	User *User `json:"user"`
}

// The required input for a updateUserDirectoryHidden mutation.
type UpdateUserDirectoryHiddenInput struct {
	// The directory hidden boolean to set onto the user.
	IsDirectoryHidden bool `json:"IsDirectoryHidden"`
}

// The result of a updateUserDirectoryHidden mutation.
type UpdateUserDirectoryHiddenPayload struct {
	// The modified user.
	User *User `json:"user"`
}

// The required input for a updateUserEmailReuseable mutation.
type UpdateUserEmailReusableInput struct {
	// The email reusable boolean to set onto the user.
	IsEmailReusable bool `json:"IsEmailReusable"`
	// The ID of the user whose broadcast setting is being updated.
	UserID string `json:"userID"`
}

// The result of a updateUserEmailReuseable mutation.
type UpdateUserEmailReusablePayload struct {
	// The modified user.
	User *User `json:"user"`
}

// The possible error returned.
type UpdateUserError struct {
	// The error code.
	Code UpdateUserErrorCode `json:"code"`
}

// The required input for a UpdateUser mutation.
type UpdateUserInput struct {
	// If true the phone number associated with this user will be deleted.
	DeletePhoneNumber *bool `json:"deletePhoneNumber"`
	// The user's personal description.
	Description *string `json:"description"`
	// The user's display name.
	DisplayName *string `json:"displayName"`
	// The user's personal email.
	Email *string `json:"email"`
	// Whether or not to send a mobile verification code if email verification is required.
	IncludeVerificationCode *bool `json:"includeVerificationCode"`
	// User id of the user being updated.
	UserID string `json:"userID"`
}

// The required input for a updateUserIsEmailRevertSuccess mutation.
type UpdateUserIsEmailRevertSuccessInput struct {
	// The show email revert success msg boolean to set onto the user.
	IsEmailRevertSuccess bool `json:"isEmailRevertSuccess"`
	// The ID of the user whose email revert success flag is being updated.
	UserID string `json:"userID"`
}

// The result of a updateUserIsEmailRevertSuccess mutation.
type UpdateUserIsEmailRevertSuccessPayload struct {
	// The modified user.
	User *User `json:"user"`
}

// The result of an updateUser mutation.
type UpdateUserPayload struct {
	// The possible error returned.
	Error *UpdateUserError `json:"error"`
	// The modified user.
	User *User `json:"user"`
}

// An error returned from the updateUserPredictionSettings mutation.
type UpdateUserPredictionSettingsError struct {
	// Code describing the error.
	Code UpdateUserPredictionSettingsErrorCode `json:"code"`
}

// Update the current authorized user's Prediction Settings.
// All fields are nullable; only specify fields that you wish to update.
type UpdateUserPredictionSettingsInput struct {
	// Whether the user has accepted the latest Predictions Terms of Service.
	HasAcceptedTos *bool `json:"hasAcceptedTOS"`
	// Whether the user has opted to display a temporary chat badge indicating their choices during Predictions Events.
	IsTemporaryChatBadgeEnabled *bool `json:"isTemporaryChatBadgeEnabled"`
}

// Payload for updating a user's Prediction Settings.
type UpdateUserPredictionSettingsPayload struct {
	// If present, there was an error with the request.
	Error *UpdateUserPredictionSettingsError `json:"error"`
	// The updated settings.
	Settings *UserPredictionSettings `json:"settings"`
}

// UpdateUserSubscriptionSettingsInput updates the users subscription settings.
type UpdateUserSubscriptionSettingsInput struct {
	// Whether the user only wants to receive gifts to channels they follow.
	GiftsInFollowedChannelsOnly *bool `json:"giftsInFollowedChannelsOnly"`
	// Whether the user wants to hide Badge Modifiers.
	IsBadgeModifierHidden *bool `json:"isBadgeModifierHidden"`
	// If the user wants to hide their Founder Badges.
	IsFounderBadgesHidden *bool `json:"isFounderBadgesHidden"`
	// Whether the user wants to show how many gifts they've purchased.
	IsGiftCountHidden *bool `json:"isGiftCountHidden"`
	// Whether the user wants to show their subscription tenure and status in the chat viewer card.
	IsSubscriptionStatusHidden *bool `json:"isSubscriptionStatusHidden"`
}

// UpdateUserSubscriptionGiftSettingsPayload returns the user's current gift settings.
type UpdateUserSubscriptionSettingsPayload struct {
	SubscriptionSettings *UserSubscriptionSettings `json:"subscriptionSettings"`
}

// Inputs to the updateUserTeamMembership mutation.
type UpdateUserTeamMembershipInput struct {
	// Whether or not the team should be the user's primary team.
	// Note only True values are effective here. A user must always have one and only one primary team, and setting false would break that invariant.
	// Setting a team as Primary will make all of a user's other team memberships non-primary.
	Primary *bool `json:"primary"`
	// Whether or not the membership should reveal its revenue.
	RevenueRevealed bool `json:"revenueRevealed"`
	// Whether or not the membership should reveal its stats.
	StatsRevealed bool `json:"statsRevealed"`
	// The team which the membership belongs to.
	TeamID string `json:"teamID"`
	// The user whose membership is being modified.
	UserID string `json:"userID"`
}

// Output from the updateUserTeamMembership mutation.
type UpdateUserTeamMembershipPayload struct {
	// The user whose membership was modified.
	User *User `json:"user"`
}

// Error information in the update user video shelves response.
type UpdateUserVideoShelvesError struct {
	// An http error code to identify the error response.
	Code int `json:"code"`
	// The translated error response message for this given error.
	Message *string `json:"message"`
}

// Input information for updating a user's video shelves. Video shelves are added/removed and reordered based on the provided shelfOptions.
type UpdateUserVideoShelvesInput struct {
	// Channel for which to update shelves.
	ChannelID string `json:"channelID"`
	// A list of different shelf options to populate the user's video shelves.
	ShelfOptions []*ShelvesAvailableOptions `json:"shelfOptions"`
}

// Response to a request to update a user's video shelves.
type UpdateUserVideoShelvesPayload struct {
	// The error response for this update request.
	Error *UpdateUserVideoShelvesError `json:"error"`
	// The list of shelves for this user.
	Shelves []*VideoShelf `json:"shelves"`
}

// Input information for updating a resume watching entry for a specified user and video.
type UpdateUserViewedVideoInput struct {
	// Position for where in the video to update for the resume watching entry.
	Position int `json:"position"`
	// User for which to update the resume watching entry.
	UserID string `json:"userID"`
	// Video for which to update the resume watching entry.
	VideoID string `json:"videoID"`
	// Type of the video for which to update the resume watching entry.
	VideoType VideoType `json:"videoType"`
}

// Response to a request to update a resume watching entry for a specified user and video.
type UpdateUserViewedVideoPayload struct {
	// The video returned from the request.
	Video *Video `json:"video"`
}

type UpdateVideoCommentInput struct {
	// ID of the comment being updated.
	CommentID string `json:"commentID"`
	// The state of the comment.
	State VideoCommentState `json:"state"`
}

type UpdateVideoCommentPayload struct {
	// The comment that was updated.
	Comment *VideoComment `json:"comment"`
}

// Input information for updating a video.
type UpdateVideoInput struct {
	// The description of the video.
	Description *string `json:"description"`
	// The name of the game presented in the video.
	Game *string `json:"game"`
	// The language of the video.
	Language *string `json:"language"`
	// The thumbnail URL of the video.
	ThumbnailPath *string `json:"thumbnailPath"`
	// The title of the video.
	Title *string `json:"title"`
	// ID of the video being updated.
	VideoID string `json:"videoID"`
}

// Response to a request to update a video.
type UpdateVideoPayload struct {
	// The video with updated fields.
	Video *Video `json:"video"`
}

// Error that may be returned by the UpdateVideoStreamSettings mutation.
type UpdateVideoStreamSettingsError struct {
	// Type of mutation error.
	Code UpdateVideoStreamSettingsErrorCode `json:"code"`
}

// UpdateVideoStreamSettingsInput updates the broadcaster's stream settings such as stream delay length seconds or stream key.
type UpdateVideoStreamSettingsInput struct {
	// ChannelID of the broadcaster. This has to be same as authenticated user's userID.
	ChannelID string `json:"channelID"`
	// The number of seconds delay for a stream. When this is set, a stream will be ingested with specified delay in seconds. Maximum is set to 900 seconds.
	DelaySeconds *int `json:"delaySeconds"`
	// Whether or not a stream should be started as a low latency stream.
	IsLowLatency *bool `json:"isLowLatency"`
	// Whether or not the broadcaster prefers to archive the vod for a stream.
	ShouldArchiveVODs *bool `json:"shouldArchiveVODs"`
	// Whether or not to show the disconnect slate.
	ShouldShowDisconnectSlate *bool `json:"shouldShowDisconnectSlate"`
}

// UpdateVideoStreamSettingsPayload returns the updated video stream settings for the broadcaster.
type UpdateVideoStreamSettingsPayload struct {
	// The updated Channel for the broadcaster.
	Channel *Channel `json:"channel"`
	// Error code.
	Error *UpdateVideoStreamSettingsError `json:"error"`
}

// The change that will be applied to the user's visibility. See VisibilityInput for details on the effects of each
// value.
type UpdateVisibilityInput struct {
	Visibility VisibilityInput `json:"visibility"`
}

type UpdateVisibilityPayload struct {
	// The modified user.
	User *User `json:"user"`
}

// The request to the UpdateWhisperSettings mutation.
type UpdateWhisperSettingsInput struct {
	// Whether to disallow strangers from iniating a whisper thread to this user.
	IsBlockingWhispersFromStrangers *bool `json:"isBlockingWhispersFromStrangers"`
}

// The response from the UpdateWhisperSettings mutation.
type UpdateWhisperSettingsPayload struct {
	// The user whose whisper settings were updated.
	User *User `json:"user"`
}

type UpdateWhisperThreadInput struct {
	// Whether to archive the room.
	IsArchived *bool `json:"isArchived"`
	// Whether to mute the room.
	IsMuted *bool `json:"isMuted"`
	// Whether to mark the message as spam.
	IsSpam *bool `json:"isSpam"`
	// ID of last message read by the user.
	LastReadMessageID *string `json:"lastReadMessageID"`
	// Whether to revoke temporary send Whisper permission from the other user.
	RemoveWhitelist *bool `json:"removeWhitelist"`
	// ID of thread to be marked as read.
	ThreadID string `json:"threadID"`
}

type UpdateWhisperThreadPayload struct {
	// Thread that was updated.
	Thread *WhisperThread `json:"thread"`
}

// Individual upload config.
type UploadConfig struct {
	// Upload id used when listening to pubsub.
	ID string `json:"ID"`
	// URL to upload images to.
	URL string `json:"URL"`
	// The type of asset of the emote image that should be uploaded.
	AssetType EmoteAssetType `json:"assetType"`
	// Images that will result out of the upload.
	Images []*UploadImage `json:"images"`
	// Size of the image that should be uploaded.
	Size EmoteImageSize `json:"size"`
}

type UploadImage struct {
	// Image ID generated by Mako for image.
	ID string `json:"ID"`
	// Size of the image.
	Size EmoteImageSize `json:"Size"`
	// The asset type of the image.
	AssetType EmoteAssetType `json:"assetType"`
}

// UseChatNotificationTokenInput is the input required for the UseChatNotificationToken mutation.
type UseChatNotificationTokenInput struct {
	// The channel that this token will be used on.
	ChannelLogin string `json:"channelLogin"`
	// Whether or not to include user's streak tenure.
	IncludeStreak bool `json:"includeStreak"`
	// An optional message that will be displayed when this chat token is used.
	Message *string `json:"message"`
	// An optional ID of token to be used.
	TokenID *string `json:"tokenID"`
}

// UseChatNotificationTokenPayload is the return of the UseChatNotificationToken mutation.
type UseChatNotificationTokenPayload struct {
	// If the token was successfully used.
	IsSuccess bool `json:"isSuccess"`
}

// Twitch user.
type User struct {
	// Information about a user's connected accounts.
	AccountConnections *AccountConnectionSet `json:"accountConnections"`
	// Information about a user's account health status.
	AccountHealth *UserAccountHealth `json:"accountHealth"`
	// Fetch active challenges for the user based on a variety of sorting options.
	// By default returns 10 challenges, sorted by start time.
	ActiveChallenges *ChannelChallengeConnection `json:"activeChallenges"`
	// An action that a user or session is performing. This field is null if the user is not friends with
	// the authenticated user.
	Activity Activity `json:"activity"`
	// Ad Properties for the given user.
	AdProperties *AdProperties `json:"adProperties"`
	// The user's relationship with Amazon.
	Amazon *UserAmazonConnection `json:"amazon"`
	// List of authenticated Twitch sessions.
	AuthenticatedSessionList []*AuthenticatedSession `json:"authenticatedSessionList"`
	// AutoModProperties is a mapping of automod categories to levels, i.e. a user has indicated they want level 4, or
	// the highest level of moderation for profanity, but level 1 for everything else.
	AutoModProperties *AutoModProperties `json:"autoModProperties"`
	// A user's configured auto refill information, contains all auto refill profiles.
	// Will have an optional filter argument in the future.
	AutoRefill *AutoRefill `json:"autoRefill"`
	// The list of channels that this user has configured to automatically host
	// when their channel is not streaming live. Users can only view their own
	// autohost channels.
	AutohostChannels *AutohostChannelConnection `json:"autohostChannels"`
	// Options and preferences for autohost behavior, including whether
	// autohosting is enabled at all and how to choose which channel to host.
	// Users can only view their own autohost settings.
	AutohostSettings *AutohostSettings `json:"autohostSettings"`
	// The list of channels that have added this user as a channel to automatically host when their channel is not
	// streaming live. Users can only view their own autohosted by channels.
	AutohostedByChannels *AutohostedByChannelConnection `json:"autohostedByChannels"`
	// An action that a user or session is performing. This field is null if the user is not friends with
	// the authenticated user.
	Availability *Availability `json:"availability"`
	// The badges which are available for the authenticated user to select for use on another user's streams and videos if no channel-specific preference is set.
	// If no domain is not specified, all emote sets will be returned.
	// This is only returned if the request is authenticated by the same user whose email is requested.
	AvailableBadges []*Badge `json:"availableBadges"`
	// A list of this user's balances in FIAT currencies
	// If this isn't the `currentUser` this will return null.
	Balances []*Balance `json:"balances"`
	// A list of this user's banned users.
	// A maximum of 100 users by most recent are returned
	// Only resolves for the authenticated user.
	BannedUsers []*ChannelBannedUser `json:"bannedUsers"`
	// A URL to the user's banner image.
	BannerImageURL *string `json:"bannerImageURL"`
	// bitsBalance is the number of bits this user currently has available to spend.
	// If this isn't the `currentUser` or the user has been banned from using bits this will return null.
	// This field can only be requested if an OAuth token is supplied with the request.
	BitsBalance *int `json:"bitsBalance"`
	// bitsEvents returns a paginated list of this user's bits usage transactions
	// If this isn't the `currentUser` this will return null.
	// This field can only be requested if an OAuth token is supplied with the request.
	BitsEvents *BitsEventConnection `json:"bitsEvents"`
	// bitsOffers is a list of the ways this user can obtain more bits.
	// If this isn't the `currentUser` or the user has been banned from using bits this will return null.
	// This field can only be requested if an OAuth token is supplied with the request.
	BitsOffers []BitsOffer `json:"bitsOffers"`
	// BitsPaymentMethods has a list of eligible payment methods for a user to transact with.
	BitsPaymentMethods *BitsPaymentMethods `json:"bitsPaymentMethods"`
	// BitsProductEligibility checks for a given user if they are eligible to purchase a given product from the associated
	// provider, quantity, and locale.
	// bitsProduct(id: ID!, provider: BitsProductProvider!, quantity: Int!, locale: String!): BitsProductEligibility!
	// bitsProducts is a list of bits products that a user is able to purchase.
	// Unlike bitsOffers, this does not return any pricing information, only information
	// about the purchasable. A provider must be supplied, which is the payment platform
	// being currently used. An optional list of SKUs can be provided if we are looking up
	// a specific set of products for a user.
	BitsProducts []*BitsProduct `json:"bitsProducts"`
	// Settings tied to a bits user.
	BitsUserSettings *BitsUserSettings `json:"bitsUserSettings"`
	// bitsUserState dictates the state of the Bits user (new to Bits, existing Bits user, etc.)
	// If this isn't the `currentUser` or the user has been banned from using bits this will return null.
	// This field can only be requested if an OAuth token is supplied with the request.
	BitsUserState *BitsUserState `json:"bitsUserState"`
	// Resolves account information that Twitch has stored for a user's blizzard account information.
	BlizzardAccount *BlizzardUser `json:"blizzardAccount"`
	// Get the blocked terms of a user.
	BlockedTerms []*ChannelBlockedTerm `json:"blockedTerms"`
	// blockedUsers returns a list users that are restrained from directly communicating with this user.
	BlockedUsers []*User `json:"blockedUsers"`
	// bounties is a list of bounty board bounties for this user.
	Bounties []*Bounty `json:"bounties"`
	// bountiesPage is a paginated list of bounty board bounties for this user.
	BountiesPage *BountyConnection `json:"bountiesPage"`
	// bountyBoardSettings are settings and rules around the behavior of bounty boards for this user.
	BountyBoardSettings *BountyBoardSettings `json:"bountyBoardSettings"`
	// Badges that are displayed in chat during this user's broacasts or videos.
	BroadcastBadges []*Badge `json:"broadcastBadges"`
	// A User's broadcast settings that persists between streams.
	BroadcastSettings *BroadcastSettings `json:"broadcastSettings"`
	// A User's campaign for their channel.
	Campaign *Campaign `json:"campaign"`
	// A User's campaign properties for their channel.
	CampaignProperties *CampaignProperties `json:"campaignProperties"`
	// A container for celebration settings for the logged in user.
	CelebrationSettings *CelebrationUserSettings `json:"celebrationSettings"`
	// The channel which belongs to the user. This is still deprecated for previous uses.
	// This should only be used for the multi-view experience.
	Channel *Channel `json:"channel"`
	// What other similar content are my viewers watching.
	ChannelAnalyticsContentOverlap *ChannelAnalyticsContentOverlap `json:"channelAnalyticsContentOverlap"`
	// A user's channel feed.
	// No authorization required.  Returns even if channel feed is disabled in the UI.
	ChannelFeed *Feed `json:"channelFeed"`
	// Returns the list of chatrooms in the channel visible by the current user.
	ChannelRooms []*Room `json:"channelRooms"`
	// Hex color of the user's name in chat, e.g. "#ccaa44".
	ChatColor *string `json:"chatColor"`
	// chatSettings are settings and rules for chatting in this user's channel.
	ChatSettings *ChatSettings `json:"chatSettings"`
	// chatUISettings are settings for the user's chat UI.
	ChatUISettings *ChatUISettings `json:"chatUISettings"`
	// cheer is the channel-specific cheer settings and current state.
	// Returns null if cheering isn't enabled for this channel.
	Cheer *CheerInfo `json:"cheer"`
	// The list of OAuth clients authorized by the current user.
	ClientAuthorizations []*ClientAuthorization `json:"clientAuthorizations"`
	// A paginated list of clips featuring this user.
	// When criteria is not specified, the default values are used.
	Clips *ClipConnection `json:"clips"`
	// A paginated list of collections (playlists) created by the user.
	Collections *CollectionsConnection `json:"collections"`
	// Properties relating to the authenticated user's community points on twitch.
	CommunityPoints *CommunityPointsUserProperties `json:"communityPoints"`
	// The company that the user belongs to.
	// Returns null if the user doesn't belong to a company.
	Company *Company `json:"company"`
	// The competitions that a user is involved in.
	// Returns null if the user doesn't have any competitions.
	// user and competition state can be null.
	Competitions *CompetitionConnection `json:"competitions"`
	// When the user created their account.
	CreatedAt time.Time `json:"createdAt"`
	// The container for creator gifts the creator has. This will be null if the creator
	// does not have this feature enabled.
	CreatorGifting *CreatorGifting `json:"creatorGifting"`
	// Creator metrics for the given time period.
	CreatorMetricsByInterval *CreatorMetricsByInterval `json:"creatorMetricsByInterval"`
	// Get the user's referral links sorted by most recently created first. Will be a null CreatorReferralLinkConnection if the user is not eligible.
	CreatorReferralLinks *CreatorReferralLinkConnection `json:"creatorReferralLinks"`
	// Get the user's creator referral link statistics summary.
	CreatorReferralSummary *CreatorReferralSummary `json:"creatorReferralSummary"`
	// Paginated past activities for the Dashboard Activity Feed.
	// Always ordered by descending timestamp.
	DashboardActivityFeedActivities *DashboardActivityFeedActivityConnection `json:"dashboardActivityFeedActivities"`
	// Paginated past activities for the Dashboard Alert Queue.
	// Always ordered by descending timestamp.
	DashboardAlertQueueActivities *DashboardAlertQueueActivityConnection `json:"dashboardAlertQueueActivities"`
	// Preferences that control what alerts are sent to the user for the Dashboard Alert Queue.
	DashboardAlertQueuePreferences *DashboardAlertQueuePreferences `json:"dashboardAlertQueuePreferences"`
	// Timestamp when a user's account was deleted/disabled.
	DeletedAt *time.Time `json:"deletedAt"`
	// A user-provided blurb describing themselves.
	// Returns null when a description has not been set.
	Description *string `json:"description"`
	// The directories the user is currently set to broadcast in.
	Directories *UserDirectoryConnection `json:"directories"`
	// Lists the chat badges that should be displayed by the user's display name in
	// features like chat and whispers. If a channelID is passed in, fetches the
	// display badges that user will have in that channel's context.
	// Includes the following badges:
	// - global authority (staff/admin/global mod)
	// - channel authority (broadcaster/mod, if channelID is set)
	// - subscriber (if channelID is set)
	// - channel selected (bits) or global selected (prime, turbo, ...).
	DisplayBadges []*Badge `json:"displayBadges"`
	// A user-styled version of their login.
	// For international users, this could be the user's login with localized characters.
	DisplayName string `json:"displayName"`
	// A drop 2.0 campaign including personal settings (e.g. account connection status). (Viewer dashboard individual item).
	DropCampaign *DropCampaign `json:"dropCampaign"`
	// A list of all available Drops 2.0 Campaigns that a user is eligible to participate in. (Viewer dashboard list).
	DropCampaigns []*DropCampaign `json:"dropCampaigns"`
	// Fetch User's current session, which describes the minutes-watched progress towards a drop.
	DropCurrentSession *DropCurrentSession `json:"dropCurrentSession"`
	// A list of channels where the user is an editor.
	EditableChannels *EditableChannelConnection `json:"editableChannels"`
	// A list of channel editors.
	Editors *EditorConnection `json:"editors"`
	// The user's email address.
	// This is only returned if the request is authenticated by the same user who's email is requested.
	Email *string `json:"email"`
	// The emote sets this user is entitled to use.
	// If no domains are specified, all emote sets will be returned.
	// If multiple domains are specified, emotes that belong to either domain are returned (OR).
	// If this user is not the current user, it returns nil and a "forbidden" error.
	EmoteSets []*EmoteSet `json:"emoteSets"`
	// The channel's emoticon prefix settings.
	EmoticonPrefix *EmoticonPrefix `json:"emoticonPrefix"`
	// The list channels that have been endorsed by the user.
	EndorsedChannels *EndorsedChannelConnection `json:"endorsedChannels"`
	// A paginated list of user's all expired subscriptions.
	// Only resolves for the current user. Returns a forbidden error if requested for another user.
	ExpiredSubscriptions *ExpiredSubscriptionConnection `json:"expiredSubscriptions"`
	// Feature flags specific to this user.
	// Always returns nil.
	FeatureFlags *FeatureFlags `json:"featureFlags"`
	// A follow relationship between this user and the one which has the target ID or login.
	// Null if no relationship exists.
	Follow *Follow `json:"follow"`
	// Retrieves a list of games which the user is following.
	FollowedGames *FollowedGameConnection `json:"followedGames"`
	// A list of broadcasters this user follows, who are hosting other broadcasters.
	// Only resolves for the authenticated user.
	FollowedHosts *FollowedHostConnection `json:"followedHosts"`
	// A list of live-streaming broadcasters this user is following.
	// Only resolves for the authenticated user.
	// NOTE: the sort input parameter is not supported and should not be used.
	FollowedLiveUsers *FollowedLiveUserConnection `json:"followedLiveUsers"`
	// Retrieves recent/popular VODs from the streamers you follow.
	// If this isn't the `currentUser` this will return null.
	FollowedVideos *VideoConnection `json:"followedVideos"`
	// A paginated list of users which follow this user.
	Followers *FollowerConnection `json:"followers"`
	// A paginated list of users this user is following.
	Follows *FollowConnection `json:"follows"`
	// A list of this user's Twitch friends.
	// A maximum of 500 friends are returned, although most users have less than the maximum.
	// Only accessible if the user is authenticated with the `user_presence_friends_read` scope.
	Friends *FriendConnection `json:"friends"`
	// Notification connection information for a time range.
	GoLiveNotificationConnection *GoLiveNotificationConnection `json:"goLiveNotificationConnection"`
	// Notification information for a time range.
	GoLiveNotifications []*GoLiveNotification `json:"goLiveNotifications"`
	// Notifications timeseries analytics for a time range.
	GoLiveNotificationsTimeseries []*GoLiveNotificationTimeseries `json:"goLiveNotificationsTimeseries"`
	// Always returns false, will be deleted soon.
	HasBadgesTimedOut bool `json:"hasBadgesTimedOut"`
	// Whether this user has Twitch Presto.
	HasPresto *bool `json:"hasPresto"`
	// Whether this user has Twitch Prime.
	HasPrime bool `json:"hasPrime"`
	// Whether this user has streamed before.
	HasStreamed *bool `json:"hasStreamed"`
	// Whether this user has Twitch Turbo.
	HasTurbo bool `json:"hasTurbo"`
	// Whether this user has unread creator changelog items.
	HasUnreadChangelogItems *bool `json:"hasUnreadChangelogItems"`
	// A curated list of suggested channels to host.
	HostRecommendations []*User `json:"hostRecommendations"`
	// The users hosting this user.
	// This field only resolves for the authenticated user, otherwise resolves to null.
	HostedBy *HostConnection `json:"hostedBy"`
	// The user who this user is hosting.
	Hosting *User `json:"hosting"`
	// The user's unique identifier.
	ID string `json:"id"`
	// Returns a SHA-1 hash of the id field.
	IDSha1 string `json:"idSHA1"`
	// A list of open friend requests sent to this user. Friend requests from non-strangers are always placed in front of
	// friend requests from strangers; `sort` affects how the two components are ordered within themselves. Only accessible
	// if the user is authenticated with the `user_presence_friends_read` scope.
	IncomingFriendRequests *IncomingFriendRequestConnection `json:"incomingFriendRequests"`
	// A list of the squad stream invitations that the user has received.
	// Each invitation has a network type of either in-network or out-of-network. The invitations are sorted by creation
	// time, with the latest invitation first.
	// This field only resolves for the authenticated user.
	IncomingSquadStreamInvitations *SquadStreamInvitationConnection `json:"incomingSquadStreamInvitations"`
	// The list of extensions the user has installed.
	// installedExtensions gives a set of Extension installations, but does not include some of the information required
	// to render extensions.  For this, use extensionsForChannel instead, where you will get more accurate response, and
	// which includes fetched extension configuration and extension permissions.
	InstalledExtensions []*ExtensionInstallation `json:"installedExtensions"`
	// Items (crates, drops, etc.) the user owns.
	Inventory *Inventory `json:"inventory"`
	// A list of teams that the user has been invited to.
	// Only resolves for the current user.
	InvitedTeams []*Team `json:"invitedTeams"`
	// Whether or not the broadcaster is eligible for payout through twitch game commerce revenue share.
	IsCommerceRevShareEnabled bool `json:"isCommerceRevShareEnabled"`
	// Whether the user's Twitch account is connected to a Twitter account.
	// Returns nil if there was an error. This field is only accessible on the current user.
	IsConnectedToTwitter *bool `json:"isConnectedToTwitter"`
	// Whether or not the user has enabled their email to be reused to create another twitch account.
	IsEmailReusable bool `json:"isEmailReusable"`
	// Whether or not the user can update their email.
	IsEmailUpdateable bool `json:"isEmailUpdateable"`
	// Whether or not the user has verified their email address by clicking a link sent to their email.
	IsEmailVerified bool `json:"isEmailVerified"`
	// Indicates that the owner of the email on the account did not signup for this account
	// This mainly implies that the account is being deleted and not eligible for self service reactivation.
	IsFlaggedToDelete bool `json:"isFlaggedToDelete"`
	// Whether or not the user can moderate any broadcast chat.
	IsGlobalMod bool `json:"isGlobalMod"`
	// Whether or not the user is in good standing, granting automatic emote approval.
	// Passes both the authed twitch user who is requesting and the user they are requesting.
	// Applies to both affiliates and partners.
	IsInEmoteGoodStanding *bool `json:"isInEmoteGoodStanding"`
	// Whether or not the user is in good standing generally.
	// Authenticated to current user. Will error if not a partner.
	IsInGoodStanding bool `json:"isInGoodStanding"`
	// Whether the user meets the GDPR compliance as per his/her country's minimum compliance age.
	IsMinimumGDPRConsentAge bool `json:"isMinimumGDPRConsentAge"`
	// Whether or not the user is moderator of a another user's channel.
	IsModerator bool `json:"isModerator"`
	// Whether or not the user is a partnered broadcaster with Twitch.
	IsPartner *bool `json:"isPartner"`
	// Whether or not the user has verified their phone number.
	// This is currently always true if the user has a phone number.
	// We do not not allow a user to set a phone number without verifying.
	IsPhoneNumberVerified bool `json:"isPhoneNumberVerified"`
	// Whether or not the user is a site admininistrator.
	IsSiteAdmin bool `json:"isSiteAdmin"`
	// Whether or not the user is a Twitch staff member.
	IsStaff bool `json:"isStaff"`
	// The key pools associated with a user.
	KeyPools *KeyPoolConnection `json:"keyPools"`
	// The user's language preference.
	Language *Language `json:"language"`
	// The user's last broadcast.
	LastBroadcast *Broadcast `json:"lastBroadcast"`
	// When the user last updated their login name.
	// This special field only resolves for the authenticated user.
	LastLoginChangeAt *time.Time `json:"lastLoginChangeAt"`
	// The last time the user's availability or activity changed.
	// This special field only resolves for the authenticated user; use friends.edges.lastStatusChangeAt to retrieve this
	// information about friends..
	// Requires the `user_presence_friends_read` scope.
	LastStatusChangeAt *time.Time `json:"lastStatusChangeAt"`
	// Fetches the latest created Poll for the user.
	LatestPoll *Poll `json:"latestPoll"`
	// The extensions this user has shared their identity with.
	LinkedExtensions []*Extension `json:"linkedExtensions"`
	// The user's standard alphanumeric Twitch name.
	Login string `json:"login"`
	// The user's profile image.
	// Valid widths are 28, 50, 70, 150, 300, and 600.
	// The image height will be the same as the given width.
	LogoURL *string `json:"logoURL"`
	// Lists a User's Uploaded Loyalty Badge.
	LoyaltyBadges []*LoyaltyBadge `json:"loyaltyBadges"`
	// Returns the max number of channel rooms that the current user is allowed to
	// create for their channel.
	MaxAllowedChannelRooms int `json:"maxAllowedChannelRooms"`
	// Returns a resolver to query different subsets of the moderation logs.
	ModLogs *ModLogs `json:"modLogs"`
	// Returns all channel roles' access permissions to moderator logs.
	ModLogsAccess []*ModLogsAccess `json:"modLogsAccess"`
	// Returns a channel role's access permission to moderator logs.
	ModLogsRoleAccess *ModLogsAccess `json:"modLogsRoleAccess"`
	// A user's settings related to the moderation view page.
	ModViewSettings *ModViewSettings `json:"modViewSettings"`
	// Returns a paginated list of channel moderators.
	Mods *ModConnection `json:"mods"`
	// A user's event notification settings.
	NotificationSettings []*EventNotificationSetting `json:"notificationSettings"`
	// A user's notifications.
	// This is only returned if the request is authenticated by the same user whose onsite notifications are requested.
	// `language` is a letter code for the language the requesting user speaks (ex. "en").
	Notifications *OnsiteNotificationConnection `json:"notifications"`
	// OAuth applications developed by the current user.
	OauthApps *OAuthAppConnection `json:"oauthApps"`
	// A URL to the image that is displayed when the user is not broadcasting nor hosting another user's broadcast.
	OfflineImageURL *string `json:"offlineImageURL"`
	// Information about the current user's onboarding state.
	Onboarding *Onboarding `json:"onboarding"`
	// List of invites to join an organization.
	OrganizationInvites *OrganizationInviteUserConnection `json:"organizationInvites"`
	// Returns a list of developer organizations.
	// Returns null if the user doesn't belong to any organizations.
	Organizations []*Organization `json:"organizations"`
	// A list of open friend requests sent by this user. Friend requests to non-strangers are always placed in front of
	// friend requests to strangers; `sort` affects how the two components are ordered within themselves. Only accessible
	// if the user is authenticated with the `user_presence_friends_read` scope.
	OutgoingFriendRequests *OutgoingFriendRequestConnection `json:"outgoingFriendRequests"`
	// A list of teams owned by the user.
	// Only resolves for the current user.
	OwnedTeams []*Team `json:"ownedTeams"`
	// panels is a list of `Panel` objects with information related to this channel.
	Panels []Panel `json:"panels"`
	// Fetch participating challenges for the user based on a variety of sorting options.
	// By default returns 10 challenges, sorted by end time.
	ParticipatingChallenges *ChannelChallengeConnection `json:"participatingChallenges"`
	// Non-partnered users can submit a partnership application via createPartnershipApplication mutation.
	// PartnershipApplication includes the status of the most recently submitted application.
	PartnershipApplication *PartnershipApplication `json:"partnershipApplication"`
	// Whether or not the user is able to be paid.
	PayableStatus *PayableStatus `json:"payableStatus"`
	// Metrics that are relevant to incentive-based contracts for some partnered
	// streamers. This API returns a year-to-date, rolling list of the past 12
	// months and includes the current (in-progress) month.
	PaymentIncentiveMetrics []*PaymentIncentiveMetricsRollup `json:"paymentIncentiveMetrics"`
	// Holds configuration necessary to start payment method management. Only the authenticated user can access their own configs.
	// This is the second step of the payment method management flow.
	// (User.paymentMethods -> User.paymentMethodConfigs -> Mutation.setDefaultPaymentMethod).
	PaymentMethodConfigs *PaymentProviderConfigs `json:"paymentMethodConfigs"`
	// List of payment methods that will be used to pay for Twitch subscriptions that renew in the future
	// This is the first step of the payment method management flow.
	// (User.paymentMethods -> User.paymentMethodConfigs -> Mutation.setDefaultPaymentMethod).
	PaymentMethods []*PaymentMethod `json:"paymentMethods"`
	// Get user's list of payment transactions. This currently aggregates subscriptions related transactions but plans
	// to also aggregate other product types such as Bits. The ultimate goal is to record, aggregate, and provide the
	// payment history of Twitch users in a convenient way.
	PaymentTransactions *PaymentTransactionConnection `json:"paymentTransactions"`
	// Payout Information.
	Payout *Payout `json:"payout"`
	// Accrued balance since last payout.
	PayoutBalance *PayoutBalance `json:"payoutBalance"`
	// A user's invite into a payout program.
	PayoutInvite *PayoutInvite `json:"payoutInvite"`
	// List of payout plans a user has when enrolled in any payout programs.
	PayoutPlans []*PayoutPlan `json:"payoutPlans"`
	// Get the permitted terms of a user.
	PermittedTerms []*ChannelPermittedTerm `json:"permittedTerms"`
	// The user's phone number. Format is always in E.164 format.
	// This is only returned if the request is authenticated by the same user whose phone is requested.
	PhoneNumber *string `json:"phoneNumber"`
	// Fetch polls for the user based on a variety of sorting options.
	// By default returns 15 polls, sorted by start time.
	Polls *PollConnection `json:"polls"`
	// Options and preferences for how the user participates in Predictions Events.
	// Users can only view their own Predictions Settings.
	PredictionsSettings *UserPredictionSettings `json:"predictionsSettings"`
	// The amount of preroll free time in seconds that a user has earned on their channel.
	PrerollFreeTimeSeconds *int `json:"prerollFreeTimeSeconds"`
	// The hex string for the user's primary creator color.
	// Example: "FFFFFF".
	PrimaryColorHex *string `json:"primaryColorHex"`
	// The primary team this user belongs to. A user may belong to more than one team at the same time but must select a single
	// team as the primary. If the user doesn't have a primary team this will be null.
	PrimaryTeam *Team `json:"primaryTeam"`
	// Always returns null, will be removed soon.
	PrimePayoutDetails *PrimePayoutDetails `json:"primePayoutDetails"`
	// The prime payout details over a period of time for the user.
	PrimePayoutHistory []*PrimePayoutDetail `json:"primePayoutHistory"`
	// The Twitch Prime settings data for the user.
	PrimeSettings *PrimeSettings `json:"primeSettings"`
	// A URL to the user's profile image.
	// Valid widths are 28, 50, 70, 96, 150, 300, and 600.
	// The image height will be the same as the given width.
	ProfileImageURL *string `json:"profileImageURL"`
	// The URL to viewing this user's profile.
	// This is typically https://twitch.tv/<login> .
	ProfileURL string `json:"profileURL"`
	// The number of views this user's profile has received since creation.
	ProfileViewCount *int `json:"profileViewCount"`
	// The program agreement for a user enrolled in a payout program.
	ProgramAgreement *ProgramAgreement `json:"programAgreement"`
	// A user's pulse feed.
	// This is only returned if the request is authenticated by the same user whose email is requested.
	PulseFeed *Feed `json:"pulseFeed"`
	// PurchaseOrder returns a user's purchase order.
	PurchaseOrder *PurchaseOrder `json:"purchaseOrder"`
	// Quests associated with a user.
	Quests *Quests `json:"quests"`
	// Twitch Radio for the user.
	Radio *Radio `json:"radio"`
	// Twitch Radio account information.
	RadioAccount *RadioAccount `json:"radioAccount"`
	// Always returns null.
	Raid *Raid `json:"raid"`
	// Preferences for raid behavior, including whether
	// raids are enabled and from whom can raids orignate.
	// Users can only view their own raid settings.
	RaidSettings *RaidSettings `json:"raidSettings"`
	// An array of recent raids by the broadcaster.
	RecentRaids []*Raid `json:"recentRaids"`
	// The feedback a user has given about recommended content.
	RecommendationFeedback *RecommendationFeedbackConnection `json:"recommendationFeedback"`
	// Recommendations for the user. Recommendations can be retrieved only if the request
	// is authenticated and only for the authenticated user.
	Recommendations *Recommendations `json:"recommendations"`
	// The recommended prefix which is generated based on user name.
	RecommendedEmoticonPrefix string `json:"recommendedEmoticonPrefix"`
	// This user's relationship with another user.
	Relationship *UserRelationship `json:"relationship"`
	// User's declared country of residence.
	Residence *UserResidence `json:"residence"`
	// Info on rewarded video for a user (eligibility).
	RewardedVideo *RewardedVideo `json:"rewardedVideo"`
	// The roles this user fulfills on Twitch.
	Roles *UserRoles `json:"roles"`
	// Search through a paginated list of public and private videos for this user.
	SearchVideos *VideoConnection `json:"searchVideos"`
	// A list of streamer onboarding content IDs that that the user has been shown, and when it was first shown.
	SeenCreatorOnboardingContent []*CreatorOnboardingContent `json:"seenCreatorOnboardingContent"`
	// The badge this user has selected for global use on Twitch.
	SelectedBadge *Badge `json:"selectedBadge"`
	// The authenticated user's relationship with this user.
	Self *UserSelfConnection `json:"self"`
	// Loads the extension installation data for the queried userID's channel that is relevant to the calling user.
	// This includes the extension configuration data & auth tokens for the extension-channel-user combination.
	SelfInstalledExtensions []*ExtensionInstallationSelfEdge `json:"selfInstalledExtensions"`
	// The settings this user has on Twitch.
	Settings *UserSettings `json:"settings"`
	// The squad stream that this user is currently a member of, or null if the user is not a member of
	// any squad stream.
	SquadStream *SquadStream `json:"squadStream"`
	// squadStreamSettings are the user's rules and settings for the squad stream feature.
	// Some fields only resolve for the authenticated user. See schema definition for more detail.
	SquadStreamSettings *SquadStreamSettings `json:"squadStreamSettings"`
	// The relationship between the authenticated user and the single sign-on (SSO) apps they have linked to their Twitch account.
	SsoLinks []*SSOLink `json:"ssoLinks"`
	// The user's live stream.
	// Null if the user is not currently broadcasting.
	Stream *Stream `json:"stream"`
	// A list of the start and end times of stream sessions.
	StreamSessions []*StreamSession `json:"streamSessions"`
	// A list stream sessions that started and ended during the specified interval.
	StreamSessionsByInterval []*StreamSession `json:"streamSessionsByInterval"`
	// A list of stream summaries. Stream summaries provide analytics information
	// for a streaming session. Last started time is for querying sessions from a previous time stamp.
	StreamSummaries []*StreamSummary `json:"streamSummaries"`
	// Stucco packs displayed in the user's dashboard stucco settings.
	StuccoPacksBroadcaster []*StuccoPack `json:"stuccoPacksBroadcaster"`
	// stuccos available in the library in the user's dashboard stucco settings.
	Stuccos []*Stucco `json:"stuccos"`
	// A list of channels to which the user is subscribed.
	// Only resolves for the authenticated user.
	SubscribedChannels *SubscribedChannelConnection `json:"subscribedChannels"`
	// The subscription score of the user. Returns both a breakdown of subscriptions and points by tier.
	// Authenticated to the current user. Will be nil if the user is not a partner or affiliate.
	SubscriberScore *SubscriberScore `json:"subscriberScore"`
	// A paginated list of user's all active subscriptions.
	// Only resolves for the current user. Returns a forbidden error if requested for another user.
	SubscriptionBenefits *SubscriptionBenefitConnection `json:"subscriptionBenefits"`
	// A list of subscription products available for purchase on the user's page.
	SubscriptionProducts []*SubscriptionProduct `json:"subscriptionProducts"`
	// A list of subscription products available for purchase on the user's page, including handleable errors.
	SubscriptionProductsResult SubscriptionProductsResult `json:"subscriptionProductsResult"`
	// Subscription preferences for the current user.
	// Only resolves for the current user. Returns an error if request for another user.
	SubscriptionSettings *UserSubscriptionSettings `json:"subscriptionSettings"`
	// Subtoken information associated with the user.
	// Includes balance of tokens which can be used to redeem Subscriptions.
	SubscriptionToken *SubscriptionToken `json:"subscriptionToken"`
	// Analytics of the frequency of tags used in discovery.
	TagAnalytics []*TagAnalytic `json:"tagAnalytics"`
	// Tags are used as a discovery and search mechanism for channels.
	// The tag data is from Graffiti directly. Graffiti is not designed to handle huge traffic.
	// Please use Stream.tags instead if know the stream is live and you can accept a 5 min delay in the data.
	// For example, you should use Stream.tags for the channel page and the browse page, but use User.tags for the dashboard.
	Tags []*Tag `json:"tags"`
	// A list of UserTeamMemberships which includes all the teams the user is a member of.
	// This includes the primary team.
	// Only resolves for the current user.
	TeamMemberships []*UserTeamMembership `json:"teamMemberships"`
	// Retrieves all the statistics within the start and end time broken down by granularity.
	// Default endAt time will be the current time (now).
	// Granularity defaults to 5 minutes.
	TimeseriesStats *TimeseriesStats `json:"timeseriesStats"`
	// Tournament associated with the user. This is used with the Bits custom cheering experience.
	Tournament *Tournament `json:"tournament"`
	// The user's relationship with Twitch.
	Twitch *UserTwitchConnection `json:"twitch"`
	// Get unacknowledged subscription events.
	UnacknowledgedSubscriptionEvents []*UnacknowledgedSubscriptionEvent `json:"unacknowledgedSubscriptionEvents"`
	// When the user last updated their account.
	// Returns null when the user's account has never been updated.
	UpdatedAt *time.Time `json:"updatedAt"`
	// Verification request object for the user and an associated contact address.
	// If no address is provided, the current email address associated with the user account will be used.
	VerificationRequest *VerificationRequest `json:"verificationRequest"`
	// Aggregated analytics for several video referral sources, for use in channel analytics.
	VideoPlayReferrals *VideoPlayReferrals `json:"videoPlayReferrals"`
	// A paginated list of video shelves to display on the user's channel.
	VideoShelves *VideoShelfConnection `json:"videoShelves"`
	// A paginated list of video shelves that are available to be displayed on the
	// user's channel. Only accessible for authorized users (user & editors).
	VideoShelvesAvailable *VideoShelfConnection `json:"videoShelvesAvailable"`
	// A paginated list of videos for this user.
	Videos *VideoConnection `json:"videos"`
	// The viewable poll for a channel.
	// Null if no viewable poll is present.
	ViewablePoll *Poll `json:"viewablePoll"`
	// A paginated list of viewed videos and their histories for this user.
	// Only resolves for current user.
	ViewedVideos *ViewedVideosConnection `json:"viewedVideos"`
	// A paginated list of channel VIPs.
	Vips *VIPConnection `json:"vips"`
	// A user's balances in their Twitch Wallet in different FIAT currencies
	// If this isn't the `currentUser` this will return null.
	WalletBalances *WalletBalances `json:"walletBalances"`
	// A list of restrictions that prevent a user from hosting Watch Parties. A
	// user can only host Watch Parties if there are no restrictions.
	WatchPartiesRestrictions []WatchPartiesRestriction `json:"watchPartiesRestrictions"`
	// A Watch Party if the User is currently broadcasting one.
	WatchParty *WatchPartyResult `json:"watchParty"`
	// Settings related to the Whispers (private user-to-user messaging) feature.
	// Only resolves for the authenticated user.
	WhisperSettings *WhisperSettings `json:"whisperSettings"`
	// A paginated list of whisper threads for the current user, sorted by recent first.
	WhisperThreads *WhisperThreadConnection `json:"whisperThreads"`
	// Withholding Tax Detail is the withholding tax rates for the creator.
	WithholdingTaxDetail *WithholdingTaxDetail `json:"withholdingTaxDetail"`
}

func (User) IsPredictionEventActor()      {}
func (User) IsTaggedContent()             {}
func (User) IsOnsiteNotificationContent() {}
func (User) IsFragmentContent()           {}
func (User) IsTitleTokenNode()            {}
func (User) IsFeaturedItemContent()       {}
func (User) IsPersonalSectionTitleToken() {}

// Groups users account health information around security of their account.
type UserAccountHealth struct {
	// Is the user required to reset their password.
	IsPasswordResetRequired bool `json:"isPasswordResetRequired"`
	// Is the users email address verified.
	IsVerifiedEmail bool `json:"isVerifiedEmail"`
	// Current status of the users password.
	PasswordStatus PasswordStatus `json:"passwordStatus"`
	// The list of Two factor Methods the user has registered with.
	// Empty list means the user does not have two factor.
	TwoFactorMethods []TwoFactorMethod `json:"twoFactorMethods"`
}

// The relationship between the user and Amazon.
type UserAmazonConnection struct {
	// The Amazon associates store linked to this user.
	AssociatesStore *AssociatesStore `json:"associatesStore"`
}

// The edge between a User and a Blizzard connection.
type UserBlizzardConnectionLink struct {
	// Returns battletag if available. Can be string or nil.
	BattleTag *string `json:"battleTag"`
}

// Exactly one of the identifiers must be specified.
type UserByAttribute struct {
	// The human-readable identifier for a clip.
	// When specified, returns the broadcaster of the clip.
	BroadcasterOfClipSlug *string `json:"broadcasterOfClipSlug"`
	// The user's login.
	Login *string `json:"login"`
	// The identifier for a video collection.
	// When specified, returns the owner of the collection.
	OwnsCollectionID *string `json:"ownsCollectionID"`
	// The identifier for a video.
	// When specified, returns the owner of the video.
	OwnsVideoID *string `json:"ownsVideoID"`
}

// Filtering criteria for paginated user clips results.
type UserClipsInput struct {
	// The ID of the broadcaster to filter results by.
	BroadcasterID *string `json:"broadcasterID"`
	// The ID of the curator to filter results by.
	CuratorID *string `json:"curatorID"`
	// DEPRECATED: `filter` should no longer be used. Prefer `period` and `sort` instead.
	// A filter which restricts results.
	Filter *ClipsFilter `json:"filter"`
	// The name of the game to filter results by.
	GameName *string `json:"gameName"`
	// The time period to restrict clips based on creation time.
	Period *ClipsPeriod `json:"period"`
	// The sort order for the clips results.
	Sort *ClipsSort `json:"sort"`
}

// Paginated list of Users, where the relationship between the source type and the User is
// generic enough that no information needs to be encoded on the edge.
type UserConnection struct {
	Edges    []*UserEdge `json:"edges"`
	PageInfo *PageInfo   `json:"pageInfo"`
	// The total number of users.
	TotalCount *int `json:"totalCount"`
}

// The connection between a user and the directories they have selected to broadcast in.
type UserDirectoryConnection struct {
	// The directories selected by this user.
	Nodes []Directory `json:"nodes"`
}

// A list of Drops awarded to the user. // deprecated.
type UserDropAwardConnection struct {
	// The Drops awarded to the user.
	Nodes []*DropAward `json:"nodes"`
	// The number of drop awards a user has received.
	TotalCount *int `json:"totalCount"`
}

// A list of Drops awarded to the user via Drops2.0.
type UserDropReward struct {
	// The DropBenefit that a user is entitled to.
	Benefit *DropBenefit `json:"benefit"`
	// The game that awarded the Drop.
	Game *Game `json:"game"`
	// The assigned ID of the awarded reward.
	ID string `json:"id"`
	// The image URL of the Benefit. Images are 80x80 pixels.
	ImageURL string `json:"imageURL"`
	// Flag if the user is connected to the game in order to receive the Reward.
	IsConnected bool `json:"isConnected"`
	// Specifies if this reward is considered for a game that is available on iOS.
	IsIosAvailable bool `json:"isIosAvailable"`
	// The timestamp when the Benefit was last awarded to the user.
	LastAwardedAt time.Time `json:"lastAwardedAt"`
	// The developer-provided name of the awarded Benefit.
	Name string `json:"name"`
	// Link where the user can connect their account necessary to receive the reward.
	RequiredAccountLink string `json:"requiredAccountLink"`
	// The number of drop awards a user has received.
	TotalCount int `json:"totalCount"`
}

// Generic edge between some type and a User, where there is no information that needs to
// to be encoded on the edge.
type UserEdge struct {
	Cursor *string `json:"cursor"`
	Node   *User   `json:"node"`
}

// The edge between a User and a Facebook connection.
type UserFacebookConnectionLink struct {
	// The user's full name on Facebook. eg. "John Doe".
	FullName string `json:"fullName"`
}

// UserLeaderboard contains a leaderboard whose entries are Users.
type UserLeaderboard struct {
	// id is the id of this leaderboard.
	ID string `json:"id"`
	// items is the list of users in the leaderboard ordered by their score.
	Items *UserLeaderboardItemConnection `json:"items"`
	// myPosition contains the item representing the authed user's position on this leaderboard.
	MyPosition *UserLeaderboardItem `json:"myPosition"`
	// SecondsRemaining is the number of seconds left before the leaderboard expires (or zero for all-time).
	SecondsRemaining int `json:"secondsRemaining"`
}

// UserLeaderboardItem at a specific node in a leaderboard connection.
type UserLeaderboardItem struct {
	// id the id of this leaderboard item.
	ID string `json:"id"`
	// rank the ordinal rank of this leaderboard item.
	Rank int `json:"rank"`
	// score the numerical value by which this leaderboard is sorted.
	Score int `json:"score"`
	// user is the user that holds this position.
	User *User `json:"user"`
}

// UserLeaderboardItemConnection is used to show the various leaderboard items.
type UserLeaderboardItemConnection struct {
	// edges ...
	Edges []*UserLeaderboardItemEdge `json:"edges"`
	// pageInfo ...
	PageInfo *PageInfo `json:"pageInfo"`
}

// UserLeaderboardItemEdge describes an edge in a bits leaderboard.
type UserLeaderboardItemEdge struct {
	// The cursor for this leaderboard edge.
	Cursor string `json:"cursor"`
	// The leaderboard entry at this edge.
	Node *UserLeaderboardItem `json:"node"`
}

// Options and preferences for how the user participates in Predictions Events.
// Users can only view their own Predictions Settings.
type UserPredictionSettings struct {
	// Whether the user has accepted the latest Predictions Terms of Service.
	HasAcceptedTos bool `json:"hasAcceptedTOS"`
	// Whether the user is in a region that is restricted from participation in making predictions.
	IsInRestrictedRegion *bool `json:"isInRestrictedRegion"`
	// Whether the user has opted to display a temporary chat badge indicating their choices during Predictions Events.
	IsTemporaryChatBadgeEnabled bool `json:"isTemporaryChatBadgeEnabled"`
}

// Statistics concerning how a user has performed when making Predictions in a given channel.
type UserPredictionStatistics struct {
	// The total number of events that this user has participated in on this channel.
	EventsTotal int `json:"eventsTotal"`
	// The number of events that this user has successfully predicted in this channel.
	EventsWon int `json:"eventsWon"`
	// The most recent prediction made by this user on this channel. Null if they have not made a Prediction recently.
	MostRecentPrediction *Prediction `json:"mostRecentPrediction"`
	// The total number of points that this user has spent making predictions in this channel.
	PointsUsed int `json:"pointsUsed"`
	// The total number of points that this user has won from correct predictions in this channel.
	PointsWon int `json:"pointsWon"`
	// The highest number of points that this user has won from a correct prediction in this channel.
	PointsWonMax int `json:"pointsWonMax"`
	// The user's current win-streak in Events on this channel.
	WinStreak int `json:"winStreak"`
	// The highest win-streak in Events on this channel the user has ever had.
	WinStreakMax int `json:"winStreakMax"`
}

// Subjective data on a User (user/channel) for the target user.
type UserRelationship struct {
	// The time when a follower relationship between the user and the target user was established.
	FollowedAt *time.Time `json:"followedAt"`
	// Statistics concerning how well the target user has performed in Prediction Events on the user's channel.
	PredictionStatistics *UserPredictionStatistics `json:"predictionStatistics"`
	// The subscription benefit relationship between the user and the target user.
	// Null if the user is not subscribed to the other user.
	SubscriptionBenefit *SubscriptionBenefit `json:"subscriptionBenefit"`
	// Subscription tenure data for the user to the target user.
	SubscriptionTenure *SubscriptionTenure `json:"subscriptionTenure"`
}

// User's residence.
type UserResidence struct {
	// Country in ISO alpha-2.
	CountryCode string `json:"countryCode"`
	// Postal code.
	PostalCode *string `json:"postalCode"`
}

// The edge between a User and a Youtube Connection.
type UserRiotConnectionLink struct {
	// The PUUID for the user's Riot account.
	ID string `json:"id"`
}

// Groups site-wide user roles together.
type UserRoles struct {
	// Whether or not the user is enrolled in the affiliate program.
	// See https://affiliate.twitch.tv for more information.
	IsAffiliate *bool `json:"isAffiliate"`
	// Whether or not the user is allowed to approve extensions on Twitch.
	IsExtensionsApprover *bool `json:"isExtensionsApprover"`
	// Whether or not the user is enrolled in the extensions developer program.
	// See https://dev.twitch.tv/docs/extensions/onboarding for more information.
	IsExtensionsDeveloper *bool `json:"isExtensionsDeveloper"`
	// Whether or not the user can moderate any broadcast chat.
	IsGlobalMod *bool `json:"isGlobalMod"`
	// Whether or not the user is a partnered broadcaster with Twitch.
	IsPartner *bool `json:"isPartner"`
	// Whether or not the user is a site admininistrator.
	IsSiteAdmin *bool `json:"isSiteAdmin"`
	// Whether or not the user is a Twitch staff member.
	IsStaff *bool `json:"isStaff"`
}

// UserSelfBitsBadge contains the current user's badge tier in a channel and progress toward the next tier.
// NOTE: should probably have been named CurrentUserBitsBadge.
type UserSelfBitsBadge struct {
	// current is the highest bits chat badge the authenticated user has achieved in this channel.
	// If a badge tier is disabled after being earned it will still appear here until the next tier is earned.
	// If the user hasn't earned any bits badges yet this will be null.
	Current *Badge `json:"current"`
	ID      string `json:"id"`
	// next is the next chat badge the authenticated user can earn in this channel.
	// If this is null then there are no higher tiers to earn.
	Next *Badge `json:"next"`
	// nextBits is the bits value of the next chat badge the authenticated user can earn in this channel.
	// If this is null then there are no higher tiers to earn.
	NextBits *int `json:"nextBits"`
	// progress is the fraction of the way the user is toward the next badge tier [0.0-1.0).
	// If `next` is null this will be zero.
	Progress float64 `json:"progress"`
	// tierNotification represents a notification sent to a user when they have achieved
	// a new bits badge in a channel. Used to send a special message.
	// If no notification is pending this will be null.
	TierNotification *BitsBadgeTierNotification `json:"tierNotification"`
	// totalBits is the number of bits the authenticated user has used in this channel.
	TotalBits int `json:"totalBits"`
}

// Subjective data on another User (user/channel) for the current user.
type UserSelfConnection struct {
	// The badges which are available for the authenticated user to select for use on another user's streams and videos.
	AvailableBadges []*Badge `json:"availableBadges"`
	// Ban status of the authenticated user with respect to this user's channel.
	BanStatus *ChatRoomBanStatus `json:"banStatus"`
	// bitsBadge contains information about bits badge progression in a channel.
	// This field can only be requested if an OAuth token is supplied with the request.
	BitsBadge *UserSelfBitsBadge `json:"bitsBadge"`
	// The bits leaderboard entry shows the current user's entry in the
	// channel's leaderboard. It does not show context entries around it.
	BitsLeaderboardEntry *BitsLeaderboardEntry `json:"bitsLeaderboardEntry"`
	// The bits leaderboard item shows the current user's entry in the
	// channel's leaderboard. It does not show context entries around it.
	BitsLeaderboardItem *BitsLeaderboardItem `json:"bitsLeaderboardItem"`
	// The bits leaderboard position shows the curreent users rank
	// and the surrounding users in the current channel.
	BitsLeaderboardPosition *BitsLeaderboard `json:"bitsLeaderboardPosition"`
	// Whether or not the authenticated user can follow this user.
	CanFollow bool `json:"canFollow"`
	// CanGift relationship between the authenticated user, another user, and a product.
	// True is the authenticated user can gift the product to the other user.
	CanGift bool `json:"canGift"`
	// CanGiftInChannel relationship between the authenticated user and a product.
	// True is the authenticated user is allowed to send gifts in this channel.
	CanGiftInChannel bool `json:"canGiftInChannel"`
	// Checks if the authenticated user can subscribe to this channel via Prime.
	CanPrimeSubscribe bool `json:"canPrimeSubscribe"`
	// Whether the authenticated user has permission to redeem a subscription to this Channel.
	// Return Values are.
	// 1) Null - The Channel to which the User is subscribed to is not supporting any subscription redemption.
	// 2) False - The User has already utilized their redemption to the channel offering subscription redemption.
	// 2) True - The User can use the subscription redemption offered by the channel.
	CanRedeemSubscription *bool `json:"canRedeemSubscription"`
	// The list of celebration products available for the authenticated user to purchase in this channel.
	CelebrationProducts []*CelebrationProduct `json:"celebrationProducts"`
	// If the authenticated user cannot chat in this channel, a list of reasons.
	// Null if the user can chat.
	ChatRestrictedReasons []ChatRestrictedReason `json:"chatRestrictedReasons"`
	// Lists the chat badges that should be displayed by the user's display name in
	// features on a particular user's channel (i.e. chat, feeds).
	// Includes the following badges:
	// - global authority (staff/admin/global mod)
	// - channel authority (broadcaster/mod)
	// - subscriber
	// - channel selected (bits) or global selected (prime, turbo, ...).
	DisplayBadges []*Badge `json:"displayBadges"`
	// A follower relationship between the authenticated user and another user.
	// Null if the relationship does not exist.
	Follower *FollowerEdge `json:"follower"`
	// The friendship-type relationship (friendship, incoming friend request, outgoing friend request) between the
	// authenticated user and another user. Null if no friendship-type relationship exists.
	Friendship FriendRelationship `json:"friendship"`
	// True if the authenticated user has joined this channel.
	IsChannelMember *bool `json:"isChannelMember"`
	// Whether or not the authenticated user is editor of another user's channel.
	IsEditor *bool `json:"isEditor"`
	// Whether or not the authenticated user is a founder badge owner of another user's channel.
	IsFounder *bool `json:"isFounder"`
	// Whether or not the authenticated user is a moderator of another user's channel.
	IsModerator *bool `json:"isModerator"`
	// Whether or not the authenticated user is a VIP of another user's channel.
	IsVip *bool `json:"isVIP"`
	// The timestamp of the last time the authenticated user sent a chat message in another user's channel within the last 30 minutes.
	// Null if the authenticated user has not chatted in the channel in the last 30 minutes.
	LastRecentChatMessageAt *time.Time `json:"lastRecentChatMessageAt"`
	// Which treatment the user should receive for the gifting pay it forward private callout.
	PayItForwardTreatment *PayItForwardTreatmentType `json:"payItForwardTreatment"`
	// Information about the authenticated user's Prime subscription credit benefit.
	PrimeSubCreditBenefit *PrimeSubCreditBenefit `json:"primeSubCreditBenefit"`
	// The most recent resub token to use for sending a special message.
	// If no notification is pending this will be null.
	ResubNotification *ResubNotification `json:"resubNotification"`
	// Lists ritual tokens that can be requested or displayed to the user in another user's channel.
	RitualTokens []*RitualToken `json:"ritualTokens"`
	// The badge the authenticated user selected for use on another user's streams and videos.
	SelectedBadge *Badge `json:"selectedBadge"`
	// Stucco packs that are available to viewers of a broadcaster.
	StuccoPacksViewer []*StuccoPack `json:"stuccoPacksViewer"`
	// The current subscriber badge that a user would have if subscribed & remaining locked subscriber badges with progress.
	SubscriberBadgeProgress []*SubscriberBadgeProgress `json:"subscriberBadgeProgress"`
	// The subscription benefit relationship between the authenticated user and another user.
	// Null if the authenticated user is not subscribed to the other user.
	SubscriptionBenefit *SubscriptionBenefit `json:"subscriptionBenefit"`
	// The number of gift subscriptions that the authenticated user has given to other users in this channel.
	SubscriptionGiftCount *int `json:"subscriptionGiftCount"`
	// Subscription tenure data for the user to this channel.
	SubscriptionTenure *SubscriptionTenure `json:"subscriptionTenure"`
	// Whether the authenticated user can send or receive Whispers to/from another user.
	WhisperPermissions *WhisperPermissions `json:"whisperPermissions"`
}

// Groups site-wide user settings together.
type UserSettings struct {
	// Whether the user is whitelisted to host Prime Video watch parties. This
	// takes precedence over user.watchPartiesRestrictions.
	CanHostWatchParties bool `json:"canHostWatchParties"`
	// The user's channel feed on/off switch.
	// The channel feed is displayed if set to true and is
	// hidden if set to false.
	ChannelFeedEnabled bool `json:"channelFeedEnabled"`
	// The cheer settings for a user, configured in their partner dashboard.
	Cheer *CheerPartnerSettings `json:"cheer"`
	// Whether or not the user has a second authentication method configured.
	HasTwoFactorEnabled *bool `json:"hasTwoFactorEnabled"`
	// Whether or not the broadcaster is eligible for payout through Amazon retail revenue share.
	IsAmazonRetailRevShareEnabled *bool `json:"isAmazonRetailRevShareEnabled"`
	// Whether or not the broadcaster is eligible for payout through twitch game commerce revenue share.
	IsCommerceRevShareEnabled *bool `json:"isCommerceRevShareEnabled"`
	// Whether or not the user has requested that their registration date be hidden in the viewer card.
	IsCreateDateHidden *bool `json:"isCreateDateHidden"`
	// Whether or not the user has elected to be hidden from search results.
	IsDirectoryHidden *bool `json:"isDirectoryHidden"`
	// Whether or not the email was successfully reverted.
	IsEmailRevertSuccess *bool `json:"isEmailRevertSuccess"`
	// Whether the user's channel has rituals enabled.
	IsRitualsEnabled bool `json:"isRitualsEnabled"`
	// Whether the user's channel is whitelisted into the rituals experiment.
	IsRitualsWhitelisted bool `json:"isRitualsWhitelisted"`
	// The user's activity sharing setting.
	// Activity is the part of a user's status that shows what they're currently playing, watching, or streaming.
	// Requires the `user_presence_friends_read` scope.
	IsSharingActivity bool `json:"isSharingActivity"`
	// Partner settings related to leaderboards.
	Leaderboard *LeaderboardSettings `json:"leaderboard"`
	// The user's preferred language tag for displaying text content.
	PreferredLanguageTag *LanguageTag `json:"preferredLanguageTag"`
	// The user's shared availability while online.
	// A value of ONLINE (typically called "invisibility") additionally means that the user's activity will not be shared
	// regardless of the isSharingActivity setting.
	// Requires the `user_presence_friends_read` scope.
	Visibility Visibility `json:"visibility"`
}

// The edge between a User and a Steam connection.
type UserSteamConnectionLink struct {
	// A Steam user ID.
	ID string `json:"id"`
}

// UserSubscriptionSettings displays the users subscription settings.
type UserSubscriptionSettings struct {
	// If the user only wants to receive gifts to channels they follow.
	GiftsToFollowedChannelsOnly bool `json:"giftsToFollowedChannelsOnly"`
	// If the user wants to hide Badge Modifier.
	IsBadgeModifierHidden bool `json:"isBadgeModifierHidden"`
	// If the user wants to hide their Founder Badges.
	IsFounderBadgesHidden bool `json:"isFounderBadgesHidden"`
	// If the user wants to hide the number of gifts they've gifted.
	IsGiftCountHidden bool `json:"isGiftCountHidden"`
	// If the user wants to hide their subscription tenure and status in the chat viewer card.
	IsSubscriptionStatusHidden bool `json:"isSubscriptionStatusHidden"`
}

// UserTeamMembership represents a User's membership to a Twitch Team.
// UserTeamMemberships are collections of teams that the User is a part of.
type UserTeamMembership struct {
	// Whether the team is the primary team for the given User.
	IsPrimary bool `json:"isPrimary"`
	// Whether the team is revenue revealed for the given User.
	IsRevenueRevealed bool `json:"isRevenueRevealed"`
	// Whether the team is stats revealed for the given User.
	IsStatsRevealed bool `json:"isStatsRevealed"`
	// The Team the user is a member of.
	Team *Team `json:"team"`
}

// The relationship between the user and Twitch.
type UserTwitchConnection struct {
	// Returns the User's preferred team in Overwatch League.
	OverwatchLeagueTeamPreference *OverwatchLeagueTeamPreference `json:"overwatchLeagueTeamPreference"`
}

// The edge between a User and a Twitter connection.
type UserTwitterConnectionLink struct {
	// A Twitter username, without the "@" (eg. "Twitch").
	Username string `json:"username"`
}

// The edge between a User and a Youtube Connection.
type UserYoutubeConnectionLink struct {
	// The URL for the user's Youtube channel.
	ChannelURL string `json:"channelURL"`
}

// Paginated list of VIP users of a channel.
type VIPConnection struct {
	// The elements of the list.
	Edges []*VIPEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Element in a list of VIP users of a channel.
type VIPEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// Timestamp of when the VIP status was granted.
	GrantedAt time.Time `json:"grantedAt"`
	// The user who has the VIP status.
	Node *User `json:"node"`
}

// Error that occurred while validating with code.
type ValidateVerificationCodeError struct {
	// Error code for error that occurred while validating with code.
	Code *ValidateVerificationCodeErrorCode `json:"code"`
}

// ValidateVerificationCodeInput is input required to verify a user contact method in EVS by validating their verification code.
type ValidateVerificationCodeInput struct {
	// Address that the user is verifying. This will most likely be an email address or phone number.
	Address string `json:"address"`
	// Code used to validate if the verification request is valid.
	Code string `json:"code"`
	// Key for the entity associated with the address. This is generally the Twitch ID of the user.
	Key string `json:"key"`
}

// ValidateVerificationCodePayload is the VerificationRequest document returned from EVS on success.
type ValidateVerificationCodePayload struct {
	// Mutation error based on user input.
	Error *ValidateVerificationCodeError `json:"error"`
	// The updated verification request.
	Request *VerificationRequest `json:"request"`
}

// VendorConsentStatus is the consent status of each vendor.
type VendorConsentStatus struct {
	// User consentStatus for this vendor.
	ConsentStatus ConsentStatus `json:"consentStatus"`
	// A flag that shows if the consent is given by the user or by consent service as default value.
	HasUserSetConsent bool `json:"hasUserSetConsent"`
	// A flag that shows if the vendor should be visible to the consent settings page.
	IsVisible bool `json:"isVisible"`
	// Vendor name.
	Name VendorName `json:"name"`
}

// VendorConsentStatusInput is the input struct for vendor consent status.
type VendorConsentStatusInput struct {
	// Consent status of this vendor.
	ConsentStatus ConsentStatus `json:"consentStatus"`
	// name of the vendor.
	Name VendorName `json:"name"`
}

// Represents a user's request to verify a given contact method, such as email address or phone number.
type VerificationRequest struct {
	// Address that the user is verifying. This will most likely be an email address or phone number.
	Address string `json:"address"`
	// Key for the entity associated with the address. This is generally the Twitch ID of the user.
	Key string `json:"key"`
	// Time at which the verification request was last modified.
	Modified time.Time `json:"modified"`
	// Status of the verification request: pending, verified, or rejected.
	Status VerificationStatus `json:"status"`
}

// VerifyContactMethodInput is input required to verify a user contact method in EVS by their opaque ID.
type VerifyContactMethodInput struct {
	// Used to validate the associated user contact info.
	OpaqueID string `json:"opaqueID"`
}

// VerifyContactMethodPayload is the VerificationRequest document returned from EVS on success.
type VerifyContactMethodPayload struct {
	// The success/failure of the verification attempt.
	IsSuccess bool `json:"isSuccess"`
	// The updated verification request.
	Request *VerificationRequest `json:"request"`
}

// Error returned during a invalid user request.
type VerifyOneTimePasswordError struct {
	// Error code returned by the backend.
	Code VerifyOneTimePasswordErrorCode `json:"code"`
	// The localized external error message.
	Message string `json:"message"`
}

// The required input for a VerifyOneTimePasswordInput mutation.
type VerifyOneTimePasswordInput struct {
	// The one time password that needs to be verified.
	OneTimePassword string `json:"oneTimePassword"`
	// The ID of the user attempting to verify a one time password.
	UserID string `json:"userID"`
}

// The result of a verifyOneTimePassword mutation.
type VerifyOneTimePasswordPayload struct {
	// error code and localized error.
	Error *VerifyOneTimePasswordError `json:"error"`
}

// Error that occurred while validating with captcha token.
type VerifyRewardedVideoEligibilityCaptchaError struct {
	// Error code for error that occurred while validating the captcha token.
	Code VerifyRewardedVideoEligibilityCaptchaErrorCode `json:"code"`
}

// Inputs for registering a Captcha for WATEB.
type VerifyRewardedVideoEligibilityCaptchaInput struct {
	// Whether we authenticated with V1 or V2 Arkose endpoint.
	ArkoseEndpointVersion ArkoseEndpointVersion `json:"arkoseEndpointVersion"`
	// The token response from Arkose to verify.
	SessionToken string `json:"sessionToken"`
}

// The response from verifying a captcha with rewarded video systems.
type VerifyRewardedVideoEligibilityCaptchaPayload struct {
	// The error (if one exists) returned from validating the captcha token.
	Error *VerifyRewardedVideoEligibilityCaptchaError `json:"error"`
}

// A container of content for a vertical grouped by shelves.
type VerticalDirectory struct {
	// The vertical's unique Twitch identifier.
	ID string `json:"id"`
	// List of shelf groups containing content for this vertical.
	ShelfGroups []*VerticalShelfGroup `json:"shelfGroups"`
	// The subtitle for the shelf group.
	Subtitle *ShelfTitle `json:"subtitle"`
	// The title for the shelf.
	Title *ShelfTitle `json:"title"`
	// Used in client tracking.
	TrackingID string `json:"trackingID"`
}

// An ordered list of content to render with metadata on the content.
type VerticalShelf struct {
	// The ordered content for the shelf.
	Content *ShelfContentConnection `json:"content"`
	// The one or more contexts for which this shelf contains content for.
	ContentContext []VerticalContentContext `json:"contentContext"`
	// A unique identifier for the shelf.
	ID string `json:"id"`
	// The subtitle for the shelf group.
	Subtitle *ShelfTitle `json:"subtitle"`
	// The title for the shelf.
	Title *ShelfTitle `json:"title"`
	// Used in client tracking.
	TrackingID string `json:"trackingID"`
	// The type of this shelf.
	Type VerticalShelfType `json:"type"`
}

// A grouping of one or more shelves.
type VerticalShelfGroup struct {
	// The one or more contexts for which this shelf group contains content for.
	ContentContext []VerticalContentContext `json:"contentContext"`
	// A unique identifer for this shelf group.
	ID string `json:"id"`
	// The ordered shelves for this shelf group.
	Shelves []*VerticalShelf `json:"shelves"`
	// The subtitle for the shelf group.
	Subtitle *ShelfTitle `json:"subtitle"`
	// The title for the shelf group.
	Title *ShelfTitle `json:"title"`
	// Used in client tracking.
	TrackingID string `json:"trackingID"`
}

// A container of content for a vertical by category, grouped by shelves.
type VerticalSubDirectory struct {
	// The one or more contexts for which this directory contains content for.
	ContentContext []VerticalContentContext `json:"contentContext"`
	// The vertical's unique Twitch identifier.
	ID string `json:"id"`
	// List of shelf groups containing content for this vertical category.
	ShelfGroups []*VerticalShelfGroup `json:"shelfGroups"`
	// The subtitle for the shelf group.
	Subtitle *ShelfTitle `json:"subtitle"`
	// The title for the shelf.
	Title *ShelfTitle `json:"title"`
	// Used in client tracking.
	TrackingID string `json:"trackingID"`
}

// The content context of a subdirectory.
type VerticalSubDirectoryContentContext struct {
	// The subdirectory content context category ids.
	CategoryIDs []string `json:"categoryIDs"`
	// The subdirectory content context tag ids.
	TagIDs []string `json:"tagIDs"`
}

type Video struct {
	// A link to an image which contains an animated preview of the video.
	AnimatedPreviewURL *string `json:"animatedPreviewURL"`
	// A list of bookmarks for this video.
	Bookmarks *VideoBookmarkConnection `json:"bookmarks"`
	// The type of broadcast the video originated from.
	BroadcastType *BroadcastType `json:"broadcastType"`
	// A paginated list of clips for this video.
	// When criteria is not specified, the default values are used.
	Clips *ClipConnection `json:"clips"`
	// A paginated list of comments against this video.
	Comments *VideoCommentConnection `json:"comments"`
	// A list of tags describing the video.
	ContentTags []*Tag `json:"contentTags"`
	// The time the video metadata record was created.
	CreatedAt *time.Time `json:"createdAt"`
	// The user who created this video.
	// This will be either the broadcaster or one of their editors.
	Creator *User `json:"creator"`
	// NOTE: named `deleteAt` in Vinyl.
	DeletedAt *time.Time `json:"deletedAt"`
	// A description of the video, formatted in markdown.
	Description *string `json:"description"`
	// The length of the video.
	Duration *string `json:"duration"`
	// The game the video is depicting.
	Game *Game `json:"game"`
	// The video's identifier.
	ID string `json:"id"`
	// Whether the video has been soft deleted.
	IsDeleted bool `json:"isDeleted"`
	// Which language the video is in.
	Language *string `json:"language"`
	// The length of the video, as an int, in seconds.
	LengthSeconds *int `json:"lengthSeconds"`
	// A list of moments for this video.
	Moments *VideoMomentConnection `json:"moments"`
	// Publicly available muted segment info, detailing which parts of the video
	// have had audio removed.
	MuteInfo *VideoMuteInfo `json:"muteInfo"`
	// For highlights, the number of seconds offset from the beginning of the past broadcast the highlight starts.
	// For past broadcasts and uploads, this means nothing.
	OffsetSeconds *int `json:"offsetSeconds"`
	// The owner of the video.
	Owner *User `json:"owner"`
	// The playback access token that determines whether the user can watch the video.
	// Fetched for both authed and unauthed users.
	PlaybackAccessToken *PlaybackAccessToken `json:"playbackAccessToken"`
	// The URL to the thumbnail which should be displayed for the video.
	// If either `height` or `width` are not given, a templated value (i.e. `{height}`, `{width}`) will be present in the URL instead.
	PreviewThumbnailURL string `json:"previewThumbnailURL"`
	// The time when the archive/highlight/upload was first ever available to public,
	// even if it is not currently public.
	PublishedAt *time.Time `json:"publishedAt"`
	// The reactions associated with this video.
	Reactions []*Reaction `json:"reactions"`
	// The time the video was recorded.
	RecordedAt *time.Time `json:"recordedAt"`
	// The reason a video is restricted if the given video is a restricted video.
	// For a video that is not restricted, this field can be null.
	ResourceRestriction *ResourceRestriction `json:"resourceRestriction"`
	// The reason a video is restricted if the given video is a restricted video.
	// For a video that is not restricted, this field can be null.
	Restriction *VideoRestriction `json:"restriction"`
	// Either PRIVATE or PUBLIC.
	Scope *VideoPrivacyScope `json:"scope"`
	// A link to a sprite sheet image made up of preview thumbnails when seeking the video timeline.
	SeekPreviewsURL *string `json:"seekPreviewsURL"`
	// The authenticated user's relationship with this video.
	Self *VideoSelfEdge `json:"self"`
	// When broadcastType is:
	// - ARCHIVE: status goes from RECORDING to RECORDED.
	// - HIGHLIGHT: status goes from UNPROCESSED to RECORDED.
	// - UPLOAD: status goes from CREATED to UPLOADING, to PENDING_TRANSCODE, to RECORDED, or FAILED if anything goes wrong.
	// - PREMIERE_UPLOAD: status goes from CREATED to UPLOADING, to PENDING_TRANSCODE, to RECORDED, or FAILED if anything goes wrong for this legacy broadcast type.
	// - PAST_PREMIERE: status goes from RECORDING to RECORDED for this legacy broadcast type.
	Status *VideoStatus `json:"status"`
	// The suggested details for creating an automated highlight from this video.
	SuggestedHighlight *VideoSuggestedHighlight `json:"suggestedHighlight"`
	// An array of tags describing the video. This field will be deprecated soon. Please use `Video.contentTag` instead.
	Tags []*string `json:"tags"`
	// A list of thumbnail URLs for the video, ordered by descending priority.
	// Owners can insert custom thumbnails into this list.
	// If either `height` or `width` are not given, a templated value (i.e. `{height}`, `{width}`) will be present in the URL instead.
	ThumbnailURLs []*string `json:"thumbnailURLs"`
	// The title of the video.
	Title *string `json:"title"`
	// A paginated list of clips featuring this vod that is, by default, ordered by view count descending.
	// When criteria is not specified, the default values are used.
	TopClips *ClipConnection `json:"topClips"`
	// The most recent time the video data was updated.
	UpdatedAt *time.Time `json:"updatedAt"`
	// The numer of views this video has. Can be delayed by up to 15 minutes.
	ViewCount *int `json:"viewCount"`
	// For a scheduled video, the time when the video will be made available to the
	// public (the time when the scope will be automatically set to "public").
	// For a video that is public or not scheduled, is null.
	ViewableAt *time.Time `json:"viewableAt"`
}

func (Video) IsTaggedContent()                 {}
func (Video) IsOnsiteNotificationContent()     {}
func (Video) IsPostEmbed()                     {}
func (Video) IsShareTarget()                   {}
func (Video) IsPremiereItem()                  {}
func (Video) IsCollectionItem()                {}
func (Video) IsVideoShelfItem()                {}
func (Video) IsReactableContent()              {}
func (Video) IsFeedEmbed()                     {}
func (Video) IsRecommendationFeedbackContent() {}
func (Video) IsShelfContent()                  {}
func (Video) IsFeedItemContent()               {}
func (Video) IsFeaturedItemContent()           {}

// A video bookmark.
type VideoBookmark struct {
	// channel the VOD belongs to.
	Channel *User `json:"channel"`
	// Time at which the bookmark was created.
	CreatedAt time.Time `json:"createdAt"`
	// Description of the bookmark.
	Description string `json:"description"`
	// ID of the bookmark.
	ID string `json:"id"`
	// Relative offset in the video.
	PositionSeconds int `json:"positionSeconds"`
	// user who created the bookmark.
	User *User `json:"user"`
}

// A paginated list of video bookmarks.
type VideoBookmarkConnection struct {
	// The elements of the paginated list.
	Edges []*VideoBookmarkEdge `json:"edges"`
	// Error of the get video bookmarks request.
	Error *VideoBookmarkConnectionError `json:"error"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// VideoBookmarkConnectionError is the error associated with a getVideoBookmarks.
type VideoBookmarkConnectionError struct {
	// The associated error code.
	Code *VideoBookmarkConnectionErrorCode `json:"code"`
}

// A video bookmark.
type VideoBookmarkEdge struct {
	// Uniquely identifies this clip's position in a connection.
	Cursor string `json:"cursor"`
	// The bookmark.
	Node *VideoBookmark `json:"node"`
}

// Comment on a video.
type VideoComment struct {
	// Author of the comment.
	Commenter *User `json:"commenter"`
	// Position of the video where this comment was added.
	ContentOffsetSeconds int `json:"contentOffsetSeconds"`
	// The time the comment was created.
	CreatedAt time.Time `json:"createdAt"`
	// The comments's unique identifier.
	ID string `json:"id"`
	// The message of the comment.
	Message *VideoCommentMessage `json:"message"`
	// DEPRECATED. List of replies on this comment.
	Replies *VideoCommentConnection `json:"replies"`
	// Where the comment originated.
	Source VideoCommentSource `json:"source"`
	// Current state of the comment.
	State VideoCommentState `json:"state"`
	// The last time this comment was updated.
	UpdatedAt time.Time `json:"updatedAt"`
	// The video on which this comment was added.
	Video *Video `json:"video"`
}

func (VideoComment) IsOnsiteNotificationContent() {}

// Paginated list of comments.
type VideoCommentConnection struct {
	Edges    []*VideoCommentEdge `json:"edges"`
	PageInfo *PageInfo           `json:"pageInfo"`
}

// Video comment edge with cursor and the comment node.
type VideoCommentEdge struct {
	Cursor *string       `json:"cursor"`
	Node   *VideoComment `json:"node"`
}

// Represents the message of a comment.
type VideoCommentMessage struct {
	// Parts of the message body with meta info.
	Fragments []*VideoCommentMessageFragment `json:"fragments"`
	// List of badges the comment author had selected for use at the time of the comment.
	UserBadges []*Badge `json:"userBadges"`
	// Text color preferences of comment's author.
	UserColor *string `json:"userColor"`
}

// Represents a part of the message body with meta info.
type VideoCommentMessageFragment struct {
	// Embedded emote info.
	Emote *EmbeddedEmote `json:"emote"`
	// User which was mentioned.
	Mention *User `json:"mention"`
	// Raw text of the comment.
	Text string `json:"text"`
}

// A paginated list of videos, and its metadata.
type VideoConnection struct {
	// The list of videos in this page.
	Edges []*VideoEdge `json:"edges"`
	// Information about this page of videos.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of videos in the larger collection.
	TotalCount *int `json:"totalCount"`
}

func (VideoConnection) IsPersonalSectionChannelContent() {}

// Optional input to filter videos.
// Add any additional optional fields to this input.
type VideoConnectionOptionsInput struct {
	// The IDs of any categories that should be included in the results.
	GameIDs []string `json:"gameIDs"`
	// Whether unpublished (private) videos should be returned. Will only be returned for the currently authenticated user. Defaults to false.
	IncludePrivate *bool `json:"includePrivate"`
	// The maximum length in seconds of any videos returned.
	MaxLengthSeconds *int `json:"maxLengthSeconds"`
	// The minimum length in seconds of any videos returned.
	MinLengthSeconds *int `json:"minLengthSeconds"`
	// The ending creation date of any videos returned (not inclusive).
	SearchRangeEndAt *time.Time `json:"searchRangeEndAt"`
	// The starting creation date of any videos returned (not inclusive).
	SearchRangeStartAt *time.Time `json:"searchRangeStartAt"`
}

// A Video Connection Search input to set params to include search term.
type VideoConnectionSearchParams struct {
	// The search term to filter video results by.
	Term *string `json:"term"`
}

// An element in a paginated list of videos, and its metadata.
type VideoEdge struct {
	Cursor *string `json:"cursor"`
	Node   *Video  `json:"node"`
}

// Video Ingest Session Metadata for the current or past broadcasts.
type VideoIngestSession struct {
	// Stream session metadata related to broadcaster's backup ingest session.
	BackupIngestSession *BackupIngestSession `json:"backupIngestSession"`
	// Bitrates of session by time. Recorded every 3 to 5 seconds.
	Bitrates []*StreamBitrate `json:"bitrates"`
	// Broadcaster of the stream.
	Broadcaster *User `json:"broadcaster"`
	// Recorded framedrop events in stream session.
	FrameDrops []*IngestFrameDrop `json:"frameDrops"`
	// Framerates of session by time. Recorded every 3 to 5 seconds.
	Framerates []*StreamFramerate `json:"framerates"`
	// The ID of the stream ingest session.
	ID string `json:"id"`
	// Stream session metadata related to broadcaster's ingest session.
	IngestSession *IngestSession `json:"ingestSession"`
	// Stream session metadata related to broadcaster's RTMP session.
	RtmpSession *RTMPSession `json:"rtmpSession"`
	// Recorded starvation events in stream session.
	StarvationEvents []*IngestStarvationEvent `json:"starvationEvents"`
	// Set of codes to indicate what is wrong with ingested stream.
	StreamHealth *IngestStreamHealth `json:"streamHealth"`
	// Stream session metadata related to broadcaster's transcode session.
	TranscodeSessions []*TranscodeSession `json:"transcodeSessions"`
}

// A video moment represents either a point in time, or a duration of time,
// during which structured metadata is present.
type VideoMoment struct {
	// channel the VOD belongs to.
	Channel *User `json:"channel"`
	// Time at which the moment was created.
	CreatedAt time.Time `json:"createdAt"`
	// The displayable context of this moment (translated, where applicable). For
	// instance, the stream marker comment, game name for game change, or “Pack opening”
	// for Hearthstone VCA. Can be null.
	Description *string `json:"description"`
	// A union of the fields that are specific to individual moments, such as Game Mode
	// inside Hearthstone VCA data.
	Details VideoMomentDetails `json:"details"`
	// The duration, in ms, that this moment is applicable, or zero if no duration.
	DurationMilliseconds int `json:"durationMilliseconds"`
	// ID of the moment.
	ID string `json:"id"`
	// Moments that cover a time range can also contain moments for that time range.
	Moments *VideoMomentConnection `json:"moments"`
	// The time, in ms, after the start of the video when this moment occurs.
	PositionMilliseconds int `json:"positionMilliseconds"`
	// The additional displayable context of this moment (translated, where applicable).
	// Can be null.
	SubDescription *string `json:"subDescription"`
	// The url to the thumbnail for this moment.
	// Can be null.
	ThumbnailURL *string `json:"thumbnailURL"`
	// The underlying moment type.
	Type VideoMomentType `json:"type"`
	// The id of the video this moment is contained in.
	Video *Video `json:"video"`
}

// A paginated list of video moments.
type VideoMomentConnection struct {
	// The elements of the paginated list.
	Edges []*VideoMomentEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// A video moment.
type VideoMomentEdge struct {
	// Uniquely identifies this moment's position in the connection.
	Cursor string `json:"cursor"`
	// The moment.
	Node *VideoMoment `json:"node"`
}

// Details about automatic mutes applied to this video.
type VideoMuteInfo struct {
	// List of segments muted.
	MutedSegmentConnection *VideoMutedSegmentConnection `json:"mutedSegmentConnection"`
}

// Information about one contiguous muted portion of video.
type VideoMutedSegment struct {
	// Duration in seconds of the mute. Standard length is 360 (6 mins).
	Duration int `json:"duration"`
	// Offset is how many seconds into the video the mute begins. May be 0.
	Offset int `json:"offset"`
}

// A list of all sections of the video that are muted.
// If pagination is required at any point in the future, put edges and pageInfo
// in this type.
type VideoMutedSegmentConnection struct {
	// No pagination functionality. All data returned in initial call.
	Nodes []*VideoMutedSegment `json:"nodes"`
}

type VideoOEmbed struct {
	AuthorName   *string          `json:"authorName"`
	AuthorURL    *string          `json:"authorURL"`
	CacheAge     *int             `json:"cacheAge"`
	Height       int              `json:"height"`
	HTML         string           `json:"html"`
	InputURL     string           `json:"inputURL"`
	ProviderName *string          `json:"providerName"`
	ProviderURL  *string          `json:"providerURL"`
	Thumbnail    *ThumbnailOEmbed `json:"thumbnail"`
	Title        *string          `json:"title"`
	Type         string           `json:"type"`
	Version      string           `json:"version"`
	Width        int              `json:"width"`
}

func (VideoOEmbed) IsOEmbed()    {}
func (VideoOEmbed) IsPostEmbed() {}
func (VideoOEmbed) IsFeedEmbed() {}

// Options to include private videos.
type VideoOptions struct {
	IncludePrivate *bool `json:"includePrivate"`
}

// The required configuration to activate a video overlay extension.
type VideoOverlayActivationInput struct {
	// The slot name of where the component extension should be displayed.
	Slot string `json:"slot"`
}

// VideoOverlayView holds the view configuration of an extension if the videoOverlay anchor is supported.
type VideoOverlayView struct {
	// Specifies whether or not the extension has the ability to link to external websites.
	CanLinkExternalContent bool `json:"canLinkExternalContent"`
	// Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
	ViewerPath string `json:"viewerPath"`
	// The URL which should be loaded in for the extension.
	ViewerURL string `json:"viewerURL"`
}

func (VideoOverlayView) IsExtensionView() {}

// VideoOverlayViewInput holds the view configuration of an extension if the videoOverlay anchor is supported.
type VideoOverlayViewInput struct {
	// Relative path of the HTML file to load for this view.
	ViewerPath string `json:"viewerPath"`
}

// Endpoints for different video referral sources, based on channel and time range.
type VideoPlayReferrals struct {
	// The referral groups and respective counts.
	Items []*AggregatedReferrals `json:"items"`
	// Sum of all referrals for a given date range.
	Total int `json:"total"`
}

// Restrictions for viewing of a video. Resolves if a video is restricted, null otherwise.
type VideoRestriction struct {
	// The product "short name" a user needs to purchase to view the video.
	ProductName string `json:"productName"`
	// The name of the product shown to users.
	ProductTitle string `json:"productTitle"`
	// The reason a video is restricted.
	Reason string `json:"reason"`
	// The type of restriction the video has.
	Type string `json:"type"`
}

// The relationship between the authenticated user and a video.
type VideoSelfEdge struct {
	// Can a user watch a restricted video.
	IsRestricted bool `json:"isRestricted"`
	// User's viewing history against a video.
	ViewingHistory *VideoViewingHistory `json:"viewingHistory"`
}

// A video shelf contains items (clips, videos) from a user to display on their videos page.
type VideoShelf struct {
	// The associated collection if the shelf items are from a specified collection.
	Collection *Collection `json:"collection"`
	// A description of what the video shelf contains.
	Description *string `json:"description"`
	// The associated game with the shelf if the items are from a specified game.
	Game *Game `json:"game"`
	// ID of the video shelf.
	ID string `json:"id"`
	// Videos/clips in the video shelf.
	Items []VideoShelfItem `json:"items"`
	// The title of the video shelf.
	Title string `json:"title"`
	// The type of items the video shelf contains.
	Type VideoShelfType `json:"type"`
}

// A paginated list of video shelves with metadata.
type VideoShelfConnection struct {
	// The list of video shelves available.
	Edges []*VideoShelfEdge `json:"edges"`
	// The max number of shelves configuration.
	MaxShelfCount *int `json:"maxShelfCount"`
	// Information about this page of video shelves.
	PageInfo *PageInfo `json:"pageInfo"`
	// The total number of shelves available.
	TotalCount int `json:"totalCount"`
}

// A video shelf.
type VideoShelfEdge struct {
	// Cursor represents the position of the current edge/node.
	Cursor string `json:"cursor"`
	// Uniquely identifies this video shelf's position in a connection.
	Node *VideoShelf `json:"node"`
}

// Video stream settings for ingesting a stream such as stream key, latency mode, or vod save preference.
// Represents a user's channel setting when starting a streamm.
type VideoStreamSettings struct {
	// A list of Twitch users who are authorized to stream on behalf of a broadcaster.
	AuthorizedUsers []*User `json:"authorizedUsers"`
	// A list of stream keys to be used for backup redundant stream.
	BackupStreamKeys []StreamKeyResult `json:"backupStreamKeys"`
	// The number of seconds delay for a stream. When this is set, a stream will be ingested with specified delay in seconds.
	DelaySeconds int `json:"delaySeconds"`
	// The number of seconds to display the disconnect slate while the stream is unstable.
	DisconnectSlateDurationSeconds int `json:"disconnectSlateDurationSeconds"`
	// When isBackupEnabled is true, streamers can stream a backup stream using the streamkey on backupStreamKeys.
	IsBackupEnabled bool `json:"isBackupEnabled"`
	// When isDelayEnabled is true, streamers can stream with specified delay seconds on delaySeconds.
	IsDelayEnabled bool `json:"isDelayEnabled"`
	// When isDisconnectSlateEnabled is true, streams will show a disconnect slate for the period specified on delaySeconds when a stream disconnects temporarily.
	IsDisconnectSlateEnabled bool `json:"isDisconnectSlateEnabled"`
	// Whether or not a stream should be started as a low latency stream.
	IsLowLatency bool `json:"isLowLatency"`
	// Whether or not the broadcaster prefers to archive the vod for a stream.
	ShouldArchiveVODs bool `json:"shouldArchiveVODs"`
	// The RTMP stream key for the user's channel. This key is required to stream a video to Twitch.
	StreamKey StreamKeyResult `json:"streamKey"`
}

// Details about creating an automated highlight from this video.
type VideoSuggestedHighlight struct {
	// Boolean for whether this set of suggested segments were addressed and dismissed.
	IsDismissed bool `json:"isDismissed"`
	// List of suggested video segments.
	Segments []*VideoSuggestedSegment `json:"segments"`
	// Status of the segments.
	Status *SegmentsStatusType `json:"status"`
}

// Information for one suggested video segment.
type VideoSuggestedSegment struct {
	// Ending time of the suggested segment in milliseconds.
	EndMs int `json:"endMS"`
	// Starting time of the suggested segment in milliseconds.
	StartMs int `json:"startMS"`
}

// Filtering criteria for paginated video top clips results.
type VideoTopClipsInput struct {
	// The ID of the curator to filter results by.
	CuratorID *string `json:"curatorID"`
	// The time period to restrict clips based on creation time.
	Period *ClipsPeriod `json:"period"`
	// The sort order for the clips results.
	Sort *ClipsSort `json:"sort"`
}

// User's viewing history against a video. All fields are null if no viewing history is available.
type VideoViewingHistory struct {
	// Position in seconds since the start of the video.
	Position *int `json:"position"`
	// When the viewing history was last updated.
	UpdatedAt *time.Time `json:"updatedAt"`
}

type ViewedNotificationsPayload struct {
	// The modified user which contains an updated OnsiteNotificationsSummary.
	User *User `json:"user"`
}

// A paginated list of viewed videos, their histories, and metadata.
type ViewedVideosConnection struct {
	// The list of videos and their viewing histories in this page.
	Edges []*ViewedVideosEdge `json:"edges"`
}

// An element in a paginated list of viewing histories, and its metadata.
type ViewedVideosEdge struct {
	// Viewing history of user against the video.
	History *VideoViewingHistory `json:"history"`
	// Video this viewing history belongs to.
	Node *Video `json:"node"`
}

// Input for Visit Stream Manager.
type VisitStreamManagerInput struct {
	// The channel ID of the stream manager visited.
	ChannelID string `json:"channelID"`
}

// Payload returned from Visit Stream Manager call.
type VisitStreamManagerPayload struct {
	// The channel ID of the stream manager visited.
	ChannelID *string `json:"channelID"`
	// The success/failure of the client.
	IsSuccess *bool `json:"isSuccess"`
	// The viewer ID trying to view the stream manager.
	ViewerID *string `json:"viewerID"`
}

// Vote in poll error.
type VoteInAdPollError struct {
	// Code describing the error.
	Code VoteInAdPollErrorCode `json:"code"`
}

// Inputs for voting on an ad poll.
type VoteInAdPollInput struct {
	// The id of the choice the vote is casted on in the poll.
	ChoiceID string `json:"choiceID"`
	// The id of the poll that is being voted in.
	PollID string `json:"pollID"`
	// The voter id of the voter.
	UserID string `json:"userID"`
	// The unique id for this vote action.
	VoteID string `json:"voteID"`
}

// Output from the vote on poll mutation.
type VoteInAdPollPayload struct {
	// If present, there was an error with the request.
	Error *VoteInAdPollError `json:"error"`
	// The voter objet returned by the vote operation.
	Vote *AdPollVote `json:"vote"`
}

// Inputs for voting on a poll by choice index.
// Poll id and choice id are retrieved from the backend, before sending the vote.
type VoteInPollByChoiceIndexInput struct {
	// The id of the channel the vote is being cast in.
	ChannelID string `json:"channelID"`
	// Important: The ***ONE INDEXED*** (NOT ZERO INDEXED) position of the choice that is chosen in the poll.
	ChoiceIndex int `json:"choiceIndex"`
	// The tokens used for this vote.
	Tokens *PollVoteTokensInput `json:"tokens"`
	// The user id of the voter.
	UserID string `json:"userID"`
	// The unique id for this vote action.
	VoteID string `json:"voteID"`
}

// Output from the vote on poll by choice index mutation.
type VoteInPollByChoiceIndexPayload struct {
	// If present, there was an error with the request.
	Error *VoteInPollError `json:"error"`
	// The voter objet returned by the vote operation.
	Voter *PollVoter `json:"voter"`
}

// Vote in poll error.
type VoteInPollError struct {
	// Code describing the error.
	Code VoteInPollErrorCode `json:"code"`
}

// Inputs for voting on a poll.
type VoteInPollInput struct {
	// The id of the choice the vote is casted on in the poll.
	ChoiceID string `json:"choiceID"`
	// The id of the poll that is being voted in.
	PollID string `json:"pollID"`
	// The tokens used for this vote.
	Tokens *PollVoteTokensInput `json:"tokens"`
	// The user id of the voter.
	UserID string `json:"userID"`
	// The unique id for this vote action.
	VoteID string `json:"voteID"`
}

// Output from the vote on poll mutation.
type VoteInPollPayload struct {
	// If present, there was an error with the request.
	Error *VoteInPollError `json:"error"`
	// The voter object returned by the vote operation.
	Voter *PollVoter `json:"voter"`
}

// Twitch Wallet Balances in multiple FIAT currencies. Can be used to purchase
// product on the Twitch Platform.
type WalletBalances struct {
	// List of all Balances that a Twitch User has on their account.
	AllBalances []*Balance `json:"allBalances"`
	// Currencies that an Twitch User is currently eligible to use.
	EligibleCurrencies []Currency `json:"eligibleCurrencies"`
}

// Contains all information for Prime Video Watch Parties.
type WatchParty struct {
	// Enum representing the restrictions on this Watch Party.
	ContentRestriction WatchPartyContentRestriction `json:"contentRestriction"`
	// Option Watch Party decoration.
	Decoration *WatchPartyDecoration `json:"decoration"`
	// The catalog item id played for this watch party.
	Gti string `json:"gti"`
	// Unique ID of the watch party.
	ID string `json:"id"`
	// Progress of the current state, null for offline watch parties.
	Progress *WatchPartyProgress `json:"progress"`
	// Current state of the watch party.
	State WatchPartyState `json:"state"`
	// Current title of the watch party.
	Title string `json:"title"`
	// CCVs for the watch party.
	ViewersCount int `json:"viewersCount"`
}

// Decoration information for a Watch Party.
type WatchPartyDecoration struct {
	// Fully decorated item for a watch party.
	Item *WatchPartyItem `json:"item"`
	// Authenticated: filled in only if the user is authorized to watch the content.
	Player *WatchPartyPlayer `json:"player"`
}

// Information to communicate to the user about an error state.
type WatchPartyError struct {
	// Error code.
	Code WatchPartyErrorCode `json:"code"`
}

// Contains all fields needed to render a watch party item.
type WatchPartyItem struct {
	// String representing the age rating.
	ContentRating *string `json:"contentRating"`
	// Enum representing the restrictions on this item. When available, defer to
	// the Watch Party content restriction.
	ContentRestriction WatchPartyContentRestriction `json:"contentRestriction"`
	// Additional details based on the item type.
	Details WatchPartyItemDetails `json:"details"`
	// List of genres.
	Genres []string `json:"genres"`
	// Whether or not this item has children content.
	HasChildren bool `json:"hasChildren"`
	// Unique GTI.
	ID string `json:"id"`
	// If the content is mature.
	IsMature bool `json:"isMature"`
	// If this is a child, ID of the parent.
	ParentID *string `json:"parentID"`
	// Link to continue watching on PV.
	PrimeVideoLink *string `json:"primeVideoLink"`
	// Prime video rating.
	PrimeVideoRating *PrimeVideoRating `json:"primeVideoRating"`
	// Null if user is logged out, contains eligibility information.
	Self *WatchPartyItemSelfEdge `json:"self"`
	// List of actors and actresses.
	Starring []string `json:"starring"`
	// Localized summary.
	Summary *string `json:"summary"`
	// Localized box art.
	ThumbnailURL string `json:"thumbnailURL"`
	// Localized title.
	Title string `json:"title"`
	// Video content type, i.e. episode or series.
	Type WatchPartyItemType `json:"type"`
	// Publication year.
	YearPublished *int `json:"yearPublished"`
}

// Watch party items, returned in a query.
type WatchPartyItemConnection struct {
	// One item per edge.
	Edges []*WatchPartyItemEdge `json:"edges"`
	// Used for user authentication errors.
	Error *WatchPartyError `json:"error"`
	// Amazon link.
	HomepageBrowseLink string `json:"homepageBrowseLink"`
	// Pagination info.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Represents a single item for a watch party.
type WatchPartyItemEdge struct {
	// Cursor to continue querying from here.
	Cursor string `json:"cursor"`
	// Item information.
	Node *WatchPartyItem `json:"node"`
}

// Contains information about viewer eligibility, likely to change.
type WatchPartyItemEligibility struct {
	// Whether the viewer can watch this content.
	CanView bool `json:"canView"`
	// Localized string explaining why if canView is false.
	Reason *string `json:"reason"`
}

// Options for querying for catalog items. These fields are mutually exclusive
// and parentID will take precedent if both are specified.
type WatchPartyItemSearchOptions struct {
	// Parameter to query for a parent's children items.
	ParentID *string `json:"parentID"`
	// Search for content based on the input string.
	SearchQuery *string `json:"searchQuery"`
}

// Used for upselling Prime, populated from authentication or geotoken.
type WatchPartyItemSelfEdge struct {
	// Info about whether or not the user can view this piece of content.
	Eligibility *WatchPartyItemEligibility `json:"eligibility"`
	// True if the content is PV gated and we will upsell.
	WillShowPrimeUpsell bool `json:"willShowPrimeUpsell"`
}

// Contains information needed to initialize a PV player and play content.
type WatchPartyPlayer struct {
	// Device Proxy URL to initialize the PV player.
	DeviceProxyBaseURL string `json:"deviceProxyBaseURL"`
	// Parameters to initialize the PV player.
	SdkInit string `json:"sdkInit"`
	// Token to initialize the PV player.
	Token string `json:"token"`
}

// Tracks the current state.
type WatchPartyProgress struct {
	// Total duration of the current state.
	DurationSeconds int `json:"durationSeconds"`
	// Current position in seconds of the state.
	PositionSeconds int `json:"positionSeconds"`
	// Wall clock time for the start of the current state.
	Start time.Time `json:"start"`
}

// Wrapper to allow passing back errors.
type WatchPartyResult struct {
	// Used for user authentication errors.
	Error *WatchPartyError `json:"error"`
	// Can be null if the channel is offline or for authentication errors.
	Session *WatchParty `json:"session"`
}

type Watching struct {
	// This activity's type, i.e. "WATCHING".
	Type *ActivityType `json:"type"`
	// The user whose stream is being watched.
	User *User `json:"user"`
}

func (Watching) IsActivity() {}

// A message sent in a whisper thread.
type WhisperMessage struct {
	// Content of the message.
	Content *MessageBody `json:"content"`
	// Time the message was deleted.
	DeletedAt *time.Time `json:"deletedAt"`
	// Time the message was edited.
	EditedAt *time.Time `json:"editedAt"`
	// User that sent the message.
	From *User `json:"from"`
	// UUID of the message.
	ID string `json:"id"`
	// Unique nonce.
	Nonce *string `json:"nonce"`
	// Time the message was sent.
	SentAt time.Time `json:"sentAt"`
	// The thread the message is a part of.
	Thread *WhisperThread `json:"thread"`
}

// Paginated list of messages in a thread.
type WhisperMessageConnection struct {
	// The elements of the list.
	Edges []*WhisperMessageEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Element in a list of messages.
type WhisperMessageEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// The whisper message.
	Node *WhisperMessage `json:"node"`
}

// The ability for a Twitch user to send or receive Whispers to/from another Twitch user.
type WhisperPermissions struct {
	// If send is NOT_PERMITTED, true if the reason is that the other Twitch user is considered a stranger.
	IsStrangerBlocked bool `json:"isStrangerBlocked"`
	// Capability of the user to receive Whispers from the other Twitch user.
	Receive *WhisperPermissionType `json:"receive"`
	// Capability of the user to send Whispers to the other Twitch user.
	Send *WhisperPermissionType `json:"send"`
}

// Settings related to the Whispers (private user-to-user messaging) feature.
type WhisperSettings struct {
	// If true, disallows strangers from initiating a whisper thread to this user.
	IsBlockingWhispersFromStrangers bool `json:"isBlockingWhispersFromStrangers"`
	// If true, this user is disallowed from sending or receiving whisper messages.
	IsWhisperBanned bool `json:"isWhisperBanned"`
}

// Spam classification data for a message.
type WhisperSpamInfo struct {
	// Time user last marked the thread as not spam.
	LastMarkedNotSpamAt *time.Time `json:"lastMarkedNotSpamAt"`
	// Spam classification score.
	Likelihood *WhisperSpamLikelihood `json:"likelihood"`
}

// A conversation between two users.
type WhisperThread struct {
	// ID of the whisper thread.
	ID string `json:"id"`
	// Whether the thread has been archived.
	IsArchived bool `json:"isArchived"`
	// Whether the user has muted the thread.
	IsMuted bool `json:"isMuted"`
	// The last message sent in this thread. Null if no messages in this thread.
	LastMessage *WhisperMessage `json:"lastMessage"`
	// List of messages in the thread.
	Messages *WhisperMessageConnection `json:"messages"`
	// List of users in the thread.
	Participants []*User `json:"participants"`
	// Spam data about the thread.
	SpamInfo *WhisperSpamInfo `json:"spamInfo"`
	// Number of whispers that have not been read by the user in the thread.
	UnreadMessagesCount int `json:"unreadMessagesCount"`
	// Last message read by the user in the thread.
	UserLastMessageRead *WhisperMessage `json:"userLastMessageRead"`
	// Timestamp of when the other participant may message the user in the thread.
	WhitelistedUntil *time.Time `json:"whitelistedUntil"`
}

// Paginated list of whisper threads.
type WhisperThreadConnection struct {
	// The elements of the list.
	Edges []*WhisperThreadEdge `json:"edges"`
	// Information about this page.
	PageInfo *PageInfo `json:"pageInfo"`
	// Total number of whisper threads.
	TotalCount int `json:"totalCount"`
	// Total number of whisper threads containing unread messages for the current user.
	TotalUnreadCount *int `json:"totalUnreadCount"`
}

// Element in a list of whisper threads.
type WhisperThreadEdge struct {
	// Opaque cursor describing this edge's position in the paginated list.
	Cursor string `json:"cursor"`
	// The whisper thread.
	Node *WhisperThread `json:"node"`
}

// Withholding Tax Detail is the withholding tax rates for the creator.
type WithholdingTaxDetail struct {
	// Government royalty tax rate applied to user's earnings.
	RoyaltyTaxRate float64 `json:"royaltyTaxRate"`
	// Government service tax rate applied to user's earnings.
	ServiceTaxRate float64 `json:"serviceTaxRate"`
}

// Contains configuration used to setup checkout via Xsolla, a payment provider.
type Xsolla struct {
	// Iframe URL to allow purchase checkout. This can be an empty string if the URL cannot be generated.
	IframeURL string `json:"iframeURL"`
	// Indicates if the token is for Xsolla's sandbox environment.
	IsSandbox bool `json:"isSandbox"`
	// Access token to allow purchase checkout. This can be an empty string if the token cannot be generated.
	Token string `json:"token"`
}

type XsollaConfigs struct {
	// Iframe URL to allow payment method management or purchase checkout
	// There are various cases in which this can be null. One example during
	// subscription purchase checkout flow is if there is an issue with the
	// Xsolla product mapping to the product in Twitch's system.
	IframeURL string `json:"iframeURL"`
	// Access token to allow purchase checkout. This can be an empty string if the token cannot be generated.
	Token string `json:"token"`
	// Indicates if the token is for Xsolla's sandbox environment.
	IsSandbox bool `json:"isSandbox"`
}

type ZuoraConfigs struct {
	// Twitch merchant account ID on Zuora.
	ExternalAccountID string `json:"externalAccountID"`
	// ID of the hosted page we will render.
	HostedPageID string `json:"hostedPageID"`
	// URL of the hosted page we will render.
	HostedPageURL string `json:"hostedPageURL"`
	// Used to encrypt sensitive information.
	PublicKey string `json:"publicKey"`
	// Need to pass generated signature to access Zuora payment pages.
	Signature string `json:"signature"`
	// In some cases, when you contact Zuora Support with an issue, the person helping you may ask you to provide the tenant ID.
	TenantID string `json:"tenantID"`
	// Zuora API uses token as part of authentication.
	Token string `json:"token"`
}

// AVC profiles for streams.
type AVCProfile string

const (
	// Low level.
	AVCProfileBaseline AVCProfile = "BASELINE"
	// Regular level.
	AVCProfileMain AVCProfile = "MAIN"
	// High level.
	AVCProfileHigh AVCProfile = "HIGH"
)

var AllAVCProfile = []AVCProfile{
	AVCProfileBaseline,
	AVCProfileMain,
	AVCProfileHigh,
}

func (e AVCProfile) IsValid() bool {
	switch e {
	case AVCProfileBaseline, AVCProfileMain, AVCProfileHigh:
		return true
	}
	return false
}

func (e AVCProfile) String() string {
	return string(e)
}

func (e *AVCProfile) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AVCProfile(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AVCProfile", str)
	}
	return nil
}

func (e AVCProfile) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Client error code.
type AcceptOrganizationInviteErrorCode string

const (
	// Internal error.
	AcceptOrganizationInviteErrorCodeInternalError AcceptOrganizationInviteErrorCode = "INTERNAL_ERROR"
	// Invalid Argument.
	AcceptOrganizationInviteErrorCodeInvalidArgument AcceptOrganizationInviteErrorCode = "INVALID_ARGUMENT"
	// Invitation not found.
	AcceptOrganizationInviteErrorCodeNotFound AcceptOrganizationInviteErrorCode = "NOT_FOUND"
	// The requesting user does not permission to accept invite.
	AcceptOrganizationInviteErrorCodePermissionDenied AcceptOrganizationInviteErrorCode = "PERMISSION_DENIED"
	// The user doesn't meet the requirements to have this role. For example, when trying to assign the
	// "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
	AcceptOrganizationInviteErrorCodeMemberIneligible AcceptOrganizationInviteErrorCode = "MEMBER_INELIGIBLE"
	// Organization Member already exists.
	AcceptOrganizationInviteErrorCodeAlreadyExists AcceptOrganizationInviteErrorCode = "ALREADY_EXISTS"
	// User is exceeds the the limit of organization they can be a member for.
	AcceptOrganizationInviteErrorCodeExceedsMembershipLimit AcceptOrganizationInviteErrorCode = "EXCEEDS_MEMBERSHIP_LIMIT"
)

var AllAcceptOrganizationInviteErrorCode = []AcceptOrganizationInviteErrorCode{
	AcceptOrganizationInviteErrorCodeInternalError,
	AcceptOrganizationInviteErrorCodeInvalidArgument,
	AcceptOrganizationInviteErrorCodeNotFound,
	AcceptOrganizationInviteErrorCodePermissionDenied,
	AcceptOrganizationInviteErrorCodeMemberIneligible,
	AcceptOrganizationInviteErrorCodeAlreadyExists,
	AcceptOrganizationInviteErrorCodeExceedsMembershipLimit,
}

func (e AcceptOrganizationInviteErrorCode) IsValid() bool {
	switch e {
	case AcceptOrganizationInviteErrorCodeInternalError, AcceptOrganizationInviteErrorCodeInvalidArgument, AcceptOrganizationInviteErrorCodeNotFound, AcceptOrganizationInviteErrorCodePermissionDenied, AcceptOrganizationInviteErrorCodeMemberIneligible, AcceptOrganizationInviteErrorCodeAlreadyExists, AcceptOrganizationInviteErrorCodeExceedsMembershipLimit:
		return true
	}
	return false
}

func (e AcceptOrganizationInviteErrorCode) String() string {
	return string(e)
}

func (e *AcceptOrganizationInviteErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AcceptOrganizationInviteErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AcceptOrganizationInviteErrorCode", str)
	}
	return nil
}

func (e AcceptOrganizationInviteErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumerates possible errors when accepting a program agreement.
type AcceptProgramAgreementError string

const (
	// Must have auth credentials to agree to a program agreement.
	AcceptProgramAgreementErrorUnauthenticated AcceptProgramAgreementError = "UNAUTHENTICATED"
	// User does not have permission to agree to the program agreement for the targeted user.
	AcceptProgramAgreementErrorForbidden AcceptProgramAgreementError = "FORBIDDEN"
	// Version of the agreement provided in the input is not valid.
	AcceptProgramAgreementErrorInvalidAgreementVersion AcceptProgramAgreementError = "INVALID_AGREEMENT_VERSION"
	// An internal error has occurred.
	AcceptProgramAgreementErrorInternalError AcceptProgramAgreementError = "INTERNAL_ERROR"
)

var AllAcceptProgramAgreementError = []AcceptProgramAgreementError{
	AcceptProgramAgreementErrorUnauthenticated,
	AcceptProgramAgreementErrorForbidden,
	AcceptProgramAgreementErrorInvalidAgreementVersion,
	AcceptProgramAgreementErrorInternalError,
}

func (e AcceptProgramAgreementError) IsValid() bool {
	switch e {
	case AcceptProgramAgreementErrorUnauthenticated, AcceptProgramAgreementErrorForbidden, AcceptProgramAgreementErrorInvalidAgreementVersion, AcceptProgramAgreementErrorInternalError:
		return true
	}
	return false
}

func (e AcceptProgramAgreementError) String() string {
	return string(e)
}

func (e *AcceptProgramAgreementError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AcceptProgramAgreementError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AcceptProgramAgreementError", str)
	}
	return nil
}

func (e AcceptProgramAgreementError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors from this mutation.
type AcceptSquadStreamInvitationErrorCode string

const (
	// Invitation to be accepted does not exist.
	AcceptSquadStreamInvitationErrorCodeInvitationNotFound AcceptSquadStreamInvitationErrorCode = "INVITATION_NOT_FOUND"
	// Squad associated with the invitation does not exist.
	AcceptSquadStreamInvitationErrorCodeSquadNotFound AcceptSquadStreamInvitationErrorCode = "SQUAD_NOT_FOUND"
	// User does not have permissions to accept invitation.
	AcceptSquadStreamInvitationErrorCodeUnauthorized AcceptSquadStreamInvitationErrorCode = "UNAUTHORIZED"
	// Invitation not in pending state cannot be accepted.
	AcceptSquadStreamInvitationErrorCodeInvitationCannotBeAccepted AcceptSquadStreamInvitationErrorCode = "INVITATION_CANNOT_BE_ACCEPTED"
	// The recipient does not have access to squad streams.
	AcceptSquadStreamInvitationErrorCodeUserCannotAccessSquads AcceptSquadStreamInvitationErrorCode = "USER_CANNOT_ACCESS_SQUADS"
)

var AllAcceptSquadStreamInvitationErrorCode = []AcceptSquadStreamInvitationErrorCode{
	AcceptSquadStreamInvitationErrorCodeInvitationNotFound,
	AcceptSquadStreamInvitationErrorCodeSquadNotFound,
	AcceptSquadStreamInvitationErrorCodeUnauthorized,
	AcceptSquadStreamInvitationErrorCodeInvitationCannotBeAccepted,
	AcceptSquadStreamInvitationErrorCodeUserCannotAccessSquads,
}

func (e AcceptSquadStreamInvitationErrorCode) IsValid() bool {
	switch e {
	case AcceptSquadStreamInvitationErrorCodeInvitationNotFound, AcceptSquadStreamInvitationErrorCodeSquadNotFound, AcceptSquadStreamInvitationErrorCodeUnauthorized, AcceptSquadStreamInvitationErrorCodeInvitationCannotBeAccepted, AcceptSquadStreamInvitationErrorCodeUserCannotAccessSquads:
		return true
	}
	return false
}

func (e AcceptSquadStreamInvitationErrorCode) String() string {
	return string(e)
}

func (e *AcceptSquadStreamInvitationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AcceptSquadStreamInvitationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AcceptSquadStreamInvitationErrorCode", str)
	}
	return nil
}

func (e AcceptSquadStreamInvitationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes from the acknowledgePredictionResult mutation.
type AcknowledgePredictionResultErrorCode string

const (
	// The authorized user is forbidden from acknowledging this Prediction result.
	AcknowledgePredictionResultErrorCodeForbidden AcknowledgePredictionResultErrorCode = "FORBIDDEN"
	// The specified Prediction ID was not found.
	AcknowledgePredictionResultErrorCodeNotFound AcknowledgePredictionResultErrorCode = "NOT_FOUND"
	// The specified Prediction ID has not been resolved yet.
	AcknowledgePredictionResultErrorCodeNotResolved AcknowledgePredictionResultErrorCode = "NOT_RESOLVED"
	// An unknown error occurred.
	AcknowledgePredictionResultErrorCodeUnknown AcknowledgePredictionResultErrorCode = "UNKNOWN"
)

var AllAcknowledgePredictionResultErrorCode = []AcknowledgePredictionResultErrorCode{
	AcknowledgePredictionResultErrorCodeForbidden,
	AcknowledgePredictionResultErrorCodeNotFound,
	AcknowledgePredictionResultErrorCodeNotResolved,
	AcknowledgePredictionResultErrorCodeUnknown,
}

func (e AcknowledgePredictionResultErrorCode) IsValid() bool {
	switch e {
	case AcknowledgePredictionResultErrorCodeForbidden, AcknowledgePredictionResultErrorCodeNotFound, AcknowledgePredictionResultErrorCodeNotResolved, AcknowledgePredictionResultErrorCodeUnknown:
		return true
	}
	return false
}

func (e AcknowledgePredictionResultErrorCode) String() string {
	return string(e)
}

func (e *AcknowledgePredictionResultErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AcknowledgePredictionResultErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AcknowledgePredictionResultErrorCode", str)
	}
	return nil
}

func (e AcknowledgePredictionResultErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ActivationState contains possible activation states found in the ActivationConfig.
type ActivationState string

const (
	// The extension is activated into a slot on the channel.
	ActivationStateActive ActivationState = "ACTIVE"
	// The extension has not been activated into a slot or required permsissions/config
	// is not set up yet.
	ActivationStateInactive ActivationState = "INACTIVE"
	// The user rejected the permissions required for the extension to be activated.
	ActivationStateRejectedPermissions ActivationState = "REJECTED_PERMISSIONS"
)

var AllActivationState = []ActivationState{
	ActivationStateActive,
	ActivationStateInactive,
	ActivationStateRejectedPermissions,
}

func (e ActivationState) IsValid() bool {
	switch e {
	case ActivationStateActive, ActivationStateInactive, ActivationStateRejectedPermissions:
		return true
	}
	return false
}

func (e ActivationState) String() string {
	return string(e)
}

func (e *ActivationState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActivationState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActivationState", str)
	}
	return nil
}

func (e ActivationState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The categories of activities which users can engage in.
type ActivityType string

const (
	ActivityTypePlaying   ActivityType = "PLAYING"
	ActivityTypeStreaming ActivityType = "STREAMING"
	ActivityTypeWatching  ActivityType = "WATCHING"
)

var AllActivityType = []ActivityType{
	ActivityTypePlaying,
	ActivityTypeStreaming,
	ActivityTypeWatching,
}

func (e ActivityType) IsValid() bool {
	switch e {
	case ActivityTypePlaying, ActivityTypeStreaming, ActivityTypeWatching:
		return true
	}
	return false
}

func (e ActivityType) String() string {
	return string(e)
}

func (e *ActivityType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActivityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActivityType", str)
	}
	return nil
}

func (e ActivityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// AdPlatform describes the type of device.
type AdPlatform string

const (
	// Ios iphone app.
	AdPlatformIosPhone AdPlatform = "IOS_PHONE"
	// Ios tablet app.
	AdPlatformIosTablet AdPlatform = "IOS_TABLET"
	// Android phone app.
	AdPlatformAndroidPhone AdPlatform = "ANDROID_PHONE"
	// Android tablet app.
	AdPlatformAndroidTablet AdPlatform = "ANDROID_TABLET"
)

var AllAdPlatform = []AdPlatform{
	AdPlatformIosPhone,
	AdPlatformIosTablet,
	AdPlatformAndroidPhone,
	AdPlatformAndroidTablet,
}

func (e AdPlatform) IsValid() bool {
	switch e {
	case AdPlatformIosPhone, AdPlatformIosTablet, AdPlatformAndroidPhone, AdPlatformAndroidTablet:
		return true
	}
	return false
}

func (e AdPlatform) String() string {
	return string(e)
}

func (e *AdPlatform) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AdPlatform", str)
	}
	return nil
}

func (e AdPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of content playing when the ad was requested.
type AdRequestContentType string

const (
	// Live streams.
	AdRequestContentTypeLive AdRequestContentType = "LIVE"
	// VOD playback.
	AdRequestContentTypeVod AdRequestContentType = "VOD"
)

var AllAdRequestContentType = []AdRequestContentType{
	AdRequestContentTypeLive,
	AdRequestContentTypeVod,
}

func (e AdRequestContentType) IsValid() bool {
	switch e {
	case AdRequestContentTypeLive, AdRequestContentTypeVod:
		return true
	}
	return false
}

func (e AdRequestContentType) String() string {
	return string(e)
}

func (e *AdRequestContentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdRequestContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AdRequestContentType", str)
	}
	return nil
}

func (e AdRequestContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors that this resolver returns.
type AddChannelBlockedTermError string

const (
	// User does not have permission to add blocked term in channel.
	AddChannelBlockedTermErrorNoPermissions AddChannelBlockedTermError = "NO_PERMISSIONS"
	// Duration provided was invalid.
	AddChannelBlockedTermErrorDurationInvalid AddChannelBlockedTermError = "DURATION_INVALID"
)

var AllAddChannelBlockedTermError = []AddChannelBlockedTermError{
	AddChannelBlockedTermErrorNoPermissions,
	AddChannelBlockedTermErrorDurationInvalid,
}

func (e AddChannelBlockedTermError) IsValid() bool {
	switch e {
	case AddChannelBlockedTermErrorNoPermissions, AddChannelBlockedTermErrorDurationInvalid:
		return true
	}
	return false
}

func (e AddChannelBlockedTermError) String() string {
	return string(e)
}

func (e *AddChannelBlockedTermError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AddChannelBlockedTermError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AddChannelBlockedTermError", str)
	}
	return nil
}

func (e AddChannelBlockedTermError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors that this resolver returns.
type AddChannelPermittedTermError string

const (
	// User does not have permission to add Permitted term in channel.
	AddChannelPermittedTermErrorNoPermissions AddChannelPermittedTermError = "NO_PERMISSIONS"
	// Duration provided was invalid.
	AddChannelPermittedTermErrorDurationInvalid AddChannelPermittedTermError = "DURATION_INVALID"
)

var AllAddChannelPermittedTermError = []AddChannelPermittedTermError{
	AddChannelPermittedTermErrorNoPermissions,
	AddChannelPermittedTermErrorDurationInvalid,
}

func (e AddChannelPermittedTermError) IsValid() bool {
	switch e {
	case AddChannelPermittedTermErrorNoPermissions, AddChannelPermittedTermErrorDurationInvalid:
		return true
	}
	return false
}

func (e AddChannelPermittedTermError) String() string {
	return string(e)
}

func (e *AddChannelPermittedTermError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AddChannelPermittedTermError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AddChannelPermittedTermError", str)
	}
	return nil
}

func (e AddChannelPermittedTermError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// AddEditorErrorCode defines a client error that occurred while adding an editor.
type AddEditorErrorCode string

const (
	// The channel does not exist.
	AddEditorErrorCodeChannelNotFound AddEditorErrorCode = "CHANNEL_NOT_FOUND"
	// The user who is to become an editor is already an editor.
	AddEditorErrorCodeTargetUserAlreadyEditor AddEditorErrorCode = "TARGET_USER_ALREADY_EDITOR"
	// The user who is to become an editor does not exist.
	AddEditorErrorCodeTargetUserNotFound AddEditorErrorCode = "TARGET_USER_NOT_FOUND"
)

var AllAddEditorErrorCode = []AddEditorErrorCode{
	AddEditorErrorCodeChannelNotFound,
	AddEditorErrorCodeTargetUserAlreadyEditor,
	AddEditorErrorCodeTargetUserNotFound,
}

func (e AddEditorErrorCode) IsValid() bool {
	switch e {
	case AddEditorErrorCodeChannelNotFound, AddEditorErrorCodeTargetUserAlreadyEditor, AddEditorErrorCodeTargetUserNotFound:
		return true
	}
	return false
}

func (e AddEditorErrorCode) String() string {
	return string(e)
}

func (e *AddEditorErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AddEditorErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AddEditorErrorCode", str)
	}
	return nil
}

func (e AddEditorErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Recently played error codes.
type AddRadioRecentlyPlayedErrorCode string

const (
	// The ID provided was malformed.
	AddRadioRecentlyPlayedErrorCodeInvalidID AddRadioRecentlyPlayedErrorCode = "INVALID_ID"
	// Permission denied to add/update a recently played item.
	AddRadioRecentlyPlayedErrorCodePermissionDenied AddRadioRecentlyPlayedErrorCode = "PERMISSION_DENIED"
)

var AllAddRadioRecentlyPlayedErrorCode = []AddRadioRecentlyPlayedErrorCode{
	AddRadioRecentlyPlayedErrorCodeInvalidID,
	AddRadioRecentlyPlayedErrorCodePermissionDenied,
}

func (e AddRadioRecentlyPlayedErrorCode) IsValid() bool {
	switch e {
	case AddRadioRecentlyPlayedErrorCodeInvalidID, AddRadioRecentlyPlayedErrorCodePermissionDenied:
		return true
	}
	return false
}

func (e AddRadioRecentlyPlayedErrorCode) String() string {
	return string(e)
}

func (e *AddRadioRecentlyPlayedErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AddRadioRecentlyPlayedErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AddRadioRecentlyPlayedErrorCode", str)
	}
	return nil
}

func (e AddRadioRecentlyPlayedErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// AddStreamAuthorizedUserErrorCode is the client error type that occurred during the AddStreamAuthorizedUser mutation.
type AddStreamAuthorizedUserErrorCode string

const (
	// Unable to assign the Targeted user to stream on behalf of the broadcaster.
	AddStreamAuthorizedUserErrorCodeTargetUserUnreturnable AddStreamAuthorizedUserErrorCode = "TARGET_USER_UNRETURNABLE"
	// The broadcaster is not found.
	AddStreamAuthorizedUserErrorCodeChannelNotFound AddStreamAuthorizedUserErrorCode = "CHANNEL_NOT_FOUND"
	// Maximum limit for adding authorized user is reached.
	AddStreamAuthorizedUserErrorCodeMaxAccountLimit AddStreamAuthorizedUserErrorCode = "MAX_ACCOUNT_LIMIT"
	// Permission denied to add an authorized user.
	AddStreamAuthorizedUserErrorCodePermissionDenied AddStreamAuthorizedUserErrorCode = "PERMISSION_DENIED"
	// Invalid argument to add an authorized user.
	AddStreamAuthorizedUserErrorCodeInvalidArgument AddStreamAuthorizedUserErrorCode = "INVALID_ARGUMENT"
)

var AllAddStreamAuthorizedUserErrorCode = []AddStreamAuthorizedUserErrorCode{
	AddStreamAuthorizedUserErrorCodeTargetUserUnreturnable,
	AddStreamAuthorizedUserErrorCodeChannelNotFound,
	AddStreamAuthorizedUserErrorCodeMaxAccountLimit,
	AddStreamAuthorizedUserErrorCodePermissionDenied,
	AddStreamAuthorizedUserErrorCodeInvalidArgument,
}

func (e AddStreamAuthorizedUserErrorCode) IsValid() bool {
	switch e {
	case AddStreamAuthorizedUserErrorCodeTargetUserUnreturnable, AddStreamAuthorizedUserErrorCodeChannelNotFound, AddStreamAuthorizedUserErrorCodeMaxAccountLimit, AddStreamAuthorizedUserErrorCodePermissionDenied, AddStreamAuthorizedUserErrorCodeInvalidArgument:
		return true
	}
	return false
}

func (e AddStreamAuthorizedUserErrorCode) String() string {
	return string(e)
}

func (e *AddStreamAuthorizedUserErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AddStreamAuthorizedUserErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AddStreamAuthorizedUserErrorCode", str)
	}
	return nil
}

func (e AddStreamAuthorizedUserErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of ad break being requested.
type AdrollType string

const (
	// Ad that runs prior to seeing a stream/vod.
	AdrollTypePreroll AdrollType = "PREROLL"
	// Ad that runs in the middle of a stream/vod.
	AdrollTypeMidroll AdrollType = "MIDROLL"
	// Ad that runs after a stream/vod.
	AdrollTypePostroll AdrollType = "POSTROLL"
)

var AllAdrollType = []AdrollType{
	AdrollTypePreroll,
	AdrollTypeMidroll,
	AdrollTypePostroll,
}

func (e AdrollType) IsValid() bool {
	switch e {
	case AdrollTypePreroll, AdrollTypeMidroll, AdrollTypePostroll:
		return true
	}
	return false
}

func (e AdrollType) String() string {
	return string(e)
}

func (e *AdrollType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdrollType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AdrollType", str)
	}
	return nil
}

func (e AdrollType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors from the mutation.
type AllocateKeysForBountyErrorCode string

const (
	// The provided input is invalid.
	AllocateKeysForBountyErrorCodeInvalidArgument AllocateKeysForBountyErrorCode = "INVALID_ARGUMENT"
	// The bounty or required key metadata was not found.
	AllocateKeysForBountyErrorCodeNotFound AllocateKeysForBountyErrorCode = "NOT_FOUND"
	// Unknown error being returned from service.
	AllocateKeysForBountyErrorCodeUnknownError AllocateKeysForBountyErrorCode = "UNKNOWN_ERROR"
)

var AllAllocateKeysForBountyErrorCode = []AllocateKeysForBountyErrorCode{
	AllocateKeysForBountyErrorCodeInvalidArgument,
	AllocateKeysForBountyErrorCodeNotFound,
	AllocateKeysForBountyErrorCodeUnknownError,
}

func (e AllocateKeysForBountyErrorCode) IsValid() bool {
	switch e {
	case AllocateKeysForBountyErrorCodeInvalidArgument, AllocateKeysForBountyErrorCodeNotFound, AllocateKeysForBountyErrorCodeUnknownError:
		return true
	}
	return false
}

func (e AllocateKeysForBountyErrorCode) String() string {
	return string(e)
}

func (e *AllocateKeysForBountyErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AllocateKeysForBountyErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AllocateKeysForBountyErrorCode", str)
	}
	return nil
}

func (e AllocateKeysForBountyErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Archive community goal error code.
type ArchiveCommunityPointsCommunityGoalErrorCode string

const (
	// The goal was not found.
	ArchiveCommunityPointsCommunityGoalErrorCodeNotFound ArchiveCommunityPointsCommunityGoalErrorCode = "NOT_FOUND"
	// The current user is not allowed to archive community goals for this channel.
	ArchiveCommunityPointsCommunityGoalErrorCodeForbidden ArchiveCommunityPointsCommunityGoalErrorCode = "FORBIDDEN"
	// An unknown error occurred.
	ArchiveCommunityPointsCommunityGoalErrorCodeUnknown ArchiveCommunityPointsCommunityGoalErrorCode = "UNKNOWN"
)

var AllArchiveCommunityPointsCommunityGoalErrorCode = []ArchiveCommunityPointsCommunityGoalErrorCode{
	ArchiveCommunityPointsCommunityGoalErrorCodeNotFound,
	ArchiveCommunityPointsCommunityGoalErrorCodeForbidden,
	ArchiveCommunityPointsCommunityGoalErrorCodeUnknown,
}

func (e ArchiveCommunityPointsCommunityGoalErrorCode) IsValid() bool {
	switch e {
	case ArchiveCommunityPointsCommunityGoalErrorCodeNotFound, ArchiveCommunityPointsCommunityGoalErrorCodeForbidden, ArchiveCommunityPointsCommunityGoalErrorCodeUnknown:
		return true
	}
	return false
}

func (e ArchiveCommunityPointsCommunityGoalErrorCode) String() string {
	return string(e)
}

func (e *ArchiveCommunityPointsCommunityGoalErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ArchiveCommunityPointsCommunityGoalErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ArchiveCommunityPointsCommunityGoalErrorCode", str)
	}
	return nil
}

func (e ArchiveCommunityPointsCommunityGoalErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors from the mutation.
type ArkoseEndpointVersion string

const (
	// Version 1 endpoint.
	ArkoseEndpointVersionV1 ArkoseEndpointVersion = "V1"
	// Version 2 endpoint.
	ArkoseEndpointVersionV2 ArkoseEndpointVersion = "V2"
)

var AllArkoseEndpointVersion = []ArkoseEndpointVersion{
	ArkoseEndpointVersionV1,
	ArkoseEndpointVersionV2,
}

func (e ArkoseEndpointVersion) IsValid() bool {
	switch e {
	case ArkoseEndpointVersionV1, ArkoseEndpointVersionV2:
		return true
	}
	return false
}

func (e ArkoseEndpointVersion) String() string {
	return string(e)
}

func (e *ArkoseEndpointVersion) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ArkoseEndpointVersion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ArkoseEndpointVersion", str)
	}
	return nil
}

func (e ArkoseEndpointVersion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enums for the difference error codes which can be returned.
type AssignExtensionBillingManagerErrorCode string

const (
	// Extension does not belong to the same organization as the assigned billing manager member.
	AssignExtensionBillingManagerErrorCodeFailedPrecondition AssignExtensionBillingManagerErrorCode = "FAILED_PRECONDITION"
	// The user doesn't meet the requirements to be the assigned billing manager.
	// For example, doesn't have a valid role or did not complete Extension Monetization (TIMs).
	AssignExtensionBillingManagerErrorCodeMemberIneligible AssignExtensionBillingManagerErrorCode = "MEMBER_INELIGIBLE"
	// User does not have permission to perform action.
	AssignExtensionBillingManagerErrorCodePermissionDenied AssignExtensionBillingManagerErrorCode = "PERMISSION_DENIED"
)

var AllAssignExtensionBillingManagerErrorCode = []AssignExtensionBillingManagerErrorCode{
	AssignExtensionBillingManagerErrorCodeFailedPrecondition,
	AssignExtensionBillingManagerErrorCodeMemberIneligible,
	AssignExtensionBillingManagerErrorCodePermissionDenied,
}

func (e AssignExtensionBillingManagerErrorCode) IsValid() bool {
	switch e {
	case AssignExtensionBillingManagerErrorCodeFailedPrecondition, AssignExtensionBillingManagerErrorCodeMemberIneligible, AssignExtensionBillingManagerErrorCodePermissionDenied:
		return true
	}
	return false
}

func (e AssignExtensionBillingManagerErrorCode) String() string {
	return string(e)
}

func (e *AssignExtensionBillingManagerErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AssignExtensionBillingManagerErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AssignExtensionBillingManagerErrorCode", str)
	}
	return nil
}

func (e AssignExtensionBillingManagerErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason why a message is flagged and/or rejected.
type AutoModCaughtMessageCategory string

const (
	// Message contained words that were aggressive.
	AutoModCaughtMessageCategoryAggressive AutoModCaughtMessageCategory = "AGGRESSIVE"
	// Message contained identity details.
	AutoModCaughtMessageCategoryIDEntity AutoModCaughtMessageCategory = "IDENTITY"
	// Message contained words that were vulgar.
	AutoModCaughtMessageCategoryProfanity AutoModCaughtMessageCategory = "PROFANITY"
	// Message contained words that were sexual.
	AutoModCaughtMessageCategorySexual AutoModCaughtMessageCategory = "SEXUAL"
)

var AllAutoModCaughtMessageCategory = []AutoModCaughtMessageCategory{
	AutoModCaughtMessageCategoryAggressive,
	AutoModCaughtMessageCategoryIDEntity,
	AutoModCaughtMessageCategoryProfanity,
	AutoModCaughtMessageCategorySexual,
}

func (e AutoModCaughtMessageCategory) IsValid() bool {
	switch e {
	case AutoModCaughtMessageCategoryAggressive, AutoModCaughtMessageCategoryIDEntity, AutoModCaughtMessageCategoryProfanity, AutoModCaughtMessageCategorySexual:
		return true
	}
	return false
}

func (e AutoModCaughtMessageCategory) String() string {
	return string(e)
}

func (e *AutoModCaughtMessageCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AutoModCaughtMessageCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AutoModCaughtMessageCategory", str)
	}
	return nil
}

func (e AutoModCaughtMessageCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes a flagged message's posting status.
type AutoModCaughtMessageStatus string

const (
	// The message has not received a decision from a mod, and may be expired. Check sentAt date to confirm.
	AutoModCaughtMessageStatusPending AutoModCaughtMessageStatus = "PENDING"
	// The message was approved by a channel moderator or the broadcaster.
	AutoModCaughtMessageStatusApproved AutoModCaughtMessageStatus = "APPROVED"
	// The message was denied by a channel moderator or the broadcaster.
	AutoModCaughtMessageStatusDenied AutoModCaughtMessageStatus = "DENIED"
)

var AllAutoModCaughtMessageStatus = []AutoModCaughtMessageStatus{
	AutoModCaughtMessageStatusPending,
	AutoModCaughtMessageStatusApproved,
	AutoModCaughtMessageStatusDenied,
}

func (e AutoModCaughtMessageStatus) IsValid() bool {
	switch e {
	case AutoModCaughtMessageStatusPending, AutoModCaughtMessageStatusApproved, AutoModCaughtMessageStatusDenied:
		return true
	}
	return false
}

func (e AutoModCaughtMessageStatus) String() string {
	return string(e)
}

func (e *AutoModCaughtMessageStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AutoModCaughtMessageStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AutoModCaughtMessageStatus", str)
	}
	return nil
}

func (e AutoModCaughtMessageStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DEPRECATED: to be replaced by IncomingRaidsPolicy.
// Determines what other channels can raid this channel.
type AutohostSettingsIncomingRaidsPolicy string

const (
	// This user cannot be radied by anyone.
	AutohostSettingsIncomingRaidsPolicyNone AutohostSettingsIncomingRaidsPolicy = "NONE"
	// This user can be raided by other people in their network.
	AutohostSettingsIncomingRaidsPolicyNetwork AutohostSettingsIncomingRaidsPolicy = "NETWORK"
	// This user can be raded by anyone.
	AutohostSettingsIncomingRaidsPolicyAll AutohostSettingsIncomingRaidsPolicy = "ALL"
)

var AllAutohostSettingsIncomingRaidsPolicy = []AutohostSettingsIncomingRaidsPolicy{
	AutohostSettingsIncomingRaidsPolicyNone,
	AutohostSettingsIncomingRaidsPolicyNetwork,
	AutohostSettingsIncomingRaidsPolicyAll,
}

func (e AutohostSettingsIncomingRaidsPolicy) IsValid() bool {
	switch e {
	case AutohostSettingsIncomingRaidsPolicyNone, AutohostSettingsIncomingRaidsPolicyNetwork, AutohostSettingsIncomingRaidsPolicyAll:
		return true
	}
	return false
}

func (e AutohostSettingsIncomingRaidsPolicy) String() string {
	return string(e)
}

func (e *AutohostSettingsIncomingRaidsPolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AutohostSettingsIncomingRaidsPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AutohostSettingsIncomingRaidsPolicy", str)
	}
	return nil
}

func (e AutohostSettingsIncomingRaidsPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The strategy to use when choosing channels to autohost.
type AutohostSettingsStrategy string

const (
	// Picks channels in the order defined by the user.
	AutohostSettingsStrategyOrdered AutohostSettingsStrategy = "ORDERED"
	// Picks channels at random.
	AutohostSettingsStrategyRandom AutohostSettingsStrategy = "RANDOM"
)

var AllAutohostSettingsStrategy = []AutohostSettingsStrategy{
	AutohostSettingsStrategyOrdered,
	AutohostSettingsStrategyRandom,
}

func (e AutohostSettingsStrategy) IsValid() bool {
	switch e {
	case AutohostSettingsStrategyOrdered, AutohostSettingsStrategyRandom:
		return true
	}
	return false
}

func (e AutohostSettingsStrategy) String() string {
	return string(e)
}

func (e *AutohostSettingsStrategy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AutohostSettingsStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AutohostSettingsStrategy", str)
	}
	return nil
}

func (e AutohostSettingsStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible computed states for a user or session.
type Availability string

const (
	AvailabilityAway    Availability = "AWAY"
	AvailabilityBusy    Availability = "BUSY"
	AvailabilityIDLe    Availability = "IDLE"
	AvailabilityOffline Availability = "OFFLINE"
	AvailabilityOnline  Availability = "ONLINE"
)

var AllAvailability = []Availability{
	AvailabilityAway,
	AvailabilityBusy,
	AvailabilityIDLe,
	AvailabilityOffline,
	AvailabilityOnline,
}

func (e Availability) IsValid() bool {
	switch e {
	case AvailabilityAway, AvailabilityBusy, AvailabilityIDLe, AvailabilityOffline, AvailabilityOnline:
		return true
	}
	return false
}

func (e Availability) String() string {
	return string(e)
}

func (e *Availability) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Availability(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Availability", str)
	}
	return nil
}

func (e Availability) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AvailabilityInput string

const (
	AvailabilityInputOnline  AvailabilityInput = "ONLINE"
	AvailabilityInputIDLe    AvailabilityInput = "IDLE"
	AvailabilityInputOffline AvailabilityInput = "OFFLINE"
)

var AllAvailabilityInput = []AvailabilityInput{
	AvailabilityInputOnline,
	AvailabilityInputIDLe,
	AvailabilityInputOffline,
}

func (e AvailabilityInput) IsValid() bool {
	switch e {
	case AvailabilityInputOnline, AvailabilityInputIDLe, AvailabilityInputOffline:
		return true
	}
	return false
}

func (e AvailabilityInput) String() string {
	return string(e)
}

func (e *AvailabilityInput) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AvailabilityInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AvailabilityInput", str)
	}
	return nil
}

func (e AvailabilityInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumerates possible badge click actions.
type BadgeClickAction string

const (
	// Go to the user's subscription page.
	BadgeClickActionSubscribe BadgeClickAction = "SUBSCRIBE"
	// Go to the Twitch Turbo purchasing page.
	BadgeClickActionGetTurbo BadgeClickAction = "GET_TURBO"
	// Go to the Bits purchasing page.
	BadgeClickActionGetBits BadgeClickAction = "GET_BITS"
	// Redirect the user to the badge click URL.
	BadgeClickActionVisitURL BadgeClickAction = "VISIT_URL"
)

var AllBadgeClickAction = []BadgeClickAction{
	BadgeClickActionSubscribe,
	BadgeClickActionGetTurbo,
	BadgeClickActionGetBits,
	BadgeClickActionVisitURL,
}

func (e BadgeClickAction) IsValid() bool {
	switch e {
	case BadgeClickActionSubscribe, BadgeClickActionGetTurbo, BadgeClickActionGetBits, BadgeClickActionVisitURL:
		return true
	}
	return false
}

func (e BadgeClickAction) String() string {
	return string(e)
}

func (e *BadgeClickAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BadgeClickAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BadgeClickAction", str)
	}
	return nil
}

func (e BadgeClickAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Deprecated: Domains that badges belong to.
type BadgeDomain string

const (
	// Badges that were granted via Twitch crates.
	BadgeDomainCrate BadgeDomain = "CRATE"
)

var AllBadgeDomain = []BadgeDomain{
	BadgeDomainCrate,
}

func (e BadgeDomain) IsValid() bool {
	switch e {
	case BadgeDomainCrate:
		return true
	}
	return false
}

func (e BadgeDomain) String() string {
	return string(e)
}

func (e *BadgeDomain) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BadgeDomain(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BadgeDomain", str)
	}
	return nil
}

func (e BadgeDomain) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumerates valid badge image sizes.
type BadgeImageSize string

const (
	// The base badge image size: 18x18.
	BadgeImageSizeNormal BadgeImageSize = "NORMAL"
	// Double the normal badge image size: 36x36.
	BadgeImageSizeDouble BadgeImageSize = "DOUBLE"
	// Quadruple the normal badge image size: 72x72.
	BadgeImageSizeQuadruple BadgeImageSize = "QUADRUPLE"
)

var AllBadgeImageSize = []BadgeImageSize{
	BadgeImageSizeNormal,
	BadgeImageSizeDouble,
	BadgeImageSizeQuadruple,
}

func (e BadgeImageSize) IsValid() bool {
	switch e {
	case BadgeImageSizeNormal, BadgeImageSizeDouble, BadgeImageSizeQuadruple:
		return true
	}
	return false
}

func (e BadgeImageSize) String() string {
	return string(e)
}

func (e *BadgeImageSize) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BadgeImageSize(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BadgeImageSize", str)
	}
	return nil
}

func (e BadgeImageSize) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A filter for controlling which Bits Badge Tier Emotes to return.
type BadgeTierEmotesFilter string

const (
	// Returns all bits badge tier emotes for this channel.
	BadgeTierEmotesFilterAll BadgeTierEmotesFilter = "ALL"
	// Returns all locked bits badge tier emotes for this user in this channel.
	BadgeTierEmotesFilterLocked BadgeTierEmotesFilter = "LOCKED"
	// Returns a few of the locked bits badge tier emotes for this user in this channel.
	// Which emotes and the exact number are determined by the back-end.
	BadgeTierEmotesFilterLockedPreview BadgeTierEmotesFilter = "LOCKED_PREVIEW"
	// Returns all unlocked bits badge tier emotes for this user in this channel.
	BadgeTierEmotesFilterUnlocked BadgeTierEmotesFilter = "UNLOCKED"
	// Returns highest currently unlocked bits badge tier emote and next to be unlocked by user.
	BadgeTierEmotesFilterHighestUnlockedAndNext BadgeTierEmotesFilter = "HIGHEST_UNLOCKED_AND_NEXT"
)

var AllBadgeTierEmotesFilter = []BadgeTierEmotesFilter{
	BadgeTierEmotesFilterAll,
	BadgeTierEmotesFilterLocked,
	BadgeTierEmotesFilterLockedPreview,
	BadgeTierEmotesFilterUnlocked,
	BadgeTierEmotesFilterHighestUnlockedAndNext,
}

func (e BadgeTierEmotesFilter) IsValid() bool {
	switch e {
	case BadgeTierEmotesFilterAll, BadgeTierEmotesFilterLocked, BadgeTierEmotesFilterLockedPreview, BadgeTierEmotesFilterUnlocked, BadgeTierEmotesFilterHighestUnlockedAndNext:
		return true
	}
	return false
}

func (e BadgeTierEmotesFilter) String() string {
	return string(e)
}

func (e *BadgeTierEmotesFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BadgeTierEmotesFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BadgeTierEmotesFilter", str)
	}
	return nil
}

func (e BadgeTierEmotesFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BanUserFromChatRoomErrorCode string

const (
	// User does not have permission to ban in channel.
	BanUserFromChatRoomErrorCodeForbidden BanUserFromChatRoomErrorCode = "FORBIDDEN"
	// Target does not exist.
	BanUserFromChatRoomErrorCodeTargetNotFound BanUserFromChatRoomErrorCode = "TARGET_NOT_FOUND"
	// User tried to ban themselves.
	BanUserFromChatRoomErrorCodeTargetIsSelf BanUserFromChatRoomErrorCode = "TARGET_IS_SELF"
	// User tried to ban anonymous user.
	BanUserFromChatRoomErrorCodeTargetIsAnonymous BanUserFromChatRoomErrorCode = "TARGET_IS_ANONYMOUS"
	// User tried to ban a moderator without permission.
	BanUserFromChatRoomErrorCodeTargetIsMod BanUserFromChatRoomErrorCode = "TARGET_IS_MOD"
	// DEPRECATED: no longer returned.
	BanUserFromChatRoomErrorCodeTargetIsVip BanUserFromChatRoomErrorCode = "TARGET_IS_VIP"
	// User tried to ban broadcaster.
	BanUserFromChatRoomErrorCodeTargetIsBroadcaster BanUserFromChatRoomErrorCode = "TARGET_IS_BROADCASTER"
	// User tried to ban staff.
	BanUserFromChatRoomErrorCodeTargetIsStaff BanUserFromChatRoomErrorCode = "TARGET_IS_STAFF"
	// User tried to ban admin.
	BanUserFromChatRoomErrorCodeTargetIsAdmin BanUserFromChatRoomErrorCode = "TARGET_IS_ADMIN"
	// User tried to ban global mod.
	BanUserFromChatRoomErrorCodeTargetIsGlobalMod BanUserFromChatRoomErrorCode = "TARGET_IS_GLOBAL_MOD"
	// User tried to ban already banned user.
	BanUserFromChatRoomErrorCodeTargetAlreadyBanned BanUserFromChatRoomErrorCode = "TARGET_ALREADY_BANNED"
	// Duration provided was too short or too long.
	BanUserFromChatRoomErrorCodeDurationInvalid BanUserFromChatRoomErrorCode = "DURATION_INVALID"
)

var AllBanUserFromChatRoomErrorCode = []BanUserFromChatRoomErrorCode{
	BanUserFromChatRoomErrorCodeForbidden,
	BanUserFromChatRoomErrorCodeTargetNotFound,
	BanUserFromChatRoomErrorCodeTargetIsSelf,
	BanUserFromChatRoomErrorCodeTargetIsAnonymous,
	BanUserFromChatRoomErrorCodeTargetIsMod,
	BanUserFromChatRoomErrorCodeTargetIsVip,
	BanUserFromChatRoomErrorCodeTargetIsBroadcaster,
	BanUserFromChatRoomErrorCodeTargetIsStaff,
	BanUserFromChatRoomErrorCodeTargetIsAdmin,
	BanUserFromChatRoomErrorCodeTargetIsGlobalMod,
	BanUserFromChatRoomErrorCodeTargetAlreadyBanned,
	BanUserFromChatRoomErrorCodeDurationInvalid,
}

func (e BanUserFromChatRoomErrorCode) IsValid() bool {
	switch e {
	case BanUserFromChatRoomErrorCodeForbidden, BanUserFromChatRoomErrorCodeTargetNotFound, BanUserFromChatRoomErrorCodeTargetIsSelf, BanUserFromChatRoomErrorCodeTargetIsAnonymous, BanUserFromChatRoomErrorCodeTargetIsMod, BanUserFromChatRoomErrorCodeTargetIsVip, BanUserFromChatRoomErrorCodeTargetIsBroadcaster, BanUserFromChatRoomErrorCodeTargetIsStaff, BanUserFromChatRoomErrorCodeTargetIsAdmin, BanUserFromChatRoomErrorCodeTargetIsGlobalMod, BanUserFromChatRoomErrorCodeTargetAlreadyBanned, BanUserFromChatRoomErrorCodeDurationInvalid:
		return true
	}
	return false
}

func (e BanUserFromChatRoomErrorCode) String() string {
	return string(e)
}

func (e *BanUserFromChatRoomErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BanUserFromChatRoomErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BanUserFromChatRoomErrorCode", str)
	}
	return nil
}

func (e BanUserFromChatRoomErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the state of the notification.
type BitsBadgeTierNotificationState string

const (
	// User dismissed the notification.
	BitsBadgeTierNotificationStateSkipped BitsBadgeTierNotificationState = "SKIPPED"
	// User shared the notification with chat.
	BitsBadgeTierNotificationStateShared BitsBadgeTierNotificationState = "SHARED"
	// Notification should be shown to user.
	BitsBadgeTierNotificationStateShow BitsBadgeTierNotificationState = "SHOW"
)

var AllBitsBadgeTierNotificationState = []BitsBadgeTierNotificationState{
	BitsBadgeTierNotificationStateSkipped,
	BitsBadgeTierNotificationStateShared,
	BitsBadgeTierNotificationStateShow,
}

func (e BitsBadgeTierNotificationState) IsValid() bool {
	switch e {
	case BitsBadgeTierNotificationStateSkipped, BitsBadgeTierNotificationStateShared, BitsBadgeTierNotificationStateShow:
		return true
	}
	return false
}

func (e BitsBadgeTierNotificationState) String() string {
	return string(e)
}

func (e *BitsBadgeTierNotificationState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitsBadgeTierNotificationState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitsBadgeTierNotificationState", str)
	}
	return nil
}

func (e BitsBadgeTierNotificationState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible sort orders for lists of bits events.
type BitsEventSort string

const (
	// Sort the bits events by amount.
	BitsEventSortAmount BitsEventSort = "AMOUNT"
	// Sort the bits events by date.
	BitsEventSortDate BitsEventSort = "DATE"
)

var AllBitsEventSort = []BitsEventSort{
	BitsEventSortAmount,
	BitsEventSortDate,
}

func (e BitsEventSort) IsValid() bool {
	switch e {
	case BitsEventSortAmount, BitsEventSortDate:
		return true
	}
	return false
}

func (e BitsEventSort) String() string {
	return string(e)
}

func (e *BitsEventSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitsEventSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitsEventSort", str)
	}
	return nil
}

func (e BitsEventSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible sort directions for lists of bits events.
type BitsEventSortDirection string

const (
	// Sort in descending order.
	BitsEventSortDirectionDesc BitsEventSortDirection = "DESC"
	// Sort in ascending order.
	BitsEventSortDirectionAsc BitsEventSortDirection = "ASC"
)

var AllBitsEventSortDirection = []BitsEventSortDirection{
	BitsEventSortDirectionDesc,
	BitsEventSortDirectionAsc,
}

func (e BitsEventSortDirection) IsValid() bool {
	switch e {
	case BitsEventSortDirectionDesc, BitsEventSortDirectionAsc:
		return true
	}
	return false
}

func (e BitsEventSortDirection) String() string {
	return string(e)
}

func (e *BitsEventSortDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitsEventSortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitsEventSortDirection", str)
	}
	return nil
}

func (e BitsEventSortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Bits event type.
type BitsEventType string

const (
	// Event for giving bits to broadcaster.
	BitsEventTypeGiveBitsToBroadcaster BitsEventType = "GIVE_BITS_TO_BROADCASTER"
	// Event for using bits on extension.
	BitsEventTypeUseBitsOnExtension BitsEventType = "USE_BITS_ON_EXTENSION"
	// Event for using bits on poll.
	BitsEventTypeUseBitsOnPoll BitsEventType = "USE_BITS_ON_POLL"
	// Unknown event type.
	BitsEventTypeUnknown BitsEventType = "UNKNOWN"
)

var AllBitsEventType = []BitsEventType{
	BitsEventTypeGiveBitsToBroadcaster,
	BitsEventTypeUseBitsOnExtension,
	BitsEventTypeUseBitsOnPoll,
	BitsEventTypeUnknown,
}

func (e BitsEventType) IsValid() bool {
	switch e {
	case BitsEventTypeGiveBitsToBroadcaster, BitsEventTypeUseBitsOnExtension, BitsEventTypeUseBitsOnPoll, BitsEventTypeUnknown:
		return true
	}
	return false
}

func (e BitsEventType) String() string {
	return string(e)
}

func (e *BitsEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitsEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitsEventType", str)
	}
	return nil
}

func (e BitsEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// BitsOfferType is the kind of offer.
type BitsOfferType string

const (
	// AD is an advertisement or other engagement that can be watched to earn bits.
	BitsOfferTypeAd BitsOfferType = "AD"
	// BUNDLE is a standard package of bits that can be purchased for a price.
	BitsOfferTypeBundle BitsOfferType = "BUNDLE"
)

var AllBitsOfferType = []BitsOfferType{
	BitsOfferTypeAd,
	BitsOfferTypeBundle,
}

func (e BitsOfferType) IsValid() bool {
	switch e {
	case BitsOfferTypeAd, BitsOfferTypeBundle:
		return true
	}
	return false
}

func (e BitsOfferType) String() string {
	return string(e)
}

func (e *BitsOfferType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitsOfferType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitsOfferType", str)
	}
	return nil
}

func (e BitsOfferType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum of payment method types.
type BitsPaymentMethodType string

const (
	// Paypal.
	BitsPaymentMethodTypePaypal BitsPaymentMethodType = "PAYPAL"
	// Amazon Pay.
	BitsPaymentMethodTypeAmazonPay BitsPaymentMethodType = "AMAZON_PAY"
	// Xsolla.
	BitsPaymentMethodTypeXsolla BitsPaymentMethodType = "XSOLLA"
)

var AllBitsPaymentMethodType = []BitsPaymentMethodType{
	BitsPaymentMethodTypePaypal,
	BitsPaymentMethodTypeAmazonPay,
	BitsPaymentMethodTypeXsolla,
}

func (e BitsPaymentMethodType) IsValid() bool {
	switch e {
	case BitsPaymentMethodTypePaypal, BitsPaymentMethodTypeAmazonPay, BitsPaymentMethodTypeXsolla:
		return true
	}
	return false
}

func (e BitsPaymentMethodType) String() string {
	return string(e)
}

func (e *BitsPaymentMethodType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitsPaymentMethodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitsPaymentMethodType", str)
	}
	return nil
}

func (e BitsPaymentMethodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumerable that identifies the checkout provider the customer is using.
type BitsProductProvider string

const (
	// Amazon checkout.
	BitsProductProviderAmazon BitsProductProvider = "AMAZON"
	// Android IAP.
	BitsProductProviderAndroid BitsProductProvider = "ANDROID"
	// iOS IAP.
	BitsProductProviderIos BitsProductProvider = "IOS"
	// Paypal checkout.
	BitsProductProviderPaypal BitsProductProvider = "PAYPAL"
	// Xsolla checkout.
	BitsProductProviderXsolla BitsProductProvider = "XSOLLA"
)

var AllBitsProductProvider = []BitsProductProvider{
	BitsProductProviderAmazon,
	BitsProductProviderAndroid,
	BitsProductProviderIos,
	BitsProductProviderPaypal,
	BitsProductProviderXsolla,
}

func (e BitsProductProvider) IsValid() bool {
	switch e {
	case BitsProductProviderAmazon, BitsProductProviderAndroid, BitsProductProviderIos, BitsProductProviderPaypal, BitsProductProviderXsolla:
		return true
	}
	return false
}

func (e BitsProductProvider) String() string {
	return string(e)
}

func (e *BitsProductProvider) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitsProductProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitsProductProvider", str)
	}
	return nil
}

func (e BitsProductProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when retrieving bits product purchase info.
type BitsProductPurchaseInfoErrorCode string

const (
	// An unexpected internal server error occurred.
	BitsProductPurchaseInfoErrorCodeInternalServerError BitsProductPurchaseInfoErrorCode = "INTERNAL_SERVER_ERROR"
	// The user is unauthorized to view purchase info.
	BitsProductPurchaseInfoErrorCodeUserUnauthorized BitsProductPurchaseInfoErrorCode = "USER_UNAUTHORIZED"
	// The Pricing ID is not found (404).
	BitsProductPurchaseInfoErrorCodePricingIDNotFound BitsProductPurchaseInfoErrorCode = "PRICING_ID_NOT_FOUND"
	// Cannot determine User Residence. Either billing address and IP doesn't match or
	// user doesn't have country of resident declared (409).
	BitsProductPurchaseInfoErrorCodeUnknownUserResidence BitsProductPurchaseInfoErrorCode = "UNKNOWN_USER_RESIDENCE"
	// The billing info could not be found for the user and provider (410).
	BitsProductPurchaseInfoErrorCodeBillingInfoNotFound BitsProductPurchaseInfoErrorCode = "BILLING_INFO_NOT_FOUND"
	// User is not eligible to purchase bits in this region (422).
	BitsProductPurchaseInfoErrorCodePurchaseIneligible BitsProductPurchaseInfoErrorCode = "PURCHASE_INELIGIBLE"
)

var AllBitsProductPurchaseInfoErrorCode = []BitsProductPurchaseInfoErrorCode{
	BitsProductPurchaseInfoErrorCodeInternalServerError,
	BitsProductPurchaseInfoErrorCodeUserUnauthorized,
	BitsProductPurchaseInfoErrorCodePricingIDNotFound,
	BitsProductPurchaseInfoErrorCodeUnknownUserResidence,
	BitsProductPurchaseInfoErrorCodeBillingInfoNotFound,
	BitsProductPurchaseInfoErrorCodePurchaseIneligible,
}

func (e BitsProductPurchaseInfoErrorCode) IsValid() bool {
	switch e {
	case BitsProductPurchaseInfoErrorCodeInternalServerError, BitsProductPurchaseInfoErrorCodeUserUnauthorized, BitsProductPurchaseInfoErrorCodePricingIDNotFound, BitsProductPurchaseInfoErrorCodeUnknownUserResidence, BitsProductPurchaseInfoErrorCodeBillingInfoNotFound, BitsProductPurchaseInfoErrorCodePurchaseIneligible:
		return true
	}
	return false
}

func (e BitsProductPurchaseInfoErrorCode) String() string {
	return string(e)
}

func (e *BitsProductPurchaseInfoErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitsProductPurchaseInfoErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitsProductPurchaseInfoErrorCode", str)
	}
	return nil
}

func (e BitsProductPurchaseInfoErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumerable that identifies bits product types.
type BitsProductType string

const (
	// A product that has to be purchased.
	BitsProductTypePurchasedProduct BitsProductType = "PURCHASED_PRODUCT"
	// An unknown product type.
	BitsProductTypeUnknown BitsProductType = "UNKNOWN"
)

var AllBitsProductType = []BitsProductType{
	BitsProductTypePurchasedProduct,
	BitsProductTypeUnknown,
}

func (e BitsProductType) IsValid() bool {
	switch e {
	case BitsProductTypePurchasedProduct, BitsProductTypeUnknown:
		return true
	}
	return false
}

func (e BitsProductType) String() string {
	return string(e)
}

func (e *BitsProductType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitsProductType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitsProductType", str)
	}
	return nil
}

func (e BitsProductType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumerable that dictates user's Bits usage state.
type BitsUserState string

const (
	// The user has never used or acquired Bits.
	BitsUserStateNewUser BitsUserState = "NEW_USER"
	// The user has acquired Bits (purchased, watched ads, etc.) but has never used it.
	BitsUserStateAcquired BitsUserState = "ACQUIRED"
	// The user has never used or acquired Bits, but clicked "Skip" button to skip the first user experience.
	BitsUserStateSkipped BitsUserState = "SKIPPED"
	// The user has cheered before.
	BitsUserStateCheered BitsUserState = "CHEERED"
	// The user state is unknown.
	BitsUserStateUnknown BitsUserState = "UNKNOWN"
)

var AllBitsUserState = []BitsUserState{
	BitsUserStateNewUser,
	BitsUserStateAcquired,
	BitsUserStateSkipped,
	BitsUserStateCheered,
	BitsUserStateUnknown,
}

func (e BitsUserState) IsValid() bool {
	switch e {
	case BitsUserStateNewUser, BitsUserStateAcquired, BitsUserStateSkipped, BitsUserStateCheered, BitsUserStateUnknown:
		return true
	}
	return false
}

func (e BitsUserState) String() string {
	return string(e)
}

func (e *BitsUserState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BitsUserState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BitsUserState", str)
	}
	return nil
}

func (e BitsUserState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Location from where the current user blocked target user.
// NOTE: it is onlyl used from the block_user mutation, this enum should have been named BlockUserContext and be placed in the same mutation file.
type BlockContext string

const (
	BlockContextWhisper BlockContext = "WHISPER"
	BlockContextChat    BlockContext = "CHAT"
)

var AllBlockContext = []BlockContext{
	BlockContextWhisper,
	BlockContextChat,
}

func (e BlockContext) IsValid() bool {
	switch e {
	case BlockContextWhisper, BlockContextChat:
		return true
	}
	return false
}

func (e BlockContext) String() string {
	return string(e)
}

func (e *BlockContext) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlockContext(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlockContext", str)
	}
	return nil
}

func (e BlockContext) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the user's status on Bounty Board.
type BountyBoardUserStatus string

const (
	// The user has been invited to join the Bounty Board program but cannot participate in bounties yet.
	BountyBoardUserStatusInvited BountyBoardUserStatus = "INVITED"
	// The user has been accepted into the Bounty Board program and can participate in bounties.
	BountyBoardUserStatusAccepted BountyBoardUserStatus = "ACCEPTED"
	// The user has been banned from the Bounty Board program.
	BountyBoardUserStatusBanned BountyBoardUserStatus = "BANNED"
	// The user is not part of the Bounty Board program.
	BountyBoardUserStatusNone BountyBoardUserStatus = "NONE"
)

var AllBountyBoardUserStatus = []BountyBoardUserStatus{
	BountyBoardUserStatusInvited,
	BountyBoardUserStatusAccepted,
	BountyBoardUserStatusBanned,
	BountyBoardUserStatusNone,
}

func (e BountyBoardUserStatus) IsValid() bool {
	switch e {
	case BountyBoardUserStatusInvited, BountyBoardUserStatusAccepted, BountyBoardUserStatusBanned, BountyBoardUserStatusNone:
		return true
	}
	return false
}

func (e BountyBoardUserStatus) String() string {
	return string(e)
}

func (e *BountyBoardUserStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BountyBoardUserStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BountyBoardUserStatus", str)
	}
	return nil
}

func (e BountyBoardUserStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of a bounty campaign.
type BountyCampaignStatus string

const (
	// The campaign is pending approval.
	BountyCampaignStatusPending BountyCampaignStatus = "PENDING"
	// The campaign has been approved.
	BountyCampaignStatusApproved BountyCampaignStatus = "APPROVED"
	// The campaign has been rejected.
	BountyCampaignStatusRejected BountyCampaignStatus = "REJECTED"
	// The campaign is live.
	BountyCampaignStatusLive BountyCampaignStatus = "LIVE"
	// The campaign is done.
	BountyCampaignStatusCompleted BountyCampaignStatus = "COMPLETED"
)

var AllBountyCampaignStatus = []BountyCampaignStatus{
	BountyCampaignStatusPending,
	BountyCampaignStatusApproved,
	BountyCampaignStatusRejected,
	BountyCampaignStatusLive,
	BountyCampaignStatusCompleted,
}

func (e BountyCampaignStatus) IsValid() bool {
	switch e {
	case BountyCampaignStatusPending, BountyCampaignStatusApproved, BountyCampaignStatusRejected, BountyCampaignStatusLive, BountyCampaignStatusCompleted:
		return true
	}
	return false
}

func (e BountyCampaignStatus) String() string {
	return string(e)
}

func (e *BountyCampaignStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BountyCampaignStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BountyCampaignStatus", str)
	}
	return nil
}

func (e BountyCampaignStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the type of the campaign.
type BountyCampaignType string

const (
	// A user is paid to stream themselves playing a game.
	BountyCampaignTypePayToStream BountyCampaignType = "PAY_TO_STREAM"
	// A user is paid to stream a game trailer.
	BountyCampaignTypeGameTrailer BountyCampaignType = "GAME_TRAILER"
	// A user is paid to stream a non-game trailer (ie. a movie trailer).
	BountyCampaignTypeMiscTrailer BountyCampaignType = "MISC_TRAILER"
	// Invalid campaign type.
	BountyCampaignTypeUnknown BountyCampaignType = "UNKNOWN"
)

var AllBountyCampaignType = []BountyCampaignType{
	BountyCampaignTypePayToStream,
	BountyCampaignTypeGameTrailer,
	BountyCampaignTypeMiscTrailer,
	BountyCampaignTypeUnknown,
}

func (e BountyCampaignType) IsValid() bool {
	switch e {
	case BountyCampaignTypePayToStream, BountyCampaignTypeGameTrailer, BountyCampaignTypeMiscTrailer, BountyCampaignTypeUnknown:
		return true
	}
	return false
}

func (e BountyCampaignType) String() string {
	return string(e)
}

func (e *BountyCampaignType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BountyCampaignType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BountyCampaignType", str)
	}
	return nil
}

func (e BountyCampaignType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible upload types for bounty campaigns.
type BountyCampaignUploadType string

const (
	// Upload type related to the box art image.
	BountyCampaignUploadTypeBoxArt BountyCampaignUploadType = "BOX_ART"
	// Upload type related to the cover image.
	BountyCampaignUploadTypeCover BountyCampaignUploadType = "COVER"
)

var AllBountyCampaignUploadType = []BountyCampaignUploadType{
	BountyCampaignUploadTypeBoxArt,
	BountyCampaignUploadTypeCover,
}

func (e BountyCampaignUploadType) IsValid() bool {
	switch e {
	case BountyCampaignUploadTypeBoxArt, BountyCampaignUploadTypeCover:
		return true
	}
	return false
}

func (e BountyCampaignUploadType) String() string {
	return string(e)
}

func (e *BountyCampaignUploadType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BountyCampaignUploadType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BountyCampaignUploadType", str)
	}
	return nil
}

func (e BountyCampaignUploadType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents all the currently possible key product types.
type BountyKeyProductType string

const (
	// The key is a coupon code.
	BountyKeyProductTypeCoupon BountyKeyProductType = "COUPON"
	// The key is for downloadable content or a game expansion.
	BountyKeyProductTypeDlc BountyKeyProductType = "DLC"
	// The key is a game code.
	BountyKeyProductTypeGame BountyKeyProductType = "GAME"
	// The key is for a gift card.
	BountyKeyProductTypeGiftcard BountyKeyProductType = "GIFTCARD"
	// The key is a code for a giveaway.
	BountyKeyProductTypeGiveaway BountyKeyProductType = "GIVEAWAY"
	// The key is for in game content - character skins, customization, etc.
	BountyKeyProductTypeIgc BountyKeyProductType = "IGC"
	// The key is for something else.
	BountyKeyProductTypeOther BountyKeyProductType = "OTHER"
)

var AllBountyKeyProductType = []BountyKeyProductType{
	BountyKeyProductTypeCoupon,
	BountyKeyProductTypeDlc,
	BountyKeyProductTypeGame,
	BountyKeyProductTypeGiftcard,
	BountyKeyProductTypeGiveaway,
	BountyKeyProductTypeIgc,
	BountyKeyProductTypeOther,
}

func (e BountyKeyProductType) IsValid() bool {
	switch e {
	case BountyKeyProductTypeCoupon, BountyKeyProductTypeDlc, BountyKeyProductTypeGame, BountyKeyProductTypeGiftcard, BountyKeyProductTypeGiveaway, BountyKeyProductTypeIgc, BountyKeyProductTypeOther:
		return true
	}
	return false
}

func (e BountyKeyProductType) String() string {
	return string(e)
}

func (e *BountyKeyProductType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BountyKeyProductType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BountyKeyProductType", str)
	}
	return nil
}

func (e BountyKeyProductType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The reason why bounty failed moderation.
type BountyModerationFailReason string

const (
	// Moderation failed because broadcast does not meet minimal stream length requirement.
	BountyModerationFailReasonMinimumTimeNotMet BountyModerationFailReason = "MINIMUM_TIME_NOT_MET"
	// Moderation failed because broadcast is not with required content.
	BountyModerationFailReasonIncorrectContent BountyModerationFailReason = "INCORRECT_CONTENT"
	// Moderation failed because broadcaster did badmouthing during stream.
	BountyModerationFailReasonBadmouthing BountyModerationFailReason = "BADMOUTHING"
	// Moderation failed because other content layered over/under required content.
	BountyModerationFailReasonOtherContentVisible BountyModerationFailReason = "OTHER_CONTENT_VISIBLE"
	// Moderation failed because broadcaster had exessive idle time during sponsored stream.
	BountyModerationFailReasonIDLe BountyModerationFailReason = "IDLE"
	// Moderation failed because missing sponsored stream VOD.
	BountyModerationFailReasonNoVod BountyModerationFailReason = "NO_VOD"
	// Other reason caused moderation failed.
	BountyModerationFailReasonOther BountyModerationFailReason = "OTHER"
)

var AllBountyModerationFailReason = []BountyModerationFailReason{
	BountyModerationFailReasonMinimumTimeNotMet,
	BountyModerationFailReasonIncorrectContent,
	BountyModerationFailReasonBadmouthing,
	BountyModerationFailReasonOtherContentVisible,
	BountyModerationFailReasonIDLe,
	BountyModerationFailReasonNoVod,
	BountyModerationFailReasonOther,
}

func (e BountyModerationFailReason) IsValid() bool {
	switch e {
	case BountyModerationFailReasonMinimumTimeNotMet, BountyModerationFailReasonIncorrectContent, BountyModerationFailReasonBadmouthing, BountyModerationFailReasonOtherContentVisible, BountyModerationFailReasonIDLe, BountyModerationFailReasonNoVod, BountyModerationFailReasonOther:
		return true
	}
	return false
}

func (e BountyModerationFailReason) String() string {
	return string(e)
}

func (e *BountyModerationFailReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BountyModerationFailReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BountyModerationFailReason", str)
	}
	return nil
}

func (e BountyModerationFailReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The moderation status of the bounty.
type BountyModerationStatus string

const (
	// The bounty has passed the moderation check.
	BountyModerationStatusPass BountyModerationStatus = "PASS"
	// The bounty is waiting for moderation check.
	BountyModerationStatusPendingReview BountyModerationStatus = "PENDING_REVIEW"
	// The bounty has failed the moderation check.
	BountyModerationStatusFail BountyModerationStatus = "FAIL"
)

var AllBountyModerationStatus = []BountyModerationStatus{
	BountyModerationStatusPass,
	BountyModerationStatusPendingReview,
	BountyModerationStatusFail,
}

func (e BountyModerationStatus) IsValid() bool {
	switch e {
	case BountyModerationStatusPass, BountyModerationStatusPendingReview, BountyModerationStatusFail:
		return true
	}
	return false
}

func (e BountyModerationStatus) String() string {
	return string(e)
}

func (e *BountyModerationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BountyModerationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BountyModerationStatus", str)
	}
	return nil
}

func (e BountyModerationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents all the possible bounty statuses.
type BountyStatus string

const (
	// The bounty can be claimed by the user.
	BountyStatusAvailable BountyStatus = "AVAILABLE"
	// The bounty has been claimed by the user and is in progress.
	BountyStatusLive BountyStatus = "LIVE"
	// The bounty was completed successfully.
	BountyStatusCompleted BountyStatus = "COMPLETED"
	// The bounty was cancelled before it was completed.
	BountyStatusCancelled BountyStatus = "CANCELLED"
)

var AllBountyStatus = []BountyStatus{
	BountyStatusAvailable,
	BountyStatusLive,
	BountyStatusCompleted,
	BountyStatusCancelled,
}

func (e BountyStatus) IsValid() bool {
	switch e {
	case BountyStatusAvailable, BountyStatusLive, BountyStatusCompleted, BountyStatusCancelled:
		return true
	}
	return false
}

func (e BountyStatus) String() string {
	return string(e)
}

func (e *BountyStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BountyStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BountyStatus", str)
	}
	return nil
}

func (e BountyStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// BroadcastFormat is type of ingest live sessions.
type BroadcastFormat string

const (
	// Default live stream. Primary session for the backup session will be shown as live.
	BroadcastFormatLive BroadcastFormat = "LIVE"
	// Stream with intentional delays requested by the broadcaster.
	BroadcastFormatDelay BroadcastFormat = "DELAY"
	// Primary session which backup session was stitched back to.
	BroadcastFormatBackup000 BroadcastFormat = "BACKUP_000"
	// First backup session.
	BroadcastFormatBackup001 BroadcastFormat = "BACKUP_001"
	// Second backup session.
	BroadcastFormatBackup002 BroadcastFormat = "BACKUP_002"
	// Third backup session.
	BroadcastFormatBackup003 BroadcastFormat = "BACKUP_003"
)

var AllBroadcastFormat = []BroadcastFormat{
	BroadcastFormatLive,
	BroadcastFormatDelay,
	BroadcastFormatBackup000,
	BroadcastFormatBackup001,
	BroadcastFormatBackup002,
	BroadcastFormatBackup003,
}

func (e BroadcastFormat) IsValid() bool {
	switch e {
	case BroadcastFormatLive, BroadcastFormatDelay, BroadcastFormatBackup000, BroadcastFormatBackup001, BroadcastFormatBackup002, BroadcastFormatBackup003:
		return true
	}
	return false
}

func (e BroadcastFormat) String() string {
	return string(e)
}

func (e *BroadcastFormat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BroadcastFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BroadcastFormat", str)
	}
	return nil
}

func (e BroadcastFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes from which source the video originated.
// NOTE: Should have been named VideoBroadcastType.
type BroadcastType string

const (
	// If the video is of a past broadcast, it's an ARCHIVE.
	BroadcastTypeArchive BroadcastType = "ARCHIVE"
	// When the video is a subsection of a past broadcast, it's a HIGHLIGHT.
	BroadcastTypeHighlight BroadcastType = "HIGHLIGHT"
	// (Legacy) When the video is directly uploaded to Twitch via the upload tool, it's an UPLOAD.
	BroadcastTypeUpload BroadcastType = "UPLOAD"
	// When the video is directly uploaded to Twitch via the video manager, it's an PREMIERE_UPLOAD.
	BroadcastTypePremiereUpload BroadcastType = "PREMIERE_UPLOAD"
	// When a video has been premiered on Twitch and is saved, it's a PAST_PREMIERE.
	BroadcastTypePastPremiere BroadcastType = "PAST_PREMIERE"
)

var AllBroadcastType = []BroadcastType{
	BroadcastTypeArchive,
	BroadcastTypeHighlight,
	BroadcastTypeUpload,
	BroadcastTypePremiereUpload,
	BroadcastTypePastPremiere,
}

func (e BroadcastType) IsValid() bool {
	switch e {
	case BroadcastTypeArchive, BroadcastTypeHighlight, BroadcastTypeUpload, BroadcastTypePremiereUpload, BroadcastTypePastPremiere:
		return true
	}
	return false
}

func (e BroadcastType) String() string {
	return string(e)
}

func (e *BroadcastType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BroadcastType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BroadcastType", str)
	}
	return nil
}

func (e BroadcastType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible values of actionPrompted in SubmitCSATFeedbackInput.
type CSATActionPrompted string

const (
	// The user registers their client app (i.e. save information for an app), in their personal console.
	CSATActionPromptedClientAppRegister CSATActionPrompted = "CLIENT_APP_REGISTER"
	// The user creates a new drop campaign.
	CSATActionPromptedDropCreateCampaign CSATActionPrompted = "DROP_CREATE_CAMPAIGN"
	// The user moves a drop's state to active.
	CSATActionPromptedDropMoveStateToActive CSATActionPrompted = "DROP_MOVE_STATE_TO_ACTIVE"
	// The user move's a drop's state to testing.
	CSATActionPromptedDropMoveStateToTesting CSATActionPrompted = "DROP_MOVE_STATE_TO_TESTING"
	// The user creates a new extension.
	CSATActionPromptedExtensionCreate CSATActionPrompted = "EXTENSION_CREATE"
	// The user changes the state of an extension.
	CSATActionPromptedExtensionStateChange CSATActionPrompted = "EXTENSION_STATE_CHANGE"
	// The user views the analytics page of their game.
	CSATActionPromptedGamesViewAnalytics CSATActionPrompted = "GAMES_VIEW_ANALYTICS"
	// The user submits box art for their game.
	CSATActionPromptedGamesSubmitBoxArt CSATActionPrompted = "GAMES_SUBMIT_BOX_ART"
	// The user creates a new organization.
	CSATActionPromptedOrganizationCreate CSATActionPrompted = "ORGANIZATION_CREATE"
	// The user adds another user to their organization.
	CSATActionPromptedOrganizationAddUser CSATActionPrompted = "ORGANIZATION_ADD_USER"
)

var AllCSATActionPrompted = []CSATActionPrompted{
	CSATActionPromptedClientAppRegister,
	CSATActionPromptedDropCreateCampaign,
	CSATActionPromptedDropMoveStateToActive,
	CSATActionPromptedDropMoveStateToTesting,
	CSATActionPromptedExtensionCreate,
	CSATActionPromptedExtensionStateChange,
	CSATActionPromptedGamesViewAnalytics,
	CSATActionPromptedGamesSubmitBoxArt,
	CSATActionPromptedOrganizationCreate,
	CSATActionPromptedOrganizationAddUser,
}

func (e CSATActionPrompted) IsValid() bool {
	switch e {
	case CSATActionPromptedClientAppRegister, CSATActionPromptedDropCreateCampaign, CSATActionPromptedDropMoveStateToActive, CSATActionPromptedDropMoveStateToTesting, CSATActionPromptedExtensionCreate, CSATActionPromptedExtensionStateChange, CSATActionPromptedGamesViewAnalytics, CSATActionPromptedGamesSubmitBoxArt, CSATActionPromptedOrganizationCreate, CSATActionPromptedOrganizationAddUser:
		return true
	}
	return false
}

func (e CSATActionPrompted) String() string {
	return string(e)
}

func (e *CSATActionPrompted) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CSATActionPrompted(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CSATActionPrompted", str)
	}
	return nil
}

func (e CSATActionPrompted) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible ratings that the user can submit as part of their feedback.
type CSATRating string

const (
	// The user selects "Very Dissatisfied".
	CSATRatingVeryDissatisfied CSATRating = "VERY_DISSATISFIED"
	// The user selects "Somewhat Dissatisfied".
	CSATRatingSomewhatDissatisfied CSATRating = "SOMEWHAT_DISSATISFIED"
	// The user selects "Neutral".
	CSATRatingNeutral CSATRating = "NEUTRAL"
	// The user selects "Somewhat Satisfied".
	CSATRatingSomewhatSatisfied CSATRating = "SOMEWHAT_SATISFIED"
	// The user selects "Very Satisfied".
	CSATRatingVerySatisfied CSATRating = "VERY_SATISFIED"
)

var AllCSATRating = []CSATRating{
	CSATRatingVeryDissatisfied,
	CSATRatingSomewhatDissatisfied,
	CSATRatingNeutral,
	CSATRatingSomewhatSatisfied,
	CSATRatingVerySatisfied,
}

func (e CSATRating) IsValid() bool {
	switch e {
	case CSATRatingVeryDissatisfied, CSATRatingSomewhatDissatisfied, CSATRatingNeutral, CSATRatingSomewhatSatisfied, CSATRatingVerySatisfied:
		return true
	}
	return false
}

func (e CSATRating) String() string {
	return string(e)
}

func (e *CSATRating) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CSATRating(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CSATRating", str)
	}
	return nil
}

func (e CSATRating) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CampaignDiscoveryEventType contains the different types of discovery events that campaign objectives can track.
type CampaignDiscoveryEventType string

const (
	// An event describing a user's interaction with the command center.
	CampaignDiscoveryEventTypeEngageCommandCenter CampaignDiscoveryEventType = "ENGAGE_COMMAND_CENTER"
	// An event describing a user's interaction with a stream.
	CampaignDiscoveryEventTypeEngageStream CampaignDiscoveryEventType = "ENGAGE_STREAM"
)

var AllCampaignDiscoveryEventType = []CampaignDiscoveryEventType{
	CampaignDiscoveryEventTypeEngageCommandCenter,
	CampaignDiscoveryEventTypeEngageStream,
}

func (e CampaignDiscoveryEventType) IsValid() bool {
	switch e {
	case CampaignDiscoveryEventTypeEngageCommandCenter, CampaignDiscoveryEventTypeEngageStream:
		return true
	}
	return false
}

func (e CampaignDiscoveryEventType) String() string {
	return string(e)
}

func (e *CampaignDiscoveryEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CampaignDiscoveryEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CampaignDiscoveryEventType", str)
	}
	return nil
}

func (e CampaignDiscoveryEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the campaign.
type CampaignType string

const (
	// The default campaign type that allows all drop types but manual_triggers.
	CampaignTypeDefault CampaignType = "DEFAULT"
	// The manual trigger campaign type only allows for manual trigger type drops.
	CampaignTypeManualTriggerBased CampaignType = "MANUAL_TRIGGER_BASED"
)

var AllCampaignType = []CampaignType{
	CampaignTypeDefault,
	CampaignTypeManualTriggerBased,
}

func (e CampaignType) IsValid() bool {
	switch e {
	case CampaignTypeDefault, CampaignTypeManualTriggerBased:
		return true
	}
	return false
}

func (e CampaignType) String() string {
	return string(e)
}

func (e *CampaignType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CampaignType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CampaignType", str)
	}
	return nil
}

func (e CampaignType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error types recognized.
type CancelActiveBoostOrdersErrorCode string

const (
	// Invalid parameter in the request.
	CancelActiveBoostOrdersErrorCodeInvalidParameter CancelActiveBoostOrdersErrorCode = "INVALID_PARAMETER"
	// Internal error being returned from service.
	CancelActiveBoostOrdersErrorCodeInternalError CancelActiveBoostOrdersErrorCode = "INTERNAL_ERROR"
)

var AllCancelActiveBoostOrdersErrorCode = []CancelActiveBoostOrdersErrorCode{
	CancelActiveBoostOrdersErrorCodeInvalidParameter,
	CancelActiveBoostOrdersErrorCodeInternalError,
}

func (e CancelActiveBoostOrdersErrorCode) IsValid() bool {
	switch e {
	case CancelActiveBoostOrdersErrorCodeInvalidParameter, CancelActiveBoostOrdersErrorCodeInternalError:
		return true
	}
	return false
}

func (e CancelActiveBoostOrdersErrorCode) String() string {
	return string(e)
}

func (e *CancelActiveBoostOrdersErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CancelActiveBoostOrdersErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CancelActiveBoostOrdersErrorCode", str)
	}
	return nil
}

func (e CancelActiveBoostOrdersErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error types recognized.
type CancelBountyErrorCode string

const (
	// Invalid parameter in the request.
	CancelBountyErrorCodeInvalidParameter CancelBountyErrorCode = "INVALID_PARAMETER"
	// Bounty isn't live, thus cannot be canceled.
	CancelBountyErrorCodeBountyNotLive CancelBountyErrorCode = "BOUNTY_NOT_LIVE"
	// Unknown error being returned from service.
	CancelBountyErrorCodeUnknownError CancelBountyErrorCode = "UNKNOWN_ERROR"
)

var AllCancelBountyErrorCode = []CancelBountyErrorCode{
	CancelBountyErrorCodeInvalidParameter,
	CancelBountyErrorCodeBountyNotLive,
	CancelBountyErrorCodeUnknownError,
}

func (e CancelBountyErrorCode) IsValid() bool {
	switch e {
	case CancelBountyErrorCodeInvalidParameter, CancelBountyErrorCodeBountyNotLive, CancelBountyErrorCodeUnknownError:
		return true
	}
	return false
}

func (e CancelBountyErrorCode) String() string {
	return string(e)
}

func (e *CancelBountyErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CancelBountyErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CancelBountyErrorCode", str)
	}
	return nil
}

func (e CancelBountyErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes from the cancelPredictionEvent mutation.
type CancelPredictionEventErrorCode string

const (
	// The current user is forbidden from cancelling this Prediction Event.
	CancelPredictionEventErrorCodeForbidden CancelPredictionEventErrorCode = "FORBIDDEN"
	// This Prediction Event has already either been resolved or canceled, and as such this action cannot be taken.
	CancelPredictionEventErrorCodeEventEnded CancelPredictionEventErrorCode = "EVENT_ENDED"
	// An unknown error occurred.
	CancelPredictionEventErrorCodeUnknown CancelPredictionEventErrorCode = "UNKNOWN"
)

var AllCancelPredictionEventErrorCode = []CancelPredictionEventErrorCode{
	CancelPredictionEventErrorCodeForbidden,
	CancelPredictionEventErrorCodeEventEnded,
	CancelPredictionEventErrorCodeUnknown,
}

func (e CancelPredictionEventErrorCode) IsValid() bool {
	switch e {
	case CancelPredictionEventErrorCodeForbidden, CancelPredictionEventErrorCodeEventEnded, CancelPredictionEventErrorCodeUnknown:
		return true
	}
	return false
}

func (e CancelPredictionEventErrorCode) String() string {
	return string(e)
}

func (e *CancelPredictionEventErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CancelPredictionEventErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CancelPredictionEventErrorCode", str)
	}
	return nil
}

func (e CancelPredictionEventErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CancelRaidErrorCode are the possible errors that this mutation returns.
type CancelRaidErrorCode string

const (
	// The a raid does not exist.
	CancelRaidErrorCodeRaidDoesNotExist CancelRaidErrorCode = "RAID_DOES_NOT_EXIST"
	// The request is missing valid channel parameters.
	CancelRaidErrorCodeInvalidChannel CancelRaidErrorCode = "INVALID_CHANNEL"
	// The user tries to unraid without an active raid.
	CancelRaidErrorCodeNoActiveRaid CancelRaidErrorCode = "NO_ACTIVE_RAID"
)

var AllCancelRaidErrorCode = []CancelRaidErrorCode{
	CancelRaidErrorCodeRaidDoesNotExist,
	CancelRaidErrorCodeInvalidChannel,
	CancelRaidErrorCodeNoActiveRaid,
}

func (e CancelRaidErrorCode) IsValid() bool {
	switch e {
	case CancelRaidErrorCodeRaidDoesNotExist, CancelRaidErrorCodeInvalidChannel, CancelRaidErrorCodeNoActiveRaid:
		return true
	}
	return false
}

func (e CancelRaidErrorCode) String() string {
	return string(e)
}

func (e *CancelRaidErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CancelRaidErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CancelRaidErrorCode", str)
	}
	return nil
}

func (e CancelRaidErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes the conditions around a user's cancellation of their purchase (e.g. refund policy).
type CancellationPolicyType string

const (
	// The product is not refundable.
	CancellationPolicyTypeNonRefundable CancellationPolicyType = "NON_REFUNDABLE"
	// The product is refundable.
	CancellationPolicyTypeRefundable CancellationPolicyType = "REFUNDABLE"
)

var AllCancellationPolicyType = []CancellationPolicyType{
	CancellationPolicyTypeNonRefundable,
	CancellationPolicyTypeRefundable,
}

func (e CancellationPolicyType) IsValid() bool {
	switch e {
	case CancellationPolicyTypeNonRefundable, CancellationPolicyTypeRefundable:
		return true
	}
	return false
}

func (e CancellationPolicyType) String() string {
	return string(e)
}

func (e *CancellationPolicyType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CancellationPolicyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CancellationPolicyType", str)
	}
	return nil
}

func (e CancellationPolicyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Area in which the celebration will show.
type CelebrationArea string

const (
	// Celebration will show everywhere over the channel page.
	CelebrationAreaEverywhere CelebrationArea = "EVERYWHERE"
	// Celebration will show only over the video.
	CelebrationAreaVideoOnly CelebrationArea = "VIDEO_ONLY"
	// Celebration will show over the video and panel.
	CelebrationAreaVideoAndPanel CelebrationArea = "VIDEO_AND_PANEL"
	// Unknown celebration area.
	CelebrationAreaUnknown CelebrationArea = "UNKNOWN"
)

var AllCelebrationArea = []CelebrationArea{
	CelebrationAreaEverywhere,
	CelebrationAreaVideoOnly,
	CelebrationAreaVideoAndPanel,
	CelebrationAreaUnknown,
}

func (e CelebrationArea) IsValid() bool {
	switch e {
	case CelebrationAreaEverywhere, CelebrationAreaVideoOnly, CelebrationAreaVideoAndPanel, CelebrationAreaUnknown:
		return true
	}
	return false
}

func (e CelebrationArea) String() string {
	return string(e)
}

func (e *CelebrationArea) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CelebrationArea(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CelebrationArea", str)
	}
	return nil
}

func (e CelebrationArea) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of effect that can show during a celebration.
type CelebrationEffect string

const (
	// Will show fireworks when the celebration triggers.
	CelebrationEffectFireworks CelebrationEffect = "FIREWORKS"
	// Will show an emote rain when the celebration triggers.
	CelebrationEffectRain CelebrationEffect = "RAIN"
	// Will show an flamethrowers when the celebration triggers.
	CelebrationEffectFlamethrowers CelebrationEffect = "FLAMETHROWERS"
	// Unknown effect.
	CelebrationEffectUnknown CelebrationEffect = "UNKNOWN"
)

var AllCelebrationEffect = []CelebrationEffect{
	CelebrationEffectFireworks,
	CelebrationEffectRain,
	CelebrationEffectFlamethrowers,
	CelebrationEffectUnknown,
}

func (e CelebrationEffect) IsValid() bool {
	switch e {
	case CelebrationEffectFireworks, CelebrationEffectRain, CelebrationEffectFlamethrowers, CelebrationEffectUnknown:
		return true
	}
	return false
}

func (e CelebrationEffect) String() string {
	return string(e)
}

func (e *CelebrationEffect) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CelebrationEffect(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CelebrationEffect", str)
	}
	return nil
}

func (e CelebrationEffect) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Vote in celebration error code.
type CelebrationErrorCode string

const (
	// Attempted to preform operation on celebration that does not exist.
	CelebrationErrorCodeCelebrationNotFound CelebrationErrorCode = "CELEBRATION_NOT_FOUND"
	// A celebration with that same event type and threshold already exists.
	CelebrationErrorCodeCelebrationAlreadyExists CelebrationErrorCode = "CELEBRATION_ALREADY_EXISTS"
	// Requesting user does not have permission.
	CelebrationErrorCodePermissionDenied CelebrationErrorCode = "PERMISSION_DENIED"
	// The user has reached the limit (20) of celebrations they can have.
	CelebrationErrorCodeOverCelebrationLimit CelebrationErrorCode = "OVER_CELEBRATION_LIMIT"
	// An unknown error occurred.
	CelebrationErrorCodeUnknown CelebrationErrorCode = "UNKNOWN"
)

var AllCelebrationErrorCode = []CelebrationErrorCode{
	CelebrationErrorCodeCelebrationNotFound,
	CelebrationErrorCodeCelebrationAlreadyExists,
	CelebrationErrorCodePermissionDenied,
	CelebrationErrorCodeOverCelebrationLimit,
	CelebrationErrorCodeUnknown,
}

func (e CelebrationErrorCode) IsValid() bool {
	switch e {
	case CelebrationErrorCodeCelebrationNotFound, CelebrationErrorCodeCelebrationAlreadyExists, CelebrationErrorCodePermissionDenied, CelebrationErrorCodeOverCelebrationLimit, CelebrationErrorCodeUnknown:
		return true
	}
	return false
}

func (e CelebrationErrorCode) String() string {
	return string(e)
}

func (e *CelebrationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CelebrationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CelebrationErrorCode", str)
	}
	return nil
}

func (e CelebrationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of event that can trigger a celebration.
type CelebrationEventType string

const (
	// Cheering with bits.
	CelebrationEventTypeBitsCheer CelebrationEventType = "BITS_CHEER"
	// Gifting subscriptions to other users.
	CelebrationEventTypeSubscriptionGift CelebrationEventType = "SUBSCRIPTION_GIFT"
	// Unknown event type.
	CelebrationEventTypeUnknown CelebrationEventType = "UNKNOWN"
)

var AllCelebrationEventType = []CelebrationEventType{
	CelebrationEventTypeBitsCheer,
	CelebrationEventTypeSubscriptionGift,
	CelebrationEventTypeUnknown,
}

func (e CelebrationEventType) IsValid() bool {
	switch e {
	case CelebrationEventTypeBitsCheer, CelebrationEventTypeSubscriptionGift, CelebrationEventTypeUnknown:
		return true
	}
	return false
}

func (e CelebrationEventType) String() string {
	return string(e)
}

func (e *CelebrationEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CelebrationEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CelebrationEventType", str)
	}
	return nil
}

func (e CelebrationEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of intensity of a celebration.
type CelebrationIntensity string

const (
	// A small intensity celebration.
	CelebrationIntensitySmall CelebrationIntensity = "SMALL"
	// A medium intensity celebration.
	CelebrationIntensityMedium CelebrationIntensity = "MEDIUM"
	// A large intensity celebration.
	CelebrationIntensityLarge CelebrationIntensity = "LARGE"
	// Unknown intensity.
	CelebrationIntensityUnknown CelebrationIntensity = "UNKNOWN"
)

var AllCelebrationIntensity = []CelebrationIntensity{
	CelebrationIntensitySmall,
	CelebrationIntensityMedium,
	CelebrationIntensityLarge,
	CelebrationIntensityUnknown,
}

func (e CelebrationIntensity) IsValid() bool {
	switch e {
	case CelebrationIntensitySmall, CelebrationIntensityMedium, CelebrationIntensityLarge, CelebrationIntensityUnknown:
		return true
	}
	return false
}

func (e CelebrationIntensity) String() string {
	return string(e)
}

func (e *CelebrationIntensity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CelebrationIntensity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CelebrationIntensity", str)
	}
	return nil
}

func (e CelebrationIntensity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Final state of the condition participant.
type ChallengeConditionParticipantEndState string

const (
	// Pending completion of associated condition.
	ChallengeConditionParticipantEndStatePending ChallengeConditionParticipantEndState = "PENDING"
	// Associated condition expired.
	ChallengeConditionParticipantEndStateConditionExpired ChallengeConditionParticipantEndState = "CONDITION_EXPIRED"
	// Associated condition was canceled.
	ChallengeConditionParticipantEndStateConditionCanceled ChallengeConditionParticipantEndState = "CONDITION_CANCELED"
	// Associated condition was satisfied.
	ChallengeConditionParticipantEndStateConditionSatisfied ChallengeConditionParticipantEndState = "CONDITION_SATISFIED"
	// Condition participant expired before associated condition could be satisfied.
	ChallengeConditionParticipantEndStateExpired ChallengeConditionParticipantEndState = "EXPIRED"
	// Condition participant was canceled.
	ChallengeConditionParticipantEndStateCanceled ChallengeConditionParticipantEndState = "CANCELED"
	// Condition participant failed validation prior to being processed.
	ChallengeConditionParticipantEndStateFailedValidation ChallengeConditionParticipantEndState = "FAILED_VALIDATION"
	// Unknown state.
	ChallengeConditionParticipantEndStateUnknown ChallengeConditionParticipantEndState = "UNKNOWN"
)

var AllChallengeConditionParticipantEndState = []ChallengeConditionParticipantEndState{
	ChallengeConditionParticipantEndStatePending,
	ChallengeConditionParticipantEndStateConditionExpired,
	ChallengeConditionParticipantEndStateConditionCanceled,
	ChallengeConditionParticipantEndStateConditionSatisfied,
	ChallengeConditionParticipantEndStateExpired,
	ChallengeConditionParticipantEndStateCanceled,
	ChallengeConditionParticipantEndStateFailedValidation,
	ChallengeConditionParticipantEndStateUnknown,
}

func (e ChallengeConditionParticipantEndState) IsValid() bool {
	switch e {
	case ChallengeConditionParticipantEndStatePending, ChallengeConditionParticipantEndStateConditionExpired, ChallengeConditionParticipantEndStateConditionCanceled, ChallengeConditionParticipantEndStateConditionSatisfied, ChallengeConditionParticipantEndStateExpired, ChallengeConditionParticipantEndStateCanceled, ChallengeConditionParticipantEndStateFailedValidation, ChallengeConditionParticipantEndStateUnknown:
		return true
	}
	return false
}

func (e ChallengeConditionParticipantEndState) String() string {
	return string(e)
}

func (e *ChallengeConditionParticipantEndState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChallengeConditionParticipantEndState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChallengeConditionParticipantEndState", str)
	}
	return nil
}

func (e ChallengeConditionParticipantEndState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Whether or not the condition participant was successfully processed upon condition completion.
type ChallengeConditionParticipantProcessingState string

const (
	// Pending completion of associated condition.
	ChallengeConditionParticipantProcessingStatePending ChallengeConditionParticipantProcessingState = "PENDING"
	// Condition participant processed successfully.
	ChallengeConditionParticipantProcessingStateSuccess ChallengeConditionParticipantProcessingState = "SUCCESS"
	// Error processing condition participant.
	ChallengeConditionParticipantProcessingStateError ChallengeConditionParticipantProcessingState = "ERROR"
	// Unknown state.
	ChallengeConditionParticipantProcessingStateUnknown ChallengeConditionParticipantProcessingState = "UNKNOWN"
)

var AllChallengeConditionParticipantProcessingState = []ChallengeConditionParticipantProcessingState{
	ChallengeConditionParticipantProcessingStatePending,
	ChallengeConditionParticipantProcessingStateSuccess,
	ChallengeConditionParticipantProcessingStateError,
	ChallengeConditionParticipantProcessingStateUnknown,
}

func (e ChallengeConditionParticipantProcessingState) IsValid() bool {
	switch e {
	case ChallengeConditionParticipantProcessingStatePending, ChallengeConditionParticipantProcessingStateSuccess, ChallengeConditionParticipantProcessingStateError, ChallengeConditionParticipantProcessingStateUnknown:
		return true
	}
	return false
}

func (e ChallengeConditionParticipantProcessingState) String() string {
	return string(e)
}

func (e *ChallengeConditionParticipantProcessingState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChallengeConditionParticipantProcessingState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChallengeConditionParticipantProcessingState", str)
	}
	return nil
}

func (e ChallengeConditionParticipantProcessingState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The current state of the condition.
type ChallengeConditionState string

const (
	// New condition participants can be associated with this condition.
	ChallengeConditionStateActive ChallengeConditionState = "ACTIVE"
	// Condition was manually terminated. New condition participants cannot be associated.
	ChallengeConditionStateCanceled ChallengeConditionState = "CANCELED"
	// Condition was satisfied for the final time. New condition participants cannot be associated with this condition.
	ChallengeConditionStateInactive ChallengeConditionState = "INACTIVE"
	// Condition was automatically terminated. New condition participants cannot be associated.
	ChallengeConditionStateExpired ChallengeConditionState = "EXPIRED"
	// Unknown state.
	ChallengeConditionStateUnknown ChallengeConditionState = "UNKNOWN"
)

var AllChallengeConditionState = []ChallengeConditionState{
	ChallengeConditionStateActive,
	ChallengeConditionStateCanceled,
	ChallengeConditionStateInactive,
	ChallengeConditionStateExpired,
	ChallengeConditionStateUnknown,
}

func (e ChallengeConditionState) IsValid() bool {
	switch e {
	case ChallengeConditionStateActive, ChallengeConditionStateCanceled, ChallengeConditionStateInactive, ChallengeConditionStateExpired, ChallengeConditionStateUnknown:
		return true
	}
	return false
}

func (e ChallengeConditionState) String() string {
	return string(e)
}

func (e *ChallengeConditionState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChallengeConditionState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChallengeConditionState", str)
	}
	return nil
}

func (e ChallengeConditionState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of effect.
type ChallengeEffectType string

const (
	// Type of effect that results in using a user's bits.
	ChallengeEffectTypeUseBits ChallengeEffectType = "USE_BITS"
	// Unknown type.
	ChallengeEffectTypeUnknown ChallengeEffectType = "UNKNOWN"
)

var AllChallengeEffectType = []ChallengeEffectType{
	ChallengeEffectTypeUseBits,
	ChallengeEffectTypeUnknown,
}

func (e ChallengeEffectType) IsValid() bool {
	switch e {
	case ChallengeEffectTypeUseBits, ChallengeEffectTypeUnknown:
		return true
	}
	return false
}

func (e ChallengeEffectType) String() string {
	return string(e)
}

func (e *ChallengeEffectType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChallengeEffectType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChallengeEffectType", str)
	}
	return nil
}

func (e ChallengeEffectType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes returned from a change username.
type ChangeUsernameErrorCode string

const (
	// Sudo token expired, prompt the user to log in again.
	ChangeUsernameErrorCodeReauthNeeded ChangeUsernameErrorCode = "REAUTH_NEEDED"
	// Too many attempts to update login.
	ChangeUsernameErrorCodeRequestsThrottled ChangeUsernameErrorCode = "REQUESTS_THROTTLED"
	// Login was changed recently (last 60 days).
	ChangeUsernameErrorCodeLoginChangeCooldown ChangeUsernameErrorCode = "LOGIN_CHANGE_COOLDOWN"
	// Login is not available.
	ChangeUsernameErrorCodeLoginUnavailable ChangeUsernameErrorCode = "LOGIN_UNAVAILABLE"
	// Login is too short.
	ChangeUsernameErrorCodeLoginTooShort ChangeUsernameErrorCode = "LOGIN_TOO_SHORT"
	// Login is too long.
	ChangeUsernameErrorCodeLoginTooLong ChangeUsernameErrorCode = "LOGIN_TOO_LONG"
	// Login contains characters that are not allowed.
	ChangeUsernameErrorCodeLoginContainsInvalidCharacters ChangeUsernameErrorCode = "LOGIN_CONTAINS_INVALID_CHARACTERS"
	// Login change requires a verified email.
	ChangeUsernameErrorCodeLoginChangeEmailVerified ChangeUsernameErrorCode = "LOGIN_CHANGE_EMAIL_VERIFIED"
	// Unrecognized error returned from the backend service.
	ChangeUsernameErrorCodeUnknownError ChangeUsernameErrorCode = "UNKNOWN_ERROR"
)

var AllChangeUsernameErrorCode = []ChangeUsernameErrorCode{
	ChangeUsernameErrorCodeReauthNeeded,
	ChangeUsernameErrorCodeRequestsThrottled,
	ChangeUsernameErrorCodeLoginChangeCooldown,
	ChangeUsernameErrorCodeLoginUnavailable,
	ChangeUsernameErrorCodeLoginTooShort,
	ChangeUsernameErrorCodeLoginTooLong,
	ChangeUsernameErrorCodeLoginContainsInvalidCharacters,
	ChangeUsernameErrorCodeLoginChangeEmailVerified,
	ChangeUsernameErrorCodeUnknownError,
}

func (e ChangeUsernameErrorCode) IsValid() bool {
	switch e {
	case ChangeUsernameErrorCodeReauthNeeded, ChangeUsernameErrorCodeRequestsThrottled, ChangeUsernameErrorCodeLoginChangeCooldown, ChangeUsernameErrorCodeLoginUnavailable, ChangeUsernameErrorCodeLoginTooShort, ChangeUsernameErrorCodeLoginTooLong, ChangeUsernameErrorCodeLoginContainsInvalidCharacters, ChangeUsernameErrorCodeLoginChangeEmailVerified, ChangeUsernameErrorCodeUnknownError:
		return true
	}
	return false
}

func (e ChangeUsernameErrorCode) String() string {
	return string(e)
}

func (e *ChangeUsernameErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeUsernameErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeUsernameErrorCode", str)
	}
	return nil
}

func (e ChangeUsernameErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ChanletSort indicates the desired order of chanlets in the list returned by LoadChanletsByUserID.
type ChanletSort string

const (
	// ChanletSortNone indicates that the order of chanlets returned is insignificant to the client and is allowed to be arbitrary.
	ChanletSortNone ChanletSort = "NONE"
	// ChanletSortViewerCount indicates chanlets should return sorted by viewer counts, descending.
	ChanletSortViewerCount ChanletSort = "VIEWER_COUNT"
)

var AllChanletSort = []ChanletSort{
	ChanletSortNone,
	ChanletSortViewerCount,
}

func (e ChanletSort) IsValid() bool {
	switch e {
	case ChanletSortNone, ChanletSortViewerCount:
		return true
	}
	return false
}

func (e ChanletSort) String() string {
	return string(e)
}

func (e *ChanletSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChanletSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChanletSort", str)
	}
	return nil
}

func (e ChanletSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible sort orders for lists of challenges.
type ChannelChallengeSort string

const (
	// Sort the challenges by time.
	ChannelChallengeSortStartTime ChannelChallengeSort = "START_TIME"
	// Sort the challenges by time.
	ChannelChallengeSortEndTime ChannelChallengeSort = "END_TIME"
)

var AllChannelChallengeSort = []ChannelChallengeSort{
	ChannelChallengeSortStartTime,
	ChannelChallengeSortEndTime,
}

func (e ChannelChallengeSort) IsValid() bool {
	switch e {
	case ChannelChallengeSortStartTime, ChannelChallengeSortEndTime:
		return true
	}
	return false
}

func (e ChannelChallengeSort) String() string {
	return string(e)
}

func (e *ChannelChallengeSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChannelChallengeSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChannelChallengeSort", str)
	}
	return nil
}

func (e ChannelChallengeSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the challenge.
type ChannelChallengeStatus string

const (
	// Encountered some challenge status that we do not know how to handle.
	ChannelChallengeStatusUnknown ChannelChallengeStatus = "UNKNOWN"
	// Challenge is active. Users can contribute bits, with the challenge information publicly visible.
	ChannelChallengeStatusActive ChannelChallengeStatus = "ACTIVE"
	// Challenge was manually ended by a user and marked as "completed". Users cannot contribute bits. Challenge information publicly visible.
	ChannelChallengeStatusCompleted ChannelChallengeStatus = "COMPLETED"
	// Challenge was manually ended by a user and marked as "failed". Users cannot contribute bits. Challenge information publicly visible.
	ChannelChallengeStatusFailed ChannelChallengeStatus = "FAILED"
	// Challenge has ended and is no longer publicly visible. Users cannot contribute bits. Challenge information publicly visible.
	ChannelChallengeStatusTimedOut ChannelChallengeStatus = "TIMED_OUT"
)

var AllChannelChallengeStatus = []ChannelChallengeStatus{
	ChannelChallengeStatusUnknown,
	ChannelChallengeStatusActive,
	ChannelChallengeStatusCompleted,
	ChannelChallengeStatusFailed,
	ChannelChallengeStatusTimedOut,
}

func (e ChannelChallengeStatus) IsValid() bool {
	switch e {
	case ChannelChallengeStatusUnknown, ChannelChallengeStatusActive, ChannelChallengeStatusCompleted, ChannelChallengeStatusFailed, ChannelChallengeStatusTimedOut:
		return true
	}
	return false
}

func (e ChannelChallengeStatus) String() string {
	return string(e)
}

func (e *ChannelChallengeStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChannelChallengeStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChannelChallengeStatus", str)
	}
	return nil
}

func (e ChannelChallengeStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of permissions a user can have on a channel.
type ChannelPermission string

const (
	// Permission to manage Chanlets, which represent sub-streams in a multiview mode.
	ChannelPermissionMultiviewAdmin ChannelPermission = "MULTIVIEW_ADMIN"
	// Permission to create restrictions on the channel.
	ChannelPermissionSetChannelRestriction ChannelPermission = "SET_CHANNEL_RESTRICTION"
)

var AllChannelPermission = []ChannelPermission{
	ChannelPermissionMultiviewAdmin,
	ChannelPermissionSetChannelRestriction,
}

func (e ChannelPermission) IsValid() bool {
	switch e {
	case ChannelPermissionMultiviewAdmin, ChannelPermissionSetChannelRestriction:
		return true
	}
	return false
}

func (e ChannelPermission) String() string {
	return string(e)
}

func (e *ChannelPermission) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChannelPermission(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChannelPermission", str)
	}
	return nil
}

func (e ChannelPermission) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of the different restriction types.
type ChannelRestrictionType string

const (
	// The resource is restricted for an unknown reason.
	ChannelRestrictionTypeUnknown ChannelRestrictionType = "UNKNOWN"
	// The channel is restricted by a subscription.
	ChannelRestrictionTypeSubOnlyLive ChannelRestrictionType = "SUB_ONLY_LIVE"
	// The channel is restricted by the All-Access Pass.
	ChannelRestrictionTypeAllAccessPass ChannelRestrictionType = "ALL_ACCESS_PASS"
)

var AllChannelRestrictionType = []ChannelRestrictionType{
	ChannelRestrictionTypeUnknown,
	ChannelRestrictionTypeSubOnlyLive,
	ChannelRestrictionTypeAllAccessPass,
}

func (e ChannelRestrictionType) IsValid() bool {
	switch e {
	case ChannelRestrictionTypeUnknown, ChannelRestrictionTypeSubOnlyLive, ChannelRestrictionTypeAllAccessPass:
		return true
	}
	return false
}

func (e ChannelRestrictionType) String() string {
	return string(e)
}

func (e *ChannelRestrictionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChannelRestrictionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChannelRestrictionType", str)
	}
	return nil
}

func (e ChannelRestrictionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible user roles within a channel.
type ChannelUserRole string

const (
	// The channel owner.
	ChannelUserRoleBroadcaster ChannelUserRole = "BROADCASTER"
	// An editor for the channel.
	ChannelUserRoleEditor ChannelUserRole = "EDITOR"
	// A moderator for the channel.
	ChannelUserRoleModerator ChannelUserRole = "MODERATOR"
	// A subscriber of the channel.
	ChannelUserRoleSubscriber ChannelUserRole = "SUBSCRIBER"
	// A user with no roles.
	ChannelUserRoleRegular ChannelUserRole = "REGULAR"
)

var AllChannelUserRole = []ChannelUserRole{
	ChannelUserRoleBroadcaster,
	ChannelUserRoleEditor,
	ChannelUserRoleModerator,
	ChannelUserRoleSubscriber,
	ChannelUserRoleRegular,
}

func (e ChannelUserRole) IsValid() bool {
	switch e {
	case ChannelUserRoleBroadcaster, ChannelUserRoleEditor, ChannelUserRoleModerator, ChannelUserRoleSubscriber, ChannelUserRoleRegular:
		return true
	}
	return false
}

func (e ChannelUserRole) String() string {
	return string(e)
}

func (e *ChannelUserRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChannelUserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChannelUserRole", str)
	}
	return nil
}

func (e ChannelUserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ChargeModelPlanIntervalUnit defines the unit of the charge model interval.
type ChargeModelPlanIntervalUnit string

const (
	// Interval unit of Days.
	ChargeModelPlanIntervalUnitDays ChargeModelPlanIntervalUnit = "DAYS"
	// Interval unit of Months.
	ChargeModelPlanIntervalUnitMonths ChargeModelPlanIntervalUnit = "MONTHS"
	// Unknown interval unit.
	ChargeModelPlanIntervalUnitUnknown ChargeModelPlanIntervalUnit = "UNKNOWN"
)

var AllChargeModelPlanIntervalUnit = []ChargeModelPlanIntervalUnit{
	ChargeModelPlanIntervalUnitDays,
	ChargeModelPlanIntervalUnitMonths,
	ChargeModelPlanIntervalUnitUnknown,
}

func (e ChargeModelPlanIntervalUnit) IsValid() bool {
	switch e {
	case ChargeModelPlanIntervalUnitDays, ChargeModelPlanIntervalUnitMonths, ChargeModelPlanIntervalUnitUnknown:
		return true
	}
	return false
}

func (e ChargeModelPlanIntervalUnit) String() string {
	return string(e)
}

func (e *ChargeModelPlanIntervalUnit) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChargeModelPlanIntervalUnit(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChargeModelPlanIntervalUnit", str)
	}
	return nil
}

func (e ChargeModelPlanIntervalUnit) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ChatPauseSetting represents the possible settings for the user's preferred way to pause chat when moderating.
type ChatPauseSetting string

const (
	// SCROLL_ONLY is the default behavior and pauses chat every time the users scrolls over the chat list.
	ChatPauseSettingScrollOnly ChatPauseSetting = "SCROLL_ONLY"
	// MOUSEOVER pauses chat whenever a user's mouse hovers over the list, unpauses automatically after 5 seconds if no scroll is performed.
	ChatPauseSettingMouseover ChatPauseSetting = "MOUSEOVER"
	// ALTKEY pauses chat when the user presses the alt key (option for mac users). It unpauses when the key is released.
	ChatPauseSettingAltkey ChatPauseSetting = "ALTKEY"
	// MOUSEOVER_ALTKEY pauses chat on mouse hover and hitting the alt key.
	ChatPauseSettingMouseoverAltkey ChatPauseSetting = "MOUSEOVER_ALTKEY"
)

var AllChatPauseSetting = []ChatPauseSetting{
	ChatPauseSettingScrollOnly,
	ChatPauseSettingMouseover,
	ChatPauseSettingAltkey,
	ChatPauseSettingMouseoverAltkey,
}

func (e ChatPauseSetting) IsValid() bool {
	switch e {
	case ChatPauseSettingScrollOnly, ChatPauseSettingMouseover, ChatPauseSettingAltkey, ChatPauseSettingMouseoverAltkey:
		return true
	}
	return false
}

func (e ChatPauseSetting) String() string {
	return string(e)
}

func (e *ChatPauseSetting) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChatPauseSetting(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChatPauseSetting", str)
	}
	return nil
}

func (e ChatPauseSetting) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reasons that a user might not be allowed to chat in a specific channel.
type ChatRestrictedReason string

const (
	// The user is prevented from chatting without a verified phone number.
	// They will be prompted to verify one upon chatting.
	ChatRestrictedReasonRequireVerifiedPhoneNumber ChatRestrictedReason = "REQUIRE_VERIFIED_PHONE_NUMBER"
	// The user is prevented from chatting by subscribers-only mode. They should
	// subscribe to the channel to chat.
	ChatRestrictedReasonSubscribersOnly ChatRestrictedReason = "SUBSCRIBERS_ONLY"
	// The user is prevented from chatting by followers-only mode. They should
	// either follow the channel, or wait longer to satisfy the required time.
	// See user.self.follower.followedAt for when the user followed, and
	// user.self.chatSettings.followersOnlyDurationMinutes for the minimum
	// required follow time.
	ChatRestrictedReasonFollowersOnly ChatRestrictedReason = "FOLLOWERS_ONLY"
	// The user is prevented from chatting by verified-only mode. They should
	// verify their account to chat.
	ChatRestrictedReasonVerifiedOnly ChatRestrictedReason = "VERIFIED_ONLY"
	// The user can't chat because they've chatted too recently. See
	// user.self.lastRecentChatMessageAt to calculate how much time is remaining
	// before they can chat again.
	ChatRestrictedReasonSlowMode ChatRestrictedReason = "SLOW_MODE"
)

var AllChatRestrictedReason = []ChatRestrictedReason{
	ChatRestrictedReasonRequireVerifiedPhoneNumber,
	ChatRestrictedReasonSubscribersOnly,
	ChatRestrictedReasonFollowersOnly,
	ChatRestrictedReasonVerifiedOnly,
	ChatRestrictedReasonSlowMode,
}

func (e ChatRestrictedReason) IsValid() bool {
	switch e {
	case ChatRestrictedReasonRequireVerifiedPhoneNumber, ChatRestrictedReasonSubscribersOnly, ChatRestrictedReasonFollowersOnly, ChatRestrictedReasonVerifiedOnly, ChatRestrictedReasonSlowMode:
		return true
	}
	return false
}

func (e ChatRestrictedReason) String() string {
	return string(e)
}

func (e *ChatRestrictedReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChatRestrictedReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChatRestrictedReason", str)
	}
	return nil
}

func (e ChatRestrictedReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ChatTheme is a client-side UI theme.
// It can be used to provide different images based on the dominant background color they are designed to display on.
type ChatTheme string

const (
	ChatThemeDark  ChatTheme = "DARK"
	ChatThemeLight ChatTheme = "LIGHT"
)

var AllChatTheme = []ChatTheme{
	ChatThemeDark,
	ChatThemeLight,
}

func (e ChatTheme) IsValid() bool {
	switch e {
	case ChatThemeDark, ChatThemeLight:
		return true
	}
	return false
}

func (e ChatTheme) String() string {
	return string(e)
}

func (e *ChatTheme) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChatTheme(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChatTheme", str)
	}
	return nil
}

func (e ChatTheme) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Actions required when initiating a checkout flow.
type CheckoutAction string

const (
	// Action to block saved payment methods.
	CheckoutActionBlockSavedPaymentMethod CheckoutAction = "BLOCK_SAVED_PAYMENT_METHOD"
	// Action to show velocity limit CTA.
	CheckoutActionExceededVelocityLimits CheckoutAction = "EXCEEDED_VELOCITY_LIMITS"
	// Action to show the user enabled 2FA before saving their payment method.
	CheckoutActionVerifiedSavedPaymentMethod CheckoutAction = "VERIFIED_SAVED_PAYMENT_METHOD"
	// Action to disable new credit cards from being added on purchases.
	CheckoutActionDisableNewCreditCard CheckoutAction = "DISABLE_NEW_CREDIT_CARD"
	// Action to indicate this user is authorized to make purchases.
	CheckoutActionAuthorizedUser CheckoutAction = "AUTHORIZED_USER"
	// Action to indicate xsolla should be prioritized.
	CheckoutActionPrioritizeXsolla CheckoutAction = "PRIORITIZE_XSOLLA"
)

var AllCheckoutAction = []CheckoutAction{
	CheckoutActionBlockSavedPaymentMethod,
	CheckoutActionExceededVelocityLimits,
	CheckoutActionVerifiedSavedPaymentMethod,
	CheckoutActionDisableNewCreditCard,
	CheckoutActionAuthorizedUser,
	CheckoutActionPrioritizeXsolla,
}

func (e CheckoutAction) IsValid() bool {
	switch e {
	case CheckoutActionBlockSavedPaymentMethod, CheckoutActionExceededVelocityLimits, CheckoutActionVerifiedSavedPaymentMethod, CheckoutActionDisableNewCreditCard, CheckoutActionAuthorizedUser, CheckoutActionPrioritizeXsolla:
		return true
	}
	return false
}

func (e CheckoutAction) String() string {
	return string(e)
}

func (e *CheckoutAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CheckoutAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CheckoutAction", str)
	}
	return nil
}

func (e CheckoutAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The supported cheermote tier thresholds.
type CheermoteTierThreshold string

const (
	// Cheermote tier threshold requiring at least 1 Bit.
	CheermoteTierThresholdTier1 CheermoteTierThreshold = "TIER_1"
	// Cheermote tier threshold requiring at least 100 Bits.
	CheermoteTierThresholdTier100 CheermoteTierThreshold = "TIER_100"
	// Cheermote tier threshold requiring at least 1000 Bits.
	CheermoteTierThresholdTier1000 CheermoteTierThreshold = "TIER_1000"
	// Cheermote tier threshold requiring at least 5000 Bits.
	CheermoteTierThresholdTier5000 CheermoteTierThreshold = "TIER_5000"
	// Cheermote tier threshold requiring at least 10000 Bits.
	CheermoteTierThresholdTier10000 CheermoteTierThreshold = "TIER_10000"
)

var AllCheermoteTierThreshold = []CheermoteTierThreshold{
	CheermoteTierThresholdTier1,
	CheermoteTierThresholdTier100,
	CheermoteTierThresholdTier1000,
	CheermoteTierThresholdTier5000,
	CheermoteTierThresholdTier10000,
}

func (e CheermoteTierThreshold) IsValid() bool {
	switch e {
	case CheermoteTierThresholdTier1, CheermoteTierThresholdTier100, CheermoteTierThresholdTier1000, CheermoteTierThresholdTier5000, CheermoteTierThresholdTier10000:
		return true
	}
	return false
}

func (e CheermoteTierThreshold) String() string {
	return string(e)
}

func (e *CheermoteTierThreshold) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CheermoteTierThreshold(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CheermoteTierThreshold", str)
	}
	return nil
}

func (e CheermoteTierThreshold) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CheermoteType is the kind of cheermore (custom vs 1st- or 3rd-party global).
type CheermoteType string

const (
	// The type for the generic "Cheer" action.
	CheermoteTypeDefault CheermoteType = "DEFAULT"
	// Custom Channel Cheermotes.
	CheermoteTypeCustom CheermoteType = "CUSTOM"
	// Sponsored Cheermotes.
	CheermoteTypeSponsored CheermoteType = "SPONSORED"
	// Charity Cheermotes.
	CheermoteTypeCharity CheermoteType = "CHARITY"
	// First Party Cheermotes, like Kappa and BibleThump.
	CheermoteTypeFirstParty CheermoteType = "FIRST_PARTY"
	// Third Party Cheermotes, like Muxy and BitBoss.
	CheermoteTypeThirdParty CheermoteType = "THIRD_PARTY"
	// Cheermotes for display only. The cannot be cheered, but will be rendered in Chat.
	CheermoteTypeDisplayOnly CheermoteType = "DISPLAY_ONLY"
	// The type for the anonymous cheer action.
	CheermoteTypeAnonymous CheermoteType = "ANONYMOUS"
	// Unknown cheermote type, we only return this if we get a bad cheermote,
	// we decided this is better than erroring the whole response, the front end should treat this the same as DISPLAY_ONLY.
	CheermoteTypeUnknown CheermoteType = "UNKNOWN"
)

var AllCheermoteType = []CheermoteType{
	CheermoteTypeDefault,
	CheermoteTypeCustom,
	CheermoteTypeSponsored,
	CheermoteTypeCharity,
	CheermoteTypeFirstParty,
	CheermoteTypeThirdParty,
	CheermoteTypeDisplayOnly,
	CheermoteTypeAnonymous,
	CheermoteTypeUnknown,
}

func (e CheermoteType) IsValid() bool {
	switch e {
	case CheermoteTypeDefault, CheermoteTypeCustom, CheermoteTypeSponsored, CheermoteTypeCharity, CheermoteTypeFirstParty, CheermoteTypeThirdParty, CheermoteTypeDisplayOnly, CheermoteTypeAnonymous, CheermoteTypeUnknown:
		return true
	}
	return false
}

func (e CheermoteType) String() string {
	return string(e)
}

func (e *CheermoteType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CheermoteType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CheermoteType", str)
	}
	return nil
}

func (e CheermoteType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error types recognized.
type ClaimBountyErrorCode string

const (
	// Invalid parameter in the request.
	ClaimBountyErrorCodeInvalidParameter ClaimBountyErrorCode = "INVALID_PARAMETER"
	// User reached the maximum number of bounties.
	ClaimBountyErrorCodeBountyLimitReached ClaimBountyErrorCode = "BOUNTY_LIMIT_REACHED"
	// User already claimed that bounty.
	ClaimBountyErrorCodeBountyAlreadyClaimed ClaimBountyErrorCode = "BOUNTY_ALREADY_CLAIMED"
	// Unknown error being returned from service.
	ClaimBountyErrorCodeUnknownError ClaimBountyErrorCode = "UNKNOWN_ERROR"
)

var AllClaimBountyErrorCode = []ClaimBountyErrorCode{
	ClaimBountyErrorCodeInvalidParameter,
	ClaimBountyErrorCodeBountyLimitReached,
	ClaimBountyErrorCodeBountyAlreadyClaimed,
	ClaimBountyErrorCodeUnknownError,
}

func (e ClaimBountyErrorCode) IsValid() bool {
	switch e {
	case ClaimBountyErrorCodeInvalidParameter, ClaimBountyErrorCodeBountyLimitReached, ClaimBountyErrorCodeBountyAlreadyClaimed, ClaimBountyErrorCodeUnknownError:
		return true
	}
	return false
}

func (e ClaimBountyErrorCode) String() string {
	return string(e)
}

func (e *ClaimBountyErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClaimBountyErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClaimBountyErrorCode", str)
	}
	return nil
}

func (e ClaimBountyErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons a claim could fail.
type ClaimCommunityPointsErrorCode string

const (
	// The point claim was not found.
	ClaimCommunityPointsErrorCodeNotFound ClaimCommunityPointsErrorCode = "NOT_FOUND"
	// The current user is not allowed to claim these points.
	ClaimCommunityPointsErrorCodeForbidden ClaimCommunityPointsErrorCode = "FORBIDDEN"
)

var AllClaimCommunityPointsErrorCode = []ClaimCommunityPointsErrorCode{
	ClaimCommunityPointsErrorCodeNotFound,
	ClaimCommunityPointsErrorCodeForbidden,
}

func (e ClaimCommunityPointsErrorCode) IsValid() bool {
	switch e {
	case ClaimCommunityPointsErrorCodeNotFound, ClaimCommunityPointsErrorCodeForbidden:
		return true
	}
	return false
}

func (e ClaimCommunityPointsErrorCode) String() string {
	return string(e)
}

func (e *ClaimCommunityPointsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClaimCommunityPointsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClaimCommunityPointsErrorCode", str)
	}
	return nil
}

func (e ClaimCommunityPointsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Hint describing the current availability state of the claim for the user.
type ClaimHint string

const (
	// We found no existing entitlements for the customer for the offer.
	// The offer is ready for claiming.
	ClaimHintAvailable ClaimHint = "AVAILABLE"
	// We found an existing entitlement for the customer, and the currently linked Amazon account is the account on the entitlement.
	// This is preventing a future claim by the querying account.
	ClaimHintClaimedNoConflicts ClaimHint = "CLAIMED_NO_CONFLICTS"
	// We found an existing entitlement for the customer, but the currently linked Amazon account is NOT the account on the entitlement.
	// This is preventing a future claim by the querying account.
	ClaimHintClaimedAmazonLinkConflict ClaimHint = "CLAIMED_AMAZON_LINK_CONFLICT"
	// We found an existing entitlement for one of the accounts for the customer.
	// The existing entitlement is not blocking an additional claim.
	ClaimHintReclaimableNoConflicts ClaimHint = "RECLAIMABLE_NO_CONFLICTS"
	// We found an existing entitlement linked to the household, but the querying account did not claim it themselves.
	// This is preventing a future claim by the querying account.
	ClaimHintClaimedByMemberOfHousehold ClaimHint = "CLAIMED_BY_MEMBER_OF_HOUSEHOLD"
	// Customer does not have Twitch Prime.
	// The user needs to sign up before claiming.
	ClaimHintNeedPrime ClaimHint = "NEED_PRIME"
	// The entitlement we found is for a code offer, and we have run out of codes.
	// We may restock codes in the future and will report another claim hint type if so.
	ClaimHintOfferFullyClaimed ClaimHint = "OFFER_FULLY_CLAIMED"
	// No valid claim hint was provided.
	// This will also occur when we implement new claim hints but have not yet updated this repo.
	ClaimHintUnknown ClaimHint = "UNKNOWN"
)

var AllClaimHint = []ClaimHint{
	ClaimHintAvailable,
	ClaimHintClaimedNoConflicts,
	ClaimHintClaimedAmazonLinkConflict,
	ClaimHintReclaimableNoConflicts,
	ClaimHintClaimedByMemberOfHousehold,
	ClaimHintNeedPrime,
	ClaimHintOfferFullyClaimed,
	ClaimHintUnknown,
}

func (e ClaimHint) IsValid() bool {
	switch e {
	case ClaimHintAvailable, ClaimHintClaimedNoConflicts, ClaimHintClaimedAmazonLinkConflict, ClaimHintReclaimableNoConflicts, ClaimHintClaimedByMemberOfHousehold, ClaimHintNeedPrime, ClaimHintOfferFullyClaimed, ClaimHintUnknown:
		return true
	}
	return false
}

func (e ClaimHint) String() string {
	return string(e)
}

func (e *ClaimHint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClaimHint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClaimHint", str)
	}
	return nil
}

func (e ClaimHint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error types recognized.
type ClaimPrimeOfferErrorCode string

const (
	// Status when offer is already claimed by the current user or an associated account.
	ClaimPrimeOfferErrorCodeOfferAlreadyClaimed ClaimPrimeOfferErrorCode = "OFFER_ALREADY_CLAIMED"
	// Unknown error being returned from service.
	ClaimPrimeOfferErrorCodeUnknown ClaimPrimeOfferErrorCode = "UNKNOWN"
)

var AllClaimPrimeOfferErrorCode = []ClaimPrimeOfferErrorCode{
	ClaimPrimeOfferErrorCodeOfferAlreadyClaimed,
	ClaimPrimeOfferErrorCodeUnknown,
}

func (e ClaimPrimeOfferErrorCode) IsValid() bool {
	switch e {
	case ClaimPrimeOfferErrorCodeOfferAlreadyClaimed, ClaimPrimeOfferErrorCodeUnknown:
		return true
	}
	return false
}

func (e ClaimPrimeOfferErrorCode) String() string {
	return string(e)
}

func (e *ClaimPrimeOfferErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClaimPrimeOfferErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClaimPrimeOfferErrorCode", str)
	}
	return nil
}

func (e ClaimPrimeOfferErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The enumerated types of claimables.
type ClaimableType string

const (
	// A key code that has a bits amount associated with it.
	ClaimableTypeBitsKeyCode ClaimableType = "BITS_KEY_CODE"
	// A key code that has a subscription to a product associated with it.
	ClaimableTypeSubsKeyCode ClaimableType = "SUBS_KEY_CODE"
	// A key code that has a gift card with monetary value associated with it.
	ClaimableTypeGiftCardKeyCode ClaimableType = "GIFT_CARD_KEY_CODE"
)

var AllClaimableType = []ClaimableType{
	ClaimableTypeBitsKeyCode,
	ClaimableTypeSubsKeyCode,
	ClaimableTypeGiftCardKeyCode,
}

func (e ClaimableType) IsValid() bool {
	switch e {
	case ClaimableTypeBitsKeyCode, ClaimableTypeSubsKeyCode, ClaimableTypeGiftCardKeyCode:
		return true
	}
	return false
}

func (e ClaimableType) String() string {
	return string(e)
}

func (e *ClaimableType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClaimableType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClaimableType", str)
	}
	return nil
}

func (e ClaimableType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration on the different status strings returned by a clip status.
type ClipCreationState string

const (
	// The creating status indicates that the source quality video is still
	// undergoing processing and transcoding.
	ClipCreationStateCreating ClipCreationState = "CREATING"
	// Clip has been successfully created in the source video quality.
	// The field videoQualities will be gradually added to with other quality options.
	ClipCreationStateCreated ClipCreationState = "CREATED"
	// Clip creation failed and will remain in this state.
	// Possible errors can happen due to problems in downloading and slicing
	// the source of the original video, clipping offline channels, transcoding, etc.
	ClipCreationStateFailed ClipCreationState = "FAILED"
)

var AllClipCreationState = []ClipCreationState{
	ClipCreationStateCreating,
	ClipCreationStateCreated,
	ClipCreationStateFailed,
}

func (e ClipCreationState) IsValid() bool {
	switch e {
	case ClipCreationStateCreating, ClipCreationStateCreated, ClipCreationStateFailed:
		return true
	}
	return false
}

func (e ClipCreationState) String() string {
	return string(e)
}

func (e *ClipCreationState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClipCreationState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClipCreationState", str)
	}
	return nil
}

func (e ClipCreationState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of methods to restrict clips results.
type ClipsFilter string

const (
	// Limit results to trending clips.
	ClipsFilterTrending ClipsFilter = "TRENDING"
	// Limit results to clips created in the period between now and the last 24 hours.
	ClipsFilterLastDay ClipsFilter = "LAST_DAY"
	// Limit results to clips created in the period between now and the last 7 days.
	ClipsFilterLastWeek ClipsFilter = "LAST_WEEK"
	// Limit results to clips created in the period between now and the last 30 days.
	ClipsFilterLastMonth ClipsFilter = "LAST_MONTH"
	// No limit on clips creation period.
	ClipsFilterAllTime ClipsFilter = "ALL_TIME"
)

var AllClipsFilter = []ClipsFilter{
	ClipsFilterTrending,
	ClipsFilterLastDay,
	ClipsFilterLastWeek,
	ClipsFilterLastMonth,
	ClipsFilterAllTime,
}

func (e ClipsFilter) IsValid() bool {
	switch e {
	case ClipsFilterTrending, ClipsFilterLastDay, ClipsFilterLastWeek, ClipsFilterLastMonth, ClipsFilterAllTime:
		return true
	}
	return false
}

func (e ClipsFilter) String() string {
	return string(e)
}

func (e *ClipsFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClipsFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClipsFilter", str)
	}
	return nil
}

func (e ClipsFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration on the different time frames to filter clips results based on
// creation time.
type ClipsPeriod string

const (
	// Limit results to clips created in the period between now and the last 24 hours.
	ClipsPeriodLastDay ClipsPeriod = "LAST_DAY"
	// Limit results to clips created in the period between now and the last 7 days.
	ClipsPeriodLastWeek ClipsPeriod = "LAST_WEEK"
	// Limit results to clips created in the period between now and the last 30 days.
	ClipsPeriodLastMonth ClipsPeriod = "LAST_MONTH"
	// No limit on when the clips were created.
	ClipsPeriodAllTime ClipsPeriod = "ALL_TIME"
)

var AllClipsPeriod = []ClipsPeriod{
	ClipsPeriodLastDay,
	ClipsPeriodLastWeek,
	ClipsPeriodLastMonth,
	ClipsPeriodAllTime,
}

func (e ClipsPeriod) IsValid() bool {
	switch e {
	case ClipsPeriodLastDay, ClipsPeriodLastWeek, ClipsPeriodLastMonth, ClipsPeriodAllTime:
		return true
	}
	return false
}

func (e ClipsPeriod) String() string {
	return string(e)
}

func (e *ClipsPeriod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClipsPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClipsPeriod", str)
	}
	return nil
}

func (e ClipsPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration on the different sort orders of clips results.
type ClipsSort string

const (
	// Sort the clips ascending by created_at.
	ClipsSortCreatedAtAsc ClipsSort = "CREATED_AT_ASC"
	// Sort the clips descending by created_at.
	ClipsSortCreatedAtDesc ClipsSort = "CREATED_AT_DESC"
	// Sort the clips ascending by views.
	ClipsSortViewsAsc ClipsSort = "VIEWS_ASC"
	// Sort the clips descending by views.
	ClipsSortViewsDesc ClipsSort = "VIEWS_DESC"
	// Sort the clips descending by popularity.
	ClipsSortTrending ClipsSort = "TRENDING"
)

var AllClipsSort = []ClipsSort{
	ClipsSortCreatedAtAsc,
	ClipsSortCreatedAtDesc,
	ClipsSortViewsAsc,
	ClipsSortViewsDesc,
	ClipsSortTrending,
}

func (e ClipsSort) IsValid() bool {
	switch e {
	case ClipsSortCreatedAtAsc, ClipsSortCreatedAtDesc, ClipsSortViewsAsc, ClipsSortViewsDesc, ClipsSortTrending:
		return true
	}
	return false
}

func (e ClipsSort) String() string {
	return string(e)
}

func (e *ClipsSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClipsSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClipsSort", str)
	}
	return nil
}

func (e ClipsSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CloneExtensionDiscoveryDataError is an error associated with the cloneExtensionDiscoveryData mutation.
type CloneExtensionDiscoveryDataError string

const (
	// User is unable to clone the extension.
	CloneExtensionDiscoveryDataErrorUnauthorized CloneExtensionDiscoveryDataError = "UNAUTHORIZED"
	// Version specified is invalid.
	CloneExtensionDiscoveryDataErrorInvalidNewVersion CloneExtensionDiscoveryDataError = "INVALID_NEW_VERSION"
	// The Version to clone from does not exist.
	CloneExtensionDiscoveryDataErrorVersionNotFound CloneExtensionDiscoveryDataError = "VERSION_NOT_FOUND"
)

var AllCloneExtensionDiscoveryDataError = []CloneExtensionDiscoveryDataError{
	CloneExtensionDiscoveryDataErrorUnauthorized,
	CloneExtensionDiscoveryDataErrorInvalidNewVersion,
	CloneExtensionDiscoveryDataErrorVersionNotFound,
}

func (e CloneExtensionDiscoveryDataError) IsValid() bool {
	switch e {
	case CloneExtensionDiscoveryDataErrorUnauthorized, CloneExtensionDiscoveryDataErrorInvalidNewVersion, CloneExtensionDiscoveryDataErrorVersionNotFound:
		return true
	}
	return false
}

func (e CloneExtensionDiscoveryDataError) String() string {
	return string(e)
}

func (e *CloneExtensionDiscoveryDataError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CloneExtensionDiscoveryDataError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CloneExtensionDiscoveryDataError", str)
	}
	return nil
}

func (e CloneExtensionDiscoveryDataError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CloneExtensionManifestError is an error associated with the cloneExtensionManifest mutation.
type CloneExtensionManifestError string

const (
	// User is unable to clone the extension.
	CloneExtensionManifestErrorUnauthorized CloneExtensionManifestError = "UNAUTHORIZED"
	// Version specified is invalid.
	CloneExtensionManifestErrorInvalidNewVersion CloneExtensionManifestError = "INVALID_NEW_VERSION"
	// The version to clone to already exists.
	CloneExtensionManifestErrorVersionAlredyExists CloneExtensionManifestError = "VERSION_ALREDY_EXISTS"
	// The Version to clone from does not exist.
	CloneExtensionManifestErrorVersionNotFound CloneExtensionManifestError = "VERSION_NOT_FOUND"
)

var AllCloneExtensionManifestError = []CloneExtensionManifestError{
	CloneExtensionManifestErrorUnauthorized,
	CloneExtensionManifestErrorInvalidNewVersion,
	CloneExtensionManifestErrorVersionAlredyExists,
	CloneExtensionManifestErrorVersionNotFound,
}

func (e CloneExtensionManifestError) IsValid() bool {
	switch e {
	case CloneExtensionManifestErrorUnauthorized, CloneExtensionManifestErrorInvalidNewVersion, CloneExtensionManifestErrorVersionAlredyExists, CloneExtensionManifestErrorVersionNotFound:
		return true
	}
	return false
}

func (e CloneExtensionManifestError) String() string {
	return string(e)
}

func (e *CloneExtensionManifestError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CloneExtensionManifestError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CloneExtensionManifestError", str)
	}
	return nil
}

func (e CloneExtensionManifestError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the status of a cloud broadcast.
type CloudBroadcastState string

const (
	// Broadcast is offline and needs to be started.
	CloudBroadcastStateOffline CloudBroadcastState = "OFFLINE"
	// Broadcast is pending and currently starting.
	CloudBroadcastStatePending CloudBroadcastState = "PENDING"
	// Broadcast is online and ready.
	CloudBroadcastStateOnline CloudBroadcastState = "ONLINE"
	// The broadcast status is unknown.
	CloudBroadcastStateUnknown CloudBroadcastState = "UNKNOWN"
)

var AllCloudBroadcastState = []CloudBroadcastState{
	CloudBroadcastStateOffline,
	CloudBroadcastStatePending,
	CloudBroadcastStateOnline,
	CloudBroadcastStateUnknown,
}

func (e CloudBroadcastState) IsValid() bool {
	switch e {
	case CloudBroadcastStateOffline, CloudBroadcastStatePending, CloudBroadcastStateOnline, CloudBroadcastStateUnknown:
		return true
	}
	return false
}

func (e CloudBroadcastState) String() string {
	return string(e)
}

func (e *CloudBroadcastState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CloudBroadcastState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CloudBroadcastState", str)
	}
	return nil
}

func (e CloudBroadcastState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of different collection types.
type CollectionType string

const (
	// Series collection type.
	CollectionTypeSeries CollectionType = "SERIES"
	// Default collection type.
	CollectionTypeDefault CollectionType = "DEFAULT"
)

var AllCollectionType = []CollectionType{
	CollectionTypeSeries,
	CollectionTypeDefault,
}

func (e CollectionType) IsValid() bool {
	switch e {
	case CollectionTypeSeries, CollectionTypeDefault:
		return true
	}
	return false
}

func (e CollectionType) String() string {
	return string(e)
}

func (e *CollectionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CollectionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CollectionType", str)
	}
	return nil
}

func (e CollectionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of CommunityPointsAutomaticRewards.
type CommunityPointsAutomaticRewardType string

const (
	// Send a single message through sub-only mode.
	CommunityPointsAutomaticRewardTypeSingleMessageBypassSubMode CommunityPointsAutomaticRewardType = "SINGLE_MESSAGE_BYPASS_SUB_MODE"
	// Unlock a random subscriber emote.
	CommunityPointsAutomaticRewardTypeRandomSubEmoteUnlock CommunityPointsAutomaticRewardType = "RANDOM_SUB_EMOTE_UNLOCK"
	// Unlock a chosen subscriber emote.
	CommunityPointsAutomaticRewardTypeChosenSubEmoteUnlock CommunityPointsAutomaticRewardType = "CHOSEN_SUB_EMOTE_UNLOCK"
	// Send a highlighted chat message.
	CommunityPointsAutomaticRewardTypeSendHighlightedMessage CommunityPointsAutomaticRewardType = "SEND_HIGHLIGHTED_MESSAGE"
	// Unlock a chosen modification for a subscriber emote.
	CommunityPointsAutomaticRewardTypeChosenModifiedSubEmoteUnlock CommunityPointsAutomaticRewardType = "CHOSEN_MODIFIED_SUB_EMOTE_UNLOCK"
)

var AllCommunityPointsAutomaticRewardType = []CommunityPointsAutomaticRewardType{
	CommunityPointsAutomaticRewardTypeSingleMessageBypassSubMode,
	CommunityPointsAutomaticRewardTypeRandomSubEmoteUnlock,
	CommunityPointsAutomaticRewardTypeChosenSubEmoteUnlock,
	CommunityPointsAutomaticRewardTypeSendHighlightedMessage,
	CommunityPointsAutomaticRewardTypeChosenModifiedSubEmoteUnlock,
}

func (e CommunityPointsAutomaticRewardType) IsValid() bool {
	switch e {
	case CommunityPointsAutomaticRewardTypeSingleMessageBypassSubMode, CommunityPointsAutomaticRewardTypeRandomSubEmoteUnlock, CommunityPointsAutomaticRewardTypeChosenSubEmoteUnlock, CommunityPointsAutomaticRewardTypeSendHighlightedMessage, CommunityPointsAutomaticRewardTypeChosenModifiedSubEmoteUnlock:
		return true
	}
	return false
}

func (e CommunityPointsAutomaticRewardType) String() string {
	return string(e)
}

func (e *CommunityPointsAutomaticRewardType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommunityPointsAutomaticRewardType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommunityPointsAutomaticRewardType", str)
	}
	return nil
}

func (e CommunityPointsAutomaticRewardType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Community goal status.
type CommunityPointsCommunityGoalStatus string

const (
	// Goal was just created.
	CommunityPointsCommunityGoalStatusUnstarted CommunityPointsCommunityGoalStatus = "UNSTARTED"
	// Goal was started.
	CommunityPointsCommunityGoalStatusStarted CommunityPointsCommunityGoalStatus = "STARTED"
	// Goal ended.
	CommunityPointsCommunityGoalStatusEnded CommunityPointsCommunityGoalStatus = "ENDED"
	// Goal marked fulfilled by streamer.
	CommunityPointsCommunityGoalStatusFulfilled CommunityPointsCommunityGoalStatus = "FULFILLED"
	// Goal archived.
	CommunityPointsCommunityGoalStatusArchived CommunityPointsCommunityGoalStatus = "ARCHIVED"
	// Goal status unknown.
	CommunityPointsCommunityGoalStatusUnknown CommunityPointsCommunityGoalStatus = "UNKNOWN"
)

var AllCommunityPointsCommunityGoalStatus = []CommunityPointsCommunityGoalStatus{
	CommunityPointsCommunityGoalStatusUnstarted,
	CommunityPointsCommunityGoalStatusStarted,
	CommunityPointsCommunityGoalStatusEnded,
	CommunityPointsCommunityGoalStatusFulfilled,
	CommunityPointsCommunityGoalStatusArchived,
	CommunityPointsCommunityGoalStatusUnknown,
}

func (e CommunityPointsCommunityGoalStatus) IsValid() bool {
	switch e {
	case CommunityPointsCommunityGoalStatusUnstarted, CommunityPointsCommunityGoalStatusStarted, CommunityPointsCommunityGoalStatusEnded, CommunityPointsCommunityGoalStatusFulfilled, CommunityPointsCommunityGoalStatusArchived, CommunityPointsCommunityGoalStatusUnknown:
		return true
	}
	return false
}

func (e CommunityPointsCommunityGoalStatus) String() string {
	return string(e)
}

func (e *CommunityPointsCommunityGoalStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommunityPointsCommunityGoalStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommunityPointsCommunityGoalStatus", str)
	}
	return nil
}

func (e CommunityPointsCommunityGoalStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Community goal type.
type CommunityPointsCommunityGoalType string

const (
	// Goal owned by creator.
	CommunityPointsCommunityGoalTypeCreator CommunityPointsCommunityGoalType = "CREATOR"
	// Community Boost Goal.
	CommunityPointsCommunityGoalTypeBoost CommunityPointsCommunityGoalType = "BOOST"
	// Goal type unknown.
	CommunityPointsCommunityGoalTypeUnknown CommunityPointsCommunityGoalType = "UNKNOWN"
)

var AllCommunityPointsCommunityGoalType = []CommunityPointsCommunityGoalType{
	CommunityPointsCommunityGoalTypeCreator,
	CommunityPointsCommunityGoalTypeBoost,
	CommunityPointsCommunityGoalTypeUnknown,
}

func (e CommunityPointsCommunityGoalType) IsValid() bool {
	switch e {
	case CommunityPointsCommunityGoalTypeCreator, CommunityPointsCommunityGoalTypeBoost, CommunityPointsCommunityGoalTypeUnknown:
		return true
	}
	return false
}

func (e CommunityPointsCommunityGoalType) String() string {
	return string(e)
}

func (e *CommunityPointsCommunityGoalType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommunityPointsCommunityGoalType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommunityPointsCommunityGoalType", str)
	}
	return nil
}

func (e CommunityPointsCommunityGoalType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The different types of content for community points.
type CommunityPointsContentType string

const (
	// The content type is not understood by GQL.
	CommunityPointsContentTypeUnknown CommunityPointsContentType = "UNKNOWN"
	// The content type for automatic rewards.
	CommunityPointsContentTypeAutomaticReward CommunityPointsContentType = "AUTOMATIC_REWARD"
	// The content type for custom rewards.
	CommunityPointsContentTypeCustomReward CommunityPointsContentType = "CUSTOM_REWARD"
)

var AllCommunityPointsContentType = []CommunityPointsContentType{
	CommunityPointsContentTypeUnknown,
	CommunityPointsContentTypeAutomaticReward,
	CommunityPointsContentTypeCustomReward,
}

func (e CommunityPointsContentType) IsValid() bool {
	switch e {
	case CommunityPointsContentTypeUnknown, CommunityPointsContentTypeAutomaticReward, CommunityPointsContentTypeCustomReward:
		return true
	}
	return false
}

func (e CommunityPointsContentType) String() string {
	return string(e)
}

func (e *CommunityPointsContentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommunityPointsContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommunityPointsContentType", str)
	}
	return nil
}

func (e CommunityPointsContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Ways to sort Community Points redemptions.
type CommunityPointsCustomRewardRedemptionQueueSortOrder string

const (
	// The oldest redemption first.
	CommunityPointsCustomRewardRedemptionQueueSortOrderOldest CommunityPointsCustomRewardRedemptionQueueSortOrder = "OLDEST"
	// The newest redemption first.
	CommunityPointsCustomRewardRedemptionQueueSortOrderNewest CommunityPointsCustomRewardRedemptionQueueSortOrder = "NEWEST"
)

var AllCommunityPointsCustomRewardRedemptionQueueSortOrder = []CommunityPointsCustomRewardRedemptionQueueSortOrder{
	CommunityPointsCustomRewardRedemptionQueueSortOrderOldest,
	CommunityPointsCustomRewardRedemptionQueueSortOrderNewest,
}

func (e CommunityPointsCustomRewardRedemptionQueueSortOrder) IsValid() bool {
	switch e {
	case CommunityPointsCustomRewardRedemptionQueueSortOrderOldest, CommunityPointsCustomRewardRedemptionQueueSortOrderNewest:
		return true
	}
	return false
}

func (e CommunityPointsCustomRewardRedemptionQueueSortOrder) String() string {
	return string(e)
}

func (e *CommunityPointsCustomRewardRedemptionQueueSortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommunityPointsCustomRewardRedemptionQueueSortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommunityPointsCustomRewardRedemptionQueueSortOrder", str)
	}
	return nil
}

func (e CommunityPointsCustomRewardRedemptionQueueSortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible states for a CommunityPointsCustomRewardRedemption.
type CommunityPointsCustomRewardRedemptionStatus string

const (
	// A redemption that has not been acted on by the broadcaster.
	CommunityPointsCustomRewardRedemptionStatusUnfulfilled CommunityPointsCustomRewardRedemptionStatus = "UNFULFILLED"
	// A redemption that has been fulfilled by the broadcaster.
	CommunityPointsCustomRewardRedemptionStatusFulfilled CommunityPointsCustomRewardRedemptionStatus = "FULFILLED"
	// A redemption that has been canceled by the broadcaster.
	CommunityPointsCustomRewardRedemptionStatusCanceled CommunityPointsCustomRewardRedemptionStatus = "CANCELED"
	// A redemption that has been reported by the broadcaster.
	CommunityPointsCustomRewardRedemptionStatusReported CommunityPointsCustomRewardRedemptionStatus = "REPORTED"
)

var AllCommunityPointsCustomRewardRedemptionStatus = []CommunityPointsCustomRewardRedemptionStatus{
	CommunityPointsCustomRewardRedemptionStatusUnfulfilled,
	CommunityPointsCustomRewardRedemptionStatusFulfilled,
	CommunityPointsCustomRewardRedemptionStatusCanceled,
	CommunityPointsCustomRewardRedemptionStatusReported,
}

func (e CommunityPointsCustomRewardRedemptionStatus) IsValid() bool {
	switch e {
	case CommunityPointsCustomRewardRedemptionStatusUnfulfilled, CommunityPointsCustomRewardRedemptionStatusFulfilled, CommunityPointsCustomRewardRedemptionStatusCanceled, CommunityPointsCustomRewardRedemptionStatusReported:
		return true
	}
	return false
}

func (e CommunityPointsCustomRewardRedemptionStatus) String() string {
	return string(e)
}

func (e *CommunityPointsCustomRewardRedemptionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommunityPointsCustomRewardRedemptionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommunityPointsCustomRewardRedemptionStatus", str)
	}
	return nil
}

func (e CommunityPointsCustomRewardRedemptionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible categories for a collection of custom reward templates.
type CommunityPointsCustomRewardTemplateCollectionCategory string

const (
	// Unknown category.
	CommunityPointsCustomRewardTemplateCollectionCategoryUnknown CommunityPointsCustomRewardTemplateCollectionCategory = "UNKNOWN"
	// The templates are for custom rewards that are related to actions in a game.
	CommunityPointsCustomRewardTemplateCollectionCategoryGame CommunityPointsCustomRewardTemplateCollectionCategory = "GAME"
	// The templates are for custom rewards that are related to actions irl.
	CommunityPointsCustomRewardTemplateCollectionCategoryIrl CommunityPointsCustomRewardTemplateCollectionCategory = "IRL"
	// The templates are for custom rewards that are related to actions on twitch.
	CommunityPointsCustomRewardTemplateCollectionCategoryTwitch CommunityPointsCustomRewardTemplateCollectionCategory = "TWITCH"
)

var AllCommunityPointsCustomRewardTemplateCollectionCategory = []CommunityPointsCustomRewardTemplateCollectionCategory{
	CommunityPointsCustomRewardTemplateCollectionCategoryUnknown,
	CommunityPointsCustomRewardTemplateCollectionCategoryGame,
	CommunityPointsCustomRewardTemplateCollectionCategoryIrl,
	CommunityPointsCustomRewardTemplateCollectionCategoryTwitch,
}

func (e CommunityPointsCustomRewardTemplateCollectionCategory) IsValid() bool {
	switch e {
	case CommunityPointsCustomRewardTemplateCollectionCategoryUnknown, CommunityPointsCustomRewardTemplateCollectionCategoryGame, CommunityPointsCustomRewardTemplateCollectionCategoryIrl, CommunityPointsCustomRewardTemplateCollectionCategoryTwitch:
		return true
	}
	return false
}

func (e CommunityPointsCustomRewardTemplateCollectionCategory) String() string {
	return string(e)
}

func (e *CommunityPointsCustomRewardTemplateCollectionCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommunityPointsCustomRewardTemplateCollectionCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommunityPointsCustomRewardTemplateCollectionCategory", str)
	}
	return nil
}

func (e CommunityPointsCustomRewardTemplateCollectionCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reasons that community point earning could be multiplied for a user in a channel.
type CommunityPointsMultiplierReason string

const (
	// Tier-1 Subscriber.
	CommunityPointsMultiplierReasonSubT1 CommunityPointsMultiplierReason = "SUB_T1"
	// Tier-2 Subscriber.
	CommunityPointsMultiplierReasonSubT2 CommunityPointsMultiplierReason = "SUB_T2"
	// Tier-3 Subscriber.
	CommunityPointsMultiplierReasonSubT3 CommunityPointsMultiplierReason = "SUB_T3"
)

var AllCommunityPointsMultiplierReason = []CommunityPointsMultiplierReason{
	CommunityPointsMultiplierReasonSubT1,
	CommunityPointsMultiplierReasonSubT2,
	CommunityPointsMultiplierReasonSubT3,
}

func (e CommunityPointsMultiplierReason) IsValid() bool {
	switch e {
	case CommunityPointsMultiplierReasonSubT1, CommunityPointsMultiplierReasonSubT2, CommunityPointsMultiplierReasonSubT3:
		return true
	}
	return false
}

func (e CommunityPointsMultiplierReason) String() string {
	return string(e)
}

func (e *CommunityPointsMultiplierReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommunityPointsMultiplierReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommunityPointsMultiplierReason", str)
	}
	return nil
}

func (e CommunityPointsMultiplierReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors from redeeming an unlock emote Community Points reward.
type CommunityPointsUnlockEmoteErrorCode string

const (
	// The emote ID provided is for the wrong channel or the wrong type of emote.
	CommunityPointsUnlockEmoteErrorCodeInvalidEmote CommunityPointsUnlockEmoteErrorCode = "INVALID_EMOTE"
	// The user is already entitled to the emote provided.
	CommunityPointsUnlockEmoteErrorCodeEmoteAlreadyEntitled CommunityPointsUnlockEmoteErrorCode = "EMOTE_ALREADY_ENTITLED"
	// The user is entitled to all emotes that would be randomly selected from.
	CommunityPointsUnlockEmoteErrorCodeNoEmotesAvailable CommunityPointsUnlockEmoteErrorCode = "NO_EMOTES_AVAILABLE"
	// The user does not have sufficient points to redeem the reward.
	CommunityPointsUnlockEmoteErrorCodeInsufficientPoints CommunityPointsUnlockEmoteErrorCode = "INSUFFICIENT_POINTS"
	// The client is retrying a redemption with a transaction id that has already been redeemed.
	CommunityPointsUnlockEmoteErrorCodeTransactionAlreadyCommitted CommunityPointsUnlockEmoteErrorCode = "TRANSACTION_ALREADY_COMMITTED"
	// The client is retrying a redemption with a transaction id that is currently being redeemed in another request.
	CommunityPointsUnlockEmoteErrorCodeTransactionInProgress CommunityPointsUnlockEmoteErrorCode = "TRANSACTION_IN_PROGRESS"
	// The reward cost has changed since the user has tried to redeem it.
	CommunityPointsUnlockEmoteErrorCodeRewardCostMismatch CommunityPointsUnlockEmoteErrorCode = "REWARD_COST_MISMATCH"
	// The reward is currently disabled.
	CommunityPointsUnlockEmoteErrorCodeRewardDisabled CommunityPointsUnlockEmoteErrorCode = "REWARD_DISABLED"
	// The user is not allowed to redeem this reward on this channel.
	CommunityPointsUnlockEmoteErrorCodeRewardForbidden CommunityPointsUnlockEmoteErrorCode = "REWARD_FORBIDDEN"
	// An unknown error occurred.
	CommunityPointsUnlockEmoteErrorCodeUnknown CommunityPointsUnlockEmoteErrorCode = "UNKNOWN"
)

var AllCommunityPointsUnlockEmoteErrorCode = []CommunityPointsUnlockEmoteErrorCode{
	CommunityPointsUnlockEmoteErrorCodeInvalidEmote,
	CommunityPointsUnlockEmoteErrorCodeEmoteAlreadyEntitled,
	CommunityPointsUnlockEmoteErrorCodeNoEmotesAvailable,
	CommunityPointsUnlockEmoteErrorCodeInsufficientPoints,
	CommunityPointsUnlockEmoteErrorCodeTransactionAlreadyCommitted,
	CommunityPointsUnlockEmoteErrorCodeTransactionInProgress,
	CommunityPointsUnlockEmoteErrorCodeRewardCostMismatch,
	CommunityPointsUnlockEmoteErrorCodeRewardDisabled,
	CommunityPointsUnlockEmoteErrorCodeRewardForbidden,
	CommunityPointsUnlockEmoteErrorCodeUnknown,
}

func (e CommunityPointsUnlockEmoteErrorCode) IsValid() bool {
	switch e {
	case CommunityPointsUnlockEmoteErrorCodeInvalidEmote, CommunityPointsUnlockEmoteErrorCodeEmoteAlreadyEntitled, CommunityPointsUnlockEmoteErrorCodeNoEmotesAvailable, CommunityPointsUnlockEmoteErrorCodeInsufficientPoints, CommunityPointsUnlockEmoteErrorCodeTransactionAlreadyCommitted, CommunityPointsUnlockEmoteErrorCodeTransactionInProgress, CommunityPointsUnlockEmoteErrorCodeRewardCostMismatch, CommunityPointsUnlockEmoteErrorCodeRewardDisabled, CommunityPointsUnlockEmoteErrorCodeRewardForbidden, CommunityPointsUnlockEmoteErrorCodeUnknown:
		return true
	}
	return false
}

func (e CommunityPointsUnlockEmoteErrorCode) String() string {
	return string(e)
}

func (e *CommunityPointsUnlockEmoteErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommunityPointsUnlockEmoteErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommunityPointsUnlockEmoteErrorCode", str)
	}
	return nil
}

func (e CommunityPointsUnlockEmoteErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Methods for updating community points CustomReward redemption statuses.
type CommunityPointsUpdateCustomRewardRedemptionStatusesMethod string

const (
	// Unknown method.
	CommunityPointsUpdateCustomRewardRedemptionStatusesMethodUnknown CommunityPointsUpdateCustomRewardRedemptionStatusesMethod = "UNKNOWN"
	// Statuses for all redemptions for the channel are being updated.
	CommunityPointsUpdateCustomRewardRedemptionStatusesMethodByChannel CommunityPointsUpdateCustomRewardRedemptionStatusesMethod = "BY_CHANNEL"
	// Statuses for all redemptions for a reward are being updated.
	CommunityPointsUpdateCustomRewardRedemptionStatusesMethodByReward CommunityPointsUpdateCustomRewardRedemptionStatusesMethod = "BY_REWARD"
	// Statuses for the provided redemptions are being updated.
	CommunityPointsUpdateCustomRewardRedemptionStatusesMethodByRedemptions CommunityPointsUpdateCustomRewardRedemptionStatusesMethod = "BY_REDEMPTIONS"
)

var AllCommunityPointsUpdateCustomRewardRedemptionStatusesMethod = []CommunityPointsUpdateCustomRewardRedemptionStatusesMethod{
	CommunityPointsUpdateCustomRewardRedemptionStatusesMethodUnknown,
	CommunityPointsUpdateCustomRewardRedemptionStatusesMethodByChannel,
	CommunityPointsUpdateCustomRewardRedemptionStatusesMethodByReward,
	CommunityPointsUpdateCustomRewardRedemptionStatusesMethodByRedemptions,
}

func (e CommunityPointsUpdateCustomRewardRedemptionStatusesMethod) IsValid() bool {
	switch e {
	case CommunityPointsUpdateCustomRewardRedemptionStatusesMethodUnknown, CommunityPointsUpdateCustomRewardRedemptionStatusesMethodByChannel, CommunityPointsUpdateCustomRewardRedemptionStatusesMethodByReward, CommunityPointsUpdateCustomRewardRedemptionStatusesMethodByRedemptions:
		return true
	}
	return false
}

func (e CommunityPointsUpdateCustomRewardRedemptionStatusesMethod) String() string {
	return string(e)
}

func (e *CommunityPointsUpdateCustomRewardRedemptionStatusesMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommunityPointsUpdateCustomRewardRedemptionStatusesMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommunityPointsUpdateCustomRewardRedemptionStatusesMethod", str)
	}
	return nil
}

func (e CommunityPointsUpdateCustomRewardRedemptionStatusesMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for user errors.
type CompetitionErrorCode string

const (
	// Used when an argument is missing but was required.
	CompetitionErrorCodeRequiredArgument CompetitionErrorCode = "REQUIRED_ARGUMENT"
	// Used when an argument that is passed in is invalid in some way.
	CompetitionErrorCodeInvalidArgument CompetitionErrorCode = "INVALID_ARGUMENT"
	// Used when an attempt to add a resource but that resource already exists.
	CompetitionErrorCodeAlreadyExists CompetitionErrorCode = "ALREADY_EXISTS"
	// Used when the registration limit on the competition has been reached.
	CompetitionErrorCodeLimitReached CompetitionErrorCode = "LIMIT_REACHED"
	// Used when the error is unknown.
	CompetitionErrorCodeUnknown CompetitionErrorCode = "UNKNOWN"
)

var AllCompetitionErrorCode = []CompetitionErrorCode{
	CompetitionErrorCodeRequiredArgument,
	CompetitionErrorCodeInvalidArgument,
	CompetitionErrorCodeAlreadyExists,
	CompetitionErrorCodeLimitReached,
	CompetitionErrorCodeUnknown,
}

func (e CompetitionErrorCode) IsValid() bool {
	switch e {
	case CompetitionErrorCodeRequiredArgument, CompetitionErrorCodeInvalidArgument, CompetitionErrorCodeAlreadyExists, CompetitionErrorCodeLimitReached, CompetitionErrorCodeUnknown:
		return true
	}
	return false
}

func (e CompetitionErrorCode) String() string {
	return string(e)
}

func (e *CompetitionErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompetitionErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompetitionErrorCode", str)
	}
	return nil
}

func (e CompetitionErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The participant type signifies whether the competition will be played as team or solo.
type CompetitionParticipantType string

const (
	// Participants are represented as a team.
	CompetitionParticipantTypeTeam CompetitionParticipantType = "TEAM"
	// Participant is represented as solo.
	CompetitionParticipantTypeSolo CompetitionParticipantType = "SOLO"
	// Unknown participant type.
	CompetitionParticipantTypeUnknown CompetitionParticipantType = "UNKNOWN"
)

var AllCompetitionParticipantType = []CompetitionParticipantType{
	CompetitionParticipantTypeTeam,
	CompetitionParticipantTypeSolo,
	CompetitionParticipantTypeUnknown,
}

func (e CompetitionParticipantType) IsValid() bool {
	switch e {
	case CompetitionParticipantTypeTeam, CompetitionParticipantTypeSolo, CompetitionParticipantTypeUnknown:
		return true
	}
	return false
}

func (e CompetitionParticipantType) String() string {
	return string(e)
}

func (e *CompetitionParticipantType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompetitionParticipantType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompetitionParticipantType", str)
	}
	return nil
}

func (e CompetitionParticipantType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The phase type subdivides phases for more complex tournament types.
type CompetitionPhaseType string

const (
	// This phase contains participants who have not used their second-chance.
	CompetitionPhaseTypeDoubleEliminationWinners CompetitionPhaseType = "DOUBLE_ELIMINATION_WINNERS"
	// This phase contains participants who have lost a lobby once.
	CompetitionPhaseTypeDoubleEliminationLosers CompetitionPhaseType = "DOUBLE_ELIMINATION_LOSERS"
	// Phase type is not applicable to a phase of this competition type.
	CompetitionPhaseTypeNotApplicable CompetitionPhaseType = "NOT_APPLICABLE"
	// Phase type is unknown.
	CompetitionPhaseTypeUnknown CompetitionPhaseType = "UNKNOWN"
)

var AllCompetitionPhaseType = []CompetitionPhaseType{
	CompetitionPhaseTypeDoubleEliminationWinners,
	CompetitionPhaseTypeDoubleEliminationLosers,
	CompetitionPhaseTypeNotApplicable,
	CompetitionPhaseTypeUnknown,
}

func (e CompetitionPhaseType) IsValid() bool {
	switch e {
	case CompetitionPhaseTypeDoubleEliminationWinners, CompetitionPhaseTypeDoubleEliminationLosers, CompetitionPhaseTypeNotApplicable, CompetitionPhaseTypeUnknown:
		return true
	}
	return false
}

func (e CompetitionPhaseType) String() string {
	return string(e)
}

func (e *CompetitionPhaseType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompetitionPhaseType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompetitionPhaseType", str)
	}
	return nil
}

func (e CompetitionPhaseType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The states a player can have in the competition.
type CompetitionPlayerState string

const (
	// The player has been invited.
	CompetitionPlayerStateInvited CompetitionPlayerState = "INVITED"
	// The player has registered to compete in this competition in the future.
	CompetitionPlayerStateRegistered CompetitionPlayerState = "REGISTERED"
	// The player has checked in to compete now.
	CompetitionPlayerStateCheckedIn CompetitionPlayerState = "CHECKED_IN"
	// The player has competed in the competition.
	CompetitionPlayerStateCompeted CompetitionPlayerState = "COMPETED"
	// The player has declined the competition.
	CompetitionPlayerStateDeclined CompetitionPlayerState = "DECLINED"
	// The player state is unknown.
	CompetitionPlayerStateUnknown CompetitionPlayerState = "UNKNOWN"
)

var AllCompetitionPlayerState = []CompetitionPlayerState{
	CompetitionPlayerStateInvited,
	CompetitionPlayerStateRegistered,
	CompetitionPlayerStateCheckedIn,
	CompetitionPlayerStateCompeted,
	CompetitionPlayerStateDeclined,
	CompetitionPlayerStateUnknown,
}

func (e CompetitionPlayerState) IsValid() bool {
	switch e {
	case CompetitionPlayerStateInvited, CompetitionPlayerStateRegistered, CompetitionPlayerStateCheckedIn, CompetitionPlayerStateCompeted, CompetitionPlayerStateDeclined, CompetitionPlayerStateUnknown:
		return true
	}
	return false
}

func (e CompetitionPlayerState) String() string {
	return string(e)
}

func (e *CompetitionPlayerState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompetitionPlayerState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompetitionPlayerState", str)
	}
	return nil
}

func (e CompetitionPlayerState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The State of the Competition.
type CompetitionState string

const (
	// Upcoming competition.
	CompetitionStateUpcoming CompetitionState = "UPCOMING"
	// Past competition.
	CompetitionStatePast CompetitionState = "PAST"
	// Live competition.
	CompetitionStateLive CompetitionState = "LIVE"
	// A competition that's awaiting check-ins.
	CompetitionStateCheckIn CompetitionState = "CHECK_IN"
	// A competition that's ready to be started.
	CompetitionStateReady CompetitionState = "READY"
	// Unknown state.
	CompetitionStateUnknown CompetitionState = "UNKNOWN"
)

var AllCompetitionState = []CompetitionState{
	CompetitionStateUpcoming,
	CompetitionStatePast,
	CompetitionStateLive,
	CompetitionStateCheckIn,
	CompetitionStateReady,
	CompetitionStateUnknown,
}

func (e CompetitionState) IsValid() bool {
	switch e {
	case CompetitionStateUpcoming, CompetitionStatePast, CompetitionStateLive, CompetitionStateCheckIn, CompetitionStateReady, CompetitionStateUnknown:
		return true
	}
	return false
}

func (e CompetitionState) String() string {
	return string(e)
}

func (e *CompetitionState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompetitionState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompetitionState", str)
	}
	return nil
}

func (e CompetitionState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The Visibility of the Competition.
type CompetitionVisibilityState string

const (
	// Private competition.
	CompetitionVisibilityStatePrivate CompetitionVisibilityState = "PRIVATE"
	// Public competition.
	CompetitionVisibilityStatePublic CompetitionVisibilityState = "PUBLIC"
	// Unknown state.
	CompetitionVisibilityStateUnknown CompetitionVisibilityState = "UNKNOWN"
)

var AllCompetitionVisibilityState = []CompetitionVisibilityState{
	CompetitionVisibilityStatePrivate,
	CompetitionVisibilityStatePublic,
	CompetitionVisibilityStateUnknown,
}

func (e CompetitionVisibilityState) IsValid() bool {
	switch e {
	case CompetitionVisibilityStatePrivate, CompetitionVisibilityStatePublic, CompetitionVisibilityStateUnknown:
		return true
	}
	return false
}

func (e CompetitionVisibilityState) String() string {
	return string(e)
}

func (e *CompetitionVisibilityState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompetitionVisibilityState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompetitionVisibilityState", str)
	}
	return nil
}

func (e CompetitionVisibilityState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ConsentStatus is the flag to show user gives or denies the consent.
type ConsentStatus string

const (
	// User gives consent.
	ConsentStatusGiven ConsentStatus = "GIVEN"
	// User denies consent.
	ConsentStatusDenied ConsentStatus = "DENIED"
)

var AllConsentStatus = []ConsentStatus{
	ConsentStatusGiven,
	ConsentStatusDenied,
}

func (e ConsentStatus) IsValid() bool {
	switch e {
	case ConsentStatusGiven, ConsentStatusDenied:
		return true
	}
	return false
}

func (e ConsentStatus) String() string {
	return string(e)
}

func (e *ConsentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConsentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConsentStatus", str)
	}
	return nil
}

func (e ConsentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration on the different content type that enable tagging.
type ContentType string

const (
	// Clip will enable tagging in v2.
	ContentTypeClip ContentType = "CLIP"
	// User is enabled for tagging in v1.
	ContentTypeUser        ContentType = "USER"
	ContentTypeLiveChannel ContentType = "LIVE_CHANNEL"
	// VOD will enable tagging in v2.
	ContentTypeVod ContentType = "VOD"
	// Games and other stream categories.
	ContentTypeCategory ContentType = "CATEGORY"
)

var AllContentType = []ContentType{
	ContentTypeClip,
	ContentTypeUser,
	ContentTypeLiveChannel,
	ContentTypeVod,
	ContentTypeCategory,
}

func (e ContentType) IsValid() bool {
	switch e {
	case ContentTypeClip, ContentTypeUser, ContentTypeLiveChannel, ContentTypeVod, ContentTypeCategory:
		return true
	}
	return false
}

func (e ContentType) String() string {
	return string(e)
}

func (e *ContentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContentType", str)
	}
	return nil
}

func (e ContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Contribute community goal error codes.
type ContributeCommunityPointsCommunityGoalErrorCode string

const (
	// The goal is not currently redeemable, possibly because stream is not live.
	ContributeCommunityPointsCommunityGoalErrorCodeNotCurrentlyRedeemable ContributeCommunityPointsCommunityGoalErrorCode = "NOT_CURRENTLY_REDEEMABLE"
	// The current user does not have enough points to contribute this amount.
	ContributeCommunityPointsCommunityGoalErrorCodeNotEnoughPoints ContributeCommunityPointsCommunityGoalErrorCode = "NOT_ENOUGH_POINTS"
	// The community goal was not found.
	ContributeCommunityPointsCommunityGoalErrorCodeNotFound ContributeCommunityPointsCommunityGoalErrorCode = "NOT_FOUND"
	// The current user is not allowed to contribute community points towards community goals for this channel.
	ContributeCommunityPointsCommunityGoalErrorCodeForbidden ContributeCommunityPointsCommunityGoalErrorCode = "FORBIDDEN"
	// The current user has already reached the maximum points contributable per stream.
	ContributeCommunityPointsCommunityGoalErrorCodeMaxPerStream ContributeCommunityPointsCommunityGoalErrorCode = "MAX_PER_STREAM"
	// The current user has a contribution already in progress.
	ContributeCommunityPointsCommunityGoalErrorCodeTransactionInProgress ContributeCommunityPointsCommunityGoalErrorCode = "TRANSACTION_IN_PROGRESS"
	// The current user has already completed this transaction.
	ContributeCommunityPointsCommunityGoalErrorCodeDuplicateTransaction ContributeCommunityPointsCommunityGoalErrorCode = "DUPLICATE_TRANSACTION"
	// The current user is banned.
	ContributeCommunityPointsCommunityGoalErrorCodeUserBanned ContributeCommunityPointsCommunityGoalErrorCode = "USER_BANNED"
	// An unknown error occurred.
	ContributeCommunityPointsCommunityGoalErrorCodeUnknown ContributeCommunityPointsCommunityGoalErrorCode = "UNKNOWN"
)

var AllContributeCommunityPointsCommunityGoalErrorCode = []ContributeCommunityPointsCommunityGoalErrorCode{
	ContributeCommunityPointsCommunityGoalErrorCodeNotCurrentlyRedeemable,
	ContributeCommunityPointsCommunityGoalErrorCodeNotEnoughPoints,
	ContributeCommunityPointsCommunityGoalErrorCodeNotFound,
	ContributeCommunityPointsCommunityGoalErrorCodeForbidden,
	ContributeCommunityPointsCommunityGoalErrorCodeMaxPerStream,
	ContributeCommunityPointsCommunityGoalErrorCodeTransactionInProgress,
	ContributeCommunityPointsCommunityGoalErrorCodeDuplicateTransaction,
	ContributeCommunityPointsCommunityGoalErrorCodeUserBanned,
	ContributeCommunityPointsCommunityGoalErrorCodeUnknown,
}

func (e ContributeCommunityPointsCommunityGoalErrorCode) IsValid() bool {
	switch e {
	case ContributeCommunityPointsCommunityGoalErrorCodeNotCurrentlyRedeemable, ContributeCommunityPointsCommunityGoalErrorCodeNotEnoughPoints, ContributeCommunityPointsCommunityGoalErrorCodeNotFound, ContributeCommunityPointsCommunityGoalErrorCodeForbidden, ContributeCommunityPointsCommunityGoalErrorCodeMaxPerStream, ContributeCommunityPointsCommunityGoalErrorCodeTransactionInProgress, ContributeCommunityPointsCommunityGoalErrorCodeDuplicateTransaction, ContributeCommunityPointsCommunityGoalErrorCodeUserBanned, ContributeCommunityPointsCommunityGoalErrorCodeUnknown:
		return true
	}
	return false
}

func (e ContributeCommunityPointsCommunityGoalErrorCode) String() string {
	return string(e)
}

func (e *ContributeCommunityPointsCommunityGoalErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContributeCommunityPointsCommunityGoalErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContributeCommunityPointsCommunityGoalErrorCode", str)
	}
	return nil
}

func (e ContributeCommunityPointsCommunityGoalErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Contribute to challenge error code.
type ContributeToChallengeErrorCode string

const (
	// User tried to contribute to a challenge that doesn't exist i.e. there is no indicated challenge at all).
	ContributeToChallengeErrorCodeChallengeNotFound ContributeToChallengeErrorCode = "CHALLENGE_NOT_FOUND"
	// User tried to contribute to a challenge that is not active.
	ContributeToChallengeErrorCodeChallengeNotActive ContributeToChallengeErrorCode = "CHALLENGE_NOT_ACTIVE"
	// Request is for a channel ID that is invalid (e.g. banned channel, channel doesn't exist).
	ContributeToChallengeErrorCodeInvalidChannelID ContributeToChallengeErrorCode = "INVALID_CHANNEL_ID"
	// User's bits balance is too low to perform request (e.g. they only have 10 bits and they request to spend 100).
	ContributeToChallengeErrorCodeInsufficientBitsBalance ContributeToChallengeErrorCode = "INSUFFICIENT_BITS_BALANCE"
	// User is not allowed to contribute to the challenge (e.g. they're banned in the channel).
	ContributeToChallengeErrorCodeUserForbidden ContributeToChallengeErrorCode = "USER_FORBIDDEN"
	// An unknown error occurred.
	ContributeToChallengeErrorCodeUnknown ContributeToChallengeErrorCode = "UNKNOWN"
)

var AllContributeToChallengeErrorCode = []ContributeToChallengeErrorCode{
	ContributeToChallengeErrorCodeChallengeNotFound,
	ContributeToChallengeErrorCodeChallengeNotActive,
	ContributeToChallengeErrorCodeInvalidChannelID,
	ContributeToChallengeErrorCodeInsufficientBitsBalance,
	ContributeToChallengeErrorCodeUserForbidden,
	ContributeToChallengeErrorCodeUnknown,
}

func (e ContributeToChallengeErrorCode) IsValid() bool {
	switch e {
	case ContributeToChallengeErrorCodeChallengeNotFound, ContributeToChallengeErrorCodeChallengeNotActive, ContributeToChallengeErrorCodeInvalidChannelID, ContributeToChallengeErrorCodeInsufficientBitsBalance, ContributeToChallengeErrorCodeUserForbidden, ContributeToChallengeErrorCodeUnknown:
		return true
	}
	return false
}

func (e ContributeToChallengeErrorCode) String() string {
	return string(e)
}

func (e *ContributeToChallengeErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContributeToChallengeErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContributeToChallengeErrorCode", str)
	}
	return nil
}

func (e ContributeToChallengeErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error code describing a CreateBadgeFlairError
type CreateBadgeFlairErrorCode string

const (
	// Channel ID argument was invalid or empty.
	CreateBadgeFlairErrorCodeInvalidChannelID CreateBadgeFlairErrorCode = "INVALID_CHANNEL_ID"
	// Image ID for 1x image was invalid or empty.
	CreateBadgeFlairErrorCodeInvalidFlairImage1xID CreateBadgeFlairErrorCode = "INVALID_FLAIR_IMAGE_1X_ID"
	// Image ID for 2x image was invalid or empty.
	CreateBadgeFlairErrorCodeInvalidFlairImage2xID CreateBadgeFlairErrorCode = "INVALID_FLAIR_IMAGE_2X_ID"
	// Image ID for 4x image was invalid or empty.
	CreateBadgeFlairErrorCodeInvalidFlairImage4xID CreateBadgeFlairErrorCode = "INVALID_FLAIR_IMAGE_4X_ID"
	// Tier value was invalid or empty.
	CreateBadgeFlairErrorCodeInvalidTier CreateBadgeFlairErrorCode = "INVALID_TIER"
)

var AllCreateBadgeFlairErrorCode = []CreateBadgeFlairErrorCode{
	CreateBadgeFlairErrorCodeInvalidChannelID,
	CreateBadgeFlairErrorCodeInvalidFlairImage1xID,
	CreateBadgeFlairErrorCodeInvalidFlairImage2xID,
	CreateBadgeFlairErrorCodeInvalidFlairImage4xID,
	CreateBadgeFlairErrorCodeInvalidTier,
}

func (e CreateBadgeFlairErrorCode) IsValid() bool {
	switch e {
	case CreateBadgeFlairErrorCodeInvalidChannelID, CreateBadgeFlairErrorCodeInvalidFlairImage1xID, CreateBadgeFlairErrorCodeInvalidFlairImage2xID, CreateBadgeFlairErrorCodeInvalidFlairImage4xID, CreateBadgeFlairErrorCodeInvalidTier:
		return true
	}
	return false
}

func (e CreateBadgeFlairErrorCode) String() string {
	return string(e)
}

func (e *CreateBadgeFlairErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateBadgeFlairErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateBadgeFlairErrorCode", str)
	}
	return nil
}

func (e CreateBadgeFlairErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Create Challenge Condition error code.
type CreateChallengeConditionErrorCode string

const (
	// User tried to create a condition with a bits recipient that is ineligible to receive bits.
	CreateChallengeConditionErrorCodeBitsRecipientIneligible CreateChallengeConditionErrorCode = "BITS_RECIPIENT_INELIGIBLE"
	// An unknown error occurred.
	CreateChallengeConditionErrorCodeUnknown CreateChallengeConditionErrorCode = "UNKNOWN"
)

var AllCreateChallengeConditionErrorCode = []CreateChallengeConditionErrorCode{
	CreateChallengeConditionErrorCodeBitsRecipientIneligible,
	CreateChallengeConditionErrorCodeUnknown,
}

func (e CreateChallengeConditionErrorCode) IsValid() bool {
	switch e {
	case CreateChallengeConditionErrorCodeBitsRecipientIneligible, CreateChallengeConditionErrorCodeUnknown:
		return true
	}
	return false
}

func (e CreateChallengeConditionErrorCode) String() string {
	return string(e)
}

func (e *CreateChallengeConditionErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateChallengeConditionErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateChallengeConditionErrorCode", str)
	}
	return nil
}

func (e CreateChallengeConditionErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Create Challenge Condition Participant error code.
type CreateChallengeConditionParticipantErrorCode string

const (
	// User tried to create a condition participant with a USE_BITS effect type, but they are ineligible to use bits.
	CreateChallengeConditionParticipantErrorCodeBitsBenefactorIneligible CreateChallengeConditionParticipantErrorCode = "BITS_BENEFACTOR_INELIGIBLE"
	// User tried to create a condition participant with a USE_BITS effect type, but they lacked sufficient bits.
	CreateChallengeConditionParticipantErrorCodeInsufficientBitsBalance CreateChallengeConditionParticipantErrorCode = "INSUFFICIENT_BITS_BALANCE"
	// User tried to create a condition participant for an inactive condition.
	CreateChallengeConditionParticipantErrorCodeConditionNotActive CreateChallengeConditionParticipantErrorCode = "CONDITION_NOT_ACTIVE"
	// User tried to create a condition participant for a non-existent condition.
	CreateChallengeConditionParticipantErrorCodeConditionNotFound CreateChallengeConditionParticipantErrorCode = "CONDITION_NOT_FOUND"
	// User tried to create a condition participant with an effect type that is not supported by the associated condition.
	CreateChallengeConditionParticipantErrorCodeEffectTypeUnsupportedByCondition CreateChallengeConditionParticipantErrorCode = "EFFECT_TYPE_UNSUPPORTED_BY_CONDITION"
	// An unknown error occurred.
	CreateChallengeConditionParticipantErrorCodeUnknown CreateChallengeConditionParticipantErrorCode = "UNKNOWN"
)

var AllCreateChallengeConditionParticipantErrorCode = []CreateChallengeConditionParticipantErrorCode{
	CreateChallengeConditionParticipantErrorCodeBitsBenefactorIneligible,
	CreateChallengeConditionParticipantErrorCodeInsufficientBitsBalance,
	CreateChallengeConditionParticipantErrorCodeConditionNotActive,
	CreateChallengeConditionParticipantErrorCodeConditionNotFound,
	CreateChallengeConditionParticipantErrorCodeEffectTypeUnsupportedByCondition,
	CreateChallengeConditionParticipantErrorCodeUnknown,
}

func (e CreateChallengeConditionParticipantErrorCode) IsValid() bool {
	switch e {
	case CreateChallengeConditionParticipantErrorCodeBitsBenefactorIneligible, CreateChallengeConditionParticipantErrorCodeInsufficientBitsBalance, CreateChallengeConditionParticipantErrorCodeConditionNotActive, CreateChallengeConditionParticipantErrorCodeConditionNotFound, CreateChallengeConditionParticipantErrorCodeEffectTypeUnsupportedByCondition, CreateChallengeConditionParticipantErrorCodeUnknown:
		return true
	}
	return false
}

func (e CreateChallengeConditionParticipantErrorCode) String() string {
	return string(e)
}

func (e *CreateChallengeConditionParticipantErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateChallengeConditionParticipantErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateChallengeConditionParticipantErrorCode", str)
	}
	return nil
}

func (e CreateChallengeConditionParticipantErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CreateClipErrorCode contains the possible errors that can occur when creating a clip.
type CreateClipErrorCode string

const (
	// This channel cannot be clipped.
	CreateClipErrorCodeChannelNotClippable CreateClipErrorCode = "CHANNEL_NOT_CLIPPABLE"
	// The channel has been banned and cannot be clipped.
	CreateClipErrorCodeChannelBanned CreateClipErrorCode = "CHANNEL_BANNED"
	// User has been banned from the channel and cannot clip.
	CreateClipErrorCodeUserBanned CreateClipErrorCode = "USER_BANNED"
	// User has been timed out from the channel and cannot clip.
	CreateClipErrorCodeUserTimedOut CreateClipErrorCode = "USER_TIMED_OUT"
	// Clip cannot be created because channel is no longer live.
	CreateClipErrorCodeChannelNotLive CreateClipErrorCode = "CHANNEL_NOT_LIVE"
	// Clip cannot be created because the request is throttled.
	CreateClipErrorCodeRequestThrottled CreateClipErrorCode = "REQUEST_THROTTLED"
	// User does not have permissions and cannot clip.
	CreateClipErrorCodeUserRestricted CreateClipErrorCode = "USER_RESTRICTED"
	// Unknown error.
	CreateClipErrorCodeUnknown CreateClipErrorCode = "UNKNOWN"
)

var AllCreateClipErrorCode = []CreateClipErrorCode{
	CreateClipErrorCodeChannelNotClippable,
	CreateClipErrorCodeChannelBanned,
	CreateClipErrorCodeUserBanned,
	CreateClipErrorCodeUserTimedOut,
	CreateClipErrorCodeChannelNotLive,
	CreateClipErrorCodeRequestThrottled,
	CreateClipErrorCodeUserRestricted,
	CreateClipErrorCodeUnknown,
}

func (e CreateClipErrorCode) IsValid() bool {
	switch e {
	case CreateClipErrorCodeChannelNotClippable, CreateClipErrorCodeChannelBanned, CreateClipErrorCodeUserBanned, CreateClipErrorCodeUserTimedOut, CreateClipErrorCodeChannelNotLive, CreateClipErrorCodeRequestThrottled, CreateClipErrorCodeUserRestricted, CreateClipErrorCodeUnknown:
		return true
	}
	return false
}

func (e CreateClipErrorCode) String() string {
	return string(e)
}

func (e *CreateClipErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateClipErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateClipErrorCode", str)
	}
	return nil
}

func (e CreateClipErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Create community goal error code.
type CreateCommunityPointsCommunityGoalErrorCode string

const (
	// Goal already exists.
	CreateCommunityPointsCommunityGoalErrorCodeDuplicateGoal CreateCommunityPointsCommunityGoalErrorCode = "DUPLICATE_GOAL"
	// Goal title failed automod.
	CreateCommunityPointsCommunityGoalErrorCodeTitleAutomodFailed CreateCommunityPointsCommunityGoalErrorCode = "TITLE_AUTOMOD_FAILED"
	// Goal title is invalid.
	CreateCommunityPointsCommunityGoalErrorCodeTitleInvalid CreateCommunityPointsCommunityGoalErrorCode = "TITLE_INVALID"
	// Goal description failed automod.
	CreateCommunityPointsCommunityGoalErrorCodeDescriptionAutomodFailed CreateCommunityPointsCommunityGoalErrorCode = "DESCRIPTION_AUTOMOD_FAILED"
	// Goal description is invalid.
	CreateCommunityPointsCommunityGoalErrorCodeDescriptionInvalid CreateCommunityPointsCommunityGoalErrorCode = "DESCRIPTION_INVALID"
	// Goal amount is invalid.
	CreateCommunityPointsCommunityGoalErrorCodeGoalAmountInvalid CreateCommunityPointsCommunityGoalErrorCode = "GOAL_AMOUNT_INVALID"
	// Goal duration is invalid.
	CreateCommunityPointsCommunityGoalErrorCodeDurationInvalid CreateCommunityPointsCommunityGoalErrorCode = "DURATION_INVALID"
	// Goal background color is invalid.
	CreateCommunityPointsCommunityGoalErrorCodeBackgroundColorInvalid CreateCommunityPointsCommunityGoalErrorCode = "BACKGROUND_COLOR_INVALID"
	// Too many goals already exists.
	CreateCommunityPointsCommunityGoalErrorCodeTooManyGoals CreateCommunityPointsCommunityGoalErrorCode = "TOO_MANY_GOALS"
	// The current user is not allowed to create goals for this channel.
	CreateCommunityPointsCommunityGoalErrorCodeForbidden CreateCommunityPointsCommunityGoalErrorCode = "FORBIDDEN"
	// An unknown error occurred.
	CreateCommunityPointsCommunityGoalErrorCodeUnknown CreateCommunityPointsCommunityGoalErrorCode = "UNKNOWN"
)

var AllCreateCommunityPointsCommunityGoalErrorCode = []CreateCommunityPointsCommunityGoalErrorCode{
	CreateCommunityPointsCommunityGoalErrorCodeDuplicateGoal,
	CreateCommunityPointsCommunityGoalErrorCodeTitleAutomodFailed,
	CreateCommunityPointsCommunityGoalErrorCodeTitleInvalid,
	CreateCommunityPointsCommunityGoalErrorCodeDescriptionAutomodFailed,
	CreateCommunityPointsCommunityGoalErrorCodeDescriptionInvalid,
	CreateCommunityPointsCommunityGoalErrorCodeGoalAmountInvalid,
	CreateCommunityPointsCommunityGoalErrorCodeDurationInvalid,
	CreateCommunityPointsCommunityGoalErrorCodeBackgroundColorInvalid,
	CreateCommunityPointsCommunityGoalErrorCodeTooManyGoals,
	CreateCommunityPointsCommunityGoalErrorCodeForbidden,
	CreateCommunityPointsCommunityGoalErrorCodeUnknown,
}

func (e CreateCommunityPointsCommunityGoalErrorCode) IsValid() bool {
	switch e {
	case CreateCommunityPointsCommunityGoalErrorCodeDuplicateGoal, CreateCommunityPointsCommunityGoalErrorCodeTitleAutomodFailed, CreateCommunityPointsCommunityGoalErrorCodeTitleInvalid, CreateCommunityPointsCommunityGoalErrorCodeDescriptionAutomodFailed, CreateCommunityPointsCommunityGoalErrorCodeDescriptionInvalid, CreateCommunityPointsCommunityGoalErrorCodeGoalAmountInvalid, CreateCommunityPointsCommunityGoalErrorCodeDurationInvalid, CreateCommunityPointsCommunityGoalErrorCodeBackgroundColorInvalid, CreateCommunityPointsCommunityGoalErrorCodeTooManyGoals, CreateCommunityPointsCommunityGoalErrorCodeForbidden, CreateCommunityPointsCommunityGoalErrorCodeUnknown:
		return true
	}
	return false
}

func (e CreateCommunityPointsCommunityGoalErrorCode) String() string {
	return string(e)
}

func (e *CreateCommunityPointsCommunityGoalErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateCommunityPointsCommunityGoalErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateCommunityPointsCommunityGoalErrorCode", str)
	}
	return nil
}

func (e CreateCommunityPointsCommunityGoalErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons creating a custom Community Points reward in a channel could fail.
type CreateCommunityPointsCustomRewardErrorCode string

const (
	// An unexpected error occurred.
	CreateCommunityPointsCustomRewardErrorCodeUnknown CreateCommunityPointsCustomRewardErrorCode = "UNKNOWN"
	// The current user is not allowed to create a reward in this channel.
	CreateCommunityPointsCustomRewardErrorCodeForbidden CreateCommunityPointsCustomRewardErrorCode = "FORBIDDEN"
	// The title failed AutoMod.
	CreateCommunityPointsCustomRewardErrorCodeTitleAutomodFailed CreateCommunityPointsCustomRewardErrorCode = "TITLE_AUTOMOD_FAILED"
	// The prompt failed AutoMod.
	CreateCommunityPointsCustomRewardErrorCodePromptAutomodFailed CreateCommunityPointsCustomRewardErrorCode = "PROMPT_AUTOMOD_FAILED"
	// The cost is invalid. Costs must be greater than 0.
	CreateCommunityPointsCustomRewardErrorCodeCostInvalid CreateCommunityPointsCustomRewardErrorCode = "COST_INVALID"
	// The maxPerStream is invalid. maxPerStream must be greater than 0.
	CreateCommunityPointsCustomRewardErrorCodeMaxPerStreamInvalid CreateCommunityPointsCustomRewardErrorCode = "MAX_PER_STREAM_INVALID"
	// The channel has too many rewards. An existing reward must be deleted before you can create a new reward.
	CreateCommunityPointsCustomRewardErrorCodeTooManyRewards CreateCommunityPointsCustomRewardErrorCode = "TOO_MANY_REWARDS"
	// The title is invalid. Titles must not be empty and must be at most 45 characters long.
	CreateCommunityPointsCustomRewardErrorCodeTitleInvalid CreateCommunityPointsCustomRewardErrorCode = "TITLE_INVALID"
	// A reward with the provided title already exists. Custom reward titles must be unique.
	CreateCommunityPointsCustomRewardErrorCodeDuplicateReward CreateCommunityPointsCustomRewardErrorCode = "DUPLICATE_REWARD"
	// The background color is invalid. Backgrounds must be a valid hex color, for example "FF0000".
	CreateCommunityPointsCustomRewardErrorCodeBackgroundColorInvalid CreateCommunityPointsCustomRewardErrorCode = "BACKGROUND_COLOR_INVALID"
	// The template id provided is invalid. Template id must be the id for a valid template or null.
	CreateCommunityPointsCustomRewardErrorCodeTemplateInvalid CreateCommunityPointsCustomRewardErrorCode = "TEMPLATE_INVALID"
	// The maxPerUserPerStream is invalid. maxPerUserPerStream must be greater than 0.
	CreateCommunityPointsCustomRewardErrorCodeMaxPerUserPerStreamInvalid CreateCommunityPointsCustomRewardErrorCode = "MAX_PER_USER_PER_STREAM_INVALID"
	// The globalCooldown is invalid. globalCooldown must be greater tham 0.
	CreateCommunityPointsCustomRewardErrorCodeGlobalCooldownInvalid CreateCommunityPointsCustomRewardErrorCode = "GLOBAL_COOLDOWN_INVALID"
)

var AllCreateCommunityPointsCustomRewardErrorCode = []CreateCommunityPointsCustomRewardErrorCode{
	CreateCommunityPointsCustomRewardErrorCodeUnknown,
	CreateCommunityPointsCustomRewardErrorCodeForbidden,
	CreateCommunityPointsCustomRewardErrorCodeTitleAutomodFailed,
	CreateCommunityPointsCustomRewardErrorCodePromptAutomodFailed,
	CreateCommunityPointsCustomRewardErrorCodeCostInvalid,
	CreateCommunityPointsCustomRewardErrorCodeMaxPerStreamInvalid,
	CreateCommunityPointsCustomRewardErrorCodeTooManyRewards,
	CreateCommunityPointsCustomRewardErrorCodeTitleInvalid,
	CreateCommunityPointsCustomRewardErrorCodeDuplicateReward,
	CreateCommunityPointsCustomRewardErrorCodeBackgroundColorInvalid,
	CreateCommunityPointsCustomRewardErrorCodeTemplateInvalid,
	CreateCommunityPointsCustomRewardErrorCodeMaxPerUserPerStreamInvalid,
	CreateCommunityPointsCustomRewardErrorCodeGlobalCooldownInvalid,
}

func (e CreateCommunityPointsCustomRewardErrorCode) IsValid() bool {
	switch e {
	case CreateCommunityPointsCustomRewardErrorCodeUnknown, CreateCommunityPointsCustomRewardErrorCodeForbidden, CreateCommunityPointsCustomRewardErrorCodeTitleAutomodFailed, CreateCommunityPointsCustomRewardErrorCodePromptAutomodFailed, CreateCommunityPointsCustomRewardErrorCodeCostInvalid, CreateCommunityPointsCustomRewardErrorCodeMaxPerStreamInvalid, CreateCommunityPointsCustomRewardErrorCodeTooManyRewards, CreateCommunityPointsCustomRewardErrorCodeTitleInvalid, CreateCommunityPointsCustomRewardErrorCodeDuplicateReward, CreateCommunityPointsCustomRewardErrorCodeBackgroundColorInvalid, CreateCommunityPointsCustomRewardErrorCodeTemplateInvalid, CreateCommunityPointsCustomRewardErrorCodeMaxPerUserPerStreamInvalid, CreateCommunityPointsCustomRewardErrorCodeGlobalCooldownInvalid:
		return true
	}
	return false
}

func (e CreateCommunityPointsCustomRewardErrorCode) String() string {
	return string(e)
}

func (e *CreateCommunityPointsCustomRewardErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateCommunityPointsCustomRewardErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateCommunityPointsCustomRewardErrorCode", str)
	}
	return nil
}

func (e CreateCommunityPointsCustomRewardErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons generating upload info for Community Points images could fail.
type CreateCommunityPointsImageUploadInfoErrorCode string

const (
	// The current user is not allowed to upload images for this channel.
	CreateCommunityPointsImageUploadInfoErrorCodeForbidden CreateCommunityPointsImageUploadInfoErrorCode = "FORBIDDEN"
	// More than one image type was specified in the request.
	CreateCommunityPointsImageUploadInfoErrorCodeMoreThanOneType CreateCommunityPointsImageUploadInfoErrorCode = "MORE_THAN_ONE_TYPE"
	// Your provided custom reward ID was not found.
	CreateCommunityPointsImageUploadInfoErrorCodeCustomRewardNotFound CreateCommunityPointsImageUploadInfoErrorCode = "CUSTOM_REWARD_NOT_FOUND"
)

var AllCreateCommunityPointsImageUploadInfoErrorCode = []CreateCommunityPointsImageUploadInfoErrorCode{
	CreateCommunityPointsImageUploadInfoErrorCodeForbidden,
	CreateCommunityPointsImageUploadInfoErrorCodeMoreThanOneType,
	CreateCommunityPointsImageUploadInfoErrorCodeCustomRewardNotFound,
}

func (e CreateCommunityPointsImageUploadInfoErrorCode) IsValid() bool {
	switch e {
	case CreateCommunityPointsImageUploadInfoErrorCodeForbidden, CreateCommunityPointsImageUploadInfoErrorCodeMoreThanOneType, CreateCommunityPointsImageUploadInfoErrorCodeCustomRewardNotFound:
		return true
	}
	return false
}

func (e CreateCommunityPointsImageUploadInfoErrorCode) String() string {
	return string(e)
}

func (e *CreateCommunityPointsImageUploadInfoErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateCommunityPointsImageUploadInfoErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateCommunityPointsImageUploadInfoErrorCode", str)
	}
	return nil
}

func (e CreateCommunityPointsImageUploadInfoErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors from CreateDropImageUploadURL.
type CreateDropImageUploadURLErrorCode string

const (
	// The user does not have permissions to create this type of image for this service.
	CreateDropImageUploadURLErrorCodeUserUnauthorized CreateDropImageUploadURLErrorCode = "USER_UNAUTHORIZED"
	// There was an issue calling a dependency of this call.
	CreateDropImageUploadURLErrorCodeServiceDependencyFailure CreateDropImageUploadURLErrorCode = "SERVICE_DEPENDENCY_FAILURE"
	// An issue not matching any other specific error code.
	CreateDropImageUploadURLErrorCodeUnknown CreateDropImageUploadURLErrorCode = "UNKNOWN"
)

var AllCreateDropImageUploadURLErrorCode = []CreateDropImageUploadURLErrorCode{
	CreateDropImageUploadURLErrorCodeUserUnauthorized,
	CreateDropImageUploadURLErrorCodeServiceDependencyFailure,
	CreateDropImageUploadURLErrorCodeUnknown,
}

func (e CreateDropImageUploadURLErrorCode) IsValid() bool {
	switch e {
	case CreateDropImageUploadURLErrorCodeUserUnauthorized, CreateDropImageUploadURLErrorCodeServiceDependencyFailure, CreateDropImageUploadURLErrorCodeUnknown:
		return true
	}
	return false
}

func (e CreateDropImageUploadURLErrorCode) String() string {
	return string(e)
}

func (e *CreateDropImageUploadURLErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateDropImageUploadURLErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateDropImageUploadURLErrorCode", str)
	}
	return nil
}

func (e CreateDropImageUploadURLErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CreateExtensionClientError is an error associated with the createExtensionClient mutation.
type CreateExtensionClientError string

const (
	// The specified name was invalid.
	CreateExtensionClientErrorInvalidName CreateExtensionClientError = "INVALID_NAME"
	// The specified name is already taken by another extension or app.
	CreateExtensionClientErrorNameInUse CreateExtensionClientError = "NAME_IN_USE"
)

var AllCreateExtensionClientError = []CreateExtensionClientError{
	CreateExtensionClientErrorInvalidName,
	CreateExtensionClientErrorNameInUse,
}

func (e CreateExtensionClientError) IsValid() bool {
	switch e {
	case CreateExtensionClientErrorInvalidName, CreateExtensionClientErrorNameInUse:
		return true
	}
	return false
}

func (e CreateExtensionClientError) String() string {
	return string(e)
}

func (e *CreateExtensionClientError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateExtensionClientError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateExtensionClientError", str)
	}
	return nil
}

func (e CreateExtensionClientError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CreateExtensionImageUploadInfoErrorCode is an error code associated with CreateExtensionImageUploadInfoError.
type CreateExtensionImageUploadInfoErrorCode string

const (
	// User is unable to make modifications to the extension.
	CreateExtensionImageUploadInfoErrorCodeUnauthorized CreateExtensionImageUploadInfoErrorCode = "UNAUTHORIZED"
	// Version specified is invalid.
	CreateExtensionImageUploadInfoErrorCodeInvalidVersion CreateExtensionImageUploadInfoErrorCode = "INVALID_VERSION"
	// Not enough discovery image to upload. Must >= 0.
	CreateExtensionImageUploadInfoErrorCodeNotEnoughUploadDiscoveryImage CreateExtensionImageUploadInfoErrorCode = "NOT_ENOUGH_UPLOAD_DISCOVERY_IMAGE"
	// Not enough logo image to upload. Must >= 0.
	CreateExtensionImageUploadInfoErrorCodeNotEnoughUploadLogoImage CreateExtensionImageUploadInfoErrorCode = "NOT_ENOUGH_UPLOAD_LOGO_IMAGE"
	// Not enough screenshot image to upload. Must >= 0.
	CreateExtensionImageUploadInfoErrorCodeNotEnoughUploadScreenshotImage CreateExtensionImageUploadInfoErrorCode = "NOT_ENOUGH_UPLOAD_SCREENSHOT_IMAGE"
	// Not enough taskbar image to upload. Must >= 0.
	CreateExtensionImageUploadInfoErrorCodeNotEnoughUploadTaskbarImage CreateExtensionImageUploadInfoErrorCode = "NOT_ENOUGH_UPLOAD_TASKBAR_IMAGE"
	// Too many discovery image to upload. Must <= 1.
	CreateExtensionImageUploadInfoErrorCodeTooManyUploadDiscoveryImage CreateExtensionImageUploadInfoErrorCode = "TOO_MANY_UPLOAD_DISCOVERY_IMAGE"
	// Too many logo image to upload. Must <= 1.
	CreateExtensionImageUploadInfoErrorCodeTooManyUploadLogoImage CreateExtensionImageUploadInfoErrorCode = "TOO_MANY_UPLOAD_LOGO_IMAGE"
	// Too many screenshot image to upload. Must <= 1.
	CreateExtensionImageUploadInfoErrorCodeTooManyUploadScreenshotImage CreateExtensionImageUploadInfoErrorCode = "TOO_MANY_UPLOAD_SCREENSHOT_IMAGE"
	// Too many taskbar image to upload. Must <= 1.
	CreateExtensionImageUploadInfoErrorCodeTooManyUploadTaskbarImage CreateExtensionImageUploadInfoErrorCode = "TOO_MANY_UPLOAD_TASKBAR_IMAGE"
)

var AllCreateExtensionImageUploadInfoErrorCode = []CreateExtensionImageUploadInfoErrorCode{
	CreateExtensionImageUploadInfoErrorCodeUnauthorized,
	CreateExtensionImageUploadInfoErrorCodeInvalidVersion,
	CreateExtensionImageUploadInfoErrorCodeNotEnoughUploadDiscoveryImage,
	CreateExtensionImageUploadInfoErrorCodeNotEnoughUploadLogoImage,
	CreateExtensionImageUploadInfoErrorCodeNotEnoughUploadScreenshotImage,
	CreateExtensionImageUploadInfoErrorCodeNotEnoughUploadTaskbarImage,
	CreateExtensionImageUploadInfoErrorCodeTooManyUploadDiscoveryImage,
	CreateExtensionImageUploadInfoErrorCodeTooManyUploadLogoImage,
	CreateExtensionImageUploadInfoErrorCodeTooManyUploadScreenshotImage,
	CreateExtensionImageUploadInfoErrorCodeTooManyUploadTaskbarImage,
}

func (e CreateExtensionImageUploadInfoErrorCode) IsValid() bool {
	switch e {
	case CreateExtensionImageUploadInfoErrorCodeUnauthorized, CreateExtensionImageUploadInfoErrorCodeInvalidVersion, CreateExtensionImageUploadInfoErrorCodeNotEnoughUploadDiscoveryImage, CreateExtensionImageUploadInfoErrorCodeNotEnoughUploadLogoImage, CreateExtensionImageUploadInfoErrorCodeNotEnoughUploadScreenshotImage, CreateExtensionImageUploadInfoErrorCodeNotEnoughUploadTaskbarImage, CreateExtensionImageUploadInfoErrorCodeTooManyUploadDiscoveryImage, CreateExtensionImageUploadInfoErrorCodeTooManyUploadLogoImage, CreateExtensionImageUploadInfoErrorCodeTooManyUploadScreenshotImage, CreateExtensionImageUploadInfoErrorCodeTooManyUploadTaskbarImage:
		return true
	}
	return false
}

func (e CreateExtensionImageUploadInfoErrorCode) String() string {
	return string(e)
}

func (e *CreateExtensionImageUploadInfoErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateExtensionImageUploadInfoErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateExtensionImageUploadInfoErrorCode", str)
	}
	return nil
}

func (e CreateExtensionImageUploadInfoErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CreateExtensionZipUploadInfoError is an error associated with the createExtensionZipUploadInfo mutation.
type CreateExtensionZipUploadInfoError string

const (
	// User is unable to make modifications to the extension.
	CreateExtensionZipUploadInfoErrorUnauthorized CreateExtensionZipUploadInfoError = "UNAUTHORIZED"
	// Version specified is invalid.
	CreateExtensionZipUploadInfoErrorInvalidVersion CreateExtensionZipUploadInfoError = "INVALID_VERSION"
)

var AllCreateExtensionZipUploadInfoError = []CreateExtensionZipUploadInfoError{
	CreateExtensionZipUploadInfoErrorUnauthorized,
	CreateExtensionZipUploadInfoErrorInvalidVersion,
}

func (e CreateExtensionZipUploadInfoError) IsValid() bool {
	switch e {
	case CreateExtensionZipUploadInfoErrorUnauthorized, CreateExtensionZipUploadInfoErrorInvalidVersion:
		return true
	}
	return false
}

func (e CreateExtensionZipUploadInfoError) String() string {
	return string(e)
}

func (e *CreateExtensionZipUploadInfoError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateExtensionZipUploadInfoError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateExtensionZipUploadInfoError", str)
	}
	return nil
}

func (e CreateExtensionZipUploadInfoError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Client error code.
type CreateGameApplicationErrorCode string

const (
	// The game has already been owned by another company.
	CreateGameApplicationErrorCodeGameHasAlreadyBeenOwned CreateGameApplicationErrorCode = "GAME_HAS_ALREADY_BEEN_OWNED"
	// Sumbitting user does not have authorization to create a game application for the organization.
	CreateGameApplicationErrorCodePermissionDenied CreateGameApplicationErrorCode = "PERMISSION_DENIED"
	// Internal error.
	CreateGameApplicationErrorCodeInternalError CreateGameApplicationErrorCode = "INTERNAL_ERROR"
)

var AllCreateGameApplicationErrorCode = []CreateGameApplicationErrorCode{
	CreateGameApplicationErrorCodeGameHasAlreadyBeenOwned,
	CreateGameApplicationErrorCodePermissionDenied,
	CreateGameApplicationErrorCodeInternalError,
}

func (e CreateGameApplicationErrorCode) IsValid() bool {
	switch e {
	case CreateGameApplicationErrorCodeGameHasAlreadyBeenOwned, CreateGameApplicationErrorCodePermissionDenied, CreateGameApplicationErrorCodeInternalError:
		return true
	}
	return false
}

func (e CreateGameApplicationErrorCode) String() string {
	return string(e)
}

func (e *CreateGameApplicationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateGameApplicationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateGameApplicationErrorCode", str)
	}
	return nil
}

func (e CreateGameApplicationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A code indicating why the create call failed, if it did.
type CreateLoyaltyBadgeResponseCode string

const (
	// Only eligible users can create a badge.
	CreateLoyaltyBadgeResponseCodeErrInvalidUser CreateLoyaltyBadgeResponseCode = "ERR_INVALID_USER"
	// The badge image 1x submitted was not valid.
	CreateLoyaltyBadgeResponseCodeErrInvalidBadgeImage1xID CreateLoyaltyBadgeResponseCode = "ERR_INVALID_BADGE_IMAGE_1X_ID"
	// The badge image 2x submitted was not valid.
	CreateLoyaltyBadgeResponseCodeErrInvalidBadgeImage2xID CreateLoyaltyBadgeResponseCode = "ERR_INVALID_BADGE_IMAGE_2X_ID"
	// The badge image 4x submitted was not valid.
	CreateLoyaltyBadgeResponseCodeErrInvalidBadgeImage4xID CreateLoyaltyBadgeResponseCode = "ERR_INVALID_BADGE_IMAGE_4X_ID"
	// The badge tenure submitted was not valid.
	CreateLoyaltyBadgeResponseCodeErrInvalidBadgeRequiredTenureMonths CreateLoyaltyBadgeResponseCode = "ERR_INVALID_BADGE_REQUIRED_TENURE_MONTHS"
	// Badge already exists for this tenure.
	CreateLoyaltyBadgeResponseCodeErrBadgeExists CreateLoyaltyBadgeResponseCode = "ERR_BADGE_EXISTS"
	// User is timed out of badge creation.
	CreateLoyaltyBadgeResponseCodeErrBadgeTimeout CreateLoyaltyBadgeResponseCode = "ERR_BADGE_TIMEOUT"
	// Unknown error occurred, most likely a server error.
	CreateLoyaltyBadgeResponseCodeErrUnknown CreateLoyaltyBadgeResponseCode = "ERR_UNKNOWN"
)

var AllCreateLoyaltyBadgeResponseCode = []CreateLoyaltyBadgeResponseCode{
	CreateLoyaltyBadgeResponseCodeErrInvalidUser,
	CreateLoyaltyBadgeResponseCodeErrInvalidBadgeImage1xID,
	CreateLoyaltyBadgeResponseCodeErrInvalidBadgeImage2xID,
	CreateLoyaltyBadgeResponseCodeErrInvalidBadgeImage4xID,
	CreateLoyaltyBadgeResponseCodeErrInvalidBadgeRequiredTenureMonths,
	CreateLoyaltyBadgeResponseCodeErrBadgeExists,
	CreateLoyaltyBadgeResponseCodeErrBadgeTimeout,
	CreateLoyaltyBadgeResponseCodeErrUnknown,
}

func (e CreateLoyaltyBadgeResponseCode) IsValid() bool {
	switch e {
	case CreateLoyaltyBadgeResponseCodeErrInvalidUser, CreateLoyaltyBadgeResponseCodeErrInvalidBadgeImage1xID, CreateLoyaltyBadgeResponseCodeErrInvalidBadgeImage2xID, CreateLoyaltyBadgeResponseCodeErrInvalidBadgeImage4xID, CreateLoyaltyBadgeResponseCodeErrInvalidBadgeRequiredTenureMonths, CreateLoyaltyBadgeResponseCodeErrBadgeExists, CreateLoyaltyBadgeResponseCodeErrBadgeTimeout, CreateLoyaltyBadgeResponseCodeErrUnknown:
		return true
	}
	return false
}

func (e CreateLoyaltyBadgeResponseCode) String() string {
	return string(e)
}

func (e *CreateLoyaltyBadgeResponseCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateLoyaltyBadgeResponseCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateLoyaltyBadgeResponseCode", str)
	}
	return nil
}

func (e CreateLoyaltyBadgeResponseCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A code indicating why the config call failed, if it did.
type CreateLoyaltyBadgeUploadConfigResponseCode string

const (
	// Only eligible users can create a badge upload config.
	CreateLoyaltyBadgeUploadConfigResponseCodeErrInvalidUser CreateLoyaltyBadgeUploadConfigResponseCode = "ERR_INVALID_USER"
	// The badge submitted was not valid.
	CreateLoyaltyBadgeUploadConfigResponseCodeErrInvalidBadgeSize CreateLoyaltyBadgeUploadConfigResponseCode = "ERR_INVALID_BADGE_SIZE"
	// Unknown error occurred, most likely a server error.
	CreateLoyaltyBadgeUploadConfigResponseCodeErrUnknown CreateLoyaltyBadgeUploadConfigResponseCode = "ERR_UNKNOWN"
)

var AllCreateLoyaltyBadgeUploadConfigResponseCode = []CreateLoyaltyBadgeUploadConfigResponseCode{
	CreateLoyaltyBadgeUploadConfigResponseCodeErrInvalidUser,
	CreateLoyaltyBadgeUploadConfigResponseCodeErrInvalidBadgeSize,
	CreateLoyaltyBadgeUploadConfigResponseCodeErrUnknown,
}

func (e CreateLoyaltyBadgeUploadConfigResponseCode) IsValid() bool {
	switch e {
	case CreateLoyaltyBadgeUploadConfigResponseCodeErrInvalidUser, CreateLoyaltyBadgeUploadConfigResponseCodeErrInvalidBadgeSize, CreateLoyaltyBadgeUploadConfigResponseCodeErrUnknown:
		return true
	}
	return false
}

func (e CreateLoyaltyBadgeUploadConfigResponseCode) String() string {
	return string(e)
}

func (e *CreateLoyaltyBadgeUploadConfigResponseCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateLoyaltyBadgeUploadConfigResponseCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateLoyaltyBadgeUploadConfigResponseCode", str)
	}
	return nil
}

func (e CreateLoyaltyBadgeUploadConfigResponseCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Client error code.
type CreateOrganizationApplicationErrorCode string

const (
	// Internal error.
	CreateOrganizationApplicationErrorCodeInternalError CreateOrganizationApplicationErrorCode = "INTERNAL_ERROR"
	// Invalid Argument.
	CreateOrganizationApplicationErrorCodeInvalidArgument CreateOrganizationApplicationErrorCode = "INVALID_ARGUMENT"
)

var AllCreateOrganizationApplicationErrorCode = []CreateOrganizationApplicationErrorCode{
	CreateOrganizationApplicationErrorCodeInternalError,
	CreateOrganizationApplicationErrorCodeInvalidArgument,
}

func (e CreateOrganizationApplicationErrorCode) IsValid() bool {
	switch e {
	case CreateOrganizationApplicationErrorCodeInternalError, CreateOrganizationApplicationErrorCodeInvalidArgument:
		return true
	}
	return false
}

func (e CreateOrganizationApplicationErrorCode) String() string {
	return string(e)
}

func (e *CreateOrganizationApplicationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateOrganizationApplicationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateOrganizationApplicationErrorCode", str)
	}
	return nil
}

func (e CreateOrganizationApplicationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CreateOrganizationInviteErrorCode defines a client error that occurred while creating an organization Invite.
type CreateOrganizationInviteErrorCode string

const (
	// Internal error.
	CreateOrganizationInviteErrorCodeInternalError CreateOrganizationInviteErrorCode = "INTERNAL_ERROR"
	// Invalid Argument.
	CreateOrganizationInviteErrorCodeInvalidArgument CreateOrganizationInviteErrorCode = "INVALID_ARGUMENT"
	// Organization Invite already exists.
	CreateOrganizationInviteErrorCodeAlreadyExists CreateOrganizationInviteErrorCode = "ALREADY_EXISTS"
	// User does not have permission to perform action.
	CreateOrganizationInviteErrorCodePermissionDenied CreateOrganizationInviteErrorCode = "PERMISSION_DENIED"
	// The user does not exist.
	CreateOrganizationInviteErrorCodeUserNotFound CreateOrganizationInviteErrorCode = "USER_NOT_FOUND"
	// The user doesn't meet the requirements to have this role. For example, when trying to assign the
	// "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
	CreateOrganizationInviteErrorCodeMemberIneligible CreateOrganizationInviteErrorCode = "MEMBER_INELIGIBLE"
)

var AllCreateOrganizationInviteErrorCode = []CreateOrganizationInviteErrorCode{
	CreateOrganizationInviteErrorCodeInternalError,
	CreateOrganizationInviteErrorCodeInvalidArgument,
	CreateOrganizationInviteErrorCodeAlreadyExists,
	CreateOrganizationInviteErrorCodePermissionDenied,
	CreateOrganizationInviteErrorCodeUserNotFound,
	CreateOrganizationInviteErrorCodeMemberIneligible,
}

func (e CreateOrganizationInviteErrorCode) IsValid() bool {
	switch e {
	case CreateOrganizationInviteErrorCodeInternalError, CreateOrganizationInviteErrorCodeInvalidArgument, CreateOrganizationInviteErrorCodeAlreadyExists, CreateOrganizationInviteErrorCodePermissionDenied, CreateOrganizationInviteErrorCodeUserNotFound, CreateOrganizationInviteErrorCodeMemberIneligible:
		return true
	}
	return false
}

func (e CreateOrganizationInviteErrorCode) String() string {
	return string(e)
}

func (e *CreateOrganizationInviteErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateOrganizationInviteErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateOrganizationInviteErrorCode", str)
	}
	return nil
}

func (e CreateOrganizationInviteErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CreateOrganizationJWTErrorCode defines a client error that occurred while creating Organization JWT.
type CreateOrganizationJWTErrorCode string

const (
	// User does not have permission to create the JWT for this operation and company.
	CreateOrganizationJWTErrorCodePermissionDenied CreateOrganizationJWTErrorCode = "PERMISSION_DENIED"
	// The operation passed in was invalid.
	CreateOrganizationJWTErrorCodeInvalidArgument CreateOrganizationJWTErrorCode = "INVALID_ARGUMENT"
)

var AllCreateOrganizationJWTErrorCode = []CreateOrganizationJWTErrorCode{
	CreateOrganizationJWTErrorCodePermissionDenied,
	CreateOrganizationJWTErrorCodeInvalidArgument,
}

func (e CreateOrganizationJWTErrorCode) IsValid() bool {
	switch e {
	case CreateOrganizationJWTErrorCodePermissionDenied, CreateOrganizationJWTErrorCodeInvalidArgument:
		return true
	}
	return false
}

func (e CreateOrganizationJWTErrorCode) String() string {
	return string(e)
}

func (e *CreateOrganizationJWTErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateOrganizationJWTErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateOrganizationJWTErrorCode", str)
	}
	return nil
}

func (e CreateOrganizationJWTErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CreateOrganizationMemberErrorCode defines a client error that occurred while creating an organization member.
type CreateOrganizationMemberErrorCode string

const (
	// Organization Member already exists.
	CreateOrganizationMemberErrorCodeAlreadyExists CreateOrganizationMemberErrorCode = "ALREADY_EXISTS"
	// User does not have permission to perform action.
	CreateOrganizationMemberErrorCodePermissionDenied CreateOrganizationMemberErrorCode = "PERMISSION_DENIED"
	// The user does not exist.
	CreateOrganizationMemberErrorCodeUserNotFound CreateOrganizationMemberErrorCode = "USER_NOT_FOUND"
	// The user doesn't meet the requirements to have this role. For example, when trying to assign the
	// "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
	CreateOrganizationMemberErrorCodeMemberIneligible CreateOrganizationMemberErrorCode = "MEMBER_INELIGIBLE"
)

var AllCreateOrganizationMemberErrorCode = []CreateOrganizationMemberErrorCode{
	CreateOrganizationMemberErrorCodeAlreadyExists,
	CreateOrganizationMemberErrorCodePermissionDenied,
	CreateOrganizationMemberErrorCodeUserNotFound,
	CreateOrganizationMemberErrorCodeMemberIneligible,
}

func (e CreateOrganizationMemberErrorCode) IsValid() bool {
	switch e {
	case CreateOrganizationMemberErrorCodeAlreadyExists, CreateOrganizationMemberErrorCodePermissionDenied, CreateOrganizationMemberErrorCodeUserNotFound, CreateOrganizationMemberErrorCodeMemberIneligible:
		return true
	}
	return false
}

func (e CreateOrganizationMemberErrorCode) String() string {
	return string(e)
}

func (e *CreateOrganizationMemberErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateOrganizationMemberErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateOrganizationMemberErrorCode", str)
	}
	return nil
}

func (e CreateOrganizationMemberErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Vote in poll error code.
type CreatePollErrorCode string

const (
	// User attempted to create poll with restricted content.
	CreatePollErrorCodeAutomodFailed CreatePollErrorCode = "AUTOMOD_FAILED"
	// User attempted to create poll when a poll was already active.
	CreatePollErrorCodePollAlreadyActive CreatePollErrorCode = "POLL_ALREADY_ACTIVE"
	// User attempted to create poll with bits on a channel where bits are not enabled.
	CreatePollErrorCodeChannelNotBitsEnabled CreatePollErrorCode = "CHANNEL_NOT_BITS_ENABLED"
	// An unknown error occurred.
	CreatePollErrorCodeUnknown CreatePollErrorCode = "UNKNOWN"
)

var AllCreatePollErrorCode = []CreatePollErrorCode{
	CreatePollErrorCodeAutomodFailed,
	CreatePollErrorCodePollAlreadyActive,
	CreatePollErrorCodeChannelNotBitsEnabled,
	CreatePollErrorCodeUnknown,
}

func (e CreatePollErrorCode) IsValid() bool {
	switch e {
	case CreatePollErrorCodeAutomodFailed, CreatePollErrorCodePollAlreadyActive, CreatePollErrorCodeChannelNotBitsEnabled, CreatePollErrorCodeUnknown:
		return true
	}
	return false
}

func (e CreatePollErrorCode) String() string {
	return string(e)
}

func (e *CreatePollErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreatePollErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreatePollErrorCode", str)
	}
	return nil
}

func (e CreatePollErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes from the createPredictionEvent mutation.
type CreatePredictionEventErrorCode string

const (
	// The current user is forbidden from creating Prediction Events on the specified channel.
	CreatePredictionEventErrorCodeForbidden CreatePredictionEventErrorCode = "FORBIDDEN"
	// User attempted to create a Prediction Event with restricted content.
	CreatePredictionEventErrorCodeAutomodFailed CreatePredictionEventErrorCode = "AUTOMOD_FAILED"
	// There is already an active or pending Prediction Event on the channel. The Event must be resolved before a new
	// Prediction Event can be created.
	CreatePredictionEventErrorCodeEventAlreadyActive CreatePredictionEventErrorCode = "EVENT_ALREADY_ACTIVE"
	// Channel Points are not enabled on this channel.
	CreatePredictionEventErrorCodeChannelPointsNotEnabled CreatePredictionEventErrorCode = "CHANNEL_POINTS_NOT_ENABLED"
	// The colors chosen for each Option must be unique.
	CreatePredictionEventErrorCodeColorsNotUnique CreatePredictionEventErrorCode = "COLORS_NOT_UNIQUE"
	// Events must have at least 2 Outcomes.
	CreatePredictionEventErrorCodeNotEnoughOutcomes CreatePredictionEventErrorCode = "NOT_ENOUGH_OUTCOMES"
	// Events have a maximum number of Outcomes.
	CreatePredictionEventErrorCodeTooManyOutcomes CreatePredictionEventErrorCode = "TOO_MANY_OUTCOMES"
	// The specified Prediction Window is invalid. Prediction window must be positive. Prediction window has a maximum.
	CreatePredictionEventErrorCodeInvalidPredictionWindow CreatePredictionEventErrorCode = "INVALID_PREDICTION_WINDOW"
	// An unknown error occurred.
	CreatePredictionEventErrorCodeUnknown CreatePredictionEventErrorCode = "UNKNOWN"
)

var AllCreatePredictionEventErrorCode = []CreatePredictionEventErrorCode{
	CreatePredictionEventErrorCodeForbidden,
	CreatePredictionEventErrorCodeAutomodFailed,
	CreatePredictionEventErrorCodeEventAlreadyActive,
	CreatePredictionEventErrorCodeChannelPointsNotEnabled,
	CreatePredictionEventErrorCodeColorsNotUnique,
	CreatePredictionEventErrorCodeNotEnoughOutcomes,
	CreatePredictionEventErrorCodeTooManyOutcomes,
	CreatePredictionEventErrorCodeInvalidPredictionWindow,
	CreatePredictionEventErrorCodeUnknown,
}

func (e CreatePredictionEventErrorCode) IsValid() bool {
	switch e {
	case CreatePredictionEventErrorCodeForbidden, CreatePredictionEventErrorCodeAutomodFailed, CreatePredictionEventErrorCodeEventAlreadyActive, CreatePredictionEventErrorCodeChannelPointsNotEnabled, CreatePredictionEventErrorCodeColorsNotUnique, CreatePredictionEventErrorCodeNotEnoughOutcomes, CreatePredictionEventErrorCodeTooManyOutcomes, CreatePredictionEventErrorCodeInvalidPredictionWindow, CreatePredictionEventErrorCodeUnknown:
		return true
	}
	return false
}

func (e CreatePredictionEventErrorCode) String() string {
	return string(e)
}

func (e *CreatePredictionEventErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreatePredictionEventErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreatePredictionEventErrorCode", str)
	}
	return nil
}

func (e CreatePredictionEventErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CreateRaidErrorCode are the possible errors that this mutation returns.
type CreateRaidErrorCode string

const (
	// The user is already raiding another channel.
	CreateRaidErrorCodeAlreadyRaiding CreateRaidErrorCode = "ALREADY_RAIDING"
	// The user tries to raid themselves.
	CreateRaidErrorCodeCannotRaidYourself CreateRaidErrorCode = "CANNOT_RAID_YOURSELF"
	// The user tries to raid an unraidable channel.
	CreateRaidErrorCodeCannotRaidThisChannel CreateRaidErrorCode = "CANNOT_RAID_THIS_CHANNEL"
	// The request is missing valid channel parameters.
	CreateRaidErrorCodeInvalidChannel CreateRaidErrorCode = "INVALID_CHANNEL"
	// The user tries to raid with too many viewers.
	CreateRaidErrorCodeTooManyViewersToRaid CreateRaidErrorCode = "TOO_MANY_VIEWERS_TO_RAID"
)

var AllCreateRaidErrorCode = []CreateRaidErrorCode{
	CreateRaidErrorCodeAlreadyRaiding,
	CreateRaidErrorCodeCannotRaidYourself,
	CreateRaidErrorCodeCannotRaidThisChannel,
	CreateRaidErrorCodeInvalidChannel,
	CreateRaidErrorCodeTooManyViewersToRaid,
}

func (e CreateRaidErrorCode) IsValid() bool {
	switch e {
	case CreateRaidErrorCodeAlreadyRaiding, CreateRaidErrorCodeCannotRaidYourself, CreateRaidErrorCodeCannotRaidThisChannel, CreateRaidErrorCodeInvalidChannel, CreateRaidErrorCodeTooManyViewersToRaid:
		return true
	}
	return false
}

func (e CreateRaidErrorCode) String() string {
	return string(e)
}

func (e *CreateRaidErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateRaidErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateRaidErrorCode", str)
	}
	return nil
}

func (e CreateRaidErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CreateRoomErrorCode string

const (
	// Name too short or too long.
	CreateRoomErrorCodeNameLengthInvalid CreateRoomErrorCode = "NAME_LENGTH_INVALID"
	// Name contains invalid characters (e.g. spaces).
	CreateRoomErrorCodeNameContainsInvalidCharacters CreateRoomErrorCode = "NAME_CONTAINS_INVALID_CHARACTERS"
	// Name failed automod check.
	CreateRoomErrorCodeNameInappropriate CreateRoomErrorCode = "NAME_INAPPROPRIATE"
	// Name was not unique to channel.
	CreateRoomErrorCodeNameNotUnique CreateRoomErrorCode = "NAME_NOT_UNIQUE"
	// Topic too short or too long.
	CreateRoomErrorCodeTopicLengthInvalid CreateRoomErrorCode = "TOPIC_LENGTH_INVALID"
	// Topic failed automod check.
	CreateRoomErrorCodeTopicInappropriate CreateRoomErrorCode = "TOPIC_INAPPROPRIATE"
	// User cannot create any more rooms.
	CreateRoomErrorCodeMaxRoomsLimitExceeded CreateRoomErrorCode = "MAX_ROOMS_LIMIT_EXCEEDED"
	// Invalid roles specified (e.g. a more permissive role for send than read).
	CreateRoomErrorCodeRolesInvalid CreateRoomErrorCode = "ROLES_INVALID"
)

var AllCreateRoomErrorCode = []CreateRoomErrorCode{
	CreateRoomErrorCodeNameLengthInvalid,
	CreateRoomErrorCodeNameContainsInvalidCharacters,
	CreateRoomErrorCodeNameInappropriate,
	CreateRoomErrorCodeNameNotUnique,
	CreateRoomErrorCodeTopicLengthInvalid,
	CreateRoomErrorCodeTopicInappropriate,
	CreateRoomErrorCodeMaxRoomsLimitExceeded,
	CreateRoomErrorCodeRolesInvalid,
}

func (e CreateRoomErrorCode) IsValid() bool {
	switch e {
	case CreateRoomErrorCodeNameLengthInvalid, CreateRoomErrorCodeNameContainsInvalidCharacters, CreateRoomErrorCodeNameInappropriate, CreateRoomErrorCodeNameNotUnique, CreateRoomErrorCodeTopicLengthInvalid, CreateRoomErrorCodeTopicInappropriate, CreateRoomErrorCodeMaxRoomsLimitExceeded, CreateRoomErrorCodeRolesInvalid:
		return true
	}
	return false
}

func (e CreateRoomErrorCode) String() string {
	return string(e)
}

func (e *CreateRoomErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateRoomErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateRoomErrorCode", str)
	}
	return nil
}

func (e CreateRoomErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible errors.
type CreateScheduleError string

const (
	// Channel already has a schedule.
	CreateScheduleErrorAlreadyExists CreateScheduleError = "ALREADY_EXISTS"
	// Cannot create a schedule for this channel.
	CreateScheduleErrorPermissionDenied CreateScheduleError = "PERMISSION_DENIED"
)

var AllCreateScheduleError = []CreateScheduleError{
	CreateScheduleErrorAlreadyExists,
	CreateScheduleErrorPermissionDenied,
}

func (e CreateScheduleError) IsValid() bool {
	switch e {
	case CreateScheduleErrorAlreadyExists, CreateScheduleErrorPermissionDenied:
		return true
	}
	return false
}

func (e CreateScheduleError) String() string {
	return string(e)
}

func (e *CreateScheduleError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateScheduleError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateScheduleError", str)
	}
	return nil
}

func (e CreateScheduleError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible errors when creating a schedule segment.
type CreateScheduleSegmentErrorCode string

const (
	// Not authorized to edit this user schedule.
	CreateScheduleSegmentErrorCodePermissionDenied CreateScheduleSegmentErrorCode = "PERMISSION_DENIED"
	// The schedule to create a segment for was not found.
	CreateScheduleSegmentErrorCodeNotFound CreateScheduleSegmentErrorCode = "NOT_FOUND"
	// The number of categories is invalid. Refer to the error for min and max acceptable values.
	CreateScheduleSegmentErrorCodeInvalidCategoryCount CreateScheduleSegmentErrorCode = "INVALID_CATEGORY_COUNT"
	// The segment time overlaps with another segment time.
	CreateScheduleSegmentErrorCodeOverlappingSegments CreateScheduleSegmentErrorCode = "OVERLAPPING_SEGMENTS"
	// The title length is invalid. Refer to the error for min and max acceptable values.
	CreateScheduleSegmentErrorCodeInvalidTitle CreateScheduleSegmentErrorCode = "INVALID_TITLE"
	// The title failed the moderation check.
	CreateScheduleSegmentErrorCodeTitleFailedModeration CreateScheduleSegmentErrorCode = "TITLE_FAILED_MODERATION"
	// The timezone is not valid.
	CreateScheduleSegmentErrorCodeInvalidTimezone CreateScheduleSegmentErrorCode = "INVALID_TIMEZONE"
	// The category is not valid.
	CreateScheduleSegmentErrorCodeInvalidCategories CreateScheduleSegmentErrorCode = "INVALID_CATEGORIES"
	// The the start day is not valid.
	CreateScheduleSegmentErrorCodeInvalidStartDay CreateScheduleSegmentErrorCode = "INVALID_START_DAY"
	// The start hour is not valid.
	CreateScheduleSegmentErrorCodeInvalidStartHour CreateScheduleSegmentErrorCode = "INVALID_START_HOUR"
	// The start minute is not valid.
	CreateScheduleSegmentErrorCodeInvalidStartMinute CreateScheduleSegmentErrorCode = "INVALID_START_MINUTE"
	// The duration is invalid. Refer to the error for min and max acceptable values.
	CreateScheduleSegmentErrorCodeInvalidDuration CreateScheduleSegmentErrorCode = "INVALID_DURATION"
	// The segment is invalid.
	CreateScheduleSegmentErrorCodeInvalidSegment CreateScheduleSegmentErrorCode = "INVALID_SEGMENT"
	// The input is not valid.
	CreateScheduleSegmentErrorCodeInvalidArgument CreateScheduleSegmentErrorCode = "INVALID_ARGUMENT"
	// The number of segments is invalid. Refer to the error for min and max acceptable values.
	CreateScheduleSegmentErrorCodeInvalidSegmentCount CreateScheduleSegmentErrorCode = "INVALID_SEGMENT_COUNT"
)

var AllCreateScheduleSegmentErrorCode = []CreateScheduleSegmentErrorCode{
	CreateScheduleSegmentErrorCodePermissionDenied,
	CreateScheduleSegmentErrorCodeNotFound,
	CreateScheduleSegmentErrorCodeInvalidCategoryCount,
	CreateScheduleSegmentErrorCodeOverlappingSegments,
	CreateScheduleSegmentErrorCodeInvalidTitle,
	CreateScheduleSegmentErrorCodeTitleFailedModeration,
	CreateScheduleSegmentErrorCodeInvalidTimezone,
	CreateScheduleSegmentErrorCodeInvalidCategories,
	CreateScheduleSegmentErrorCodeInvalidStartDay,
	CreateScheduleSegmentErrorCodeInvalidStartHour,
	CreateScheduleSegmentErrorCodeInvalidStartMinute,
	CreateScheduleSegmentErrorCodeInvalidDuration,
	CreateScheduleSegmentErrorCodeInvalidSegment,
	CreateScheduleSegmentErrorCodeInvalidArgument,
	CreateScheduleSegmentErrorCodeInvalidSegmentCount,
}

func (e CreateScheduleSegmentErrorCode) IsValid() bool {
	switch e {
	case CreateScheduleSegmentErrorCodePermissionDenied, CreateScheduleSegmentErrorCodeNotFound, CreateScheduleSegmentErrorCodeInvalidCategoryCount, CreateScheduleSegmentErrorCodeOverlappingSegments, CreateScheduleSegmentErrorCodeInvalidTitle, CreateScheduleSegmentErrorCodeTitleFailedModeration, CreateScheduleSegmentErrorCodeInvalidTimezone, CreateScheduleSegmentErrorCodeInvalidCategories, CreateScheduleSegmentErrorCodeInvalidStartDay, CreateScheduleSegmentErrorCodeInvalidStartHour, CreateScheduleSegmentErrorCodeInvalidStartMinute, CreateScheduleSegmentErrorCodeInvalidDuration, CreateScheduleSegmentErrorCodeInvalidSegment, CreateScheduleSegmentErrorCodeInvalidArgument, CreateScheduleSegmentErrorCodeInvalidSegmentCount:
		return true
	}
	return false
}

func (e CreateScheduleSegmentErrorCode) String() string {
	return string(e)
}

func (e *CreateScheduleSegmentErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateScheduleSegmentErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateScheduleSegmentErrorCode", str)
	}
	return nil
}

func (e CreateScheduleSegmentErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CreateSocialMediaError is a user error while creating a social media.
type CreateSocialMediaError string

const (
	// The title failed moderation.
	CreateSocialMediaErrorFailedTitleModeration CreateSocialMediaError = "FAILED_TITLE_MODERATION"
	// The provided title was too long.
	CreateSocialMediaErrorTitleTooLong CreateSocialMediaError = "TITLE_TOO_LONG"
	// The provided url is invalid.
	CreateSocialMediaErrorInvalidURL CreateSocialMediaError = "INVALID_URL"
	// Maximun number of social medias reached.
	CreateSocialMediaErrorTooMany CreateSocialMediaError = "TOO_MANY"
)

var AllCreateSocialMediaError = []CreateSocialMediaError{
	CreateSocialMediaErrorFailedTitleModeration,
	CreateSocialMediaErrorTitleTooLong,
	CreateSocialMediaErrorInvalidURL,
	CreateSocialMediaErrorTooMany,
}

func (e CreateSocialMediaError) IsValid() bool {
	switch e {
	case CreateSocialMediaErrorFailedTitleModeration, CreateSocialMediaErrorTitleTooLong, CreateSocialMediaErrorInvalidURL, CreateSocialMediaErrorTooMany:
		return true
	}
	return false
}

func (e CreateSocialMediaError) String() string {
	return string(e)
}

func (e *CreateSocialMediaError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateSocialMediaError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateSocialMediaError", str)
	}
	return nil
}

func (e CreateSocialMediaError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CreateSquadStreamInvitationErrorCode are the possible errors that this mutation returns.
type CreateSquadStreamInvitationErrorCode string

const (
	// The squad is already full.
	CreateSquadStreamInvitationErrorCodeSquadFull CreateSquadStreamInvitationErrorCode = "SQUAD_FULL"
	// The recipient does not have access to squad streams.
	CreateSquadStreamInvitationErrorCodeUserCannotAccessSquads CreateSquadStreamInvitationErrorCode = "USER_CANNOT_ACCESS_SQUADS"
	// The recipient is already in the squad.
	CreateSquadStreamInvitationErrorCodeUserAlreadyInSquad CreateSquadStreamInvitationErrorCode = "USER_ALREADY_IN_SQUAD"
	// The recipient is already invited to the squad.
	CreateSquadStreamInvitationErrorCodeInvitationAlreadyExists CreateSquadStreamInvitationErrorCode = "INVITATION_ALREADY_EXISTS"
	// The sender does not have permission to invite the recipient.
	CreateSquadStreamInvitationErrorCodeInvitationBlocked CreateSquadStreamInvitationErrorCode = "INVITATION_BLOCKED"
	// The invitation is not valid (e.g. the user is inviting themselves).
	CreateSquadStreamInvitationErrorCodeInvitationInvalid CreateSquadStreamInvitationErrorCode = "INVITATION_INVALID"
	// The user is not authorized to invite members to the squad.
	CreateSquadStreamInvitationErrorCodeUnauthorized CreateSquadStreamInvitationErrorCode = "UNAUTHORIZED"
)

var AllCreateSquadStreamInvitationErrorCode = []CreateSquadStreamInvitationErrorCode{
	CreateSquadStreamInvitationErrorCodeSquadFull,
	CreateSquadStreamInvitationErrorCodeUserCannotAccessSquads,
	CreateSquadStreamInvitationErrorCodeUserAlreadyInSquad,
	CreateSquadStreamInvitationErrorCodeInvitationAlreadyExists,
	CreateSquadStreamInvitationErrorCodeInvitationBlocked,
	CreateSquadStreamInvitationErrorCodeInvitationInvalid,
	CreateSquadStreamInvitationErrorCodeUnauthorized,
}

func (e CreateSquadStreamInvitationErrorCode) IsValid() bool {
	switch e {
	case CreateSquadStreamInvitationErrorCodeSquadFull, CreateSquadStreamInvitationErrorCodeUserCannotAccessSquads, CreateSquadStreamInvitationErrorCodeUserAlreadyInSquad, CreateSquadStreamInvitationErrorCodeInvitationAlreadyExists, CreateSquadStreamInvitationErrorCodeInvitationBlocked, CreateSquadStreamInvitationErrorCodeInvitationInvalid, CreateSquadStreamInvitationErrorCodeUnauthorized:
		return true
	}
	return false
}

func (e CreateSquadStreamInvitationErrorCode) String() string {
	return string(e)
}

func (e *CreateSquadStreamInvitationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateSquadStreamInvitationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateSquadStreamInvitationErrorCode", str)
	}
	return nil
}

func (e CreateSquadStreamInvitationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error codes from create unban request mutation.
type CreateUnbanRequestErrorCode string

const (
	// User already has a request for the current ban.
	CreateUnbanRequestErrorCodeAlreadyCreated CreateUnbanRequestErrorCode = "ALREADY_CREATED"
	// User is not banned in the channel.
	CreateUnbanRequestErrorCodeNotBanned CreateUnbanRequestErrorCode = "NOT_BANNED"
	// User is attempting to create a request too since their ban. Must wait for cooldown period to end.
	CreateUnbanRequestErrorCodeTooSoonSinceBan CreateUnbanRequestErrorCode = "TOO_SOON_SINCE_BAN"
	// Channel is not receiving unban requests.
	CreateUnbanRequestErrorCodeUnbanRequestsDisabled CreateUnbanRequestErrorCode = "UNBAN_REQUESTS_DISABLED"
	// Unknown error.
	CreateUnbanRequestErrorCodeUnknown CreateUnbanRequestErrorCode = "UNKNOWN"
)

var AllCreateUnbanRequestErrorCode = []CreateUnbanRequestErrorCode{
	CreateUnbanRequestErrorCodeAlreadyCreated,
	CreateUnbanRequestErrorCodeNotBanned,
	CreateUnbanRequestErrorCodeTooSoonSinceBan,
	CreateUnbanRequestErrorCodeUnbanRequestsDisabled,
	CreateUnbanRequestErrorCodeUnknown,
}

func (e CreateUnbanRequestErrorCode) IsValid() bool {
	switch e {
	case CreateUnbanRequestErrorCodeAlreadyCreated, CreateUnbanRequestErrorCodeNotBanned, CreateUnbanRequestErrorCodeTooSoonSinceBan, CreateUnbanRequestErrorCodeUnbanRequestsDisabled, CreateUnbanRequestErrorCodeUnknown:
		return true
	}
	return false
}

func (e CreateUnbanRequestErrorCode) String() string {
	return string(e)
}

func (e *CreateUnbanRequestErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateUnbanRequestErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateUnbanRequestErrorCode", str)
	}
	return nil
}

func (e CreateUnbanRequestErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// CreateVideoBookmarkErrorCode are the possible errors that this mutation returns.
type CreateVideoBookmarkErrorCode string

const (
	// The broadcaster is not live.
	CreateVideoBookmarkErrorCodeBroadcasterNotLive CreateVideoBookmarkErrorCode = "BROADCASTER_NOT_LIVE"
	// Archives are disabled for the channel.
	CreateVideoBookmarkErrorCodeArchivesDisabled CreateVideoBookmarkErrorCode = "ARCHIVES_DISABLED"
	// The rerun broadcast format is unsupported..
	CreateVideoBookmarkErrorCodeBroadcastFormatInvalidRerun CreateVideoBookmarkErrorCode = "BROADCAST_FORMAT_INVALID_RERUN"
	// The premiere broadcast format is unsupported.
	CreateVideoBookmarkErrorCodeBroadcastFormatInvalidPremiere CreateVideoBookmarkErrorCode = "BROADCAST_FORMAT_INVALID_PREMIERE"
	// The VOD for the associated broadcast is not yet ready.
	CreateVideoBookmarkErrorCodeVodNotReady CreateVideoBookmarkErrorCode = "VOD_NOT_READY"
	// An unexpected internal server error occurred.
	CreateVideoBookmarkErrorCodeInternalServerError CreateVideoBookmarkErrorCode = "INTERNAL_SERVER_ERROR"
	// The user is unauthorized to create the bookmark.
	CreateVideoBookmarkErrorCodeUserUnauthorized CreateVideoBookmarkErrorCode = "USER_UNAUTHORIZED"
	// The description length has exceeded the max length.
	CreateVideoBookmarkErrorCodeMaxDescriptionLengthExceeded CreateVideoBookmarkErrorCode = "MAX_DESCRIPTION_LENGTH_EXCEEDED"
)

var AllCreateVideoBookmarkErrorCode = []CreateVideoBookmarkErrorCode{
	CreateVideoBookmarkErrorCodeBroadcasterNotLive,
	CreateVideoBookmarkErrorCodeArchivesDisabled,
	CreateVideoBookmarkErrorCodeBroadcastFormatInvalidRerun,
	CreateVideoBookmarkErrorCodeBroadcastFormatInvalidPremiere,
	CreateVideoBookmarkErrorCodeVodNotReady,
	CreateVideoBookmarkErrorCodeInternalServerError,
	CreateVideoBookmarkErrorCodeUserUnauthorized,
	CreateVideoBookmarkErrorCodeMaxDescriptionLengthExceeded,
}

func (e CreateVideoBookmarkErrorCode) IsValid() bool {
	switch e {
	case CreateVideoBookmarkErrorCodeBroadcasterNotLive, CreateVideoBookmarkErrorCodeArchivesDisabled, CreateVideoBookmarkErrorCodeBroadcastFormatInvalidRerun, CreateVideoBookmarkErrorCodeBroadcastFormatInvalidPremiere, CreateVideoBookmarkErrorCodeVodNotReady, CreateVideoBookmarkErrorCodeInternalServerError, CreateVideoBookmarkErrorCodeUserUnauthorized, CreateVideoBookmarkErrorCodeMaxDescriptionLengthExceeded:
		return true
	}
	return false
}

func (e CreateVideoBookmarkErrorCode) String() string {
	return string(e)
}

func (e *CreateVideoBookmarkErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateVideoBookmarkErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateVideoBookmarkErrorCode", str)
	}
	return nil
}

func (e CreateVideoBookmarkErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Setting for a user's channel that indicates what type of badge flair, if any,
// is available for eligible subscribers to select.
type CreatorBadgeFlairSetting string

const (
	// Indicates no badge flair is available.
	CreatorBadgeFlairSettingNone CreatorBadgeFlairSetting = "NONE"
	// Indicates badge flair using the default Twitch-provided flair asset is available.
	CreatorBadgeFlairSettingDefault CreatorBadgeFlairSetting = "DEFAULT"
	// Indicates badge flair using a custom user-provided flair asset is available.
	CreatorBadgeFlairSettingCustom CreatorBadgeFlairSetting = "CUSTOM"
)

var AllCreatorBadgeFlairSetting = []CreatorBadgeFlairSetting{
	CreatorBadgeFlairSettingNone,
	CreatorBadgeFlairSettingDefault,
	CreatorBadgeFlairSettingCustom,
}

func (e CreatorBadgeFlairSetting) IsValid() bool {
	switch e {
	case CreatorBadgeFlairSettingNone, CreatorBadgeFlairSettingDefault, CreatorBadgeFlairSettingCustom:
		return true
	}
	return false
}

func (e CreatorBadgeFlairSetting) String() string {
	return string(e)
}

func (e *CreatorBadgeFlairSetting) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreatorBadgeFlairSetting(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreatorBadgeFlairSetting", str)
	}
	return nil
}

func (e CreatorBadgeFlairSetting) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid subscription tiers that custom badge flair can be associated to.
type CreatorBadgeFlairTier string

const (
	// Tier 2 subscriptions (sometimes represented with string "2000")
	CreatorBadgeFlairTierTier2 CreatorBadgeFlairTier = "TIER_2"
	// Tier 3 subscriptions (sometimes represented with string "3000")
	CreatorBadgeFlairTierTier3 CreatorBadgeFlairTier = "TIER_3"
)

var AllCreatorBadgeFlairTier = []CreatorBadgeFlairTier{
	CreatorBadgeFlairTierTier2,
	CreatorBadgeFlairTierTier3,
}

func (e CreatorBadgeFlairTier) IsValid() bool {
	switch e {
	case CreatorBadgeFlairTierTier2, CreatorBadgeFlairTierTier3:
		return true
	}
	return false
}

func (e CreatorBadgeFlairTier) String() string {
	return string(e)
}

func (e *CreatorBadgeFlairTier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreatorBadgeFlairTier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreatorBadgeFlairTier", str)
	}
	return nil
}

func (e CreatorBadgeFlairTier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Specifies the general trend of this data set vs the previous data set.
type CreatorReferralTrend string

const (
	// The new data set has increased relative to the previous data set.
	CreatorReferralTrendPositive CreatorReferralTrend = "POSITIVE"
	// The new data set has not changed relative to the previous data set.
	CreatorReferralTrendNeutral CreatorReferralTrend = "NEUTRAL"
	// The new data set has decreased relative to the previous data set.
	CreatorReferralTrendNegative CreatorReferralTrend = "NEGATIVE"
)

var AllCreatorReferralTrend = []CreatorReferralTrend{
	CreatorReferralTrendPositive,
	CreatorReferralTrendNeutral,
	CreatorReferralTrendNegative,
}

func (e CreatorReferralTrend) IsValid() bool {
	switch e {
	case CreatorReferralTrendPositive, CreatorReferralTrendNeutral, CreatorReferralTrendNegative:
		return true
	}
	return false
}

func (e CreatorReferralTrend) String() string {
	return string(e)
}

func (e *CreatorReferralTrend) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreatorReferralTrend(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreatorReferralTrend", str)
	}
	return nil
}

func (e CreatorReferralTrend) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of non-fiat currencies.
type CreditType string

const (
	// Indicates that there is no specific type of Credit in this model.
	CreditTypeNoCreditType CreditType = "NO_CREDIT_TYPE"
	// A sub token type.
	CreditTypeSubToken CreditType = "SUB_TOKEN"
)

var AllCreditType = []CreditType{
	CreditTypeNoCreditType,
	CreditTypeSubToken,
}

func (e CreditType) IsValid() bool {
	switch e {
	case CreditTypeNoCreditType, CreditTypeSubToken:
		return true
	}
	return false
}

func (e CreditType) String() string {
	return string(e)
}

func (e *CreditType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreditType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreditType", str)
	}
	return nil
}

func (e CreditType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of ISO 4217 currencies accepted by the API.
type Currency string

const (
	// Afghani currency.
	CurrencyAfn Currency = "AFN"
	// Euro currency.
	CurrencyEur Currency = "EUR"
	// Lek currency.
	CurrencyAll Currency = "ALL"
	// Algerian Dinar currency.
	CurrencyDzd Currency = "DZD"
	// US Dollar currency.
	CurrencyUsd Currency = "USD"
	// Kwanza currency.
	CurrencyAoa Currency = "AOA"
	// East Caribbean Dollar currency.
	CurrencyXcd Currency = "XCD"
	// Argentine Peso currency.
	CurrencyArs Currency = "ARS"
	// Armenian Dram currency.
	CurrencyAmd Currency = "AMD"
	// Aruban Florin currency.
	CurrencyAwg Currency = "AWG"
	// Australian Dollar currency.
	CurrencyAud Currency = "AUD"
	// Azerbaijan Manat currency.
	CurrencyAzn Currency = "AZN"
	// Bahamian Dollar currency.
	CurrencyBsd Currency = "BSD"
	// Bahraini Dinar currency.
	CurrencyBhd Currency = "BHD"
	// Taka currency.
	CurrencyBdt Currency = "BDT"
	// Barbados Dollar currency.
	CurrencyBbd Currency = "BBD"
	// Belarusian Ruble currency.
	CurrencyByn Currency = "BYN"
	// Belize Dollar currency.
	CurrencyBzd Currency = "BZD"
	// CFA Franc BCEAO currency.
	CurrencyXof Currency = "XOF"
	// Bermudian Dollar currency.
	CurrencyBmd Currency = "BMD"
	// Indian Rupee currency.
	CurrencyInr Currency = "INR"
	// Ngultrum currency.
	CurrencyBtn Currency = "BTN"
	// Boliviano currency.
	CurrencyBob Currency = "BOB"
	// Mvdol currency.
	CurrencyBov Currency = "BOV"
	// Convertible Mark currency.
	CurrencyBam Currency = "BAM"
	// Pula currency.
	CurrencyBwp Currency = "BWP"
	// Norwegian Krone currency.
	CurrencyNok Currency = "NOK"
	// Brazilian Real currency.
	CurrencyBrl Currency = "BRL"
	// Brunei Dollar currency.
	CurrencyBnd Currency = "BND"
	// Bulgarian Lev currency.
	CurrencyBgn Currency = "BGN"
	// Burundi Franc currency.
	CurrencyBif Currency = "BIF"
	// Cabo Verde Escudo currency.
	CurrencyCve Currency = "CVE"
	// Riel currency.
	CurrencyKhr Currency = "KHR"
	// CFA Franc BEAC currency.
	CurrencyXaf Currency = "XAF"
	// Canadian Dollar currency.
	CurrencyCad Currency = "CAD"
	// Cayman Islands Dollar currency.
	CurrencyKyd Currency = "KYD"
	// Chilean Peso currency.
	CurrencyClp Currency = "CLP"
	// Unidad de Fomento currency.
	CurrencyClf Currency = "CLF"
	// Yuan Renminbi currency.
	CurrencyCny Currency = "CNY"
	// Colombian Peso currency.
	CurrencyCop Currency = "COP"
	// Unidad de Valor Real currency.
	CurrencyCou Currency = "COU"
	// Comorian Franc currency.
	CurrencyKmf Currency = "KMF"
	// Congolese Franc currency.
	CurrencyCdf Currency = "CDF"
	// New Zealand Dollar currency.
	CurrencyNzd Currency = "NZD"
	// Costa Rican Colon currency.
	CurrencyCrc Currency = "CRC"
	// Kuna currency.
	CurrencyHrk Currency = "HRK"
	// Cuban Peso currency.
	CurrencyCup Currency = "CUP"
	// Peso Convertible currency.
	CurrencyCuc Currency = "CUC"
	// Netherlands Antillean Guilder currency.
	CurrencyAng Currency = "ANG"
	// Czech Koruna currency.
	CurrencyCzk Currency = "CZK"
	// Danish Krone currency.
	CurrencyDkk Currency = "DKK"
	// Djibouti Franc currency.
	CurrencyDjf Currency = "DJF"
	// Dominican Peso currency.
	CurrencyDop Currency = "DOP"
	// Egyptian Pound currency.
	CurrencyEgp Currency = "EGP"
	// El Salvador Colon currency.
	CurrencySvc Currency = "SVC"
	// Nakfa currency.
	CurrencyErn Currency = "ERN"
	// Ethiopian Birr currency.
	CurrencyEtb Currency = "ETB"
	// Falkland Islands Pound currency.
	CurrencyFkp Currency = "FKP"
	// Fiji Dollar currency.
	CurrencyFjd Currency = "FJD"
	// CFP Franc currency.
	CurrencyXpf Currency = "XPF"
	// Dalasi currency.
	CurrencyGmd Currency = "GMD"
	// Lari currency.
	CurrencyGel Currency = "GEL"
	// Ghana Cedi currency.
	CurrencyGhs Currency = "GHS"
	// Gibraltar Pound currency.
	CurrencyGip Currency = "GIP"
	// Quetzal currency.
	CurrencyGtq Currency = "GTQ"
	// Pound Sterling currency.
	CurrencyGbp Currency = "GBP"
	// Guinean Franc currency.
	CurrencyGnf Currency = "GNF"
	// Guyana Dollar currency.
	CurrencyGyd Currency = "GYD"
	// Gourde currency.
	CurrencyHtg Currency = "HTG"
	// Lempira currency.
	CurrencyHnl Currency = "HNL"
	// Hong Kong Dollar currency.
	CurrencyHkd Currency = "HKD"
	// Forint currency.
	CurrencyHuf Currency = "HUF"
	// Iceland Krona currency.
	CurrencyIsk Currency = "ISK"
	// Rupiah currency.
	CurrencyIDR Currency = "IDR"
	// Iranian Rial currency.
	CurrencyIrr Currency = "IRR"
	// Iraqi Dinar currency.
	CurrencyIqd Currency = "IQD"
	// New Israeli Sheqel currency.
	CurrencyIls Currency = "ILS"
	// Jamaican Dollar currency.
	CurrencyJmd Currency = "JMD"
	// Yen currency.
	CurrencyJpy Currency = "JPY"
	// Jordanian Dinar currency.
	CurrencyJod Currency = "JOD"
	// Tenge currency.
	CurrencyKzt Currency = "KZT"
	// Kenyan Shilling currency.
	CurrencyKes Currency = "KES"
	// Won currency.
	CurrencyKrw Currency = "KRW"
	// Kuwaiti Dinar currency.
	CurrencyKwd Currency = "KWD"
	// Som currency.
	CurrencyKgs Currency = "KGS"
	// Lao Kip currency.
	CurrencyLak Currency = "LAK"
	// Lebanese Pound currency.
	CurrencyLbp Currency = "LBP"
	// Loti currency.
	CurrencyLsl Currency = "LSL"
	// Rand currency.
	CurrencyZar Currency = "ZAR"
	// Liberian Dollar currency.
	CurrencyLrd Currency = "LRD"
	// Libyan Dinar currency.
	CurrencyLyd Currency = "LYD"
	// Swiss Franc currency.
	CurrencyChf Currency = "CHF"
	// Pataca currency.
	CurrencyMop Currency = "MOP"
	// Denar currency.
	CurrencyMkd Currency = "MKD"
	// Malagasy Ariary currency.
	CurrencyMga Currency = "MGA"
	// Malawi Kwacha currency.
	CurrencyMwk Currency = "MWK"
	// Malaysian Ringgit currency.
	CurrencyMyr Currency = "MYR"
	// Rufiyaa currency.
	CurrencyMvr Currency = "MVR"
	// Ouguiya currency.
	CurrencyMru Currency = "MRU"
	// Mauritius Rupee currency.
	CurrencyMur Currency = "MUR"
	// ADB Unit of Account currency.
	CurrencyXua Currency = "XUA"
	// Mexican Peso currency.
	CurrencyMxn Currency = "MXN"
	// Mexican Unidad de Inversion (UDI) currency.
	CurrencyMxv Currency = "MXV"
	// Moldovan Leu currency.
	CurrencyMdl Currency = "MDL"
	// Tugrik currency.
	CurrencyMnt Currency = "MNT"
	// Moroccan Dirham currency.
	CurrencyMad Currency = "MAD"
	// Mozambique Metical currency.
	CurrencyMzn Currency = "MZN"
	// Kyat currency.
	CurrencyMmk Currency = "MMK"
	// Namibia Dollar currency.
	CurrencyNad Currency = "NAD"
	// Nepalese Rupee currency.
	CurrencyNpr Currency = "NPR"
	// Cordoba Oro currency.
	CurrencyNio Currency = "NIO"
	// Naira currency.
	CurrencyNgn Currency = "NGN"
	// Rial Omani currency.
	CurrencyOmr Currency = "OMR"
	// Pakistan Rupee currency.
	CurrencyPkr Currency = "PKR"
	// Balboa currency.
	CurrencyPab Currency = "PAB"
	// Kina currency.
	CurrencyPgk Currency = "PGK"
	// Guarani currency.
	CurrencyPyg Currency = "PYG"
	// Sol currency.
	CurrencyPen Currency = "PEN"
	// Philippine Peso currency.
	CurrencyPhp Currency = "PHP"
	// Zloty currency.
	CurrencyPln Currency = "PLN"
	// Qatari Rial currency.
	CurrencyQar Currency = "QAR"
	// Romanian Leu currency.
	CurrencyRon Currency = "RON"
	// Russian Ruble currency.
	CurrencyRub Currency = "RUB"
	// Rwanda Franc currency.
	CurrencyRwf Currency = "RWF"
	// Saint Helena Pound currency.
	CurrencyShp Currency = "SHP"
	// Tala currency.
	CurrencyWst Currency = "WST"
	// Dobra currency.
	CurrencyStn Currency = "STN"
	// Saudi Riyal currency.
	CurrencySar Currency = "SAR"
	// Serbian Dinar currency.
	CurrencyRsd Currency = "RSD"
	// Seychelles Rupee currency.
	CurrencyScr Currency = "SCR"
	// Leone currency.
	CurrencySll Currency = "SLL"
	// Singapore Dollar currency.
	CurrencySgd Currency = "SGD"
	// Sucre currency.
	CurrencyXsu Currency = "XSU"
	// Solomon Islands Dollar currency.
	CurrencySbd Currency = "SBD"
	// Somali Shilling currency.
	CurrencySos Currency = "SOS"
	// South Sudanese Pound currency.
	CurrencySsp Currency = "SSP"
	// Sri Lanka Rupee currency.
	CurrencyLkr Currency = "LKR"
	// Sudanese Pound currency.
	CurrencySdg Currency = "SDG"
	// Surinam Dollar currency.
	CurrencySrd Currency = "SRD"
	// Lilangeni currency.
	CurrencySzl Currency = "SZL"
	// Swedish Krona currency.
	CurrencySek Currency = "SEK"
	// WIR Euro currency.
	CurrencyChe Currency = "CHE"
	// WIR Franc currency.
	CurrencyChw Currency = "CHW"
	// New Taiwan Dollar currency.
	CurrencyTwd Currency = "TWD"
	// Somoni currency.
	CurrencyTjs Currency = "TJS"
	// Tanzanian Shilling currency.
	CurrencyTzs Currency = "TZS"
	// Baht currency.
	CurrencyThb Currency = "THB"
	// Pa’anga currency.
	CurrencyTop Currency = "TOP"
	// Trinidad and Tobago Dollar currency.
	CurrencyTtd Currency = "TTD"
	// Tunisian Dinar currency.
	CurrencyTnd Currency = "TND"
	// Turkish Lira currency.
	CurrencyTry Currency = "TRY"
	// Turkmenistan New Manat currency.
	CurrencyTmt Currency = "TMT"
	// Uganda Shilling currency.
	CurrencyUgx Currency = "UGX"
	// Hryvnia currency.
	CurrencyUah Currency = "UAH"
	// UAE Dirham currency.
	CurrencyAed Currency = "AED"
	// Peso Uruguayo currency.
	CurrencyUyu Currency = "UYU"
	// Uruguay Peso en Unidades Indexadas (UI) currency.
	CurrencyUyi Currency = "UYI"
	// Unidad Previsional currency.
	CurrencyUyw Currency = "UYW"
	// Uzbekistan Sum currency.
	CurrencyUzs Currency = "UZS"
	// Vatu currency.
	CurrencyVuv Currency = "VUV"
	// Bolívar Soberano currency.
	CurrencyVes Currency = "VES"
	// Dong currency.
	CurrencyVnd Currency = "VND"
	// Yemeni Rial currency.
	CurrencyYer Currency = "YER"
	// Zambian Kwacha currency.
	CurrencyZmw Currency = "ZMW"
	// Zimbabwe Dollar currency.
	CurrencyZwl Currency = "ZWL"
)

var AllCurrency = []Currency{
	CurrencyAfn,
	CurrencyEur,
	CurrencyAll,
	CurrencyDzd,
	CurrencyUsd,
	CurrencyAoa,
	CurrencyXcd,
	CurrencyArs,
	CurrencyAmd,
	CurrencyAwg,
	CurrencyAud,
	CurrencyAzn,
	CurrencyBsd,
	CurrencyBhd,
	CurrencyBdt,
	CurrencyBbd,
	CurrencyByn,
	CurrencyBzd,
	CurrencyXof,
	CurrencyBmd,
	CurrencyInr,
	CurrencyBtn,
	CurrencyBob,
	CurrencyBov,
	CurrencyBam,
	CurrencyBwp,
	CurrencyNok,
	CurrencyBrl,
	CurrencyBnd,
	CurrencyBgn,
	CurrencyBif,
	CurrencyCve,
	CurrencyKhr,
	CurrencyXaf,
	CurrencyCad,
	CurrencyKyd,
	CurrencyClp,
	CurrencyClf,
	CurrencyCny,
	CurrencyCop,
	CurrencyCou,
	CurrencyKmf,
	CurrencyCdf,
	CurrencyNzd,
	CurrencyCrc,
	CurrencyHrk,
	CurrencyCup,
	CurrencyCuc,
	CurrencyAng,
	CurrencyCzk,
	CurrencyDkk,
	CurrencyDjf,
	CurrencyDop,
	CurrencyEgp,
	CurrencySvc,
	CurrencyErn,
	CurrencyEtb,
	CurrencyFkp,
	CurrencyFjd,
	CurrencyXpf,
	CurrencyGmd,
	CurrencyGel,
	CurrencyGhs,
	CurrencyGip,
	CurrencyGtq,
	CurrencyGbp,
	CurrencyGnf,
	CurrencyGyd,
	CurrencyHtg,
	CurrencyHnl,
	CurrencyHkd,
	CurrencyHuf,
	CurrencyIsk,
	CurrencyIDR,
	CurrencyIrr,
	CurrencyIqd,
	CurrencyIls,
	CurrencyJmd,
	CurrencyJpy,
	CurrencyJod,
	CurrencyKzt,
	CurrencyKes,
	CurrencyKrw,
	CurrencyKwd,
	CurrencyKgs,
	CurrencyLak,
	CurrencyLbp,
	CurrencyLsl,
	CurrencyZar,
	CurrencyLrd,
	CurrencyLyd,
	CurrencyChf,
	CurrencyMop,
	CurrencyMkd,
	CurrencyMga,
	CurrencyMwk,
	CurrencyMyr,
	CurrencyMvr,
	CurrencyMru,
	CurrencyMur,
	CurrencyXua,
	CurrencyMxn,
	CurrencyMxv,
	CurrencyMdl,
	CurrencyMnt,
	CurrencyMad,
	CurrencyMzn,
	CurrencyMmk,
	CurrencyNad,
	CurrencyNpr,
	CurrencyNio,
	CurrencyNgn,
	CurrencyOmr,
	CurrencyPkr,
	CurrencyPab,
	CurrencyPgk,
	CurrencyPyg,
	CurrencyPen,
	CurrencyPhp,
	CurrencyPln,
	CurrencyQar,
	CurrencyRon,
	CurrencyRub,
	CurrencyRwf,
	CurrencyShp,
	CurrencyWst,
	CurrencyStn,
	CurrencySar,
	CurrencyRsd,
	CurrencyScr,
	CurrencySll,
	CurrencySgd,
	CurrencyXsu,
	CurrencySbd,
	CurrencySos,
	CurrencySsp,
	CurrencyLkr,
	CurrencySdg,
	CurrencySrd,
	CurrencySzl,
	CurrencySek,
	CurrencyChe,
	CurrencyChw,
	CurrencyTwd,
	CurrencyTjs,
	CurrencyTzs,
	CurrencyThb,
	CurrencyTop,
	CurrencyTtd,
	CurrencyTnd,
	CurrencyTry,
	CurrencyTmt,
	CurrencyUgx,
	CurrencyUah,
	CurrencyAed,
	CurrencyUyu,
	CurrencyUyi,
	CurrencyUyw,
	CurrencyUzs,
	CurrencyVuv,
	CurrencyVes,
	CurrencyVnd,
	CurrencyYer,
	CurrencyZmw,
	CurrencyZwl,
}

func (e Currency) IsValid() bool {
	switch e {
	case CurrencyAfn, CurrencyEur, CurrencyAll, CurrencyDzd, CurrencyUsd, CurrencyAoa, CurrencyXcd, CurrencyArs, CurrencyAmd, CurrencyAwg, CurrencyAud, CurrencyAzn, CurrencyBsd, CurrencyBhd, CurrencyBdt, CurrencyBbd, CurrencyByn, CurrencyBzd, CurrencyXof, CurrencyBmd, CurrencyInr, CurrencyBtn, CurrencyBob, CurrencyBov, CurrencyBam, CurrencyBwp, CurrencyNok, CurrencyBrl, CurrencyBnd, CurrencyBgn, CurrencyBif, CurrencyCve, CurrencyKhr, CurrencyXaf, CurrencyCad, CurrencyKyd, CurrencyClp, CurrencyClf, CurrencyCny, CurrencyCop, CurrencyCou, CurrencyKmf, CurrencyCdf, CurrencyNzd, CurrencyCrc, CurrencyHrk, CurrencyCup, CurrencyCuc, CurrencyAng, CurrencyCzk, CurrencyDkk, CurrencyDjf, CurrencyDop, CurrencyEgp, CurrencySvc, CurrencyErn, CurrencyEtb, CurrencyFkp, CurrencyFjd, CurrencyXpf, CurrencyGmd, CurrencyGel, CurrencyGhs, CurrencyGip, CurrencyGtq, CurrencyGbp, CurrencyGnf, CurrencyGyd, CurrencyHtg, CurrencyHnl, CurrencyHkd, CurrencyHuf, CurrencyIsk, CurrencyIDR, CurrencyIrr, CurrencyIqd, CurrencyIls, CurrencyJmd, CurrencyJpy, CurrencyJod, CurrencyKzt, CurrencyKes, CurrencyKrw, CurrencyKwd, CurrencyKgs, CurrencyLak, CurrencyLbp, CurrencyLsl, CurrencyZar, CurrencyLrd, CurrencyLyd, CurrencyChf, CurrencyMop, CurrencyMkd, CurrencyMga, CurrencyMwk, CurrencyMyr, CurrencyMvr, CurrencyMru, CurrencyMur, CurrencyXua, CurrencyMxn, CurrencyMxv, CurrencyMdl, CurrencyMnt, CurrencyMad, CurrencyMzn, CurrencyMmk, CurrencyNad, CurrencyNpr, CurrencyNio, CurrencyNgn, CurrencyOmr, CurrencyPkr, CurrencyPab, CurrencyPgk, CurrencyPyg, CurrencyPen, CurrencyPhp, CurrencyPln, CurrencyQar, CurrencyRon, CurrencyRub, CurrencyRwf, CurrencyShp, CurrencyWst, CurrencyStn, CurrencySar, CurrencyRsd, CurrencyScr, CurrencySll, CurrencySgd, CurrencyXsu, CurrencySbd, CurrencySos, CurrencySsp, CurrencyLkr, CurrencySdg, CurrencySrd, CurrencySzl, CurrencySek, CurrencyChe, CurrencyChw, CurrencyTwd, CurrencyTjs, CurrencyTzs, CurrencyThb, CurrencyTop, CurrencyTtd, CurrencyTnd, CurrencyTry, CurrencyTmt, CurrencyUgx, CurrencyUah, CurrencyAed, CurrencyUyu, CurrencyUyi, CurrencyUyw, CurrencyUzs, CurrencyVuv, CurrencyVes, CurrencyVnd, CurrencyYer, CurrencyZmw, CurrencyZwl:
		return true
	}
	return false
}

func (e Currency) String() string {
	return string(e)
}

func (e *Currency) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Currency(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Currency", str)
	}
	return nil
}

func (e Currency) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DashboardActivityFeedActivityAlertStatus are the possible alert statuses that an activity's corresponding alert can have.
type DashboardActivityFeedActivityAlertStatus string

const (
	// The alert failed to be published.
	DashboardActivityFeedActivityAlertStatusFailed DashboardActivityFeedActivityAlertStatus = "FAILED"
	// The alert was received when the channel was offline.
	DashboardActivityFeedActivityAlertStatusOffline DashboardActivityFeedActivityAlertStatus = "OFFLINE"
	// The alert has been played and will not be seen again.
	DashboardActivityFeedActivityAlertStatusPlayed DashboardActivityFeedActivityAlertStatus = "PLAYED"
	// The alert is currently being displayed.
	DashboardActivityFeedActivityAlertStatusPlaying DashboardActivityFeedActivityAlertStatus = "PLAYING"
	// The alert is in the alert queue, but yet to be seen.
	DashboardActivityFeedActivityAlertStatusQueued DashboardActivityFeedActivityAlertStatus = "QUEUED"
	// The alert was not queued and will not be displayed.
	DashboardActivityFeedActivityAlertStatusRejected DashboardActivityFeedActivityAlertStatus = "REJECTED"
	// The alert was being displayed, but was skipped by the broadcaster.
	DashboardActivityFeedActivityAlertStatusSkipped DashboardActivityFeedActivityAlertStatus = "SKIPPED"
	// The alert was purged from the alert queue by the broadcaster, after being queued originally.
	DashboardActivityFeedActivityAlertStatusPurged DashboardActivityFeedActivityAlertStatus = "PURGED"
)

var AllDashboardActivityFeedActivityAlertStatus = []DashboardActivityFeedActivityAlertStatus{
	DashboardActivityFeedActivityAlertStatusFailed,
	DashboardActivityFeedActivityAlertStatusOffline,
	DashboardActivityFeedActivityAlertStatusPlayed,
	DashboardActivityFeedActivityAlertStatusPlaying,
	DashboardActivityFeedActivityAlertStatusQueued,
	DashboardActivityFeedActivityAlertStatusRejected,
	DashboardActivityFeedActivityAlertStatusSkipped,
	DashboardActivityFeedActivityAlertStatusPurged,
}

func (e DashboardActivityFeedActivityAlertStatus) IsValid() bool {
	switch e {
	case DashboardActivityFeedActivityAlertStatusFailed, DashboardActivityFeedActivityAlertStatusOffline, DashboardActivityFeedActivityAlertStatusPlayed, DashboardActivityFeedActivityAlertStatusPlaying, DashboardActivityFeedActivityAlertStatusQueued, DashboardActivityFeedActivityAlertStatusRejected, DashboardActivityFeedActivityAlertStatusSkipped, DashboardActivityFeedActivityAlertStatusPurged:
		return true
	}
	return false
}

func (e DashboardActivityFeedActivityAlertStatus) String() string {
	return string(e)
}

func (e *DashboardActivityFeedActivityAlertStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DashboardActivityFeedActivityAlertStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DashboardActivityFeedActivityAlertStatus", str)
	}
	return nil
}

func (e DashboardActivityFeedActivityAlertStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Client error code.
type DeclineOrganizationInviteErrorCode string

const (
	// Internal error.
	DeclineOrganizationInviteErrorCodeInternalError DeclineOrganizationInviteErrorCode = "INTERNAL_ERROR"
	// Invitation not found.
	DeclineOrganizationInviteErrorCodeNotFound DeclineOrganizationInviteErrorCode = "NOT_FOUND"
	// Permission Denied.
	DeclineOrganizationInviteErrorCodePermissionDenied DeclineOrganizationInviteErrorCode = "PERMISSION_DENIED"
)

var AllDeclineOrganizationInviteErrorCode = []DeclineOrganizationInviteErrorCode{
	DeclineOrganizationInviteErrorCodeInternalError,
	DeclineOrganizationInviteErrorCodeNotFound,
	DeclineOrganizationInviteErrorCodePermissionDenied,
}

func (e DeclineOrganizationInviteErrorCode) IsValid() bool {
	switch e {
	case DeclineOrganizationInviteErrorCodeInternalError, DeclineOrganizationInviteErrorCodeNotFound, DeclineOrganizationInviteErrorCodePermissionDenied:
		return true
	}
	return false
}

func (e DeclineOrganizationInviteErrorCode) String() string {
	return string(e)
}

func (e *DeclineOrganizationInviteErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeclineOrganizationInviteErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeclineOrganizationInviteErrorCode", str)
	}
	return nil
}

func (e DeclineOrganizationInviteErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The errors returned from this mutation.
type DeleteChannelBlockedTermErrorCode string

const (
	// User does not have permission to delete blocked term in channel.
	DeleteChannelBlockedTermErrorCodeNoPermissions DeleteChannelBlockedTermErrorCode = "NO_PERMISSIONS"
)

var AllDeleteChannelBlockedTermErrorCode = []DeleteChannelBlockedTermErrorCode{
	DeleteChannelBlockedTermErrorCodeNoPermissions,
}

func (e DeleteChannelBlockedTermErrorCode) IsValid() bool {
	switch e {
	case DeleteChannelBlockedTermErrorCodeNoPermissions:
		return true
	}
	return false
}

func (e DeleteChannelBlockedTermErrorCode) String() string {
	return string(e)
}

func (e *DeleteChannelBlockedTermErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteChannelBlockedTermErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteChannelBlockedTermErrorCode", str)
	}
	return nil
}

func (e DeleteChannelBlockedTermErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible error types returned from this mutation.
type DeleteChannelPermittedTermErrorCode string

const (
	// User does not have permission to delete Permitted term in channel.
	DeleteChannelPermittedTermErrorCodeNoPermissions DeleteChannelPermittedTermErrorCode = "NO_PERMISSIONS"
)

var AllDeleteChannelPermittedTermErrorCode = []DeleteChannelPermittedTermErrorCode{
	DeleteChannelPermittedTermErrorCodeNoPermissions,
}

func (e DeleteChannelPermittedTermErrorCode) IsValid() bool {
	switch e {
	case DeleteChannelPermittedTermErrorCodeNoPermissions:
		return true
	}
	return false
}

func (e DeleteChannelPermittedTermErrorCode) String() string {
	return string(e)
}

func (e *DeleteChannelPermittedTermErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteChannelPermittedTermErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteChannelPermittedTermErrorCode", str)
	}
	return nil
}

func (e DeleteChannelPermittedTermErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The response codes for this mutation.
type DeleteChatMessageStatusCode string

const (
	// Deletion was successful.
	DeleteChatMessageStatusCodeSuccess DeleteChatMessageStatusCode = "SUCCESS"
	// Deletion was successful. Target user is staff.
	DeleteChatMessageStatusCodeSuccessStaff DeleteChatMessageStatusCode = "SUCCESS_STAFF"
	// User does not have permission to delete messages.
	DeleteChatMessageStatusCodeForbidden DeleteChatMessageStatusCode = "FORBIDDEN"
	// Target is the broadcaster.
	DeleteChatMessageStatusCodeTargetIsBroadcaster DeleteChatMessageStatusCode = "TARGET_IS_BROADCASTER"
	// Target is another moderator.
	DeleteChatMessageStatusCodeTargetIsModerator DeleteChatMessageStatusCode = "TARGET_IS_MODERATOR"
)

var AllDeleteChatMessageStatusCode = []DeleteChatMessageStatusCode{
	DeleteChatMessageStatusCodeSuccess,
	DeleteChatMessageStatusCodeSuccessStaff,
	DeleteChatMessageStatusCodeForbidden,
	DeleteChatMessageStatusCodeTargetIsBroadcaster,
	DeleteChatMessageStatusCodeTargetIsModerator,
}

func (e DeleteChatMessageStatusCode) IsValid() bool {
	switch e {
	case DeleteChatMessageStatusCodeSuccess, DeleteChatMessageStatusCodeSuccessStaff, DeleteChatMessageStatusCodeForbidden, DeleteChatMessageStatusCodeTargetIsBroadcaster, DeleteChatMessageStatusCodeTargetIsModerator:
		return true
	}
	return false
}

func (e DeleteChatMessageStatusCode) String() string {
	return string(e)
}

func (e *DeleteChatMessageStatusCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteChatMessageStatusCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteChatMessageStatusCode", str)
	}
	return nil
}

func (e DeleteChatMessageStatusCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes for DeleteCheermoteTierError.
type DeleteCheermoteTierErrorCode string

const (
	// The user is not allowed to delete this cheermote tier.
	DeleteCheermoteTierErrorCodePermissionDenied DeleteCheermoteTierErrorCode = "PERMISSION_DENIED"
	// Unknown error.
	DeleteCheermoteTierErrorCodeUnknown DeleteCheermoteTierErrorCode = "UNKNOWN"
)

var AllDeleteCheermoteTierErrorCode = []DeleteCheermoteTierErrorCode{
	DeleteCheermoteTierErrorCodePermissionDenied,
	DeleteCheermoteTierErrorCodeUnknown,
}

func (e DeleteCheermoteTierErrorCode) IsValid() bool {
	switch e {
	case DeleteCheermoteTierErrorCodePermissionDenied, DeleteCheermoteTierErrorCodeUnknown:
		return true
	}
	return false
}

func (e DeleteCheermoteTierErrorCode) String() string {
	return string(e)
}

func (e *DeleteCheermoteTierErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteCheermoteTierErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteCheermoteTierErrorCode", str)
	}
	return nil
}

func (e DeleteCheermoteTierErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Delete community goal error code.
type DeleteCommunityPointsCommunityGoalErrorCode string

const (
	// The goal was not found.
	DeleteCommunityPointsCommunityGoalErrorCodeNotFound DeleteCommunityPointsCommunityGoalErrorCode = "NOT_FOUND"
	// The current user is not allowed to delete community goals for this channel.
	DeleteCommunityPointsCommunityGoalErrorCodeForbidden DeleteCommunityPointsCommunityGoalErrorCode = "FORBIDDEN"
	// An unknown error occurred.
	DeleteCommunityPointsCommunityGoalErrorCodeUnknown DeleteCommunityPointsCommunityGoalErrorCode = "UNKNOWN"
)

var AllDeleteCommunityPointsCommunityGoalErrorCode = []DeleteCommunityPointsCommunityGoalErrorCode{
	DeleteCommunityPointsCommunityGoalErrorCodeNotFound,
	DeleteCommunityPointsCommunityGoalErrorCodeForbidden,
	DeleteCommunityPointsCommunityGoalErrorCodeUnknown,
}

func (e DeleteCommunityPointsCommunityGoalErrorCode) IsValid() bool {
	switch e {
	case DeleteCommunityPointsCommunityGoalErrorCodeNotFound, DeleteCommunityPointsCommunityGoalErrorCodeForbidden, DeleteCommunityPointsCommunityGoalErrorCodeUnknown:
		return true
	}
	return false
}

func (e DeleteCommunityPointsCommunityGoalErrorCode) String() string {
	return string(e)
}

func (e *DeleteCommunityPointsCommunityGoalErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteCommunityPointsCommunityGoalErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteCommunityPointsCommunityGoalErrorCode", str)
	}
	return nil
}

func (e DeleteCommunityPointsCommunityGoalErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons deleting a custom Community Points reward in a channel could fail.
type DeleteCommunityPointsCustomRewardErrorCode string

const (
	// An unexpected error occurred.
	DeleteCommunityPointsCustomRewardErrorCodeUnknown DeleteCommunityPointsCustomRewardErrorCode = "UNKNOWN"
	// The current user is not allowed to delete a reward in this channel.
	DeleteCommunityPointsCustomRewardErrorCodeForbidden DeleteCommunityPointsCustomRewardErrorCode = "FORBIDDEN"
	// The reward was not found.
	DeleteCommunityPointsCustomRewardErrorCodeNotFound DeleteCommunityPointsCustomRewardErrorCode = "NOT_FOUND"
)

var AllDeleteCommunityPointsCustomRewardErrorCode = []DeleteCommunityPointsCustomRewardErrorCode{
	DeleteCommunityPointsCustomRewardErrorCodeUnknown,
	DeleteCommunityPointsCustomRewardErrorCodeForbidden,
	DeleteCommunityPointsCustomRewardErrorCodeNotFound,
}

func (e DeleteCommunityPointsCustomRewardErrorCode) IsValid() bool {
	switch e {
	case DeleteCommunityPointsCustomRewardErrorCodeUnknown, DeleteCommunityPointsCustomRewardErrorCodeForbidden, DeleteCommunityPointsCustomRewardErrorCodeNotFound:
		return true
	}
	return false
}

func (e DeleteCommunityPointsCustomRewardErrorCode) String() string {
	return string(e)
}

func (e *DeleteCommunityPointsCustomRewardErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteCommunityPointsCustomRewardErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteCommunityPointsCustomRewardErrorCode", str)
	}
	return nil
}

func (e DeleteCommunityPointsCustomRewardErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes for DeleteEmoteError.
type DeleteEmoteErrorCode string

const (
	// The specified emote does not exist.
	DeleteEmoteErrorCodeEmoteNotFound DeleteEmoteErrorCode = "EMOTE_NOT_FOUND"
	// The user is not allowed to delete this emote.
	DeleteEmoteErrorCodePermissionDenied DeleteEmoteErrorCode = "PERMISSION_DENIED"
	// Unknown error.
	DeleteEmoteErrorCodeUnknown DeleteEmoteErrorCode = "UNKNOWN"
)

var AllDeleteEmoteErrorCode = []DeleteEmoteErrorCode{
	DeleteEmoteErrorCodeEmoteNotFound,
	DeleteEmoteErrorCodePermissionDenied,
	DeleteEmoteErrorCodeUnknown,
}

func (e DeleteEmoteErrorCode) IsValid() bool {
	switch e {
	case DeleteEmoteErrorCodeEmoteNotFound, DeleteEmoteErrorCodePermissionDenied, DeleteEmoteErrorCodeUnknown:
		return true
	}
	return false
}

func (e DeleteEmoteErrorCode) String() string {
	return string(e)
}

func (e *DeleteEmoteErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteEmoteErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteEmoteErrorCode", str)
	}
	return nil
}

func (e DeleteEmoteErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error types returned for the deleteExtension mutation.
type DeleteExtensionError string

const (
	// Returned when the extension id was not specified.
	DeleteExtensionErrorMissingExtensionID DeleteExtensionError = "MISSING_EXTENSION_ID"
	// Returned when the id specified could not be found.
	DeleteExtensionErrorExtensionNotFound DeleteExtensionError = "EXTENSION_NOT_FOUND"
	// Returned when the calling user does not have access to delete the extension.
	DeleteExtensionErrorUnauthorized DeleteExtensionError = "UNAUTHORIZED"
)

var AllDeleteExtensionError = []DeleteExtensionError{
	DeleteExtensionErrorMissingExtensionID,
	DeleteExtensionErrorExtensionNotFound,
	DeleteExtensionErrorUnauthorized,
}

func (e DeleteExtensionError) IsValid() bool {
	switch e {
	case DeleteExtensionErrorMissingExtensionID, DeleteExtensionErrorExtensionNotFound, DeleteExtensionErrorUnauthorized:
		return true
	}
	return false
}

func (e DeleteExtensionError) String() string {
	return string(e)
}

func (e *DeleteExtensionError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteExtensionError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteExtensionError", str)
	}
	return nil
}

func (e DeleteExtensionError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DeleteExtensionImageError is an error associated with the deleteExtensionImage mutation.
type DeleteExtensionImageError string

const (
	// User is unable to make modifications to the extension.
	DeleteExtensionImageErrorUnauthorized DeleteExtensionImageError = "UNAUTHORIZED"
	// Version specified is invalid.
	DeleteExtensionImageErrorInvalidVersion DeleteExtensionImageError = "INVALID_VERSION"
	// Cannot find url in the manifest.
	DeleteExtensionImageErrorCannotFindURLInManifest DeleteExtensionImageError = "CANNOT_FIND_URL_IN_MANIFEST"
	// Invalid image url.
	DeleteExtensionImageErrorInvalidImageURL DeleteExtensionImageError = "INVALID_IMAGE_URL"
)

var AllDeleteExtensionImageError = []DeleteExtensionImageError{
	DeleteExtensionImageErrorUnauthorized,
	DeleteExtensionImageErrorInvalidVersion,
	DeleteExtensionImageErrorCannotFindURLInManifest,
	DeleteExtensionImageErrorInvalidImageURL,
}

func (e DeleteExtensionImageError) IsValid() bool {
	switch e {
	case DeleteExtensionImageErrorUnauthorized, DeleteExtensionImageErrorInvalidVersion, DeleteExtensionImageErrorCannotFindURLInManifest, DeleteExtensionImageErrorInvalidImageURL:
		return true
	}
	return false
}

func (e DeleteExtensionImageError) String() string {
	return string(e)
}

func (e *DeleteExtensionImageError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteExtensionImageError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteExtensionImageError", str)
	}
	return nil
}

func (e DeleteExtensionImageError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DeleteExtensionImageError is an error associated with the deleteExtensionSecrets mutation.
type DeleteExtensionSecretsError string

const (
	// User is unable to delete the extension secrets.
	DeleteExtensionSecretsErrorUnauthorized DeleteExtensionSecretsError = "UNAUTHORIZED"
)

var AllDeleteExtensionSecretsError = []DeleteExtensionSecretsError{
	DeleteExtensionSecretsErrorUnauthorized,
}

func (e DeleteExtensionSecretsError) IsValid() bool {
	switch e {
	case DeleteExtensionSecretsErrorUnauthorized:
		return true
	}
	return false
}

func (e DeleteExtensionSecretsError) String() string {
	return string(e)
}

func (e *DeleteExtensionSecretsError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteExtensionSecretsError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteExtensionSecretsError", str)
	}
	return nil
}

func (e DeleteExtensionSecretsError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible errors when deleting a schedule.
type DeleteScheduleError string

const (
	// Not authorized to delete this user schedule.
	DeleteScheduleErrorPermissionDenied DeleteScheduleError = "PERMISSION_DENIED"
)

var AllDeleteScheduleError = []DeleteScheduleError{
	DeleteScheduleErrorPermissionDenied,
}

func (e DeleteScheduleError) IsValid() bool {
	switch e {
	case DeleteScheduleErrorPermissionDenied:
		return true
	}
	return false
}

func (e DeleteScheduleError) String() string {
	return string(e)
}

func (e *DeleteScheduleError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteScheduleError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteScheduleError", str)
	}
	return nil
}

func (e DeleteScheduleError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible errors when deleting a schedule segment.
type DeleteScheduleSegmentError string

const (
	// Not authorized to delete this segment.
	DeleteScheduleSegmentErrorPermissionDenied DeleteScheduleSegmentError = "PERMISSION_DENIED"
)

var AllDeleteScheduleSegmentError = []DeleteScheduleSegmentError{
	DeleteScheduleSegmentErrorPermissionDenied,
}

func (e DeleteScheduleSegmentError) IsValid() bool {
	switch e {
	case DeleteScheduleSegmentErrorPermissionDenied:
		return true
	}
	return false
}

func (e DeleteScheduleSegmentError) String() string {
	return string(e)
}

func (e *DeleteScheduleSegmentError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteScheduleSegmentError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteScheduleSegmentError", str)
	}
	return nil
}

func (e DeleteScheduleSegmentError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors that this mutation returns.
type DeleteSquadStreamInvitationErrorCode string

const (
	// Invitation to be deleted does not exist.
	DeleteSquadStreamInvitationErrorCodeInvitationNotFound DeleteSquadStreamInvitationErrorCode = "INVITATION_NOT_FOUND"
	// Squad associated with the invitation does not exist.
	DeleteSquadStreamInvitationErrorCodeSquadNotFound DeleteSquadStreamInvitationErrorCode = "SQUAD_NOT_FOUND"
	// User does not have permissions to delete invitation.
	DeleteSquadStreamInvitationErrorCodeUnauthorized DeleteSquadStreamInvitationErrorCode = "UNAUTHORIZED"
	// Invitation not in pending or rejected state cannot be deleted.
	DeleteSquadStreamInvitationErrorCodeInvitationCannotBeDeleted DeleteSquadStreamInvitationErrorCode = "INVITATION_CANNOT_BE_DELETED"
)

var AllDeleteSquadStreamInvitationErrorCode = []DeleteSquadStreamInvitationErrorCode{
	DeleteSquadStreamInvitationErrorCodeInvitationNotFound,
	DeleteSquadStreamInvitationErrorCodeSquadNotFound,
	DeleteSquadStreamInvitationErrorCodeUnauthorized,
	DeleteSquadStreamInvitationErrorCodeInvitationCannotBeDeleted,
}

func (e DeleteSquadStreamInvitationErrorCode) IsValid() bool {
	switch e {
	case DeleteSquadStreamInvitationErrorCodeInvitationNotFound, DeleteSquadStreamInvitationErrorCodeSquadNotFound, DeleteSquadStreamInvitationErrorCodeUnauthorized, DeleteSquadStreamInvitationErrorCodeInvitationCannotBeDeleted:
		return true
	}
	return false
}

func (e DeleteSquadStreamInvitationErrorCode) String() string {
	return string(e)
}

func (e *DeleteSquadStreamInvitationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteSquadStreamInvitationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteSquadStreamInvitationErrorCode", str)
	}
	return nil
}

func (e DeleteSquadStreamInvitationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DeleteStreamAuthorizedUserErrorCode is the client error type that occurred during the DeleteStreamAuthorizedUser mutation.
type DeleteStreamAuthorizedUserErrorCode string

const (
	// Unable to assign the Targeted user to stream on behalf of the broadcaster.
	DeleteStreamAuthorizedUserErrorCodeTargetUserUnreturnable DeleteStreamAuthorizedUserErrorCode = "TARGET_USER_UNRETURNABLE"
	// The broadcaster is not found.
	DeleteStreamAuthorizedUserErrorCodeChannelNotFound DeleteStreamAuthorizedUserErrorCode = "CHANNEL_NOT_FOUND"
	// Maximum limit for adding authorized user is reached.
	DeleteStreamAuthorizedUserErrorCodeMaxAccountLimit DeleteStreamAuthorizedUserErrorCode = "MAX_ACCOUNT_LIMIT"
	// Permission denied to add an authorized user.
	DeleteStreamAuthorizedUserErrorCodePermissionDenied DeleteStreamAuthorizedUserErrorCode = "PERMISSION_DENIED"
	// Invalid argument to add an authorized user.
	DeleteStreamAuthorizedUserErrorCodeInvalidArgument DeleteStreamAuthorizedUserErrorCode = "INVALID_ARGUMENT"
)

var AllDeleteStreamAuthorizedUserErrorCode = []DeleteStreamAuthorizedUserErrorCode{
	DeleteStreamAuthorizedUserErrorCodeTargetUserUnreturnable,
	DeleteStreamAuthorizedUserErrorCodeChannelNotFound,
	DeleteStreamAuthorizedUserErrorCodeMaxAccountLimit,
	DeleteStreamAuthorizedUserErrorCodePermissionDenied,
	DeleteStreamAuthorizedUserErrorCodeInvalidArgument,
}

func (e DeleteStreamAuthorizedUserErrorCode) IsValid() bool {
	switch e {
	case DeleteStreamAuthorizedUserErrorCodeTargetUserUnreturnable, DeleteStreamAuthorizedUserErrorCodeChannelNotFound, DeleteStreamAuthorizedUserErrorCodeMaxAccountLimit, DeleteStreamAuthorizedUserErrorCodePermissionDenied, DeleteStreamAuthorizedUserErrorCodeInvalidArgument:
		return true
	}
	return false
}

func (e DeleteStreamAuthorizedUserErrorCode) String() string {
	return string(e)
}

func (e *DeleteStreamAuthorizedUserErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeleteStreamAuthorizedUserErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeleteStreamAuthorizedUserErrorCode", str)
	}
	return nil
}

func (e DeleteStreamAuthorizedUserErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DeletedMessageDisplaySetting represents the possible settings for how deleted messages should be displayed.
type DeletedMessageDisplaySetting string

const (
	// LEGACY hides deleted messages behind a clickable '<message_deleted>' chat line.
	DeletedMessageDisplaySettingLegacy DeletedMessageDisplaySetting = "LEGACY"
	// BRIEF removes all deleted messages and inserts a system message that reports the number of deleted messages.
	DeletedMessageDisplaySettingBrief DeletedMessageDisplaySetting = "BRIEF"
	// DETAILED the deleted message is readable but strikethrough and grayed out.
	DeletedMessageDisplaySettingDetailed DeletedMessageDisplaySetting = "DETAILED"
)

var AllDeletedMessageDisplaySetting = []DeletedMessageDisplaySetting{
	DeletedMessageDisplaySettingLegacy,
	DeletedMessageDisplaySettingBrief,
	DeletedMessageDisplaySettingDetailed,
}

func (e DeletedMessageDisplaySetting) IsValid() bool {
	switch e {
	case DeletedMessageDisplaySettingLegacy, DeletedMessageDisplaySettingBrief, DeletedMessageDisplaySettingDetailed:
		return true
	}
	return false
}

func (e DeletedMessageDisplaySetting) String() string {
	return string(e)
}

func (e *DeletedMessageDisplaySetting) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeletedMessageDisplaySetting(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeletedMessageDisplaySetting", str)
	}
	return nil
}

func (e DeletedMessageDisplaySetting) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of types of directory.
type DirectoryType string

const (
	// A game.
	DirectoryTypeGame DirectoryType = "GAME"
)

var AllDirectoryType = []DirectoryType{
	DirectoryTypeGame,
}

func (e DirectoryType) IsValid() bool {
	switch e {
	case DirectoryTypeGame:
		return true
	}
	return false
}

func (e DirectoryType) String() string {
	return string(e)
}

func (e *DirectoryType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectoryType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectoryType", str)
	}
	return nil
}

func (e DirectoryType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible error enums returned while trying to disable two factor authentication.
type DisableTwoFactorErrorCode string

const (
	// The user needs to re-authenticate to perform this operation.
	DisableTwoFactorErrorCodeReauthNeeded DisableTwoFactorErrorCode = "REAUTH_NEEDED"
	// Something unexpected occured.
	DisableTwoFactorErrorCodeUnknownError DisableTwoFactorErrorCode = "UNKNOWN_ERROR"
)

var AllDisableTwoFactorErrorCode = []DisableTwoFactorErrorCode{
	DisableTwoFactorErrorCodeReauthNeeded,
	DisableTwoFactorErrorCodeUnknownError,
}

func (e DisableTwoFactorErrorCode) IsValid() bool {
	switch e {
	case DisableTwoFactorErrorCodeReauthNeeded, DisableTwoFactorErrorCodeUnknownError:
		return true
	}
	return false
}

func (e DisableTwoFactorErrorCode) String() string {
	return string(e)
}

func (e *DisableTwoFactorErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DisableTwoFactorErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DisableTwoFactorErrorCode", str)
	}
	return nil
}

func (e DisableTwoFactorErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DisableUserAccountErrorCode is an error while deleting a user.
type DisableUserAccountErrorCode string

const (
	// User ID is invalid.
	DisableUserAccountErrorCodeInvalidUserID DisableUserAccountErrorCode = "INVALID_USER_ID"
	// Requester is not authorized to make the requested change.
	DisableUserAccountErrorCodeUnauthorized DisableUserAccountErrorCode = "UNAUTHORIZED"
)

var AllDisableUserAccountErrorCode = []DisableUserAccountErrorCode{
	DisableUserAccountErrorCodeInvalidUserID,
	DisableUserAccountErrorCodeUnauthorized,
}

func (e DisableUserAccountErrorCode) IsValid() bool {
	switch e {
	case DisableUserAccountErrorCodeInvalidUserID, DisableUserAccountErrorCodeUnauthorized:
		return true
	}
	return false
}

func (e DisableUserAccountErrorCode) String() string {
	return string(e)
}

func (e *DisableUserAccountErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DisableUserAccountErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DisableUserAccountErrorCode", str)
	}
	return nil
}

func (e DisableUserAccountErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DEPRECATED: to be replaced by SubscriptionPromotionDiscountType.
// Valid discount types for subscription products.
type DiscountType string

const (
	// Percent discount type, eg. "50%".
	DiscountTypePercentOff DiscountType = "PERCENT_OFF"
)

var AllDiscountType = []DiscountType{
	DiscountTypePercentOff,
}

func (e DiscountType) IsValid() bool {
	switch e {
	case DiscountTypePercentOff:
		return true
	}
	return false
}

func (e DiscountType) String() string {
	return string(e)
}

func (e *DiscountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountType", str)
	}
	return nil
}

func (e DiscountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DismissRitualTokenErrorCode string

const (
	// Token is not in a status that can be dismissed.
	DismissRitualTokenErrorCodeTokenNotAvailable DismissRitualTokenErrorCode = "TOKEN_NOT_AVAILABLE"
	// Token does not exist.
	DismissRitualTokenErrorCodeTokenNotFound DismissRitualTokenErrorCode = "TOKEN_NOT_FOUND"
)

var AllDismissRitualTokenErrorCode = []DismissRitualTokenErrorCode{
	DismissRitualTokenErrorCodeTokenNotAvailable,
	DismissRitualTokenErrorCodeTokenNotFound,
}

func (e DismissRitualTokenErrorCode) IsValid() bool {
	switch e {
	case DismissRitualTokenErrorCodeTokenNotAvailable, DismissRitualTokenErrorCodeTokenNotFound:
		return true
	}
	return false
}

func (e DismissRitualTokenErrorCode) String() string {
	return string(e)
}

func (e *DismissRitualTokenErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DismissRitualTokenErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DismissRitualTokenErrorCode", str)
	}
	return nil
}

func (e DismissRitualTokenErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A list of all supported Action types. //To be deprecated.
type DropActionType string

const (
	// Returned in case the action type cannot be identified.
	DropActionTypeUnknownActionType DropActionType = "UNKNOWN_ACTION_TYPE"
	// Returned in case the action starts a user claim flow.
	DropActionTypeUserClaimFlow DropActionType = "USER_CLAIM_FLOW"
)

var AllDropActionType = []DropActionType{
	DropActionTypeUnknownActionType,
	DropActionTypeUserClaimFlow,
}

func (e DropActionType) IsValid() bool {
	switch e {
	case DropActionTypeUnknownActionType, DropActionTypeUserClaimFlow:
		return true
	}
	return false
}

func (e DropActionType) String() string {
	return string(e)
}

func (e *DropActionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DropActionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DropActionType", str)
	}
	return nil
}

func (e DropActionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible status of a drops campaign.
type DropCampaignStatus string

const (
	// Drop campaign is currently active.
	DropCampaignStatusActive DropCampaignStatus = "ACTIVE"
	// The drop campaign is past its end date.
	DropCampaignStatusExpired DropCampaignStatus = "EXPIRED"
	// The drop campaign is currently in testing mode.
	DropCampaignStatusTest DropCampaignStatus = "TEST"
	// The drop campaign is live but not yet past the start date.
	DropCampaignStatusUpcoming DropCampaignStatus = "UPCOMING"
	// The drop campaign has been turned off.
	DropCampaignStatusDisabled DropCampaignStatus = "DISABLED"
)

var AllDropCampaignStatus = []DropCampaignStatus{
	DropCampaignStatusActive,
	DropCampaignStatusExpired,
	DropCampaignStatusTest,
	DropCampaignStatusUpcoming,
	DropCampaignStatusDisabled,
}

func (e DropCampaignStatus) IsValid() bool {
	switch e {
	case DropCampaignStatusActive, DropCampaignStatusExpired, DropCampaignStatusTest, DropCampaignStatusUpcoming, DropCampaignStatusDisabled:
		return true
	}
	return false
}

func (e DropCampaignStatus) String() string {
	return string(e)
}

func (e *DropCampaignStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DropCampaignStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DropCampaignStatus", str)
	}
	return nil
}

func (e DropCampaignStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The operator used to compare the in-game event.
type DropEventConditionOperator string

const (
	// An unknown operator, only possible before the drop condition has been set.
	DropEventConditionOperatorUnknown DropEventConditionOperator = "UNKNOWN"
	// Less than.
	DropEventConditionOperatorSmaller DropEventConditionOperator = "SMALLER"
	// Less than or equal.
	DropEventConditionOperatorSmallerEqual DropEventConditionOperator = "SMALLER_EQUAL"
	// Equal.
	DropEventConditionOperatorEqual DropEventConditionOperator = "EQUAL"
	// Greater than.
	DropEventConditionOperatorGreater DropEventConditionOperator = "GREATER"
	// Greater than or equal.
	DropEventConditionOperatorGreaterEqual DropEventConditionOperator = "GREATER_EQUAL"
)

var AllDropEventConditionOperator = []DropEventConditionOperator{
	DropEventConditionOperatorUnknown,
	DropEventConditionOperatorSmaller,
	DropEventConditionOperatorSmallerEqual,
	DropEventConditionOperatorEqual,
	DropEventConditionOperatorGreater,
	DropEventConditionOperatorGreaterEqual,
}

func (e DropEventConditionOperator) IsValid() bool {
	switch e {
	case DropEventConditionOperatorUnknown, DropEventConditionOperatorSmaller, DropEventConditionOperatorSmallerEqual, DropEventConditionOperatorEqual, DropEventConditionOperatorGreater, DropEventConditionOperatorGreaterEqual:
		return true
	}
	return false
}

func (e DropEventConditionOperator) String() string {
	return string(e)
}

func (e *DropEventConditionOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DropEventConditionOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DropEventConditionOperator", str)
	}
	return nil
}

func (e DropEventConditionOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DropImageType is the list of possible uses that an image can have for drops.
type DropImageType string

const (
	// Image for telling viewers that drops are available if they link accounts.
	DropImageTypeLinkNotification DropImageType = "LINK_NOTIFICATION"
	// Image for showing a viewer what item a developer awarded as a drop.
	DropImageTypeItem DropImageType = "ITEM"
)

var AllDropImageType = []DropImageType{
	DropImageTypeLinkNotification,
	DropImageTypeItem,
}

func (e DropImageType) IsValid() bool {
	switch e {
	case DropImageTypeLinkNotification, DropImageTypeItem:
		return true
	}
	return false
}

func (e DropImageType) String() string {
	return string(e)
}

func (e *DropImageType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DropImageType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DropImageType", str)
	}
	return nil
}

func (e DropImageType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status enums for a drop instance.
type DropInstanceEligibilityStatus string

const (
	// User can claim all rewards.
	DropInstanceEligibilityStatusEligibleForAll DropInstanceEligibilityStatus = "ELIGIBLE_FOR_ALL"
	// User can claim some rewards.
	DropInstanceEligibilityStatusLimited DropInstanceEligibilityStatus = "LIMITED"
	// User can not claim any of the rewards in this drop instance.
	DropInstanceEligibilityStatusEntitlementLimitReached DropInstanceEligibilityStatus = "ENTITLEMENT_LIMIT_REACHED"
	// User has already claimed this drop instance.
	DropInstanceEligibilityStatusDropInstanceAlreadyClaimed DropInstanceEligibilityStatus = "DROP_INSTANCE_ALREADY_CLAIMED"
	// The claim duration has expired and user can no longer claim this drop instance.
	DropInstanceEligibilityStatusExpired DropInstanceEligibilityStatus = "EXPIRED"
	// Unknown is returned if a status is returned from the backend that was not expected.
	DropInstanceEligibilityStatusUnknown DropInstanceEligibilityStatus = "UNKNOWN"
)

var AllDropInstanceEligibilityStatus = []DropInstanceEligibilityStatus{
	DropInstanceEligibilityStatusEligibleForAll,
	DropInstanceEligibilityStatusLimited,
	DropInstanceEligibilityStatusEntitlementLimitReached,
	DropInstanceEligibilityStatusDropInstanceAlreadyClaimed,
	DropInstanceEligibilityStatusExpired,
	DropInstanceEligibilityStatusUnknown,
}

func (e DropInstanceEligibilityStatus) IsValid() bool {
	switch e {
	case DropInstanceEligibilityStatusEligibleForAll, DropInstanceEligibilityStatusLimited, DropInstanceEligibilityStatusEntitlementLimitReached, DropInstanceEligibilityStatusDropInstanceAlreadyClaimed, DropInstanceEligibilityStatusExpired, DropInstanceEligibilityStatusUnknown:
		return true
	}
	return false
}

func (e DropInstanceEligibilityStatus) String() string {
	return string(e)
}

func (e *DropInstanceEligibilityStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DropInstanceEligibilityStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DropInstanceEligibilityStatus", str)
	}
	return nil
}

func (e DropInstanceEligibilityStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Availability enum for Drop Rewards.
type DropRewardAvailability string

const (
	// User can claim this item.
	DropRewardAvailabilityAvailable DropRewardAvailability = "AVAILABLE"
	// User has claimed this item already the maximum number of times.
	DropRewardAvailabilityLimitReached DropRewardAvailability = "LIMIT_REACHED"
	// Unknown is returned when an unexpected status is received from the backend.
	DropRewardAvailabilityUnknown DropRewardAvailability = "UNKNOWN"
)

var AllDropRewardAvailability = []DropRewardAvailability{
	DropRewardAvailabilityAvailable,
	DropRewardAvailabilityLimitReached,
	DropRewardAvailabilityUnknown,
}

func (e DropRewardAvailability) IsValid() bool {
	switch e {
	case DropRewardAvailabilityAvailable, DropRewardAvailabilityLimitReached, DropRewardAvailabilityUnknown:
		return true
	}
	return false
}

func (e DropRewardAvailability) String() string {
	return string(e)
}

func (e *DropRewardAvailability) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DropRewardAvailability(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DropRewardAvailability", str)
	}
	return nil
}

func (e DropRewardAvailability) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of drop rule you're creating. Event vs Minutes Watched.
type DropRuleType string

const (
	// A drop that is triggered by an in-game event.
	DropRuleTypeEventBased DropRuleType = "EVENT_BASED"
	// A drop that is granted based on the user's minutes-watched of the drop's game.
	DropRuleTypeTimeBased DropRuleType = "TIME_BASED"
	// A drop that is triggered by an manual triggered event.
	DropRuleTypeManualTriggerBased DropRuleType = "MANUAL_TRIGGER_BASED"
)

var AllDropRuleType = []DropRuleType{
	DropRuleTypeEventBased,
	DropRuleTypeTimeBased,
	DropRuleTypeManualTriggerBased,
}

func (e DropRuleType) IsValid() bool {
	switch e {
	case DropRuleTypeEventBased, DropRuleTypeTimeBased, DropRuleTypeManualTriggerBased:
		return true
	}
	return false
}

func (e DropRuleType) String() string {
	return string(e)
}

func (e *DropRuleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DropRuleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DropRuleType", str)
	}
	return nil
}

func (e DropRuleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for Drops2 errors.
type DropsErrorCode string

const (
	// The error code is unknown.
	DropsErrorCodeUnknown DropsErrorCode = "UNKNOWN"
	// The user is either not authenticated or not authorized to perform the request.
	DropsErrorCodeUnauthorized DropsErrorCode = "UNAUTHORIZED"
	// A request field either was not present or did not meet validation requirements.
	DropsErrorCodeInvalidArgument DropsErrorCode = "INVALID_ARGUMENT"
	// The drops2 object is not in the right state to perform this operation.
	DropsErrorCodeFailedPrecondition DropsErrorCode = "FAILED_PRECONDITION"
	// The object you wish to query / modify is not found.
	DropsErrorCodeNotFound DropsErrorCode = "NOT_FOUND"
	// The object you're trying to create, already exists.
	DropsErrorCodeAlreadyExists DropsErrorCode = "ALREADY_EXISTS"
)

var AllDropsErrorCode = []DropsErrorCode{
	DropsErrorCodeUnknown,
	DropsErrorCodeUnauthorized,
	DropsErrorCodeInvalidArgument,
	DropsErrorCodeFailedPrecondition,
	DropsErrorCodeNotFound,
	DropsErrorCodeAlreadyExists,
}

func (e DropsErrorCode) IsValid() bool {
	switch e {
	case DropsErrorCodeUnknown, DropsErrorCodeUnauthorized, DropsErrorCodeInvalidArgument, DropsErrorCodeFailedPrecondition, DropsErrorCodeNotFound, DropsErrorCodeAlreadyExists:
		return true
	}
	return false
}

func (e DropsErrorCode) String() string {
	return string(e)
}

func (e *DropsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DropsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DropsErrorCode", str)
	}
	return nil
}

func (e DropsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The list of names of payment methods that are supported for web checkout.
type EligiblePaymentMethodName string

const (
	// Amazon Pay payment method.
	EligiblePaymentMethodNameAmazonPay EligiblePaymentMethodName = "AMAZON_PAY"
	// Paypal payment method.
	EligiblePaymentMethodNamePaypal EligiblePaymentMethodName = "PAYPAL"
	// Credit card payment method.
	EligiblePaymentMethodNameCreditCard EligiblePaymentMethodName = "CREDIT_CARD"
	// Xsolla payment method.
	EligiblePaymentMethodNameXsolla EligiblePaymentMethodName = "XSOLLA"
	// Twitch Wallet balance payment method.
	EligiblePaymentMethodNameWallet EligiblePaymentMethodName = "WALLET"
	// Direct Debit payment method.
	EligiblePaymentMethodNameDirectDebit EligiblePaymentMethodName = "DIRECT_DEBIT"
)

var AllEligiblePaymentMethodName = []EligiblePaymentMethodName{
	EligiblePaymentMethodNameAmazonPay,
	EligiblePaymentMethodNamePaypal,
	EligiblePaymentMethodNameCreditCard,
	EligiblePaymentMethodNameXsolla,
	EligiblePaymentMethodNameWallet,
	EligiblePaymentMethodNameDirectDebit,
}

func (e EligiblePaymentMethodName) IsValid() bool {
	switch e {
	case EligiblePaymentMethodNameAmazonPay, EligiblePaymentMethodNamePaypal, EligiblePaymentMethodNameCreditCard, EligiblePaymentMethodNameXsolla, EligiblePaymentMethodNameWallet, EligiblePaymentMethodNameDirectDebit:
		return true
	}
	return false
}

func (e EligiblePaymentMethodName) String() string {
	return string(e)
}

func (e *EligiblePaymentMethodName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EligiblePaymentMethodName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EligiblePaymentMethodName", str)
	}
	return nil
}

func (e EligiblePaymentMethodName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The asset type of the emote (static, animated, etc.).
type EmoteAssetType string

const (
	// The emote's asset is animated (e.g. GIF).
	EmoteAssetTypeAnimated EmoteAssetType = "ANIMATED"
	// The emote's asset is static (e.g. PNG).
	EmoteAssetTypeStatic EmoteAssetType = "STATIC"
	// The emote's asset type is unknown.
	EmoteAssetTypeUnknown EmoteAssetType = "UNKNOWN"
)

var AllEmoteAssetType = []EmoteAssetType{
	EmoteAssetTypeAnimated,
	EmoteAssetTypeStatic,
	EmoteAssetTypeUnknown,
}

func (e EmoteAssetType) IsValid() bool {
	switch e {
	case EmoteAssetTypeAnimated, EmoteAssetTypeStatic, EmoteAssetTypeUnknown:
		return true
	}
	return false
}

func (e EmoteAssetType) String() string {
	return string(e)
}

func (e *EmoteAssetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmoteAssetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmoteAssetType", str)
	}
	return nil
}

func (e EmoteAssetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum of supported image sizes.
type EmoteImageSize string

const (
	// Lowest supported resolution.
	EmoteImageSizeSize1x EmoteImageSize = "SIZE_1X"
	// Resolution used for kinda high density displays.
	EmoteImageSizeSize2x EmoteImageSize = "SIZE_2X"
	// Highest density display support.
	EmoteImageSizeSize4x EmoteImageSize = "SIZE_4X"
	// Original size, used for resizing functionality.
	EmoteImageSizeSizeOriginal EmoteImageSize = "SIZE_ORIGINAL"
)

var AllEmoteImageSize = []EmoteImageSize{
	EmoteImageSizeSize1x,
	EmoteImageSizeSize2x,
	EmoteImageSizeSize4x,
	EmoteImageSizeSizeOriginal,
}

func (e EmoteImageSize) IsValid() bool {
	switch e {
	case EmoteImageSizeSize1x, EmoteImageSizeSize2x, EmoteImageSizeSize4x, EmoteImageSizeSizeOriginal:
		return true
	}
	return false
}

func (e EmoteImageSize) String() string {
	return string(e)
}

func (e *EmoteImageSize) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmoteImageSize(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmoteImageSize", str)
	}
	return nil
}

func (e EmoteImageSize) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum of supported resizing plans.
type EmoteResizePlan string

const (
	// Resize a provided SIZE_ORIGINAL_IMAGE.
	EmoteResizePlanAutoResize EmoteResizePlan = "AUTO_RESIZE"
	// Don't resize, use the image as is for 1x, 2x or 4x.
	EmoteResizePlanNoResize EmoteResizePlan = "NO_RESIZE"
)

var AllEmoteResizePlan = []EmoteResizePlan{
	EmoteResizePlanAutoResize,
	EmoteResizePlanNoResize,
}

func (e EmoteResizePlan) IsValid() bool {
	switch e {
	case EmoteResizePlanAutoResize, EmoteResizePlanNoResize:
		return true
	}
	return false
}

func (e EmoteResizePlan) String() string {
	return string(e)
}

func (e *EmoteResizePlan) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmoteResizePlan(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmoteResizePlan", str)
	}
	return nil
}

func (e EmoteResizePlan) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Deprecated: Domains that emotes belong to.
type EmoteSetDomain string

const (
	// Emotes that were granted via Twitch crates.
	EmoteSetDomainCrate EmoteSetDomain = "CRATE"
)

var AllEmoteSetDomain = []EmoteSetDomain{
	EmoteSetDomainCrate,
}

func (e EmoteSetDomain) IsValid() bool {
	switch e {
	case EmoteSetDomainCrate:
		return true
	}
	return false
}

func (e EmoteSetDomain) String() string {
	return string(e)
}

func (e *EmoteSetDomain) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmoteSetDomain(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmoteSetDomain", str)
	}
	return nil
}

func (e EmoteSetDomain) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The state of an emote.
type EmoteState string

const (
	// Emote has been approved and is active.
	EmoteStateActive EmoteState = "ACTIVE"
	// Emote has been uploaded and is awaiting approval.
	EmoteStatePending EmoteState = "PENDING"
	// Emote is inactive.
	EmoteStateInactive EmoteState = "INACTIVE"
	// Emote has an unknown state.
	EmoteStateUnknown EmoteState = "UNKNOWN"
)

var AllEmoteState = []EmoteState{
	EmoteStateActive,
	EmoteStatePending,
	EmoteStateInactive,
	EmoteStateUnknown,
}

func (e EmoteState) IsValid() bool {
	switch e {
	case EmoteStateActive, EmoteStatePending, EmoteStateInactive, EmoteStateUnknown:
		return true
	}
	return false
}

func (e EmoteState) String() string {
	return string(e)
}

func (e *EmoteState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmoteState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmoteState", str)
	}
	return nil
}

func (e EmoteState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Used to filter emotes by state.
type EmoteStateFilter string

const (
	// Show all emotes, including active and pending.
	EmoteStateFilterAll EmoteStateFilter = "ALL"
	// Show only active emotes.
	EmoteStateFilterActive EmoteStateFilter = "ACTIVE"
)

var AllEmoteStateFilter = []EmoteStateFilter{
	EmoteStateFilterAll,
	EmoteStateFilterActive,
}

func (e EmoteStateFilter) IsValid() bool {
	switch e {
	case EmoteStateFilterAll, EmoteStateFilterActive:
		return true
	}
	return false
}

func (e EmoteStateFilter) String() string {
	return string(e)
}

func (e *EmoteStateFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmoteStateFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmoteStateFilter", str)
	}
	return nil
}

func (e EmoteStateFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EmoteType string

const (
	// Emote is a channel points reward.
	EmoteTypeChannelPoints EmoteType = "CHANNEL_POINTS"
	// Emote is a bits badge tier reward.
	EmoteTypeBitsBadgeTiers EmoteType = "BITS_BADGE_TIERS"
	// Emote is a subscription product benefit.
	EmoteTypeSubscriptions EmoteType = "SUBSCRIPTIONS"
	// Emote is a Twitch Prime benefit.
	EmoteTypePrime EmoteType = "PRIME"
	// Emote is a Twitch Turbo benefit.
	EmoteTypeTurbo EmoteType = "TURBO"
	// Emote is one of the robot, monkey, or glitch smilies sets.
	EmoteTypeSmilies EmoteType = "SMILIES"
	// Emote is a global emote.
	EmoteTypeGlobals EmoteType = "GLOBALS"
	// Emote has an unknown type.
	EmoteTypeUnknown EmoteType = "UNKNOWN"
)

var AllEmoteType = []EmoteType{
	EmoteTypeChannelPoints,
	EmoteTypeBitsBadgeTiers,
	EmoteTypeSubscriptions,
	EmoteTypePrime,
	EmoteTypeTurbo,
	EmoteTypeSmilies,
	EmoteTypeGlobals,
	EmoteTypeUnknown,
}

func (e EmoteType) IsValid() bool {
	switch e {
	case EmoteTypeChannelPoints, EmoteTypeBitsBadgeTiers, EmoteTypeSubscriptions, EmoteTypePrime, EmoteTypeTurbo, EmoteTypeSmilies, EmoteTypeGlobals, EmoteTypeUnknown:
		return true
	}
	return false
}

func (e EmoteType) String() string {
	return string(e)
}

func (e *EmoteType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmoteType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmoteType", str)
	}
	return nil
}

func (e EmoteType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// State to track if the emote prefix is approved or not.
type EmoticonPrefixState string

const (
	// Unknown.
	EmoticonPrefixStateUnknown EmoticonPrefixState = "UNKNOWN"
	// No prefix has been submitted.
	EmoticonPrefixStateUnset EmoticonPrefixState = "UNSET"
	// Prefix is approved and active.
	EmoticonPrefixStateActive EmoticonPrefixState = "ACTIVE"
	// Prefix was rejected by Twitch.
	EmoticonPrefixStateRejected EmoticonPrefixState = "REJECTED"
	// Prefix is waiting moderation by Twitch.
	EmoticonPrefixStatePending EmoticonPrefixState = "PENDING"
)

var AllEmoticonPrefixState = []EmoticonPrefixState{
	EmoticonPrefixStateUnknown,
	EmoticonPrefixStateUnset,
	EmoticonPrefixStateActive,
	EmoticonPrefixStateRejected,
	EmoticonPrefixStatePending,
}

func (e EmoticonPrefixState) IsValid() bool {
	switch e {
	case EmoticonPrefixStateUnknown, EmoticonPrefixStateUnset, EmoticonPrefixStateActive, EmoticonPrefixStateRejected, EmoticonPrefixStatePending:
		return true
	}
	return false
}

func (e EmoticonPrefixState) String() string {
	return string(e)
}

func (e *EmoticonPrefixState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EmoticonPrefixState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EmoticonPrefixState", str)
	}
	return nil
}

func (e EmoticonPrefixState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible values for an Extension Anchor.
type ExtensionAnchor string

const (
	// Component extension anchor.
	ExtensionAnchorComponent ExtensionAnchor = "COMPONENT"
	// Hidden extensions are used currently for load tests.
	ExtensionAnchorHidden ExtensionAnchor = "HIDDEN"
	// Panel extension anchor.
	ExtensionAnchorPanel ExtensionAnchor = "PANEL"
	// Video overlay extension anchor.
	ExtensionAnchorVideoOverlay ExtensionAnchor = "VIDEO_OVERLAY"
)

var AllExtensionAnchor = []ExtensionAnchor{
	ExtensionAnchorComponent,
	ExtensionAnchorHidden,
	ExtensionAnchorPanel,
	ExtensionAnchorVideoOverlay,
}

func (e ExtensionAnchor) IsValid() bool {
	switch e {
	case ExtensionAnchorComponent, ExtensionAnchorHidden, ExtensionAnchorPanel, ExtensionAnchorVideoOverlay:
		return true
	}
	return false
}

func (e ExtensionAnchor) String() string {
	return string(e)
}

func (e *ExtensionAnchor) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExtensionAnchor(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExtensionAnchor", str)
	}
	return nil
}

func (e ExtensionAnchor) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The support levels for Bits features.
type ExtensionBitsSupportLevel string

const (
	// This extension doesn't have any support for bit features.
	ExtensionBitsSupportLevelNone ExtensionBitsSupportLevel = "NONE"
	// This extension has support for bit features but can operate in the event
	// the broadcaster disables the permissions.
	ExtensionBitsSupportLevelOptional ExtensionBitsSupportLevel = "OPTIONAL"
	// This extension requires support for bit features and cannot operate in the event
	// the broadcaster disables the permissions.
	ExtensionBitsSupportLevelRequired ExtensionBitsSupportLevel = "REQUIRED"
)

var AllExtensionBitsSupportLevel = []ExtensionBitsSupportLevel{
	ExtensionBitsSupportLevelNone,
	ExtensionBitsSupportLevelOptional,
	ExtensionBitsSupportLevelRequired,
}

func (e ExtensionBitsSupportLevel) IsValid() bool {
	switch e {
	case ExtensionBitsSupportLevelNone, ExtensionBitsSupportLevelOptional, ExtensionBitsSupportLevelRequired:
		return true
	}
	return false
}

func (e ExtensionBitsSupportLevel) String() string {
	return string(e)
}

func (e *ExtensionBitsSupportLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExtensionBitsSupportLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExtensionBitsSupportLevel", str)
	}
	return nil
}

func (e ExtensionBitsSupportLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of the different sort keys to sort extensions within a category.
type ExtensionCategorySortKey string

const (
	// Manual sort key refers to an arbitrary sorting of extensions.
	ExtensionCategorySortKeyManual ExtensionCategorySortKey = "MANUAL"
	// Popularity sort key refers to sorting of extensions by popularity.
	ExtensionCategorySortKeyPopularity ExtensionCategorySortKey = "POPULARITY"
	// Time sort key refers to sorting of extensions from newest to latest.
	ExtensionCategorySortKeyTime ExtensionCategorySortKey = "TIME"
)

var AllExtensionCategorySortKey = []ExtensionCategorySortKey{
	ExtensionCategorySortKeyManual,
	ExtensionCategorySortKeyPopularity,
	ExtensionCategorySortKeyTime,
}

func (e ExtensionCategorySortKey) IsValid() bool {
	switch e {
	case ExtensionCategorySortKeyManual, ExtensionCategorySortKeyPopularity, ExtensionCategorySortKeyTime:
		return true
	}
	return false
}

func (e ExtensionCategorySortKey) String() string {
	return string(e)
}

func (e *ExtensionCategorySortKey) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExtensionCategorySortKey(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExtensionCategorySortKey", str)
	}
	return nil
}

func (e ExtensionCategorySortKey) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of the different category types that are currently supported.
type ExtensionCategoryType string

const (
	// Curated Category Type is Twitch controlled.
	ExtensionCategoryTypeCurated ExtensionCategoryType = "CURATED"
	// Developer Category Type is developer controlled.
	ExtensionCategoryTypeDeveloper ExtensionCategoryType = "DEVELOPER"
	// Pseudo Categories are categories whose extensions are generated. Slugs are required
	// on pseudo categories and are often the best way to retrieve them. Example pseudo categories
	// and slugs include "new-releases" and "whitelisted".
	ExtensionCategoryTypePseudo ExtensionCategoryType = "PSEUDO"
)

var AllExtensionCategoryType = []ExtensionCategoryType{
	ExtensionCategoryTypeCurated,
	ExtensionCategoryTypeDeveloper,
	ExtensionCategoryTypePseudo,
}

func (e ExtensionCategoryType) IsValid() bool {
	switch e {
	case ExtensionCategoryTypeCurated, ExtensionCategoryTypeDeveloper, ExtensionCategoryTypePseudo:
		return true
	}
	return false
}

func (e ExtensionCategoryType) String() string {
	return string(e)
}

func (e *ExtensionCategoryType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExtensionCategoryType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExtensionCategoryType", str)
	}
	return nil
}

func (e ExtensionCategoryType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible locations for Extension Configuration to be hosted.
type ExtensionConfigurationLocation string

const (
	// Configuration not required for activation of this extension.
	ExtensionConfigurationLocationNone ExtensionConfigurationLocation = "NONE"
	// Configuration hosted by Twitch using Extensions Configuration service.
	ExtensionConfigurationLocationHosted ExtensionConfigurationLocation = "HOSTED"
	// Custom/Own service hosted configuration.
	ExtensionConfigurationLocationCustom ExtensionConfigurationLocation = "CUSTOM"
)

var AllExtensionConfigurationLocation = []ExtensionConfigurationLocation{
	ExtensionConfigurationLocationNone,
	ExtensionConfigurationLocationHosted,
	ExtensionConfigurationLocationCustom,
}

func (e ExtensionConfigurationLocation) IsValid() bool {
	switch e {
	case ExtensionConfigurationLocationNone, ExtensionConfigurationLocationHosted, ExtensionConfigurationLocationCustom:
		return true
	}
	return false
}

func (e ExtensionConfigurationLocation) String() string {
	return string(e)
}

func (e *ExtensionConfigurationLocation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExtensionConfigurationLocation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExtensionConfigurationLocation", str)
	}
	return nil
}

func (e ExtensionConfigurationLocation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Extension Link User Error Code.
type ExtensionLinkUserErrorCode string

const (
	// The current user is not authorized to link / unlink this extension.
	ExtensionLinkUserErrorCodeUnauthorized ExtensionLinkUserErrorCode = "UNAUTHORIZED"
	// The request body was invalid.
	ExtensionLinkUserErrorCodeBadRequest ExtensionLinkUserErrorCode = "BAD_REQUEST"
	// An unexpected error occurred.
	ExtensionLinkUserErrorCodeUnknown ExtensionLinkUserErrorCode = "UNKNOWN"
)

var AllExtensionLinkUserErrorCode = []ExtensionLinkUserErrorCode{
	ExtensionLinkUserErrorCodeUnauthorized,
	ExtensionLinkUserErrorCodeBadRequest,
	ExtensionLinkUserErrorCodeUnknown,
}

func (e ExtensionLinkUserErrorCode) IsValid() bool {
	switch e {
	case ExtensionLinkUserErrorCodeUnauthorized, ExtensionLinkUserErrorCodeBadRequest, ExtensionLinkUserErrorCodeUnknown:
		return true
	}
	return false
}

func (e ExtensionLinkUserErrorCode) String() string {
	return string(e)
}

func (e *ExtensionLinkUserErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExtensionLinkUserErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExtensionLinkUserErrorCode", str)
	}
	return nil
}

func (e ExtensionLinkUserErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumerates where the user can submit an extension rating.
type ExtensionRatingLocation string

const (
	// The global notifications popout.
	ExtensionRatingLocationNotification ExtensionRatingLocation = "NOTIFICATION"
)

var AllExtensionRatingLocation = []ExtensionRatingLocation{
	ExtensionRatingLocationNotification,
}

func (e ExtensionRatingLocation) IsValid() bool {
	switch e {
	case ExtensionRatingLocationNotification:
		return true
	}
	return false
}

func (e ExtensionRatingLocation) String() string {
	return string(e)
}

func (e *ExtensionRatingLocation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExtensionRatingLocation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExtensionRatingLocation", str)
	}
	return nil
}

func (e ExtensionRatingLocation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible types of required actions after attempting to activate an extension.
type ExtensionRequiredActionType string

const (
	// The user must accept the permissions in order to complete the activation.
	ExtensionRequiredActionTypePromptForPermissions ExtensionRequiredActionType = "PROMPT_FOR_PERMISSIONS"
	// The user must configure the extension in order to complete the activation.
	ExtensionRequiredActionTypeRequiresConfiguration ExtensionRequiredActionType = "REQUIRES_CONFIGURATION"
)

var AllExtensionRequiredActionType = []ExtensionRequiredActionType{
	ExtensionRequiredActionTypePromptForPermissions,
	ExtensionRequiredActionTypeRequiresConfiguration,
}

func (e ExtensionRequiredActionType) IsValid() bool {
	switch e {
	case ExtensionRequiredActionTypePromptForPermissions, ExtensionRequiredActionTypeRequiresConfiguration:
		return true
	}
	return false
}

func (e ExtensionRequiredActionType) String() string {
	return string(e)
}

func (e *ExtensionRequiredActionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExtensionRequiredActionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExtensionRequiredActionType", str)
	}
	return nil
}

func (e ExtensionRequiredActionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible values for ExtensionState.
type ExtensionState string

const (
	// IN_TEST extensions are currently being worked on by a developer.
	ExtensionStateInTest ExtensionState = "IN_TEST"
	// READY_FOR_REVIEW extensions are currently being examined by a developer for their readiness
	// to be reviewed (assets hosted on CDN).
	ExtensionStateReadyForReview ExtensionState = "READY_FOR_REVIEW"
	// IN_REVIEW extensions are being looked at by Twitch.
	ExtensionStateInReview ExtensionState = "IN_REVIEW"
	// REJECTED extensions are permanently rejected; no action by the  developer will make them acceptable.
	ExtensionStateRejected ExtensionState = "REJECTED"
	// APPROVED extensions are ready to be released, at the developer's convenience.
	ExtensionStateApproved ExtensionState = "APPROVED"
	// RELEASED extensions are currently available to users.  Only one version of an extension
	// can be in this state at any time.
	ExtensionStateReleased ExtensionState = "RELEASED"
	// DEPRECATED extensions were once released, but a newer version now exists.
	ExtensionStateDeprecated ExtensionState = "DEPRECATED"
	// PENDING_ACTION extensions are ones that were reviewed by Twitch and returned to the developer for fixing.
	ExtensionStatePendingAction ExtensionState = "PENDING_ACTION"
	// UPLOADING extensions are in the process of having their assets loaded onto S3.
	ExtensionStateUploading ExtensionState = "UPLOADING"
	// ASSETS_UPLOADED extensions have had their assets uploaded already to S3. This state mirrors
	// the existing READY_FOR_REVIEW state, but doesn't incur an implicit upload.
	ExtensionStateAssetsUploaded ExtensionState = "ASSETS_UPLOADED"
	// DELETED extensions have been deleted; this is a soft delete so we can undelete things.
	ExtensionStateDeleted ExtensionState = "DELETED"
)

var AllExtensionState = []ExtensionState{
	ExtensionStateInTest,
	ExtensionStateReadyForReview,
	ExtensionStateInReview,
	ExtensionStateRejected,
	ExtensionStateApproved,
	ExtensionStateReleased,
	ExtensionStateDeprecated,
	ExtensionStatePendingAction,
	ExtensionStateUploading,
	ExtensionStateAssetsUploaded,
	ExtensionStateDeleted,
}

func (e ExtensionState) IsValid() bool {
	switch e {
	case ExtensionStateInTest, ExtensionStateReadyForReview, ExtensionStateInReview, ExtensionStateRejected, ExtensionStateApproved, ExtensionStateReleased, ExtensionStateDeprecated, ExtensionStatePendingAction, ExtensionStateUploading, ExtensionStateAssetsUploaded, ExtensionStateDeleted:
		return true
	}
	return false
}

func (e ExtensionState) String() string {
	return string(e)
}

func (e *ExtensionState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExtensionState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExtensionState", str)
	}
	return nil
}

func (e ExtensionState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ExtensionStateFilter contains all the valid states to filter the list of extensions by.
type ExtensionStateFilter string

const (
	// Released extension.
	ExtensionStateFilterReleased ExtensionStateFilter = "RELEASED"
)

var AllExtensionStateFilter = []ExtensionStateFilter{
	ExtensionStateFilterReleased,
}

func (e ExtensionStateFilter) IsValid() bool {
	switch e {
	case ExtensionStateFilterReleased:
		return true
	}
	return false
}

func (e ExtensionStateFilter) String() string {
	return string(e)
}

func (e *ExtensionStateFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExtensionStateFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExtensionStateFilter", str)
	}
	return nil
}

func (e ExtensionStateFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The support levels for subscriptions features.
type ExtensionSubscriptionsSupportLevel string

const (
	// This extension doesn't have any support for subscriptions features.
	ExtensionSubscriptionsSupportLevelNone ExtensionSubscriptionsSupportLevel = "NONE"
	// This extension has support for subscriptions features but can operate in the event
	// the broadcaster disables the permissions.
	ExtensionSubscriptionsSupportLevelOptional ExtensionSubscriptionsSupportLevel = "OPTIONAL"
)

var AllExtensionSubscriptionsSupportLevel = []ExtensionSubscriptionsSupportLevel{
	ExtensionSubscriptionsSupportLevelNone,
	ExtensionSubscriptionsSupportLevelOptional,
}

func (e ExtensionSubscriptionsSupportLevel) IsValid() bool {
	switch e {
	case ExtensionSubscriptionsSupportLevelNone, ExtensionSubscriptionsSupportLevelOptional:
		return true
	}
	return false
}

func (e ExtensionSubscriptionsSupportLevel) String() string {
	return string(e)
}

func (e *ExtensionSubscriptionsSupportLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExtensionSubscriptionsSupportLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExtensionSubscriptionsSupportLevel", str)
	}
	return nil
}

func (e ExtensionSubscriptionsSupportLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for follow errors.
type FollowUserErrorCode string

const (
	// Used when fromUser is being blocked by targetUser.
	FollowUserErrorCodeForbidden FollowUserErrorCode = "FORBIDDEN"
	// Used when user has reached their follow cap.
	FollowUserErrorCodeTooManyFollows FollowUserErrorCode = "TOO_MANY_FOLLOWS"
)

var AllFollowUserErrorCode = []FollowUserErrorCode{
	FollowUserErrorCodeForbidden,
	FollowUserErrorCodeTooManyFollows,
}

func (e FollowUserErrorCode) IsValid() bool {
	switch e {
	case FollowUserErrorCodeForbidden, FollowUserErrorCodeTooManyFollows:
		return true
	}
	return false
}

func (e FollowUserErrorCode) String() string {
	return string(e)
}

func (e *FollowUserErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FollowUserErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FollowUserErrorCode", str)
	}
	return nil
}

func (e FollowUserErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FollowedGamesType string

const (
	// Only games which are currently being streamed will be returned.
	FollowedGamesTypeLive FollowedGamesType = "LIVE"
	// All followed games.
	FollowedGamesTypeAll FollowedGamesType = "ALL"
)

var AllFollowedGamesType = []FollowedGamesType{
	FollowedGamesTypeLive,
	FollowedGamesTypeAll,
}

func (e FollowedGamesType) IsValid() bool {
	switch e {
	case FollowedGamesTypeLive, FollowedGamesTypeAll:
		return true
	}
	return false
}

func (e FollowedGamesType) String() string {
	return string(e)
}

func (e *FollowedGamesType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FollowedGamesType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FollowedGamesType", str)
	}
	return nil
}

func (e FollowedGamesType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FollowsFilter string

const (
	// All users the user is following.
	FollowsFilterAll FollowsFilter = "ALL"
	// Users the user is following to which the user can subscribe.
	// this is authenticated so only a logged in user can filter by SUBBABLE.
	FollowsFilterSubbable FollowsFilter = "SUBBABLE"
)

var AllFollowsFilter = []FollowsFilter{
	FollowsFilterAll,
	FollowsFilterSubbable,
}

func (e FollowsFilter) IsValid() bool {
	switch e {
	case FollowsFilterAll, FollowsFilterSubbable:
		return true
	}
	return false
}

func (e FollowsFilter) String() string {
	return string(e)
}

func (e *FollowsFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FollowsFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FollowsFilter", str)
	}
	return nil
}

func (e FollowsFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The format type signifies the format the competition will run from.
type FormatType string

const (
	// Double elimination bracket format.
	FormatTypeDoubleElim FormatType = "DOUBLE_ELIM"
	// Single elimination bracket format.
	FormatTypeSingleElim FormatType = "SINGLE_ELIM"
	// Round robin format.
	FormatTypeRoundRobin FormatType = "ROUND_ROBIN"
	// Leaderboard format.
	FormatTypeLeaderboard FormatType = "LEADERBOARD"
	// Custom format.
	FormatTypeCustom FormatType = "CUSTOM"
	// Unknown format.
	FormatTypeUnknown FormatType = "UNKNOWN"
)

var AllFormatType = []FormatType{
	FormatTypeDoubleElim,
	FormatTypeSingleElim,
	FormatTypeRoundRobin,
	FormatTypeLeaderboard,
	FormatTypeCustom,
	FormatTypeUnknown,
}

func (e FormatType) IsValid() bool {
	switch e {
	case FormatTypeDoubleElim, FormatTypeSingleElim, FormatTypeRoundRobin, FormatTypeLeaderboard, FormatTypeCustom, FormatTypeUnknown:
		return true
	}
	return false
}

func (e FormatType) String() string {
	return string(e)
}

func (e *FormatType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FormatType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FormatType", str)
	}
	return nil
}

func (e FormatType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Decides how to sort Friendship-related responses.
type FriendSort string

const (
	// Sort from oldest to newest.
	FriendSortAsc FriendSort = "ASC"
	// Sort from newest to oldest.
	FriendSortDesc FriendSort = "DESC"
)

var AllFriendSort = []FriendSort{
	FriendSortAsc,
	FriendSortDesc,
}

func (e FriendSort) IsValid() bool {
	switch e {
	case FriendSortAsc, FriendSortDesc:
		return true
	}
	return false
}

func (e FriendSort) String() string {
	return string(e)
}

func (e *FriendSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FriendSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FriendSort", str)
	}
	return nil
}

func (e FriendSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible ways of sorting collections of categories.
type GameSort string

const (
	// Sort by number of concurrent viewers, descending (most viewers first).
	GameSortViewerCount GameSort = "VIEWER_COUNT"
	// Sort by relevance to the current user.
	GameSortRelevance GameSort = "RELEVANCE"
)

var AllGameSort = []GameSort{
	GameSortViewerCount,
	GameSortRelevance,
}

func (e GameSort) IsValid() bool {
	switch e {
	case GameSortViewerCount, GameSortRelevance:
		return true
	}
	return false
}

func (e GameSort) String() string {
	return string(e)
}

func (e *GameSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GameSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GameSort", str)
	}
	return nil
}

func (e GameSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible error enums returned while trying to generate a second factor QR code.
type GenerateSecondFactorQRCodeErrorCode string

const (
	// The user needs to re-authenticate to perform this operation.
	GenerateSecondFactorQRCodeErrorCodeReauthNeeded GenerateSecondFactorQRCodeErrorCode = "REAUTH_NEEDED"
	// The user does not have two factor enabled and cannot generate a QR code.
	GenerateSecondFactorQRCodeErrorCodeNoTwoFactor GenerateSecondFactorQRCodeErrorCode = "NO_TWO_FACTOR"
	// The user has requested too many second factor QR codes.
	GenerateSecondFactorQRCodeErrorCodeRequestThrottled GenerateSecondFactorQRCodeErrorCode = "REQUEST_THROTTLED"
	// The user does not exist.
	GenerateSecondFactorQRCodeErrorCodeUserNotFound GenerateSecondFactorQRCodeErrorCode = "USER_NOT_FOUND"
	// Something unexpected occured.
	GenerateSecondFactorQRCodeErrorCodeUnknownError GenerateSecondFactorQRCodeErrorCode = "UNKNOWN_ERROR"
)

var AllGenerateSecondFactorQRCodeErrorCode = []GenerateSecondFactorQRCodeErrorCode{
	GenerateSecondFactorQRCodeErrorCodeReauthNeeded,
	GenerateSecondFactorQRCodeErrorCodeNoTwoFactor,
	GenerateSecondFactorQRCodeErrorCodeRequestThrottled,
	GenerateSecondFactorQRCodeErrorCodeUserNotFound,
	GenerateSecondFactorQRCodeErrorCodeUnknownError,
}

func (e GenerateSecondFactorQRCodeErrorCode) IsValid() bool {
	switch e {
	case GenerateSecondFactorQRCodeErrorCodeReauthNeeded, GenerateSecondFactorQRCodeErrorCodeNoTwoFactor, GenerateSecondFactorQRCodeErrorCodeRequestThrottled, GenerateSecondFactorQRCodeErrorCodeUserNotFound, GenerateSecondFactorQRCodeErrorCodeUnknownError:
		return true
	}
	return false
}

func (e GenerateSecondFactorQRCodeErrorCode) String() string {
	return string(e)
}

func (e *GenerateSecondFactorQRCodeErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GenerateSecondFactorQRCodeErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GenerateSecondFactorQRCodeErrorCode", str)
	}
	return nil
}

func (e GenerateSecondFactorQRCodeErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An error describing why the issue happened, when relevant.
type GetExtensionSecretsError string

const (
	// User has indicated an invalid extension id.
	GetExtensionSecretsErrorInvalidClient GetExtensionSecretsError = "INVALID_CLIENT"
	// User is unable to read the extension secrets.
	GetExtensionSecretsErrorUnauthorized GetExtensionSecretsError = "UNAUTHORIZED"
	// Something went wrong on our side that we need to fix.
	GetExtensionSecretsErrorInternal GetExtensionSecretsError = "INTERNAL"
)

var AllGetExtensionSecretsError = []GetExtensionSecretsError{
	GetExtensionSecretsErrorInvalidClient,
	GetExtensionSecretsErrorUnauthorized,
	GetExtensionSecretsErrorInternal,
}

func (e GetExtensionSecretsError) IsValid() bool {
	switch e {
	case GetExtensionSecretsErrorInvalidClient, GetExtensionSecretsErrorUnauthorized, GetExtensionSecretsErrorInternal:
		return true
	}
	return false
}

func (e GetExtensionSecretsError) String() string {
	return string(e)
}

func (e *GetExtensionSecretsError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GetExtensionSecretsError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GetExtensionSecretsError", str)
	}
	return nil
}

func (e GetExtensionSecretsError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of a gift offer.
type GiftType string

const (
	// A single recipient gift type.
	GiftTypeSingleRecipient GiftType = "SINGLE_RECIPIENT"
	// A community gift type.
	GiftTypeCommunity GiftType = "COMMUNITY"
)

var AllGiftType = []GiftType{
	GiftTypeSingleRecipient,
	GiftTypeCommunity,
}

func (e GiftType) IsValid() bool {
	switch e {
	case GiftTypeSingleRecipient, GiftTypeCommunity:
		return true
	}
	return false
}

func (e GiftType) String() string {
	return string(e)
}

func (e *GiftType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GiftType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GiftType", str)
	}
	return nil
}

func (e GiftType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// GoRaidErrorCode are the possible errors that this mutation returns.
type GoRaidErrorCode string

const (
	// The request is missing valid channel parameters.
	GoRaidErrorCodeInvalidChannel GoRaidErrorCode = "INVALID_CHANNEL"
	// The user tries to unraid without an active raid.
	GoRaidErrorCodeNoActiveRaid GoRaidErrorCode = "NO_ACTIVE_RAID"
)

var AllGoRaidErrorCode = []GoRaidErrorCode{
	GoRaidErrorCodeInvalidChannel,
	GoRaidErrorCodeNoActiveRaid,
}

func (e GoRaidErrorCode) IsValid() bool {
	switch e {
	case GoRaidErrorCodeInvalidChannel, GoRaidErrorCodeNoActiveRaid:
		return true
	}
	return false
}

func (e GoRaidErrorCode) String() string {
	return string(e)
}

func (e *GoRaidErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GoRaidErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GoRaidErrorCode", str)
	}
	return nil
}

func (e GoRaidErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Set based on the auth input type.
type GrantType string

const (
	// Used for the initial flow after LWA, one-time usage.
	GrantTypeAuthorizationCode GrantType = "AUTHORIZATION_CODE"
	// Used for follow up refreshes, can be used as many times as needed.
	GrantTypeRefreshToken GrantType = "REFRESH_TOKEN"
)

var AllGrantType = []GrantType{
	GrantTypeAuthorizationCode,
	GrantTypeRefreshToken,
}

func (e GrantType) IsValid() bool {
	switch e {
	case GrantTypeAuthorizationCode, GrantTypeRefreshToken:
		return true
	}
	return false
}

func (e GrantType) String() string {
	return string(e)
}

func (e *GrantType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GrantType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GrantType", str)
	}
	return nil
}

func (e GrantType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// GrantVIPErrorCode defines a client error that occurred while granting the VIP status.
type GrantVIPErrorCode string

const (
	// The channel does not exist.
	GrantVIPErrorCodeChannelNotFound GrantVIPErrorCode = "CHANNEL_NOT_FOUND"
	// The granter does not have permission to grant VIP status in this channel.
	GrantVIPErrorCodeForbidden GrantVIPErrorCode = "FORBIDDEN"
	// The user who is to be granted the VIP status actually already has the VIP status.
	GrantVIPErrorCodeGranteeAlreadyVip GrantVIPErrorCode = "GRANTEE_ALREADY_VIP"
	// The user who is to be granted the VIP status is banned or timed out in this channel.
	GrantVIPErrorCodeGranteeChatBanned GrantVIPErrorCode = "GRANTEE_CHAT_BANNED"
	// The user who is to be granted the VIP status does not exist.
	GrantVIPErrorCodeGranteeNotFound GrantVIPErrorCode = "GRANTEE_NOT_FOUND"
	// The channel has reached the maximum number of users with the VIP status and cannot grant the status to any more users.
	GrantVIPErrorCodeMaxVipsReached GrantVIPErrorCode = "MAX_VIPS_REACHED"
	// The channel has not completed the VIP Achievement to unlock the VIP feature.
	GrantVIPErrorCodeVipAchievementIncomplete GrantVIPErrorCode = "VIP_ACHIEVEMENT_INCOMPLETE"
)

var AllGrantVIPErrorCode = []GrantVIPErrorCode{
	GrantVIPErrorCodeChannelNotFound,
	GrantVIPErrorCodeForbidden,
	GrantVIPErrorCodeGranteeAlreadyVip,
	GrantVIPErrorCodeGranteeChatBanned,
	GrantVIPErrorCodeGranteeNotFound,
	GrantVIPErrorCodeMaxVipsReached,
	GrantVIPErrorCodeVipAchievementIncomplete,
}

func (e GrantVIPErrorCode) IsValid() bool {
	switch e {
	case GrantVIPErrorCodeChannelNotFound, GrantVIPErrorCodeForbidden, GrantVIPErrorCodeGranteeAlreadyVip, GrantVIPErrorCodeGranteeChatBanned, GrantVIPErrorCodeGranteeNotFound, GrantVIPErrorCodeMaxVipsReached, GrantVIPErrorCodeVipAchievementIncomplete:
		return true
	}
	return false
}

func (e GrantVIPErrorCode) String() string {
	return string(e)
}

func (e *GrantVIPErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GrantVIPErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GrantVIPErrorCode", str)
	}
	return nil
}

func (e GrantVIPErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Different types of granularities supported.
type Granularity string

const (
	// Bucketed by five minute intervals.
	GranularityFiveMinute Granularity = "FIVE_MINUTE"
	// Bucketed by twenty minute intervals.
	GranularityTwentyMinute Granularity = "TWENTY_MINUTE"
	// Bucketed by forty minute intervals.
	GranularityFortyMinute Granularity = "FORTY_MINUTE"
	// Bucketed by day intervals.
	GranularityDay Granularity = "DAY"
	// Bucketed by week intervals.
	GranularityWeek Granularity = "WEEK"
	// Bucketed by month intervals.
	GranularityMonth Granularity = "MONTH"
)

var AllGranularity = []Granularity{
	GranularityFiveMinute,
	GranularityTwentyMinute,
	GranularityFortyMinute,
	GranularityDay,
	GranularityWeek,
	GranularityMonth,
}

func (e Granularity) IsValid() bool {
	switch e {
	case GranularityFiveMinute, GranularityTwentyMinute, GranularityFortyMinute, GranularityDay, GranularityWeek, GranularityMonth:
		return true
	}
	return false
}

func (e Granularity) String() string {
	return string(e)
}

func (e *Granularity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Granularity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Granularity", str)
	}
	return nil
}

func (e Granularity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The hero preset.
type HeroPreset string

const (
	// The first preset.
	HeroPresetPreset1 HeroPreset = "PRESET_1"
	// The second preset.
	HeroPresetPreset2 HeroPreset = "PRESET_2"
)

var AllHeroPreset = []HeroPreset{
	HeroPresetPreset1,
	HeroPresetPreset2,
}

func (e HeroPreset) IsValid() bool {
	switch e {
	case HeroPresetPreset1, HeroPresetPreset2:
		return true
	}
	return false
}

func (e HeroPreset) String() string {
	return string(e)
}

func (e *HeroPreset) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HeroPreset(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HeroPreset", str)
	}
	return nil
}

func (e HeroPreset) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// HostTargetChannelErrorCode are the list of thrown errors.
type HostTargetChannelErrorCode string

const (
	// The target channel is already being hosted.
	HostTargetChannelErrorCodeTargetChannelAlreadyHosted HostTargetChannelErrorCode = "TARGET_CHANNEL_ALREADY_HOSTED"
	// The target channel is unhostable because the target channel has ignored/banned the channel attempting to host, the target channel is blocked from hosting, etc.
	HostTargetChannelErrorCodeUnhostableChannel HostTargetChannelErrorCode = "UNHOSTABLE_CHANNEL"
	// The target channel is a TOS/DMCA/suspended channel and cannot be hosted.
	HostTargetChannelErrorCodeTargetChannelInBadStanding HostTargetChannelErrorCode = "TARGET_CHANNEL_IN_BAD_STANDING"
	// A channel cannot host itself.
	HostTargetChannelErrorCodeCannotHostSelf HostTargetChannelErrorCode = "CANNOT_HOST_SELF"
)

var AllHostTargetChannelErrorCode = []HostTargetChannelErrorCode{
	HostTargetChannelErrorCodeTargetChannelAlreadyHosted,
	HostTargetChannelErrorCodeUnhostableChannel,
	HostTargetChannelErrorCodeTargetChannelInBadStanding,
	HostTargetChannelErrorCodeCannotHostSelf,
}

func (e HostTargetChannelErrorCode) IsValid() bool {
	switch e {
	case HostTargetChannelErrorCodeTargetChannelAlreadyHosted, HostTargetChannelErrorCodeUnhostableChannel, HostTargetChannelErrorCodeTargetChannelInBadStanding, HostTargetChannelErrorCodeCannotHostSelf:
		return true
	}
	return false
}

func (e HostTargetChannelErrorCode) String() string {
	return string(e)
}

func (e *HostTargetChannelErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HostTargetChannelErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HostTargetChannelErrorCode", str)
	}
	return nil
}

func (e HostTargetChannelErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The conductor type of the Hype Train reward.
type HypeTrainConductorType string

const (
	// The current conductor of an active hype train.
	HypeTrainConductorTypeCurrent HypeTrainConductorType = "CURRENT"
	// The former conductor of a hype train.
	HypeTrainConductorTypeFormer HypeTrainConductorType = "FORMER"
	// An unknown conductor type.
	HypeTrainConductorTypeUnknown HypeTrainConductorType = "UNKNOWN"
)

var AllHypeTrainConductorType = []HypeTrainConductorType{
	HypeTrainConductorTypeCurrent,
	HypeTrainConductorTypeFormer,
	HypeTrainConductorTypeUnknown,
}

func (e HypeTrainConductorType) IsValid() bool {
	switch e {
	case HypeTrainConductorTypeCurrent, HypeTrainConductorTypeFormer, HypeTrainConductorTypeUnknown:
		return true
	}
	return false
}

func (e HypeTrainConductorType) String() string {
	return string(e)
}

func (e *HypeTrainConductorType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HypeTrainConductorType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HypeTrainConductorType", str)
	}
	return nil
}

func (e HypeTrainConductorType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The difficulty a Hype Train can be set to.
type HypeTrainDifficulty string

const (
	// Easy, the easiest difficulty level.
	HypeTrainDifficultyEasy HypeTrainDifficulty = "EASY"
	// Medium, the middle difficulty level.
	HypeTrainDifficultyMedium HypeTrainDifficulty = "MEDIUM"
	// Hard, the hard difficulty level.
	HypeTrainDifficultyHard HypeTrainDifficulty = "HARD"
	// Super Hard, the harder difficulty level.
	HypeTrainDifficultySuperHard HypeTrainDifficulty = "SUPER_HARD"
	// Insane, the hardest difficulty level.
	HypeTrainDifficultyInsane HypeTrainDifficulty = "INSANE"
	// An unknown difficulty.
	HypeTrainDifficultyUnknown HypeTrainDifficulty = "UNKNOWN"
)

var AllHypeTrainDifficulty = []HypeTrainDifficulty{
	HypeTrainDifficultyEasy,
	HypeTrainDifficultyMedium,
	HypeTrainDifficultyHard,
	HypeTrainDifficultySuperHard,
	HypeTrainDifficultyInsane,
	HypeTrainDifficultyUnknown,
}

func (e HypeTrainDifficulty) IsValid() bool {
	switch e {
	case HypeTrainDifficultyEasy, HypeTrainDifficultyMedium, HypeTrainDifficultyHard, HypeTrainDifficultySuperHard, HypeTrainDifficultyInsane, HypeTrainDifficultyUnknown:
		return true
	}
	return false
}

func (e HypeTrainDifficulty) String() string {
	return string(e)
}

func (e *HypeTrainDifficulty) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HypeTrainDifficulty(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HypeTrainDifficulty", str)
	}
	return nil
}

func (e HypeTrainDifficulty) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The enumerated end reasons for a Hype Train.
type HypeTrainEndReason string

const (
	// The Hype Train expired, which means that the Hype Train never completed level 1 after being started.
	HypeTrainEndReasonExpired HypeTrainEndReason = "EXPIRED"
	// The Hype Train is in progress, which means it has not ended.
	HypeTrainEndReasonInProgress HypeTrainEndReason = "IN_PROGRESS"
	// The Hype Train was completed, which means that any level was completed.
	HypeTrainEndReasonCompleted HypeTrainEndReason = "COMPLETED"
	// An unknown ending reason.
	HypeTrainEndReasonUnknown HypeTrainEndReason = "UNKNOWN"
)

var AllHypeTrainEndReason = []HypeTrainEndReason{
	HypeTrainEndReasonExpired,
	HypeTrainEndReasonInProgress,
	HypeTrainEndReasonCompleted,
	HypeTrainEndReasonUnknown,
}

func (e HypeTrainEndReason) IsValid() bool {
	switch e {
	case HypeTrainEndReasonExpired, HypeTrainEndReasonInProgress, HypeTrainEndReasonCompleted, HypeTrainEndReasonUnknown:
		return true
	}
	return false
}

func (e HypeTrainEndReason) String() string {
	return string(e)
}

func (e *HypeTrainEndReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HypeTrainEndReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HypeTrainEndReason", str)
	}
	return nil
}

func (e HypeTrainEndReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of event types for Hype Train Activity Feeds.
type HypeTrainEventType string

const (
	// Event of when a Hype Train started for the given channel.
	HypeTrainEventTypeHypeTrainStarted HypeTrainEventType = "HYPE_TRAIN_STARTED"
	// Event of when a Hype Train ended for the given channel.
	HypeTrainEventTypeHypeTrainEnded HypeTrainEventType = "HYPE_TRAIN_ENDED"
	// Notification of when another Hype Train can start.
	HypeTrainEventTypeHypeTrainCoolDownExpired HypeTrainEventType = "HYPE_TRAIN_COOL_DOWN_EXPIRED"
)

var AllHypeTrainEventType = []HypeTrainEventType{
	HypeTrainEventTypeHypeTrainStarted,
	HypeTrainEventTypeHypeTrainEnded,
	HypeTrainEventTypeHypeTrainCoolDownExpired,
}

func (e HypeTrainEventType) IsValid() bool {
	switch e {
	case HypeTrainEventTypeHypeTrainStarted, HypeTrainEventTypeHypeTrainEnded, HypeTrainEventTypeHypeTrainCoolDownExpired:
		return true
	}
	return false
}

func (e HypeTrainEventType) String() string {
	return string(e)
}

func (e *HypeTrainEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HypeTrainEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HypeTrainEventType", str)
	}
	return nil
}

func (e HypeTrainEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The participation action of events in a Hype Train.
type HypeTrainParticipationAction string

const (
	// A Cheer event.
	HypeTrainParticipationActionCheer HypeTrainParticipationAction = "CHEER"
	// A use of bits in extensions.
	HypeTrainParticipationActionBitsOnExtension HypeTrainParticipationAction = "BITS_ON_EXTENSION"
	// A poll bits usage.
	HypeTrainParticipationActionPolls HypeTrainParticipationAction = "POLLS"
	// A tier 1 sub purchase.
	HypeTrainParticipationActionTier1Sub HypeTrainParticipationAction = "TIER_1_SUB"
	// A tier 2 sub purchase.
	HypeTrainParticipationActionTier2Sub HypeTrainParticipationAction = "TIER_2_SUB"
	// A tier 3 sub purchase.
	HypeTrainParticipationActionTier3Sub HypeTrainParticipationAction = "TIER_3_SUB"
	// A tier 1 sub gift.
	HypeTrainParticipationActionTier1GiftedSub HypeTrainParticipationAction = "TIER_1_GIFTED_SUB"
	// A tier 2 sub gift.
	HypeTrainParticipationActionTier2GiftedSub HypeTrainParticipationAction = "TIER_2_GIFTED_SUB"
	// A tier 3 sub gift.
	HypeTrainParticipationActionTier3GiftedSub HypeTrainParticipationAction = "TIER_3_GIFTED_SUB"
	// An unkonwn action.
	HypeTrainParticipationActionUnknown HypeTrainParticipationAction = "UNKNOWN"
)

var AllHypeTrainParticipationAction = []HypeTrainParticipationAction{
	HypeTrainParticipationActionCheer,
	HypeTrainParticipationActionBitsOnExtension,
	HypeTrainParticipationActionPolls,
	HypeTrainParticipationActionTier1Sub,
	HypeTrainParticipationActionTier2Sub,
	HypeTrainParticipationActionTier3Sub,
	HypeTrainParticipationActionTier1GiftedSub,
	HypeTrainParticipationActionTier2GiftedSub,
	HypeTrainParticipationActionTier3GiftedSub,
	HypeTrainParticipationActionUnknown,
}

func (e HypeTrainParticipationAction) IsValid() bool {
	switch e {
	case HypeTrainParticipationActionCheer, HypeTrainParticipationActionBitsOnExtension, HypeTrainParticipationActionPolls, HypeTrainParticipationActionTier1Sub, HypeTrainParticipationActionTier2Sub, HypeTrainParticipationActionTier3Sub, HypeTrainParticipationActionTier1GiftedSub, HypeTrainParticipationActionTier2GiftedSub, HypeTrainParticipationActionTier3GiftedSub, HypeTrainParticipationActionUnknown:
		return true
	}
	return false
}

func (e HypeTrainParticipationAction) String() string {
	return string(e)
}

func (e *HypeTrainParticipationAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HypeTrainParticipationAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HypeTrainParticipationAction", str)
	}
	return nil
}

func (e HypeTrainParticipationAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The Hype Train participation source that denotes the commerce types that can occur.
type HypeTrainParticipationSource string

const (
	// Bits source, like cheering.
	HypeTrainParticipationSourceBits HypeTrainParticipationSource = "BITS"
	// Subs source, like subbing to twitch.tv/michael on stream.
	HypeTrainParticipationSourceSubs HypeTrainParticipationSource = "SUBS"
	// An unknown source.
	HypeTrainParticipationSourceUnknown HypeTrainParticipationSource = "UNKNOWN"
)

var AllHypeTrainParticipationSource = []HypeTrainParticipationSource{
	HypeTrainParticipationSourceBits,
	HypeTrainParticipationSourceSubs,
	HypeTrainParticipationSourceUnknown,
}

func (e HypeTrainParticipationSource) IsValid() bool {
	switch e {
	case HypeTrainParticipationSourceBits, HypeTrainParticipationSourceSubs, HypeTrainParticipationSourceUnknown:
		return true
	}
	return false
}

func (e HypeTrainParticipationSource) String() string {
	return string(e)
}

func (e *HypeTrainParticipationSource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HypeTrainParticipationSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HypeTrainParticipationSource", str)
	}
	return nil
}

func (e HypeTrainParticipationSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The enumerated types of rewards that can be entitled.
type HypeTrainRewardType string

const (
	// Emote rewards.
	HypeTrainRewardTypeEmote HypeTrainRewardType = "EMOTE"
	// Badge rewards.
	HypeTrainRewardTypeBadge HypeTrainRewardType = "BADGE"
	// An unknown reward type.
	HypeTrainRewardTypeUnknown HypeTrainRewardType = "UNKNOWN"
)

var AllHypeTrainRewardType = []HypeTrainRewardType{
	HypeTrainRewardTypeEmote,
	HypeTrainRewardTypeBadge,
	HypeTrainRewardTypeUnknown,
}

func (e HypeTrainRewardType) IsValid() bool {
	switch e {
	case HypeTrainRewardTypeEmote, HypeTrainRewardTypeBadge, HypeTrainRewardTypeUnknown:
		return true
	}
	return false
}

func (e HypeTrainRewardType) String() string {
	return string(e)
}

func (e *HypeTrainRewardType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HypeTrainRewardType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HypeTrainRewardType", str)
	}
	return nil
}

func (e HypeTrainRewardType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Determines what other channels can raid this channel.
type IncomingRaidsPolicy string

const (
	// This user cannot be radied by anyone.
	IncomingRaidsPolicyNone IncomingRaidsPolicy = "NONE"
	// This user can be raided by other people in their network.
	IncomingRaidsPolicyNetwork IncomingRaidsPolicy = "NETWORK"
	// This user can be raided by anyone.
	IncomingRaidsPolicyAll IncomingRaidsPolicy = "ALL"
)

var AllIncomingRaidsPolicy = []IncomingRaidsPolicy{
	IncomingRaidsPolicyNone,
	IncomingRaidsPolicyNetwork,
	IncomingRaidsPolicyAll,
}

func (e IncomingRaidsPolicy) IsValid() bool {
	switch e {
	case IncomingRaidsPolicyNone, IncomingRaidsPolicyNetwork, IncomingRaidsPolicyAll:
		return true
	}
	return false
}

func (e IncomingRaidsPolicy) String() string {
	return string(e)
}

func (e *IncomingRaidsPolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IncomingRaidsPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IncomingRaidsPolicy", str)
	}
	return nil
}

func (e IncomingRaidsPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason of why the stream is unstable.
type IngestStreamHealthReason string

const (
	// Reason not set.
	IngestStreamHealthReasonUnknown IngestStreamHealthReason = "UNKNOWN"
	// Stream is behaving normally.
	IngestStreamHealthReasonAllGood IngestStreamHealthReason = "ALL_GOOD"
	// Broadcaster's encoder is sending an incompatible audio codec.
	IngestStreamHealthReasonIncompAudioCodec IngestStreamHealthReason = "INCOMP_AUDIO_CODEC"
	// Broadcaster's encoder is sending an incompatible video codec.
	IngestStreamHealthReasonIncompVideoCodec IngestStreamHealthReason = "INCOMP_VIDEO_CODEC"
	// Broadcaster's encoder is using a deprecated MP3 audio codec.
	IngestStreamHealthReasonIncompMp3Deprecated IngestStreamHealthReason = "INCOMP_MP3_DEPRECATED"
	// The stream is unstable due to high bitrate of the stream.
	IngestStreamHealthReasonHighBitrate IngestStreamHealthReason = "HIGH_BITRATE"
	// Some frames are being dropped by the broadcaster's encoder.
	IngestStreamHealthReasonDroppedFrames IngestStreamHealthReason = "DROPPED_FRAMES"
	// Ingest server expects video segments in sequence, but the server did not receive them from the client.
	IngestStreamHealthReasonStarvation IngestStreamHealthReason = "STARVATION"
	// The interval between each key frame is too high.
	IngestStreamHealthReasonHighKeyFrameInterval IngestStreamHealthReason = "HIGH_KEY_FRAME_INTERVAL"
)

var AllIngestStreamHealthReason = []IngestStreamHealthReason{
	IngestStreamHealthReasonUnknown,
	IngestStreamHealthReasonAllGood,
	IngestStreamHealthReasonIncompAudioCodec,
	IngestStreamHealthReasonIncompVideoCodec,
	IngestStreamHealthReasonIncompMp3Deprecated,
	IngestStreamHealthReasonHighBitrate,
	IngestStreamHealthReasonDroppedFrames,
	IngestStreamHealthReasonStarvation,
	IngestStreamHealthReasonHighKeyFrameInterval,
}

func (e IngestStreamHealthReason) IsValid() bool {
	switch e {
	case IngestStreamHealthReasonUnknown, IngestStreamHealthReasonAllGood, IngestStreamHealthReasonIncompAudioCodec, IngestStreamHealthReasonIncompVideoCodec, IngestStreamHealthReasonIncompMp3Deprecated, IngestStreamHealthReasonHighBitrate, IngestStreamHealthReasonDroppedFrames, IngestStreamHealthReasonStarvation, IngestStreamHealthReasonHighKeyFrameInterval:
		return true
	}
	return false
}

func (e IngestStreamHealthReason) String() string {
	return string(e)
}

func (e *IngestStreamHealthReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IngestStreamHealthReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IngestStreamHealthReason", str)
	}
	return nil
}

func (e IngestStreamHealthReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health of the stream to inform the broadcaster.
type IngestStreamHealthStatus string

const (
	// A misspelling of UNKNOWN.
	IngestStreamHealthStatusUnknwon IngestStreamHealthStatus = "UNKNWON"
	// The stream is ingested okay.
	IngestStreamHealthStatusOk IngestStreamHealthStatus = "OK"
	// The stream is at warning level.
	IngestStreamHealthStatusWarn IngestStreamHealthStatus = "WARN"
	// The stream is unstable.
	IngestStreamHealthStatusUnstable IngestStreamHealthStatus = "UNSTABLE"
	// Health Status not set.
	IngestStreamHealthStatusUnknown IngestStreamHealthStatus = "UNKNOWN"
)

var AllIngestStreamHealthStatus = []IngestStreamHealthStatus{
	IngestStreamHealthStatusUnknwon,
	IngestStreamHealthStatusOk,
	IngestStreamHealthStatusWarn,
	IngestStreamHealthStatusUnstable,
	IngestStreamHealthStatusUnknown,
}

func (e IngestStreamHealthStatus) IsValid() bool {
	switch e {
	case IngestStreamHealthStatusUnknwon, IngestStreamHealthStatusOk, IngestStreamHealthStatusWarn, IngestStreamHealthStatusUnstable, IngestStreamHealthStatusUnknown:
		return true
	}
	return false
}

func (e IngestStreamHealthStatus) String() string {
	return string(e)
}

func (e *IngestStreamHealthStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IngestStreamHealthStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IngestStreamHealthStatus", str)
	}
	return nil
}

func (e IngestStreamHealthStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// InstallExtensionErrorCode is an error code associated with InstallExtensionError.
type InstallExtensionErrorCode string

const (
	// User is unable to make modifications to the extension.
	InstallExtensionErrorCodeUnauthorized InstallExtensionErrorCode = "UNAUTHORIZED"
	// Channel id is invalid, for example, is empty.
	InstallExtensionErrorCodeInvalidChannelID InstallExtensionErrorCode = "INVALID_CHANNEL_ID"
)

var AllInstallExtensionErrorCode = []InstallExtensionErrorCode{
	InstallExtensionErrorCodeUnauthorized,
	InstallExtensionErrorCodeInvalidChannelID,
}

func (e InstallExtensionErrorCode) IsValid() bool {
	switch e {
	case InstallExtensionErrorCodeUnauthorized, InstallExtensionErrorCodeInvalidChannelID:
		return true
	}
	return false
}

func (e InstallExtensionErrorCode) String() string {
	return string(e)
}

func (e *InstallExtensionErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstallExtensionErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstallExtensionErrorCode", str)
	}
	return nil
}

func (e InstallExtensionErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible errors.
type InterruptScheduleErrorCode string

const (
	// Not authorized to disable the schedule.
	InterruptScheduleErrorCodeForbidden InterruptScheduleErrorCode = "FORBIDDEN"
	// The schedule was not found.
	InterruptScheduleErrorCodeNotFound InterruptScheduleErrorCode = "NOT_FOUND"
	// EndAt is too far in the future.
	InterruptScheduleErrorCodeEndTooFarInFuture InterruptScheduleErrorCode = "END_TOO_FAR_IN_FUTURE"
	// The argument is invalid and does not map to a known error.
	InterruptScheduleErrorCodeInvalidArgument InterruptScheduleErrorCode = "INVALID_ARGUMENT"
)

var AllInterruptScheduleErrorCode = []InterruptScheduleErrorCode{
	InterruptScheduleErrorCodeForbidden,
	InterruptScheduleErrorCodeNotFound,
	InterruptScheduleErrorCodeEndTooFarInFuture,
	InterruptScheduleErrorCodeInvalidArgument,
}

func (e InterruptScheduleErrorCode) IsValid() bool {
	switch e {
	case InterruptScheduleErrorCodeForbidden, InterruptScheduleErrorCodeNotFound, InterruptScheduleErrorCodeEndTooFarInFuture, InterruptScheduleErrorCodeInvalidArgument:
		return true
	}
	return false
}

func (e InterruptScheduleErrorCode) String() string {
	return string(e)
}

func (e *InterruptScheduleErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InterruptScheduleErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InterruptScheduleErrorCode", str)
	}
	return nil
}

func (e InterruptScheduleErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of key batch statuses.
type KeyBatchStatus string

const (
	// The key batch is active and keys generated from it can be claimed.
	KeyBatchStatusActive KeyBatchStatus = "ACTIVE"
	// The key batch is inactive and keys generated from it cannot be claimed.
	KeyBatchStatusInactive KeyBatchStatus = "INACTIVE"
	// The key batch is invalid and keys generated from it are invalidated.
	KeyBatchStatusInvalidated KeyBatchStatus = "INVALIDATED"
)

var AllKeyBatchStatus = []KeyBatchStatus{
	KeyBatchStatusActive,
	KeyBatchStatusInactive,
	KeyBatchStatusInvalidated,
}

func (e KeyBatchStatus) IsValid() bool {
	switch e {
	case KeyBatchStatusActive, KeyBatchStatusInactive, KeyBatchStatusInvalidated:
		return true
	}
	return false
}

func (e KeyBatchStatus) String() string {
	return string(e)
}

func (e *KeyBatchStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = KeyBatchStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid KeyBatchStatus", str)
	}
	return nil
}

func (e KeyBatchStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of key pool statuses.
type KeyPoolStatus string

const (
	// The key pool is active and can generate more key batches.
	KeyPoolStatusActive KeyPoolStatus = "ACTIVE"
	// The key pool is inactive and all batches are invalid.
	KeyPoolStatusInactive KeyPoolStatus = "INACTIVE"
	// The key pool is invalid and new batches cannot be made.
	KeyPoolStatusInvalidated KeyPoolStatus = "INVALIDATED"
)

var AllKeyPoolStatus = []KeyPoolStatus{
	KeyPoolStatusActive,
	KeyPoolStatusInactive,
	KeyPoolStatusInvalidated,
}

func (e KeyPoolStatus) IsValid() bool {
	switch e {
	case KeyPoolStatusActive, KeyPoolStatusInactive, KeyPoolStatusInvalidated:
		return true
	}
	return false
}

func (e KeyPoolStatus) String() string {
	return string(e)
}

func (e *KeyPoolStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = KeyPoolStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid KeyPoolStatus", str)
	}
	return nil
}

func (e KeyPoolStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of broadcaster languages.
type Language string

const (
	// Arabic.
	LanguageAr Language = "AR"
	// American Sign Language.
	LanguageAsl Language = "ASL"
	// Bulgarian.
	LanguageBg Language = "BG"
	// Catalan.
	LanguageCa Language = "CA"
	// Czech.
	LanguageCs Language = "CS"
	// Danish.
	LanguageDa Language = "DA"
	// German.
	LanguageDe Language = "DE"
	// Greek.
	LanguageEl Language = "EL"
	// English.
	LanguageEn Language = "EN"
	// Spanish.
	LanguageEs Language = "ES"
	// Finnish.
	LanguageFi Language = "FI"
	// French.
	LanguageFr Language = "FR"
	// Hindi.
	LanguageHi Language = "HI"
	// Hungarian.
	LanguageHu Language = "HU"
	// Indonesian.
	LanguageID Language = "ID"
	// Italian.
	LanguageIt Language = "IT"
	// Japanese.
	LanguageJa Language = "JA"
	// Korean.
	LanguageKo Language = "KO"
	// Malay.
	LanguageMs Language = "MS"
	// Dutch.
	LanguageNl Language = "NL"
	// Norwegian.
	LanguageNo Language = "NO"
	// Other.
	LanguageOther Language = "OTHER"
	// Polish.
	LanguagePl Language = "PL"
	// Portuguese.
	LanguagePt Language = "PT"
	// Romanian.
	LanguageRo Language = "RO"
	// Russian.
	LanguageRu Language = "RU"
	// Slovak.
	LanguageSk Language = "SK"
	// Swedish.
	LanguageSv Language = "SV"
	// Thai.
	LanguageTh Language = "TH"
	// Tagalog.
	LanguageTl Language = "TL"
	// Turkish.
	LanguageTr Language = "TR"
	// Ukrainian.
	LanguageUk Language = "UK"
	// Vietnamese.
	LanguageVi Language = "VI"
	// Chinese.
	LanguageZh Language = "ZH"
	// Chinese (Hong Kong).
	LanguageZhHk Language = "ZH_HK"
)

var AllLanguage = []Language{
	LanguageAr,
	LanguageAsl,
	LanguageBg,
	LanguageCa,
	LanguageCs,
	LanguageDa,
	LanguageDe,
	LanguageEl,
	LanguageEn,
	LanguageEs,
	LanguageFi,
	LanguageFr,
	LanguageHi,
	LanguageHu,
	LanguageID,
	LanguageIt,
	LanguageJa,
	LanguageKo,
	LanguageMs,
	LanguageNl,
	LanguageNo,
	LanguageOther,
	LanguagePl,
	LanguagePt,
	LanguageRo,
	LanguageRu,
	LanguageSk,
	LanguageSv,
	LanguageTh,
	LanguageTl,
	LanguageTr,
	LanguageUk,
	LanguageVi,
	LanguageZh,
	LanguageZhHk,
}

func (e Language) IsValid() bool {
	switch e {
	case LanguageAr, LanguageAsl, LanguageBg, LanguageCa, LanguageCs, LanguageDa, LanguageDe, LanguageEl, LanguageEn, LanguageEs, LanguageFi, LanguageFr, LanguageHi, LanguageHu, LanguageID, LanguageIt, LanguageJa, LanguageKo, LanguageMs, LanguageNl, LanguageNo, LanguageOther, LanguagePl, LanguagePt, LanguageRo, LanguageRu, LanguageSk, LanguageSv, LanguageTh, LanguageTl, LanguageTr, LanguageUk, LanguageVi, LanguageZh, LanguageZhHk:
		return true
	}
	return false
}

func (e Language) String() string {
	return string(e)
}

func (e *Language) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Language(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Language", str)
	}
	return nil
}

func (e Language) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of user language tags (shortened BCP 47) available on Twitch. This should not be confused with Language, which is broadcaster language.
type LanguageTag string

const (
	// Arabic.
	LanguageTagAr LanguageTag = "AR"
	// Bulgarian.
	LanguageTagBg LanguageTag = "BG"
	// Czech.
	LanguageTagCs LanguageTag = "CS"
	// Danish.
	LanguageTagDa LanguageTag = "DA"
	// German.
	LanguageTagDe LanguageTag = "DE"
	// Greek.
	LanguageTagEl LanguageTag = "EL"
	// English.
	LanguageTagEn LanguageTag = "EN"
	// English - Great Britain.
	LanguageTagEnGb LanguageTag = "EN_GB"
	// Spanish.
	LanguageTagEs LanguageTag = "ES"
	// Spanish - Mexico.
	LanguageTagEsMx LanguageTag = "ES_MX"
	// Finnish.
	LanguageTagFi LanguageTag = "FI"
	// French.
	LanguageTagFr LanguageTag = "FR"
	// Hindi.
	LanguageTagHi LanguageTag = "HI"
	// Hungarian.
	LanguageTagHu LanguageTag = "HU"
	// Italian.
	LanguageTagIt LanguageTag = "IT"
	// Japanese.
	LanguageTagJa LanguageTag = "JA"
	// Korean.
	LanguageTagKo LanguageTag = "KO"
	// Dutch.
	LanguageTagNl LanguageTag = "NL"
	// Norwegian.
	LanguageTagNo LanguageTag = "NO"
	// Polish.
	LanguageTagPl LanguageTag = "PL"
	// Portuguese.
	LanguageTagPt LanguageTag = "PT"
	// Portuguese - Brazil.
	LanguageTagPtBr LanguageTag = "PT_BR"
	// Romanian.
	LanguageTagRo LanguageTag = "RO"
	// Russian.
	LanguageTagRu LanguageTag = "RU"
	// Slovak.
	LanguageTagSk LanguageTag = "SK"
	// Swedish.
	LanguageTagSv LanguageTag = "SV"
	// Thai.
	LanguageTagTh LanguageTag = "TH"
	// Turkish.
	LanguageTagTr LanguageTag = "TR"
	// Vietnamese.
	LanguageTagVi LanguageTag = "VI"
	// Chinese - China.
	LanguageTagZhCn LanguageTag = "ZH_CN"
	// Chinese - Taiwan.
	LanguageTagZhTw LanguageTag = "ZH_TW"
	// Chinese.
	LanguageTagZh LanguageTag = "ZH"
)

var AllLanguageTag = []LanguageTag{
	LanguageTagAr,
	LanguageTagBg,
	LanguageTagCs,
	LanguageTagDa,
	LanguageTagDe,
	LanguageTagEl,
	LanguageTagEn,
	LanguageTagEnGb,
	LanguageTagEs,
	LanguageTagEsMx,
	LanguageTagFi,
	LanguageTagFr,
	LanguageTagHi,
	LanguageTagHu,
	LanguageTagIt,
	LanguageTagJa,
	LanguageTagKo,
	LanguageTagNl,
	LanguageTagNo,
	LanguageTagPl,
	LanguageTagPt,
	LanguageTagPtBr,
	LanguageTagRo,
	LanguageTagRu,
	LanguageTagSk,
	LanguageTagSv,
	LanguageTagTh,
	LanguageTagTr,
	LanguageTagVi,
	LanguageTagZhCn,
	LanguageTagZhTw,
	LanguageTagZh,
}

func (e LanguageTag) IsValid() bool {
	switch e {
	case LanguageTagAr, LanguageTagBg, LanguageTagCs, LanguageTagDa, LanguageTagDe, LanguageTagEl, LanguageTagEn, LanguageTagEnGb, LanguageTagEs, LanguageTagEsMx, LanguageTagFi, LanguageTagFr, LanguageTagHi, LanguageTagHu, LanguageTagIt, LanguageTagJa, LanguageTagKo, LanguageTagNl, LanguageTagNo, LanguageTagPl, LanguageTagPt, LanguageTagPtBr, LanguageTagRo, LanguageTagRu, LanguageTagSk, LanguageTagSv, LanguageTagTh, LanguageTagTr, LanguageTagVi, LanguageTagZhCn, LanguageTagZhTw, LanguageTagZh:
		return true
	}
	return false
}

func (e LanguageTag) String() string {
	return string(e)
}

func (e *LanguageTag) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LanguageTag(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LanguageTag", str)
	}
	return nil
}

func (e LanguageTag) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// LeaderboardTimePeriodType enumerates the various types of supported Leaderboards.
type LeaderboardTimePeriodType string

const (
	// Daily leaderboards reset at midnight PT.
	LeaderboardTimePeriodTypeDay LeaderboardTimePeriodType = "DAY"
	// Weekly leaderboards reset at midnight PT between Sunday and Monday.
	LeaderboardTimePeriodTypeWeek LeaderboardTimePeriodType = "WEEK"
	// Monthly leaderboards reset at midnight PT on the last day of the month.
	LeaderboardTimePeriodTypeMonth LeaderboardTimePeriodType = "MONTH"
	// All time leaderboards are cumulative back to when Bits launched in June of 2016.
	LeaderboardTimePeriodTypeAlltime LeaderboardTimePeriodType = "ALLTIME"
)

var AllLeaderboardTimePeriodType = []LeaderboardTimePeriodType{
	LeaderboardTimePeriodTypeDay,
	LeaderboardTimePeriodTypeWeek,
	LeaderboardTimePeriodTypeMonth,
	LeaderboardTimePeriodTypeAlltime,
}

func (e LeaderboardTimePeriodType) IsValid() bool {
	switch e {
	case LeaderboardTimePeriodTypeDay, LeaderboardTimePeriodTypeWeek, LeaderboardTimePeriodTypeMonth, LeaderboardTimePeriodTypeAlltime:
		return true
	}
	return false
}

func (e LeaderboardTimePeriodType) String() string {
	return string(e)
}

func (e *LeaderboardTimePeriodType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LeaderboardTimePeriodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LeaderboardTimePeriodType", str)
	}
	return nil
}

func (e LeaderboardTimePeriodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// LeaderboardType enumerates the various types of supported Leaderboards.
type LeaderboardType string

const (
	// Bits cheering leaderboards.
	LeaderboardTypeCheer LeaderboardType = "CHEER"
	// Sub gifting leaderboards.
	LeaderboardTypeSubgift LeaderboardType = "SUBGIFT"
)

var AllLeaderboardType = []LeaderboardType{
	LeaderboardTypeCheer,
	LeaderboardTypeSubgift,
}

func (e LeaderboardType) IsValid() bool {
	switch e {
	case LeaderboardTypeCheer, LeaderboardTypeSubgift:
		return true
	}
	return false
}

func (e LeaderboardType) String() string {
	return string(e)
}

func (e *LeaderboardType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LeaderboardType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LeaderboardType", str)
	}
	return nil
}

func (e LeaderboardType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// LeaveSquadStreamErrorCode are the possible errors that this mutation returns.
type LeaveSquadStreamErrorCode string

const (
	// The user is not in the squad specified.
	LeaveSquadStreamErrorCodeUserNotInSquad LeaveSquadStreamErrorCode = "USER_NOT_IN_SQUAD"
	// The operation is unauthorized.
	LeaveSquadStreamErrorCodeUnauthorized LeaveSquadStreamErrorCode = "UNAUTHORIZED"
)

var AllLeaveSquadStreamErrorCode = []LeaveSquadStreamErrorCode{
	LeaveSquadStreamErrorCodeUserNotInSquad,
	LeaveSquadStreamErrorCodeUnauthorized,
}

func (e LeaveSquadStreamErrorCode) IsValid() bool {
	switch e {
	case LeaveSquadStreamErrorCodeUserNotInSquad, LeaveSquadStreamErrorCodeUnauthorized:
		return true
	}
	return false
}

func (e LeaveSquadStreamErrorCode) String() string {
	return string(e)
}

func (e *LeaveSquadStreamErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LeaveSquadStreamErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LeaveSquadStreamErrorCode", str)
	}
	return nil
}

func (e LeaveSquadStreamErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// LinkSSOErrorCode enumerates the possible errors that can cause account linking to fail.
type LinkSSOErrorCode string

const (
	// The activation code is incorrect.
	LinkSSOErrorCodeCodeIncorrect LinkSSOErrorCode = "CODE_INCORRECT"
	// The activation code is expired.
	LinkSSOErrorCodeCodeExpired LinkSSOErrorCode = "CODE_EXPIRED"
	// The user has already linked an SSO app of the same type to their account.
	LinkSSOErrorCodeAlreadyLinked LinkSSOErrorCode = "ALREADY_LINKED"
)

var AllLinkSSOErrorCode = []LinkSSOErrorCode{
	LinkSSOErrorCodeCodeIncorrect,
	LinkSSOErrorCodeCodeExpired,
	LinkSSOErrorCodeAlreadyLinked,
}

func (e LinkSSOErrorCode) IsValid() bool {
	switch e {
	case LinkSSOErrorCodeCodeIncorrect, LinkSSOErrorCodeCodeExpired, LinkSSOErrorCodeAlreadyLinked:
		return true
	}
	return false
}

func (e LinkSSOErrorCode) String() string {
	return string(e)
}

func (e *LinkSSOErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkSSOErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkSSOErrorCode", str)
	}
	return nil
}

func (e LinkSSOErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The location that a piece of text should link to.
type LinkType string

const (
	// Do not link to anything.
	LinkTypeNoLink LinkType = "NO_LINK"
	// Link to the categories directory (on web: https://www.twitch.tv/directory).
	LinkTypeCategoriesDirectory LinkType = "CATEGORIES_DIRECTORY"
	// Link to the streams directory (on web: https://www.twitch.tv/directory/all).
	LinkTypeStreamsDirectory LinkType = "STREAMS_DIRECTORY"
)

var AllLinkType = []LinkType{
	LinkTypeNoLink,
	LinkTypeCategoriesDirectory,
	LinkTypeStreamsDirectory,
}

func (e LinkType) IsValid() bool {
	switch e {
	case LinkTypeNoLink, LinkTypeCategoriesDirectory, LinkTypeStreamsDirectory:
		return true
	}
	return false
}

func (e LinkType) String() string {
	return string(e)
}

func (e *LinkType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LinkType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LinkType", str)
	}
	return nil
}

func (e LinkType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The lobby state signifies the progress in the competition.
type LobbyState string

const (
	// No participants are in lobby.
	LobbyStatePrep LobbyState = "PREP"
	// Participants have filled the lobby and can be swapped around different lobbies.
	LobbyStateReady LobbyState = "READY"
	// Participants are currently playing in the lobby, they can be scored but cannot be swapped to different lobbies.
	LobbyStateActive LobbyState = "ACTIVE"
	// Participants are all scored and no longer playing.
	LobbyStateDone LobbyState = "DONE"
	// Lobby state is unknown.
	LobbyStateUnknown LobbyState = "UNKNOWN"
)

var AllLobbyState = []LobbyState{
	LobbyStatePrep,
	LobbyStateReady,
	LobbyStateActive,
	LobbyStateDone,
	LobbyStateUnknown,
}

func (e LobbyState) IsValid() bool {
	switch e {
	case LobbyStatePrep, LobbyStateReady, LobbyStateActive, LobbyStateDone, LobbyStateUnknown:
		return true
	}
	return false
}

func (e LobbyState) String() string {
	return string(e)
}

func (e *LobbyState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LobbyState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LobbyState", str)
	}
	return nil
}

func (e LobbyState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes from the lockPredictionEvent mutation.
type LockPredictionEventErrorCode string

const (
	// The current user is forbidden from updating this Prediction Event.
	LockPredictionEventErrorCodeForbidden LockPredictionEventErrorCode = "FORBIDDEN"
	// This Prediction Event is not currently in the ACTIVE state.
	LockPredictionEventErrorCodeEventNotActive LockPredictionEventErrorCode = "EVENT_NOT_ACTIVE"
	// An unknown error occurred.
	LockPredictionEventErrorCodeUnknown LockPredictionEventErrorCode = "UNKNOWN"
)

var AllLockPredictionEventErrorCode = []LockPredictionEventErrorCode{
	LockPredictionEventErrorCodeForbidden,
	LockPredictionEventErrorCodeEventNotActive,
	LockPredictionEventErrorCodeUnknown,
}

func (e LockPredictionEventErrorCode) IsValid() bool {
	switch e {
	case LockPredictionEventErrorCodeForbidden, LockPredictionEventErrorCodeEventNotActive, LockPredictionEventErrorCodeUnknown:
		return true
	}
	return false
}

func (e LockPredictionEventErrorCode) String() string {
	return string(e)
}

func (e *LockPredictionEventErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LockPredictionEventErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LockPredictionEventErrorCode", str)
	}
	return nil
}

func (e LockPredictionEventErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes from the makePrediction mutation.
type MakePredictionErrorCode string

const (
	// The current user is forbidden from making a Prediction on this Prediction Event.
	MakePredictionErrorCodeForbidden MakePredictionErrorCode = "FORBIDDEN"
	// The provided event ID or outcome ID does not exist.
	MakePredictionErrorCodeNotFound MakePredictionErrorCode = "NOT_FOUND"
	// This Prediction Event is no longer actively accepting predictions.
	MakePredictionErrorCodeEventNotActive MakePredictionErrorCode = "EVENT_NOT_ACTIVE"
	// The client is retrying with a transaction id that has already been used.
	MakePredictionErrorCodeDuplicateTransaction MakePredictionErrorCode = "DUPLICATE_TRANSACTION"
	// The client is retrying with a transaction id that is currently being processed in another request.
	MakePredictionErrorCodeTransactionInProgress MakePredictionErrorCode = "TRANSACTION_IN_PROGRESS"
	// The user does not have enough points to make this prediction.
	MakePredictionErrorCodeNotEnoughPoints MakePredictionErrorCode = "NOT_ENOUGH_POINTS"
	// Making this prediction would bring the user's total amount spent on this prediction above the maximum.
	MakePredictionErrorCodeMaxPointsPerEvent MakePredictionErrorCode = "MAX_POINTS_PER_EVENT"
	// The user has already made a prediction on a different Outcome, so this prediction cannot be made.
	MakePredictionErrorCodeMultipleOutcomes MakePredictionErrorCode = "MULTIPLE_OUTCOMES"
	// An unknown error occurred.
	MakePredictionErrorCodeUnknown MakePredictionErrorCode = "UNKNOWN"
)

var AllMakePredictionErrorCode = []MakePredictionErrorCode{
	MakePredictionErrorCodeForbidden,
	MakePredictionErrorCodeNotFound,
	MakePredictionErrorCodeEventNotActive,
	MakePredictionErrorCodeDuplicateTransaction,
	MakePredictionErrorCodeTransactionInProgress,
	MakePredictionErrorCodeNotEnoughPoints,
	MakePredictionErrorCodeMaxPointsPerEvent,
	MakePredictionErrorCodeMultipleOutcomes,
	MakePredictionErrorCodeUnknown,
}

func (e MakePredictionErrorCode) IsValid() bool {
	switch e {
	case MakePredictionErrorCodeForbidden, MakePredictionErrorCodeNotFound, MakePredictionErrorCodeEventNotActive, MakePredictionErrorCodeDuplicateTransaction, MakePredictionErrorCodeTransactionInProgress, MakePredictionErrorCodeNotEnoughPoints, MakePredictionErrorCodeMaxPointsPerEvent, MakePredictionErrorCodeMultipleOutcomes, MakePredictionErrorCodeUnknown:
		return true
	}
	return false
}

func (e MakePredictionErrorCode) String() string {
	return string(e)
}

func (e *MakePredictionErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MakePredictionErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MakePredictionErrorCode", str)
	}
	return nil
}

func (e MakePredictionErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible return status of a drop trigger try on a channel.
type ManuallyTriggerDropResultStatus string

const (
	// Returned if the trigger try was successful.
	ManuallyTriggerDropResultStatusSuccess ManuallyTriggerDropResultStatus = "SUCCESS"
	// Returned if the streamer is not eligible to have the drop triggered on it.
	ManuallyTriggerDropResultStatusVerificationFailure ManuallyTriggerDropResultStatus = "VERIFICATION_FAILURE"
	// Returned if the drop triggered returned an error for given channel.
	ManuallyTriggerDropResultStatusError ManuallyTriggerDropResultStatus = "ERROR"
)

var AllManuallyTriggerDropResultStatus = []ManuallyTriggerDropResultStatus{
	ManuallyTriggerDropResultStatusSuccess,
	ManuallyTriggerDropResultStatusVerificationFailure,
	ManuallyTriggerDropResultStatusError,
}

func (e ManuallyTriggerDropResultStatus) IsValid() bool {
	switch e {
	case ManuallyTriggerDropResultStatusSuccess, ManuallyTriggerDropResultStatusVerificationFailure, ManuallyTriggerDropResultStatusError:
		return true
	}
	return false
}

func (e ManuallyTriggerDropResultStatus) String() string {
	return string(e)
}

func (e *ManuallyTriggerDropResultStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ManuallyTriggerDropResultStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ManuallyTriggerDropResultStatus", str)
	}
	return nil
}

func (e ManuallyTriggerDropResultStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Revealed Metric types that the client can filter on.
type MemberMetricsRevealedParams string

const (
	// Return all members.
	MemberMetricsRevealedParamsNone MemberMetricsRevealedParams = "NONE"
	// Return all `StatsRevealed` members.
	MemberMetricsRevealedParamsStats MemberMetricsRevealedParams = "STATS"
	// Return all `RevenueRevealed` members.
	MemberMetricsRevealedParamsRevenue MemberMetricsRevealedParams = "REVENUE"
	// Return users with both `StatsRevealed` and `RevenueRevealed`.
	MemberMetricsRevealedParamsStatsAndRevenue MemberMetricsRevealedParams = "STATS_AND_REVENUE"
)

var AllMemberMetricsRevealedParams = []MemberMetricsRevealedParams{
	MemberMetricsRevealedParamsNone,
	MemberMetricsRevealedParamsStats,
	MemberMetricsRevealedParamsRevenue,
	MemberMetricsRevealedParamsStatsAndRevenue,
}

func (e MemberMetricsRevealedParams) IsValid() bool {
	switch e {
	case MemberMetricsRevealedParamsNone, MemberMetricsRevealedParamsStats, MemberMetricsRevealedParamsRevenue, MemberMetricsRevealedParamsStatsAndRevenue:
		return true
	}
	return false
}

func (e MemberMetricsRevealedParams) String() string {
	return string(e)
}

func (e *MemberMetricsRevealedParams) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MemberMetricsRevealedParams(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MemberMetricsRevealedParams", str)
	}
	return nil
}

func (e MemberMetricsRevealedParams) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Access levels to moderator logs.
type ModLogsAccessLevel string

const (
	// User cannot read moderator logs or create new entries.
	ModLogsAccessLevelNone ModLogsAccessLevel = "NONE"
	// User can read moderator log entries.
	ModLogsAccessLevelRead ModLogsAccessLevel = "READ"
	// User can read and create moderator log entries.
	ModLogsAccessLevelWrite ModLogsAccessLevel = "WRITE"
)

var AllModLogsAccessLevel = []ModLogsAccessLevel{
	ModLogsAccessLevelNone,
	ModLogsAccessLevelRead,
	ModLogsAccessLevelWrite,
}

func (e ModLogsAccessLevel) IsValid() bool {
	switch e {
	case ModLogsAccessLevelNone, ModLogsAccessLevelRead, ModLogsAccessLevelWrite:
		return true
	}
	return false
}

func (e ModLogsAccessLevel) String() string {
	return string(e)
}

func (e *ModLogsAccessLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ModLogsAccessLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ModLogsAccessLevel", str)
	}
	return nil
}

func (e ModLogsAccessLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ModLogsAction represents the recorded actions a channel moderator takes on a channel.
type ModLogsAction string

const (
	// Default Action.
	ModLogsActionInvalidAction ModLogsAction = "INVALID_ACTION"
	// Channel Mod chat bans a user.
	ModLogsActionBanUser ModLogsAction = "BAN_USER"
	// Channel Mod chat timeouts a user.
	ModLogsActionTimeoutUser ModLogsAction = "TIMEOUT_USER"
	// Channel Mod chat unbans a user.
	ModLogsActionUnbanUser ModLogsAction = "UNBAN_USER"
	// Channel Mod sets chat mode.
	ModLogsActionSetChannelMode ModLogsAction = "SET_CHANNEL_MODE"
	// Channel Mod changes.
	ModLogsActionChangeChannelRules ModLogsAction = "CHANGE_CHANNEL_RULES"
	// Channel Mod approves an automod caught message.
	ModLogsActionAllowMessage ModLogsAction = "ALLOW_MESSAGE"
	// Channel Mod denies an automod caught message.
	ModLogsActionDenyMessage ModLogsAction = "DENY_MESSAGE"
	// Channel Mod updates mod terms.
	ModLogsActionUpdateModeratedTerms ModLogsAction = "UPDATE_MODERATED_TERMS"
	// Channel Mod creates a mod comment about a user.
	ModLogsActionComment ModLogsAction = "COMMENT"
	// Channel Mod chat untimeouts a user.
	ModLogsActionUntimeoutUser ModLogsAction = "UNTIMEOUT_USER"
)

var AllModLogsAction = []ModLogsAction{
	ModLogsActionInvalidAction,
	ModLogsActionBanUser,
	ModLogsActionTimeoutUser,
	ModLogsActionUnbanUser,
	ModLogsActionSetChannelMode,
	ModLogsActionChangeChannelRules,
	ModLogsActionAllowMessage,
	ModLogsActionDenyMessage,
	ModLogsActionUpdateModeratedTerms,
	ModLogsActionComment,
	ModLogsActionUntimeoutUser,
}

func (e ModLogsAction) IsValid() bool {
	switch e {
	case ModLogsActionInvalidAction, ModLogsActionBanUser, ModLogsActionTimeoutUser, ModLogsActionUnbanUser, ModLogsActionSetChannelMode, ModLogsActionChangeChannelRules, ModLogsActionAllowMessage, ModLogsActionDenyMessage, ModLogsActionUpdateModeratedTerms, ModLogsActionComment, ModLogsActionUntimeoutUser:
		return true
	}
	return false
}

func (e ModLogsAction) String() string {
	return string(e)
}

func (e *ModLogsAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ModLogsAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ModLogsAction", str)
	}
	return nil
}

func (e ModLogsAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ModUserErrorCode defines a client error that occurred while adding a moderator.
type ModUserErrorCode string

const (
	// The requesting user does not have permission to add a moderator in this channel.
	ModUserErrorCodeForbidden ModUserErrorCode = "FORBIDDEN"
	// The target user does not exist or has a suspended account.
	ModUserErrorCodeTargetNotFound ModUserErrorCode = "TARGET_NOT_FOUND"
	// The channel does not exist.
	ModUserErrorCodeChannelNotFound ModUserErrorCode = "CHANNEL_NOT_FOUND"
	// The target user is banned or timed out in this channel.
	ModUserErrorCodeTargetIsChatBanned ModUserErrorCode = "TARGET_IS_CHAT_BANNED"
	// The target user is already a moderator.
	ModUserErrorCodeTargetAlreadyMod ModUserErrorCode = "TARGET_ALREADY_MOD"
)

var AllModUserErrorCode = []ModUserErrorCode{
	ModUserErrorCodeForbidden,
	ModUserErrorCodeTargetNotFound,
	ModUserErrorCodeChannelNotFound,
	ModUserErrorCodeTargetIsChatBanned,
	ModUserErrorCodeTargetAlreadyMod,
}

func (e ModUserErrorCode) IsValid() bool {
	switch e {
	case ModUserErrorCodeForbidden, ModUserErrorCodeTargetNotFound, ModUserErrorCodeChannelNotFound, ModUserErrorCodeTargetIsChatBanned, ModUserErrorCodeTargetAlreadyMod:
		return true
	}
	return false
}

func (e ModUserErrorCode) String() string {
	return string(e)
}

func (e *ModUserErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ModUserErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ModUserErrorCode", str)
	}
	return nil
}

func (e ModUserErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ModerationAction represents the recorded actions a channel moderator takes on a channel.
type ModerationAction string

const (
	// Moderator changes Automod settings levels.
	ModerationActionAutomodLevelChange ModerationAction = "AUTOMOD_LEVEL_CHANGE"
	// Moderator allows message caught by Automod.
	ModerationActionAllowMessage ModerationAction = "ALLOW_MESSAGE"
	// Moderator approves unban request.
	ModerationActionApproveUnbanRequest ModerationAction = "APPROVE_UNBAN_REQUEST"
	// Moderator bans a user.
	ModerationActionBanUser ModerationAction = "BAN_USER"
	// Moderator adds terms to Automod blocked list.
	ModerationActionBlockedTermAdd ModerationAction = "BLOCKED_TERM_ADD"
	// Moderator removes terms to Automod blocked list.
	ModerationActionBlockedTermRemove ModerationAction = "BLOCKED_TERM_REMOVE"
	// Moderator clears chat.
	ModerationActionChatClear ModerationAction = "CHAT_CLEAR"
	// Moderator creates a mod comment about a user.
	ModerationActionComment ModerationAction = "COMMENT"
	// Moderator deletes a chat message.
	ModerationActionDeleteMessage ModerationAction = "DELETE_MESSAGE"
	// Moderator denies message caught by Automod.
	ModerationActionDenyMessage ModerationAction = "DENY_MESSAGE"
	// Moderator denies unban request.
	ModerationActionDenyUnbanRequest ModerationAction = "DENY_UNBAN_REQUEST"
	// Moderator turns emotes only chat off.
	ModerationActionEmotesOnlyOff ModerationAction = "EMOTES_ONLY_OFF"
	// Moderator turns chat to motes only.
	ModerationActionEmotesOnlyOn ModerationAction = "EMOTES_ONLY_ON"
	// Moderator turns followers only chat off.
	ModerationActionFollowersOnlyOff ModerationAction = "FOLLOWERS_ONLY_OFF"
	// Moderator turns chat to followers only.
	ModerationActionFollowersOnlyOn ModerationAction = "FOLLOWERS_ONLY_ON"
	// Moderator hosts another channel.
	ModerationActionHost ModerationAction = "HOST"
	// Default Action.
	ModerationActionInvalidAction ModerationAction = "INVALID_ACTION"
	// Moderator unmods a user.
	ModerationActionUnmodUser ModerationAction = "UNMOD_USER"
	// Moderator mods a user.
	ModerationActionModUser ModerationAction = "MOD_USER"
	// Moderator adds terms to Automod permitted list.
	ModerationActionPermittedTermAdd ModerationAction = "PERMITTED_TERM_ADD"
	// Moderator removes terms to Automod permitted list.
	ModerationActionPermittedTermRemove ModerationAction = "PERMITTED_TERM_REMOVE"
	// Moderator raids another channel.
	ModerationActionRaid ModerationAction = "RAID"
	// Moderator turns slow off in chat.
	ModerationActionSlowOff ModerationAction = "SLOW_OFF"
	// Moderator slows chat.
	ModerationActionSlowOn ModerationAction = "SLOW_ON"
	// Moderator turns subscribers only chat off.
	ModerationActionSubsOnlyOff ModerationAction = "SUBS_ONLY_OFF"
	// Moderator turns chat to subscribers only.
	ModerationActionSubsOnlyOn ModerationAction = "SUBS_ONLY_ON"
	// Moderator timeouts a user.
	ModerationActionTimeoutUser ModerationAction = "TIMEOUT_USER"
	// Moderator unbans a user.
	ModerationActionUnbanUser ModerationAction = "UNBAN_USER"
	// Moderator unhosts another channel.
	ModerationActionUnhost ModerationAction = "UNHOST"
	// Moderator turns unique only chat off.
	ModerationActionUniqueOff ModerationAction = "UNIQUE_OFF"
	// Moderator turns unique only chat on.
	ModerationActionUniqueOn ModerationAction = "UNIQUE_ON"
	// Moderator unraids another channel.
	ModerationActionUnraid ModerationAction = "UNRAID"
	// Moderator untimeouts a user.
	ModerationActionUntimeoutUser ModerationAction = "UNTIMEOUT_USER"
	// Moderator makes user not vip.
	ModerationActionUnvipUser ModerationAction = "UNVIP_USER"
	// Moderator makes user vip.
	ModerationActionVipUser ModerationAction = "VIP_USER"
)

var AllModerationAction = []ModerationAction{
	ModerationActionAutomodLevelChange,
	ModerationActionAllowMessage,
	ModerationActionApproveUnbanRequest,
	ModerationActionBanUser,
	ModerationActionBlockedTermAdd,
	ModerationActionBlockedTermRemove,
	ModerationActionChatClear,
	ModerationActionComment,
	ModerationActionDeleteMessage,
	ModerationActionDenyMessage,
	ModerationActionDenyUnbanRequest,
	ModerationActionEmotesOnlyOff,
	ModerationActionEmotesOnlyOn,
	ModerationActionFollowersOnlyOff,
	ModerationActionFollowersOnlyOn,
	ModerationActionHost,
	ModerationActionInvalidAction,
	ModerationActionUnmodUser,
	ModerationActionModUser,
	ModerationActionPermittedTermAdd,
	ModerationActionPermittedTermRemove,
	ModerationActionRaid,
	ModerationActionSlowOff,
	ModerationActionSlowOn,
	ModerationActionSubsOnlyOff,
	ModerationActionSubsOnlyOn,
	ModerationActionTimeoutUser,
	ModerationActionUnbanUser,
	ModerationActionUnhost,
	ModerationActionUniqueOff,
	ModerationActionUniqueOn,
	ModerationActionUnraid,
	ModerationActionUntimeoutUser,
	ModerationActionUnvipUser,
	ModerationActionVipUser,
}

func (e ModerationAction) IsValid() bool {
	switch e {
	case ModerationActionAutomodLevelChange, ModerationActionAllowMessage, ModerationActionApproveUnbanRequest, ModerationActionBanUser, ModerationActionBlockedTermAdd, ModerationActionBlockedTermRemove, ModerationActionChatClear, ModerationActionComment, ModerationActionDeleteMessage, ModerationActionDenyMessage, ModerationActionDenyUnbanRequest, ModerationActionEmotesOnlyOff, ModerationActionEmotesOnlyOn, ModerationActionFollowersOnlyOff, ModerationActionFollowersOnlyOn, ModerationActionHost, ModerationActionInvalidAction, ModerationActionUnmodUser, ModerationActionModUser, ModerationActionPermittedTermAdd, ModerationActionPermittedTermRemove, ModerationActionRaid, ModerationActionSlowOff, ModerationActionSlowOn, ModerationActionSubsOnlyOff, ModerationActionSubsOnlyOn, ModerationActionTimeoutUser, ModerationActionUnbanUser, ModerationActionUnhost, ModerationActionUniqueOff, ModerationActionUniqueOn, ModerationActionUnraid, ModerationActionUntimeoutUser, ModerationActionUnvipUser, ModerationActionVipUser:
		return true
	}
	return false
}

func (e ModerationAction) String() string {
	return string(e)
}

func (e *ModerationAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ModerationAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ModerationAction", str)
	}
	return nil
}

func (e ModerationAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible categories of developer apps.
type OAuthAppCategory string

const (
	// Game integration category.
	OAuthAppCategoryGameIntegration OAuthAppCategory = "GAME_INTEGRATION"
	// Website integration category.
	OAuthAppCategoryWebsiteIntegration OAuthAppCategory = "WEBSITE_INTEGRATION"
	// Application integration category.
	OAuthAppCategoryApplicationIntegration OAuthAppCategory = "APPLICATION_INTEGRATION"
	// Browser extension category.
	OAuthAppCategoryBrowserExtension OAuthAppCategory = "BROWSER_EXTENSION"
	// Broadcaster suite category.
	OAuthAppCategoryBroadcasterSuite OAuthAppCategory = "BROADCASTER_SUITE"
	// Chat bot category.
	OAuthAppCategoryChatBot OAuthAppCategory = "CHAT_BOT"
	// Giveaway loyalty tool category.
	OAuthAppCategoryGiveawayLoyaltyTool OAuthAppCategory = "GIVEAWAY_LOYALTY_TOOL"
	// Analytics tool category.
	OAuthAppCategoryAnalyticsTool OAuthAppCategory = "ANALYTICS_TOOL"
	// Category for when the other categories do not describe.
	OAuthAppCategoryOther OAuthAppCategory = "OTHER"
)

var AllOAuthAppCategory = []OAuthAppCategory{
	OAuthAppCategoryGameIntegration,
	OAuthAppCategoryWebsiteIntegration,
	OAuthAppCategoryApplicationIntegration,
	OAuthAppCategoryBrowserExtension,
	OAuthAppCategoryBroadcasterSuite,
	OAuthAppCategoryChatBot,
	OAuthAppCategoryGiveawayLoyaltyTool,
	OAuthAppCategoryAnalyticsTool,
	OAuthAppCategoryOther,
}

func (e OAuthAppCategory) IsValid() bool {
	switch e {
	case OAuthAppCategoryGameIntegration, OAuthAppCategoryWebsiteIntegration, OAuthAppCategoryApplicationIntegration, OAuthAppCategoryBrowserExtension, OAuthAppCategoryBroadcasterSuite, OAuthAppCategoryChatBot, OAuthAppCategoryGiveawayLoyaltyTool, OAuthAppCategoryAnalyticsTool, OAuthAppCategoryOther:
		return true
	}
	return false
}

func (e OAuthAppCategory) String() string {
	return string(e)
}

func (e *OAuthAppCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OAuthAppCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OAuthAppCategory", str)
	}
	return nil
}

func (e OAuthAppCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Deliver method type for Prime Offers entitlements.
type OfferDeliveryMethod string

const (
	// The entitlement will be delivered as a claim code, which can be used to get the entitlement.
	OfferDeliveryMethodClaimCode OfferDeliveryMethod = "CLAIM_CODE"
	// The entitlement will be directly delivered.
	OfferDeliveryMethodDirectEntitlement OfferDeliveryMethod = "DIRECT_ENTITLEMENT"
	// The entitlement will be directly delivered and a Twitch account is not needed for the offer.
	OfferDeliveryMethodSesEntitlement OfferDeliveryMethod = "SES_ENTITLEMENT"
	// Misspelling of EXTERNAL_OFFER.
	OfferDeliveryMethodExternal OfferDeliveryMethod = "EXTERNAL"
	// The entitlement will be delivered via external means.
	OfferDeliveryMethodExternalOffer OfferDeliveryMethod = "EXTERNAL_OFFER"
)

var AllOfferDeliveryMethod = []OfferDeliveryMethod{
	OfferDeliveryMethodClaimCode,
	OfferDeliveryMethodDirectEntitlement,
	OfferDeliveryMethodSesEntitlement,
	OfferDeliveryMethodExternal,
	OfferDeliveryMethodExternalOffer,
}

func (e OfferDeliveryMethod) IsValid() bool {
	switch e {
	case OfferDeliveryMethodClaimCode, OfferDeliveryMethodDirectEntitlement, OfferDeliveryMethodSesEntitlement, OfferDeliveryMethodExternal, OfferDeliveryMethodExternalOffer:
		return true
	}
	return false
}

func (e OfferDeliveryMethod) String() string {
	return string(e)
}

func (e *OfferDeliveryMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OfferDeliveryMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OfferDeliveryMethod", str)
	}
	return nil
}

func (e OfferDeliveryMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// OfferIneligibilityReasonCode indicates why a user isn't eligible.
type OfferIneligibilityReasonCode string

const (
	// Not eligible because the user has already purchased this offer.
	OfferIneligibilityReasonCodeAlreadyPurchased OfferIneligibilityReasonCode = "ALREADY_PURCHASED"
	// Not eligible because something about the transaction could not be verified.
	OfferIneligibilityReasonCodeCouldNotVerify OfferIneligibilityReasonCode = "COULD_NOT_VERIFY"
	// Offer would exceed user's max token balance.
	OfferIneligibilityReasonCodeMaxTokenBalance OfferIneligibilityReasonCode = "MAX_TOKEN_BALANCE"
	// No ineligibility reason was given.
	OfferIneligibilityReasonCodeNone OfferIneligibilityReasonCode = "NONE"
	// The reason for ineligibility could not be resolved.
	OfferIneligibilityReasonCodeOther OfferIneligibilityReasonCode = "OTHER"
)

var AllOfferIneligibilityReasonCode = []OfferIneligibilityReasonCode{
	OfferIneligibilityReasonCodeAlreadyPurchased,
	OfferIneligibilityReasonCodeCouldNotVerify,
	OfferIneligibilityReasonCodeMaxTokenBalance,
	OfferIneligibilityReasonCodeNone,
	OfferIneligibilityReasonCodeOther,
}

func (e OfferIneligibilityReasonCode) IsValid() bool {
	switch e {
	case OfferIneligibilityReasonCodeAlreadyPurchased, OfferIneligibilityReasonCodeCouldNotVerify, OfferIneligibilityReasonCodeMaxTokenBalance, OfferIneligibilityReasonCodeNone, OfferIneligibilityReasonCodeOther:
		return true
	}
	return false
}

func (e OfferIneligibilityReasonCode) String() string {
	return string(e)
}

func (e *OfferIneligibilityReasonCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OfferIneligibilityReasonCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OfferIneligibilityReasonCode", str)
	}
	return nil
}

func (e OfferIneligibilityReasonCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The platform on which the Offer is valid.
type OfferPlatform string

const (
	// The web site.
	OfferPlatformWeb OfferPlatform = "WEB"
	// The iOS app.
	OfferPlatformIos OfferPlatform = "IOS"
	// The Android app.
	OfferPlatformAndroid OfferPlatform = "ANDROID"
	// The desktop app.
	OfferPlatformDesktop OfferPlatform = "DESKTOP"
)

var AllOfferPlatform = []OfferPlatform{
	OfferPlatformWeb,
	OfferPlatformIos,
	OfferPlatformAndroid,
	OfferPlatformDesktop,
}

func (e OfferPlatform) IsValid() bool {
	switch e {
	case OfferPlatformWeb, OfferPlatformIos, OfferPlatformAndroid, OfferPlatformDesktop:
		return true
	}
	return false
}

func (e OfferPlatform) String() string {
	return string(e)
}

func (e *OfferPlatform) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OfferPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OfferPlatform", str)
	}
	return nil
}

func (e OfferPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// OfferPUrchaseType provides extra contextual details for the type of purchase.
type OfferPurchaseType string

const (
	// This offer is a default, standard purchase.
	OfferPurchaseTypeDefaultPurchase OfferPurchaseType = "DEFAULT_PURCHASE"
	// This offer being purchased will be a tier upgrade from their current active tier.
	OfferPurchaseTypeUpgradeRecurringSubTier OfferPurchaseType = "UPGRADE_RECURRING_SUB_TIER"
	// This offer being purchased will be a tier downgrade from their current active tier.
	OfferPurchaseTypeDowngradeRecurringSubTier OfferPurchaseType = "DOWNGRADE_RECURRING_SUB_TIER"
	// This offer being purchased is future-dated.
	OfferPurchaseTypeFuturePurchase OfferPurchaseType = "FUTURE_PURCHASE"
)

var AllOfferPurchaseType = []OfferPurchaseType{
	OfferPurchaseTypeDefaultPurchase,
	OfferPurchaseTypeUpgradeRecurringSubTier,
	OfferPurchaseTypeDowngradeRecurringSubTier,
	OfferPurchaseTypeFuturePurchase,
}

func (e OfferPurchaseType) IsValid() bool {
	switch e {
	case OfferPurchaseTypeDefaultPurchase, OfferPurchaseTypeUpgradeRecurringSubTier, OfferPurchaseTypeDowngradeRecurringSubTier, OfferPurchaseTypeFuturePurchase:
		return true
	}
	return false
}

func (e OfferPurchaseType) String() string {
	return string(e)
}

func (e *OfferPurchaseType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OfferPurchaseType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OfferPurchaseType", str)
	}
	return nil
}

func (e OfferPurchaseType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Determines where the notification will be displayed at front end.
type OnsiteNotificationDisplayType string

const (
	// Notifications that will be displayed in the "My Twitch" tab.
	OnsiteNotificationDisplayTypeViewer OnsiteNotificationDisplayType = "VIEWER"
	// Notifications that will be displayed in the "My Channel" tab.
	OnsiteNotificationDisplayTypeCreator OnsiteNotificationDisplayType = "CREATOR"
)

var AllOnsiteNotificationDisplayType = []OnsiteNotificationDisplayType{
	OnsiteNotificationDisplayTypeViewer,
	OnsiteNotificationDisplayTypeCreator,
}

func (e OnsiteNotificationDisplayType) IsValid() bool {
	switch e {
	case OnsiteNotificationDisplayTypeViewer, OnsiteNotificationDisplayTypeCreator:
		return true
	}
	return false
}

func (e OnsiteNotificationDisplayType) String() string {
	return string(e)
}

func (e *OnsiteNotificationDisplayType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OnsiteNotificationDisplayType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OnsiteNotificationDisplayType", str)
	}
	return nil
}

func (e OnsiteNotificationDisplayType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Used to determine how to render the onsite notification.
type OnsiteNotificationRenderStyle string

const (
	// The default render style with no buttons and a single click CTA.
	OnsiteNotificationRenderStyleDefault OnsiteNotificationRenderStyle = "DEFAULT"
	// Rendered with two CTA buttons.
	OnsiteNotificationRenderStyleTwoButtons OnsiteNotificationRenderStyle = "TWO_BUTTONS"
)

var AllOnsiteNotificationRenderStyle = []OnsiteNotificationRenderStyle{
	OnsiteNotificationRenderStyleDefault,
	OnsiteNotificationRenderStyleTwoButtons,
}

func (e OnsiteNotificationRenderStyle) IsValid() bool {
	switch e {
	case OnsiteNotificationRenderStyleDefault, OnsiteNotificationRenderStyleTwoButtons:
		return true
	}
	return false
}

func (e OnsiteNotificationRenderStyle) String() string {
	return string(e)
}

func (e *OnsiteNotificationRenderStyle) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OnsiteNotificationRenderStyle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OnsiteNotificationRenderStyle", str)
	}
	return nil
}

func (e OnsiteNotificationRenderStyle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Capabilities that a mobile client has for displaying onsite notifications.
type OnsiteNotificationsCapability string

const (
	// Mobile destination type Homepage.
	OnsiteNotificationsCapabilityHomepage OnsiteNotificationsCapability = "HOMEPAGE"
	// Mobile destination type ChannelPage.
	OnsiteNotificationsCapabilityChannelPage OnsiteNotificationsCapability = "CHANNEL_PAGE"
	// Mobile destination type NotificationSettingsPage.
	OnsiteNotificationsCapabilityNotificationSettingsPage OnsiteNotificationsCapability = "NOTIFICATION_SETTINGS_PAGE"
	// Mobile destination type BroadcasterDashboard.
	OnsiteNotificationsCapabilityBroadcasterDashboard OnsiteNotificationsCapability = "BROADCASTER_DASHBOARD"
	// Mobile destination type BrowseGame.
	OnsiteNotificationsCapabilityBrowseGame OnsiteNotificationsCapability = "BROWSE_GAME"
	// Mobile destination type ExternalLink.
	OnsiteNotificationsCapabilityExternalLink OnsiteNotificationsCapability = "EXTERNAL_LINK"
	// Mobile destination type WebOnly.
	OnsiteNotificationsCapabilityWebOnly OnsiteNotificationsCapability = "WEB_ONLY"
	// Mobile destination type WhisperThread.
	OnsiteNotificationsCapabilityWhisperThread OnsiteNotificationsCapability = "WHISPER_THREAD"
	// Mobile destination type FriendRequest.
	OnsiteNotificationsCapabilityFriendRequest OnsiteNotificationsCapability = "FRIEND_REQUEST"
	// Pushy notification type hotclip.
	OnsiteNotificationsCapabilityHotClip OnsiteNotificationsCapability = "HOT_CLIP"
	// Pushy notification type hotclipfollower.
	OnsiteNotificationsCapabilityHotClipFollower OnsiteNotificationsCapability = "HOT_CLIP_FOLLOWER"
	// Pushy notification type vodupload.
	OnsiteNotificationsCapabilityVodUpload OnsiteNotificationsCapability = "VOD_UPLOAD"
	// Pushy notification type vodcomment.
	OnsiteNotificationsCapabilityVodComment OnsiteNotificationsCapability = "VOD_COMMENT"
	// Pushy notification type vodcommentmod.
	OnsiteNotificationsCapabilityVodCommentMod OnsiteNotificationsCapability = "VOD_COMMENT_MOD"
	// Pushy notification type vodcommentreply.
	OnsiteNotificationsCapabilityVodCommentReply OnsiteNotificationsCapability = "VOD_COMMENT_REPLY"
	// Pushy notification type subgiftreceived.
	OnsiteNotificationsCapabilitySubGiftReceived OnsiteNotificationsCapability = "SUB_GIFT_RECEIVED"
	// Pushy notification type dropsavailable.
	OnsiteNotificationsCapabilityDropsAvailable OnsiteNotificationsCapability = "DROPS_AVAILABLE"
	// Pushy notification type communityguidelineschange.
	OnsiteNotificationsCapabilityCommunityGUIDElinesChange OnsiteNotificationsCapability = "COMMUNITY_GUIDELINES_CHANGE"
	// Pushy notification type smartannouncement.
	OnsiteNotificationsCapabilitySmartAnnouncement OnsiteNotificationsCapability = "SMART_ANNOUNCEMENT"
	// Pushy notification type affiliateinvite.
	OnsiteNotificationsCapabilityAffiliateInvite OnsiteNotificationsCapability = "AFFILIATE_INVITE"
)

var AllOnsiteNotificationsCapability = []OnsiteNotificationsCapability{
	OnsiteNotificationsCapabilityHomepage,
	OnsiteNotificationsCapabilityChannelPage,
	OnsiteNotificationsCapabilityNotificationSettingsPage,
	OnsiteNotificationsCapabilityBroadcasterDashboard,
	OnsiteNotificationsCapabilityBrowseGame,
	OnsiteNotificationsCapabilityExternalLink,
	OnsiteNotificationsCapabilityWebOnly,
	OnsiteNotificationsCapabilityWhisperThread,
	OnsiteNotificationsCapabilityFriendRequest,
	OnsiteNotificationsCapabilityHotClip,
	OnsiteNotificationsCapabilityHotClipFollower,
	OnsiteNotificationsCapabilityVodUpload,
	OnsiteNotificationsCapabilityVodComment,
	OnsiteNotificationsCapabilityVodCommentMod,
	OnsiteNotificationsCapabilityVodCommentReply,
	OnsiteNotificationsCapabilitySubGiftReceived,
	OnsiteNotificationsCapabilityDropsAvailable,
	OnsiteNotificationsCapabilityCommunityGUIDElinesChange,
	OnsiteNotificationsCapabilitySmartAnnouncement,
	OnsiteNotificationsCapabilityAffiliateInvite,
}

func (e OnsiteNotificationsCapability) IsValid() bool {
	switch e {
	case OnsiteNotificationsCapabilityHomepage, OnsiteNotificationsCapabilityChannelPage, OnsiteNotificationsCapabilityNotificationSettingsPage, OnsiteNotificationsCapabilityBroadcasterDashboard, OnsiteNotificationsCapabilityBrowseGame, OnsiteNotificationsCapabilityExternalLink, OnsiteNotificationsCapabilityWebOnly, OnsiteNotificationsCapabilityWhisperThread, OnsiteNotificationsCapabilityFriendRequest, OnsiteNotificationsCapabilityHotClip, OnsiteNotificationsCapabilityHotClipFollower, OnsiteNotificationsCapabilityVodUpload, OnsiteNotificationsCapabilityVodComment, OnsiteNotificationsCapabilityVodCommentMod, OnsiteNotificationsCapabilityVodCommentReply, OnsiteNotificationsCapabilitySubGiftReceived, OnsiteNotificationsCapabilityDropsAvailable, OnsiteNotificationsCapabilityCommunityGUIDElinesChange, OnsiteNotificationsCapabilitySmartAnnouncement, OnsiteNotificationsCapabilityAffiliateInvite:
		return true
	}
	return false
}

func (e OnsiteNotificationsCapability) String() string {
	return string(e)
}

func (e *OnsiteNotificationsCapability) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OnsiteNotificationsCapability(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OnsiteNotificationsCapability", str)
	}
	return nil
}

func (e OnsiteNotificationsCapability) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of company applications.
type OrganizationAppilcationStatus string

const (
	// Application is pending.
	OrganizationAppilcationStatusPending OrganizationAppilcationStatus = "PENDING"
	// Application has been rejected.
	OrganizationAppilcationStatusRejected OrganizationAppilcationStatus = "REJECTED"
	// Application has been approved.
	OrganizationAppilcationStatusApproved OrganizationAppilcationStatus = "APPROVED"
	// Application has been deleted.
	OrganizationAppilcationStatusDeleted OrganizationAppilcationStatus = "DELETED"
)

var AllOrganizationAppilcationStatus = []OrganizationAppilcationStatus{
	OrganizationAppilcationStatusPending,
	OrganizationAppilcationStatusRejected,
	OrganizationAppilcationStatusApproved,
	OrganizationAppilcationStatusDeleted,
}

func (e OrganizationAppilcationStatus) IsValid() bool {
	switch e {
	case OrganizationAppilcationStatusPending, OrganizationAppilcationStatusRejected, OrganizationAppilcationStatusApproved, OrganizationAppilcationStatusDeleted:
		return true
	}
	return false
}

func (e OrganizationAppilcationStatus) String() string {
	return string(e)
}

func (e *OrganizationAppilcationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationAppilcationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationAppilcationStatus", str)
	}
	return nil
}

func (e OrganizationAppilcationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Role for an organization member.
type OrganizationMemberRole string

const (
	// Adiministrator role.
	OrganizationMemberRoleAdministrator OrganizationMemberRole = "ADMINISTRATOR"
	// Developer role.
	OrganizationMemberRoleDeveloper OrganizationMemberRole = "DEVELOPER"
	// Manager role.
	OrganizationMemberRoleManager OrganizationMemberRole = "MANAGER"
	// Marketer role.
	OrganizationMemberRoleMarketer OrganizationMemberRole = "MARKETER"
	// Owner Role.
	OrganizationMemberRoleOwner OrganizationMemberRole = "OWNER"
	// Billing Manager Role.
	OrganizationMemberRoleBillingManager OrganizationMemberRole = "BILLING_MANAGER"
	// Shadow Account Role.
	OrganizationMemberRoleShadowAccount OrganizationMemberRole = "SHADOW_ACCOUNT"
)

var AllOrganizationMemberRole = []OrganizationMemberRole{
	OrganizationMemberRoleAdministrator,
	OrganizationMemberRoleDeveloper,
	OrganizationMemberRoleManager,
	OrganizationMemberRoleMarketer,
	OrganizationMemberRoleOwner,
	OrganizationMemberRoleBillingManager,
	OrganizationMemberRoleShadowAccount,
}

func (e OrganizationMemberRole) IsValid() bool {
	switch e {
	case OrganizationMemberRoleAdministrator, OrganizationMemberRoleDeveloper, OrganizationMemberRoleManager, OrganizationMemberRoleMarketer, OrganizationMemberRoleOwner, OrganizationMemberRoleBillingManager, OrganizationMemberRoleShadowAccount:
		return true
	}
	return false
}

func (e OrganizationMemberRole) String() string {
	return string(e)
}

func (e *OrganizationMemberRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationMemberRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationMemberRole", str)
	}
	return nil
}

func (e OrganizationMemberRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of work an organization does.
type OrganizationType string

const (
	// Organization that developes games.
	OrganizationTypeGameDeveloper OrganizationType = "GAME_DEVELOPER"
	// Organization that publishes games.
	OrganizationTypeGamePublisher OrganizationType = "GAME_PUBLISHER"
	// Organization that does other work.
	OrganizationTypeOther OrganizationType = "OTHER"
	// Organization that works in brands/advertsing.
	OrganizationTypeBrandsAdvertising OrganizationType = "BRANDS_ADVERTISING"
	// Organization that works with broadcaster tools.
	OrganizationTypeBroadcasterTools OrganizationType = "BROADCASTER_TOOLS"
)

var AllOrganizationType = []OrganizationType{
	OrganizationTypeGameDeveloper,
	OrganizationTypeGamePublisher,
	OrganizationTypeOther,
	OrganizationTypeBrandsAdvertising,
	OrganizationTypeBroadcasterTools,
}

func (e OrganizationType) IsValid() bool {
	switch e {
	case OrganizationTypeGameDeveloper, OrganizationTypeGamePublisher, OrganizationTypeOther, OrganizationTypeBrandsAdvertising, OrganizationTypeBroadcasterTools:
		return true
	}
	return false
}

func (e OrganizationType) String() string {
	return string(e)
}

func (e *OrganizationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationType", str)
	}
	return nil
}

func (e OrganizationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// PanelType is the kind of panel.
type PanelType string

const (
	// DEFAULT panels contain one or more of the content values in `Panel` to display.
	PanelTypeDefault PanelType = "DEFAULT"
	// EXTENSION panels are placeholders for extension content.
	PanelTypeExtension PanelType = "EXTENSION"
)

var AllPanelType = []PanelType{
	PanelTypeDefault,
	PanelTypeExtension,
}

func (e PanelType) IsValid() bool {
	switch e {
	case PanelTypeDefault, PanelTypeExtension:
		return true
	}
	return false
}

func (e PanelType) String() string {
	return string(e)
}

func (e *PanelType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PanelType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PanelType", str)
	}
	return nil
}

func (e PanelType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// PasswordStatus determines the current state of the users password.
type PasswordStatus string

const (
	// The users password has never been evaluated.
	PasswordStatusNotEvaluated PasswordStatus = "NOT_EVALUATED"
	// The users password meets requirements.
	PasswordStatusValid PasswordStatus = "VALID"
	// The users password does not meet requirements.
	PasswordStatusInvalid PasswordStatus = "INVALID"
	// Unknown password status.
	PasswordStatusUnknown PasswordStatus = "UNKNOWN"
)

var AllPasswordStatus = []PasswordStatus{
	PasswordStatusNotEvaluated,
	PasswordStatusValid,
	PasswordStatusInvalid,
	PasswordStatusUnknown,
}

func (e PasswordStatus) IsValid() bool {
	switch e {
	case PasswordStatusNotEvaluated, PasswordStatusValid, PasswordStatusInvalid, PasswordStatusUnknown:
		return true
	}
	return false
}

func (e PasswordStatus) String() string {
	return string(e)
}

func (e *PasswordStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PasswordStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PasswordStatus", str)
	}
	return nil
}

func (e PasswordStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Which possible treatments the user can get for their pay it forward private callout.
type PayItForwardTreatmentType string

const (
	// Thank treatment.
	PayItForwardTreatmentTypeThank PayItForwardTreatmentType = "THANK"
	// Gift treatment.
	PayItForwardTreatmentTypeGift PayItForwardTreatmentType = "GIFT"
)

var AllPayItForwardTreatmentType = []PayItForwardTreatmentType{
	PayItForwardTreatmentTypeThank,
	PayItForwardTreatmentTypeGift,
}

func (e PayItForwardTreatmentType) IsValid() bool {
	switch e {
	case PayItForwardTreatmentTypeThank, PayItForwardTreatmentTypeGift:
		return true
	}
	return false
}

func (e PayItForwardTreatmentType) String() string {
	return string(e)
}

func (e *PayItForwardTreatmentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PayItForwardTreatmentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PayItForwardTreatmentType", str)
	}
	return nil
}

func (e PayItForwardTreatmentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of credit cards supported.
type PaymentCardType string

const (
	// Visa.
	PaymentCardTypeVisa PaymentCardType = "VISA"
	// Mastercard.
	PaymentCardTypeMastercard PaymentCardType = "MASTERCARD"
	// American Express.
	PaymentCardTypeAmericanExpress PaymentCardType = "AMERICAN_EXPRESS"
	// Discover.
	PaymentCardTypeDiscover PaymentCardType = "DISCOVER"
)

var AllPaymentCardType = []PaymentCardType{
	PaymentCardTypeVisa,
	PaymentCardTypeMastercard,
	PaymentCardTypeAmericanExpress,
	PaymentCardTypeDiscover,
}

func (e PaymentCardType) IsValid() bool {
	switch e {
	case PaymentCardTypeVisa, PaymentCardTypeMastercard, PaymentCardTypeAmericanExpress, PaymentCardTypeDiscover:
		return true
	}
	return false
}

func (e PaymentCardType) String() string {
	return string(e)
}

func (e *PaymentCardType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentCardType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentCardType", str)
	}
	return nil
}

func (e PaymentCardType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Payment instrument used through the payment provider.
type PaymentInstrumentType string

const (
	// Credit or debit card.
	PaymentInstrumentTypeCreditCard PaymentInstrumentType = "CREDIT_CARD"
	// Pay with Amazon.
	PaymentInstrumentTypeAmazon PaymentInstrumentType = "AMAZON"
	// Pay with Paypal.
	PaymentInstrumentTypePaypal PaymentInstrumentType = "PAYPAL"
	// Pay with Google In-App Billing.
	PaymentInstrumentTypeGoogleIab PaymentInstrumentType = "GOOGLE_IAB"
	// Pay with Apple In-App Purchase.
	PaymentInstrumentTypeAppleIap PaymentInstrumentType = "APPLE_IAP"
	// Xsolla only.
	PaymentInstrumentTypeSkrill PaymentInstrumentType = "SKRILL"
	// Xsolla only.
	PaymentInstrumentTypeYandex PaymentInstrumentType = "YANDEX"
	// Xsolla only.
	PaymentInstrumentTypeWebmoney PaymentInstrumentType = "WEBMONEY"
	// Xsolla default.
	PaymentInstrumentTypeUnknown PaymentInstrumentType = "UNKNOWN"
	// Pay with Wallet.
	PaymentInstrumentTypeWallet PaymentInstrumentType = "WALLET"
	// Pay with bank account.
	PaymentInstrumentTypeDirectDebit PaymentInstrumentType = "DIRECT_DEBIT"
)

var AllPaymentInstrumentType = []PaymentInstrumentType{
	PaymentInstrumentTypeCreditCard,
	PaymentInstrumentTypeAmazon,
	PaymentInstrumentTypePaypal,
	PaymentInstrumentTypeGoogleIab,
	PaymentInstrumentTypeAppleIap,
	PaymentInstrumentTypeSkrill,
	PaymentInstrumentTypeYandex,
	PaymentInstrumentTypeWebmoney,
	PaymentInstrumentTypeUnknown,
	PaymentInstrumentTypeWallet,
	PaymentInstrumentTypeDirectDebit,
}

func (e PaymentInstrumentType) IsValid() bool {
	switch e {
	case PaymentInstrumentTypeCreditCard, PaymentInstrumentTypeAmazon, PaymentInstrumentTypePaypal, PaymentInstrumentTypeGoogleIab, PaymentInstrumentTypeAppleIap, PaymentInstrumentTypeSkrill, PaymentInstrumentTypeYandex, PaymentInstrumentTypeWebmoney, PaymentInstrumentTypeUnknown, PaymentInstrumentTypeWallet, PaymentInstrumentTypeDirectDebit:
		return true
	}
	return false
}

func (e PaymentInstrumentType) String() string {
	return string(e)
}

func (e *PaymentInstrumentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentInstrumentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentInstrumentType", str)
	}
	return nil
}

func (e PaymentInstrumentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The list of availability statuses for a payment method.
type PaymentMethodAvailabilityStatus string

const (
	// Available status.
	PaymentMethodAvailabilityStatusAvailable PaymentMethodAvailabilityStatus = "AVAILABLE"
	// Degraded status.
	PaymentMethodAvailabilityStatusDegraded PaymentMethodAvailabilityStatus = "DEGRADED"
	// Full outage status.
	PaymentMethodAvailabilityStatusFullOutage PaymentMethodAvailabilityStatus = "FULL_OUTAGE"
)

var AllPaymentMethodAvailabilityStatus = []PaymentMethodAvailabilityStatus{
	PaymentMethodAvailabilityStatusAvailable,
	PaymentMethodAvailabilityStatusDegraded,
	PaymentMethodAvailabilityStatusFullOutage,
}

func (e PaymentMethodAvailabilityStatus) IsValid() bool {
	switch e {
	case PaymentMethodAvailabilityStatusAvailable, PaymentMethodAvailabilityStatusDegraded, PaymentMethodAvailabilityStatusFullOutage:
		return true
	}
	return false
}

func (e PaymentMethodAvailabilityStatus) String() string {
	return string(e)
}

func (e *PaymentMethodAvailabilityStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentMethodAvailabilityStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentMethodAvailabilityStatus", str)
	}
	return nil
}

func (e PaymentMethodAvailabilityStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of payment providers.
type PaymentProvider string

const (
	// Unknown payment provider.
	PaymentProviderUnknown PaymentProvider = "UNKNOWN"
	// (Deprecated) Paypal payment provider now a payment method provided by Recurly.
	PaymentProviderPaypal PaymentProvider = "PAYPAL"
	// (Deprecated) Paypal payment provider.
	PaymentProviderPaypalRt PaymentProvider = "PAYPAL_RT"
	// Recurly payment provider, allows payments with credit card, amazon, paypal.
	PaymentProviderRecurly PaymentProvider = "RECURLY"
	// Xsolla payment provider, usually provides Iframe for users to go through checkout process.
	PaymentProviderXsolla PaymentProvider = "XSOLLA"
	// (Deprecated) Xsolla payment provider, usually provides Iframe for users to go through checkout process.
	PaymentProviderXsollaV3 PaymentProvider = "XSOLLA_V3"
	// Zuora payment provider, supports credit card payments.
	PaymentProviderZuora PaymentProvider = "ZUORA"
	// Twitch Prime used to buy product on Twitch.
	PaymentProviderPrime PaymentProvider = "PRIME"
	// Google In-App Billing, for Android transactions.
	PaymentProviderGoogleIab PaymentProvider = "GOOGLE_IAB"
	// Apple In-App Purchases for iOS transactions.
	PaymentProviderAppleIap PaymentProvider = "APPLE_IAP"
	// Sub tokens, which can be redeemed for channel subscriptions.
	PaymentProviderSubToken PaymentProvider = "SUB_TOKEN"
)

var AllPaymentProvider = []PaymentProvider{
	PaymentProviderUnknown,
	PaymentProviderPaypal,
	PaymentProviderPaypalRt,
	PaymentProviderRecurly,
	PaymentProviderXsolla,
	PaymentProviderXsollaV3,
	PaymentProviderZuora,
	PaymentProviderPrime,
	PaymentProviderGoogleIab,
	PaymentProviderAppleIap,
	PaymentProviderSubToken,
}

func (e PaymentProvider) IsValid() bool {
	switch e {
	case PaymentProviderUnknown, PaymentProviderPaypal, PaymentProviderPaypalRt, PaymentProviderRecurly, PaymentProviderXsolla, PaymentProviderXsollaV3, PaymentProviderZuora, PaymentProviderPrime, PaymentProviderGoogleIab, PaymentProviderAppleIap, PaymentProviderSubToken:
		return true
	}
	return false
}

func (e PaymentProvider) String() string {
	return string(e)
}

func (e *PaymentProvider) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentProvider", str)
	}
	return nil
}

func (e PaymentProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The payment scheme supported.
type PaymentScheme string

const (
	// SEPA.
	PaymentSchemeSepa PaymentScheme = "SEPA"
	// BACS.
	PaymentSchemeBacs PaymentScheme = "BACS"
)

var AllPaymentScheme = []PaymentScheme{
	PaymentSchemeSepa,
	PaymentSchemeBacs,
}

func (e PaymentScheme) IsValid() bool {
	switch e {
	case PaymentSchemeSepa, PaymentSchemeBacs:
		return true
	}
	return false
}

func (e PaymentScheme) String() string {
	return string(e)
}

func (e *PaymentScheme) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentScheme(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentScheme", str)
	}
	return nil
}

func (e PaymentScheme) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible sort orders for lists of payment transactions.
type PaymentTransactionSort string

const (
	// Sort the payment transactions descending by price.
	PaymentTransactionSortPriceDesc PaymentTransactionSort = "PRICE_DESC"
	// Sort the payment transactions ascending by price.
	PaymentTransactionSortPriceAsc PaymentTransactionSort = "PRICE_ASC"
	// Sort by purchase date descending.
	PaymentTransactionSortPurchaseDateDesc PaymentTransactionSort = "PURCHASE_DATE_DESC"
	// Sort by purchase date ascending.
	PaymentTransactionSortPurchaseDateAsc PaymentTransactionSort = "PURCHASE_DATE_ASC"
)

var AllPaymentTransactionSort = []PaymentTransactionSort{
	PaymentTransactionSortPriceDesc,
	PaymentTransactionSortPriceAsc,
	PaymentTransactionSortPurchaseDateDesc,
	PaymentTransactionSortPurchaseDateAsc,
}

func (e PaymentTransactionSort) IsValid() bool {
	switch e {
	case PaymentTransactionSortPriceDesc, PaymentTransactionSortPriceAsc, PaymentTransactionSortPurchaseDateDesc, PaymentTransactionSortPurchaseDateAsc:
		return true
	}
	return false
}

func (e PaymentTransactionSort) String() string {
	return string(e)
}

func (e *PaymentTransactionSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentTransactionSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentTransactionSort", str)
	}
	return nil
}

func (e PaymentTransactionSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Payment transaction type.
type PaymentTransactionType string

const (
	// Transaction for a subscription type.
	PaymentTransactionTypeSubscription PaymentTransactionType = "SUBSCRIPTION"
	// Transaction for a bits type.
	PaymentTransactionTypeBits PaymentTransactionType = "BITS"
	// Transaction for a sub token.
	PaymentTransactionTypeSubToken PaymentTransactionType = "SUB_TOKEN"
	// Transaction for gift cards.
	PaymentTransactionTypeGiftCard PaymentTransactionType = "GIFT_CARD"
	// Transaction for celebration.
	PaymentTransactionTypeCelebration PaymentTransactionType = "CELEBRATION"
	// Transaction for an unknown type.
	PaymentTransactionTypeUnknown PaymentTransactionType = "UNKNOWN"
)

var AllPaymentTransactionType = []PaymentTransactionType{
	PaymentTransactionTypeSubscription,
	PaymentTransactionTypeBits,
	PaymentTransactionTypeSubToken,
	PaymentTransactionTypeGiftCard,
	PaymentTransactionTypeCelebration,
	PaymentTransactionTypeUnknown,
}

func (e PaymentTransactionType) IsValid() bool {
	switch e {
	case PaymentTransactionTypeSubscription, PaymentTransactionTypeBits, PaymentTransactionTypeSubToken, PaymentTransactionTypeGiftCard, PaymentTransactionTypeCelebration, PaymentTransactionTypeUnknown:
		return true
	}
	return false
}

func (e PaymentTransactionType) String() string {
	return string(e)
}

func (e *PaymentTransactionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentTransactionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentTransactionType", str)
	}
	return nil
}

func (e PaymentTransactionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Select the kind of transactions.
type PaymentTransactionTypeFilter string

const (
	// Only return payment transactions that associated with subscription products.
	PaymentTransactionTypeFilterSubscriptions PaymentTransactionTypeFilter = "SUBSCRIPTIONS"
	// Only return payment transactions that are associated with subtoken purchases and redemptions.
	PaymentTransactionTypeFilterSubToken PaymentTransactionTypeFilter = "SUB_TOKEN"
	// The default filter (no filter).
	PaymentTransactionTypeFilterAll PaymentTransactionTypeFilter = "ALL"
)

var AllPaymentTransactionTypeFilter = []PaymentTransactionTypeFilter{
	PaymentTransactionTypeFilterSubscriptions,
	PaymentTransactionTypeFilterSubToken,
	PaymentTransactionTypeFilterAll,
}

func (e PaymentTransactionTypeFilter) IsValid() bool {
	switch e {
	case PaymentTransactionTypeFilterSubscriptions, PaymentTransactionTypeFilterSubToken, PaymentTransactionTypeFilterAll:
		return true
	}
	return false
}

func (e PaymentTransactionTypeFilter) String() string {
	return string(e)
}

func (e *PaymentTransactionTypeFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentTransactionTypeFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentTransactionTypeFilter", str)
	}
	return nil
}

func (e PaymentTransactionTypeFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumerates valid payout categories.
type PayoutCategory string

const (
	// Assigned if the user has a payout plan for the affiliate program.
	PayoutCategoryAffiliate PayoutCategory = "AFFILIATE"
	// Assigned if the user has a payout plan for the extensions developer program.
	PayoutCategoryExtensionsDeveloper PayoutCategory = "EXTENSIONS_DEVELOPER"
	// Assigned if the user has a payout plan for the partner program.
	PayoutCategoryPartner PayoutCategory = "PARTNER"
)

var AllPayoutCategory = []PayoutCategory{
	PayoutCategoryAffiliate,
	PayoutCategoryExtensionsDeveloper,
	PayoutCategoryPartner,
}

func (e PayoutCategory) IsValid() bool {
	switch e {
	case PayoutCategoryAffiliate, PayoutCategoryExtensionsDeveloper, PayoutCategoryPartner:
		return true
	}
	return false
}

func (e PayoutCategory) String() string {
	return string(e)
}

func (e *PayoutCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PayoutCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PayoutCategory", str)
	}
	return nil
}

func (e PayoutCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// PayoutOnboardingCategory enumerates valid categories for payout onboarding.
type PayoutOnboardingCategory string

const (
	// Assigned for payout onboarding flows to enroll a user into the affiliate program.
	PayoutOnboardingCategoryAffiliate PayoutOnboardingCategory = "AFFILIATE"
	// Assigned for payout onboarding flows to enroll a user into the partner program with the "standard" payout plan.
	PayoutOnboardingCategoryStandardPartner PayoutOnboardingCategory = "STANDARD_PARTNER"
	// Assigned for payout onboarding flows to enroll a user into the partner program with the "premium" payout plan.
	PayoutOnboardingCategoryPremiumPartner PayoutOnboardingCategory = "PREMIUM_PARTNER"
	// Assigned for payout onboarding flows to enroll a user into the partner program with a "custom" payout plan.
	PayoutOnboardingCategoryCustomPartner PayoutOnboardingCategory = "CUSTOM_PARTNER"
	// Assigned for payout onboarding flows to enroll a user into the extensions developer program.
	PayoutOnboardingCategoryExtensionsDeveloper PayoutOnboardingCategory = "EXTENSIONS_DEVELOPER"
	// Assigned for payout onboarding flows to enroll a user into an unpaid partner program.
	PayoutOnboardingCategoryUnpaidPartner PayoutOnboardingCategory = "UNPAID_PARTNER"
)

var AllPayoutOnboardingCategory = []PayoutOnboardingCategory{
	PayoutOnboardingCategoryAffiliate,
	PayoutOnboardingCategoryStandardPartner,
	PayoutOnboardingCategoryPremiumPartner,
	PayoutOnboardingCategoryCustomPartner,
	PayoutOnboardingCategoryExtensionsDeveloper,
	PayoutOnboardingCategoryUnpaidPartner,
}

func (e PayoutOnboardingCategory) IsValid() bool {
	switch e {
	case PayoutOnboardingCategoryAffiliate, PayoutOnboardingCategoryStandardPartner, PayoutOnboardingCategoryPremiumPartner, PayoutOnboardingCategoryCustomPartner, PayoutOnboardingCategoryExtensionsDeveloper, PayoutOnboardingCategoryUnpaidPartner:
		return true
	}
	return false
}

func (e PayoutOnboardingCategory) String() string {
	return string(e)
}

func (e *PayoutOnboardingCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PayoutOnboardingCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PayoutOnboardingCategory", str)
	}
	return nil
}

func (e PayoutOnboardingCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// PayoutOnboardingStep enumerates valid payout onboarding steps.
type PayoutOnboardingStep string

const (
	// User needs to complete their registration step.
	PayoutOnboardingStepRegistrationNotStarted PayoutOnboardingStep = "REGISTRATION_NOT_STARTED"
	// User needs to agree to their payout agreement.
	PayoutOnboardingStepAgreementNotStarted PayoutOnboardingStep = "AGREEMENT_NOT_STARTED"
	// User needs to submit their royalty tax interview.
	PayoutOnboardingStepRoyaltyTaxInterviewNotStarted PayoutOnboardingStep = "ROYALTY_TAX_INTERVIEW_NOT_STARTED"
	// User submitted their royalty tax interview and is waiting for it to be accepted.
	PayoutOnboardingStepRoyaltyTaxInterviewPending PayoutOnboardingStep = "ROYALTY_TAX_INTERVIEW_PENDING"
	// User submitted their royalty tax interview but additional action by the user is required before completion.
	PayoutOnboardingStepRoyaltyTaxInterviewActionRequired PayoutOnboardingStep = "ROYALTY_TAX_INTERVIEW_ACTION_REQUIRED"
	// User submitted their royalty tax interview and received mismatch errors.
	PayoutOnboardingStepRoyaltyTaxInterviewMismatch PayoutOnboardingStep = "ROYALTY_TAX_INTERVIEW_MISMATCH"
	// User submitted their royalty tax interview and received errors while it was processed.
	PayoutOnboardingStepRoyaltyTaxInterviewFailed PayoutOnboardingStep = "ROYALTY_TAX_INTERVIEW_FAILED"
	// User has completed their royalty tax interview and needs to complete their service tax interview.
	PayoutOnboardingStepServiceTaxInterviewNotStarted PayoutOnboardingStep = "SERVICE_TAX_INTERVIEW_NOT_STARTED"
	// User submitted their service tax interview and is waiting for it to be accepted.
	PayoutOnboardingStepServiceTaxInterviewPending PayoutOnboardingStep = "SERVICE_TAX_INTERVIEW_PENDING"
	// User submitted their service tax interview but additional action by the user is required before completion.
	PayoutOnboardingStepServiceTaxInterviewActionRequired PayoutOnboardingStep = "SERVICE_TAX_INTERVIEW_ACTION_REQUIRED"
	// User submitted their service tax interview and received mismatch errors.
	PayoutOnboardingStepServiceTaxInterviewMismatch PayoutOnboardingStep = "SERVICE_TAX_INTERVIEW_MISMATCH"
	// User submitted their service tax interview and received errors while it was processed.
	PayoutOnboardingStepServiceTaxInterviewFailed PayoutOnboardingStep = "SERVICE_TAX_INTERVIEW_FAILED"
	// User neeeds to setup how they want to get paid out.
	PayoutOnboardingStepPayoutMethodNotStarted PayoutOnboardingStep = "PAYOUT_METHOD_NOT_STARTED"
	// User submitted their payout method and is waiting for it to be accepted.
	PayoutOnboardingStepPayoutMethodPending PayoutOnboardingStep = "PAYOUT_METHOD_PENDING"
	// User is waiting for a final approval from the payout onboarding reviewers.
	PayoutOnboardingStepReviewPending PayoutOnboardingStep = "REVIEW_PENDING"
	// User has completed their payout onboarding.
	PayoutOnboardingStepCompleted PayoutOnboardingStep = "COMPLETED"
	// User has canceled their payout onboarding workflow.
	PayoutOnboardingStepCanceled PayoutOnboardingStep = "CANCELED"
	// User has a pending upgrade to their payout agreement.
	PayoutOnboardingStepAgreementPendingUpgrade PayoutOnboardingStep = "AGREEMENT_PENDING_UPGRADE"
)

var AllPayoutOnboardingStep = []PayoutOnboardingStep{
	PayoutOnboardingStepRegistrationNotStarted,
	PayoutOnboardingStepAgreementNotStarted,
	PayoutOnboardingStepRoyaltyTaxInterviewNotStarted,
	PayoutOnboardingStepRoyaltyTaxInterviewPending,
	PayoutOnboardingStepRoyaltyTaxInterviewActionRequired,
	PayoutOnboardingStepRoyaltyTaxInterviewMismatch,
	PayoutOnboardingStepRoyaltyTaxInterviewFailed,
	PayoutOnboardingStepServiceTaxInterviewNotStarted,
	PayoutOnboardingStepServiceTaxInterviewPending,
	PayoutOnboardingStepServiceTaxInterviewActionRequired,
	PayoutOnboardingStepServiceTaxInterviewMismatch,
	PayoutOnboardingStepServiceTaxInterviewFailed,
	PayoutOnboardingStepPayoutMethodNotStarted,
	PayoutOnboardingStepPayoutMethodPending,
	PayoutOnboardingStepReviewPending,
	PayoutOnboardingStepCompleted,
	PayoutOnboardingStepCanceled,
	PayoutOnboardingStepAgreementPendingUpgrade,
}

func (e PayoutOnboardingStep) IsValid() bool {
	switch e {
	case PayoutOnboardingStepRegistrationNotStarted, PayoutOnboardingStepAgreementNotStarted, PayoutOnboardingStepRoyaltyTaxInterviewNotStarted, PayoutOnboardingStepRoyaltyTaxInterviewPending, PayoutOnboardingStepRoyaltyTaxInterviewActionRequired, PayoutOnboardingStepRoyaltyTaxInterviewMismatch, PayoutOnboardingStepRoyaltyTaxInterviewFailed, PayoutOnboardingStepServiceTaxInterviewNotStarted, PayoutOnboardingStepServiceTaxInterviewPending, PayoutOnboardingStepServiceTaxInterviewActionRequired, PayoutOnboardingStepServiceTaxInterviewMismatch, PayoutOnboardingStepServiceTaxInterviewFailed, PayoutOnboardingStepPayoutMethodNotStarted, PayoutOnboardingStepPayoutMethodPending, PayoutOnboardingStepReviewPending, PayoutOnboardingStepCompleted, PayoutOnboardingStepCanceled, PayoutOnboardingStepAgreementPendingUpgrade:
		return true
	}
	return false
}

func (e PayoutOnboardingStep) String() string {
	return string(e)
}

func (e *PayoutOnboardingStep) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PayoutOnboardingStep(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PayoutOnboardingStep", str)
	}
	return nil
}

func (e PayoutOnboardingStep) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumerates valid payout plan tags.
type PayoutPlanTag string

const (
	// Assigned if the user has the "standard" payout plan.
	PayoutPlanTagStandard PayoutPlanTag = "STANDARD"
	// Assigned if the user has the "premium" payout plan.
	PayoutPlanTagPremium PayoutPlanTag = "PREMIUM"
	// Assigned if the user has the "custom" payout plan.
	PayoutPlanTagCustom PayoutPlanTag = "CUSTOM"
	// Assigned if the user has a payout plan created through the legacy onboarding flow.
	PayoutPlanTagLegacy PayoutPlanTag = "LEGACY"
	// Assigned if user has an esports payout plan. Twitch pays them lump sum when they get rewarded from competing in a Twtich sponsored event.
	PayoutPlanTagEsports PayoutPlanTag = "ESPORTS"
)

var AllPayoutPlanTag = []PayoutPlanTag{
	PayoutPlanTagStandard,
	PayoutPlanTagPremium,
	PayoutPlanTagCustom,
	PayoutPlanTagLegacy,
	PayoutPlanTagEsports,
}

func (e PayoutPlanTag) IsValid() bool {
	switch e {
	case PayoutPlanTagStandard, PayoutPlanTagPremium, PayoutPlanTagCustom, PayoutPlanTagLegacy, PayoutPlanTagEsports:
		return true
	}
	return false
}

func (e PayoutPlanTag) String() string {
	return string(e)
}

func (e *PayoutPlanTag) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PayoutPlanTag(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PayoutPlanTag", str)
	}
	return nil
}

func (e PayoutPlanTag) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Denotes the type of pending subscription.
type PendingSubType string

const (
	// This pending subscription was a conversion from a gift sub to a paid sub.
	PendingSubTypeGiftToPaid PendingSubType = "GIFT_TO_PAID"
	// This pending subscription was a conversion from a DNRd sub to a renewing sub.
	PendingSubTypeDnrToResubRecurring PendingSubType = "DNR_TO_RESUB_RECURRING"
	// This pending subscription was a conversion from a DNRd sub to a one month sub.
	PendingSubTypeDnrToResubNonrecurring PendingSubType = "DNR_TO_RESUB_NONRECURRING"
	// This pending subscription was a conversion from a prime sub to a paid sub.
	PendingSubTypePrimeToPaid PendingSubType = "PRIME_TO_PAID"
)

var AllPendingSubType = []PendingSubType{
	PendingSubTypeGiftToPaid,
	PendingSubTypeDnrToResubRecurring,
	PendingSubTypeDnrToResubNonrecurring,
	PendingSubTypePrimeToPaid,
}

func (e PendingSubType) IsValid() bool {
	switch e {
	case PendingSubTypeGiftToPaid, PendingSubTypeDnrToResubRecurring, PendingSubTypeDnrToResubNonrecurring, PendingSubTypePrimeToPaid:
		return true
	}
	return false
}

func (e PendingSubType) String() string {
	return string(e)
}

func (e *PendingSubType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PendingSubType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PendingSubType", str)
	}
	return nil
}

func (e PendingSubType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The permanent emote modifiers available to set.
type PermanentEmoteModifier string

const (
	// Unknown emote modifier.
	PermanentEmoteModifierUnknown PermanentEmoteModifier = "UNKNOWN"
	// BlackWhite emote modifier.
	PermanentEmoteModifierBlackWhite PermanentEmoteModifier = "BLACK_WHITE"
	// HorizontalFlip emote modifier.
	PermanentEmoteModifierHorizontalFlip PermanentEmoteModifier = "HORIZONTAL_FLIP"
	// Sunglasses emote modifier.
	PermanentEmoteModifierSunglasses PermanentEmoteModifier = "SUNGLASSES"
	// Thinking emote modifier.
	PermanentEmoteModifierThinking PermanentEmoteModifier = "THINKING"
	// Squished emote modifier.
	PermanentEmoteModifierSquished PermanentEmoteModifier = "SQUISHED"
)

var AllPermanentEmoteModifier = []PermanentEmoteModifier{
	PermanentEmoteModifierUnknown,
	PermanentEmoteModifierBlackWhite,
	PermanentEmoteModifierHorizontalFlip,
	PermanentEmoteModifierSunglasses,
	PermanentEmoteModifierThinking,
	PermanentEmoteModifierSquished,
}

func (e PermanentEmoteModifier) IsValid() bool {
	switch e {
	case PermanentEmoteModifierUnknown, PermanentEmoteModifierBlackWhite, PermanentEmoteModifierHorizontalFlip, PermanentEmoteModifierSunglasses, PermanentEmoteModifierThinking, PermanentEmoteModifierSquished:
		return true
	}
	return false
}

func (e PermanentEmoteModifier) String() string {
	return string(e)
}

func (e *PermanentEmoteModifier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PermanentEmoteModifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PermanentEmoteModifier", str)
	}
	return nil
}

func (e PermanentEmoteModifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes how to label channels in combined sections. This enum is closely related
// to - but separate from - the PersonalSectionType enum. Some sections may not have labels
// and some labels may not have sections.
type PersonalSectionChannelLabel string

const (
	// Use no label.
	PersonalSectionChannelLabelNone PersonalSectionChannelLabel = "NONE"
	// Use label for recommended channel.
	PersonalSectionChannelLabelRecommended PersonalSectionChannelLabel = "RECOMMENDED"
	// Use label for similar channel.
	PersonalSectionChannelLabelSimilar PersonalSectionChannelLabel = "SIMILAR"
	// Use label for followed channel.
	PersonalSectionChannelLabelFollowed PersonalSectionChannelLabel = "FOLLOWED"
	// Use label for popular channel.
	PersonalSectionChannelLabelPopular PersonalSectionChannelLabel = "POPULAR"
)

var AllPersonalSectionChannelLabel = []PersonalSectionChannelLabel{
	PersonalSectionChannelLabelNone,
	PersonalSectionChannelLabelRecommended,
	PersonalSectionChannelLabelSimilar,
	PersonalSectionChannelLabelFollowed,
	PersonalSectionChannelLabelPopular,
}

func (e PersonalSectionChannelLabel) IsValid() bool {
	switch e {
	case PersonalSectionChannelLabelNone, PersonalSectionChannelLabelRecommended, PersonalSectionChannelLabelSimilar, PersonalSectionChannelLabelFollowed, PersonalSectionChannelLabelPopular:
		return true
	}
	return false
}

func (e PersonalSectionChannelLabel) String() string {
	return string(e)
}

func (e *PersonalSectionChannelLabel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PersonalSectionChannelLabel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PersonalSectionChannelLabel", str)
	}
	return nil
}

func (e PersonalSectionChannelLabel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes the type in personal sections.
type PersonalSectionType string

const (
	// Returns the list of followed channels if the user is authenticated.
	PersonalSectionTypeFollowedSection PersonalSectionType = "FOLLOWED_SECTION"
	// Returns the list of recommended channels.
	PersonalSectionTypeRecommendedSection PersonalSectionType = "RECOMMENDED_SECTION"
	// Returns the list of popular channels.
	PersonalSectionTypePopularSection PersonalSectionType = "POPULAR_SECTION"
	// Returns the list of similar channels.
	PersonalSectionTypeSimilarSection PersonalSectionType = "SIMILAR_SECTION"
)

var AllPersonalSectionType = []PersonalSectionType{
	PersonalSectionTypeFollowedSection,
	PersonalSectionTypeRecommendedSection,
	PersonalSectionTypePopularSection,
	PersonalSectionTypeSimilarSection,
}

func (e PersonalSectionType) IsValid() bool {
	switch e {
	case PersonalSectionTypeFollowedSection, PersonalSectionTypeRecommendedSection, PersonalSectionTypePopularSection, PersonalSectionTypeSimilarSection:
		return true
	}
	return false
}

func (e PersonalSectionType) String() string {
	return string(e)
}

func (e *PersonalSectionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PersonalSectionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PersonalSectionType", str)
	}
	return nil
}

func (e PersonalSectionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The phase state signifies the progress of the phase in the competition.
type PhaseState string

const (
	// No lobbies are currently actively playing in the phase.
	PhaseStateUnstarted PhaseState = "UNSTARTED"
	// Some or all the lobbies in the phase are actively playing.
	PhaseStatePlaying PhaseState = "PLAYING"
	// All lobbies in the phase are done playing.
	PhaseStateFinished PhaseState = "FINISHED"
	// Lobby state is unknown.
	PhaseStateUnknown PhaseState = "UNKNOWN"
)

var AllPhaseState = []PhaseState{
	PhaseStateUnstarted,
	PhaseStatePlaying,
	PhaseStateFinished,
	PhaseStateUnknown,
}

func (e PhaseState) IsValid() bool {
	switch e {
	case PhaseStateUnstarted, PhaseStatePlaying, PhaseStateFinished, PhaseStateUnknown:
		return true
	}
	return false
}

func (e PhaseState) String() string {
	return string(e)
}

func (e *PhaseState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PhaseState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PhaseState", str)
	}
	return nil
}

func (e PhaseState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Stream platform type.
type PlatformType string

const (
	PlatformTypeAll  PlatformType = "all"
	PlatformTypePs4  PlatformType = "ps4"
	PlatformTypeXbox PlatformType = "xbox"
)

var AllPlatformType = []PlatformType{
	PlatformTypeAll,
	PlatformTypePs4,
	PlatformTypeXbox,
}

func (e PlatformType) IsValid() bool {
	switch e {
	case PlatformTypeAll, PlatformTypePs4, PlatformTypeXbox:
		return true
	}
	return false
}

func (e PlatformType) String() string {
	return string(e)
}

func (e *PlatformType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlatformType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlatformType", str)
	}
	return nil
}

func (e PlatformType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible sort orders for lists of polls.
type PollSort string

const (
	// Sort the polls by time.
	PollSortStartTime PollSort = "START_TIME"
)

var AllPollSort = []PollSort{
	PollSortStartTime,
}

func (e PollSort) IsValid() bool {
	switch e {
	case PollSortStartTime:
		return true
	}
	return false
}

func (e PollSort) String() string {
	return string(e)
}

func (e *PollSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PollSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PollSort", str)
	}
	return nil
}

func (e PollSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the poll.
type PollStatus string

const (
	// Encountered some poll status that we do not know how to handle BibleThump.
	PollStatusUnknown PollStatus = "UNKNOWN"
	// Poll is running. Users can vote. Results are publicly visible.
	PollStatusActive PollStatus = "ACTIVE"
	// Poll ran its entire duration and "naturally" completed. Users cannot vote. Results are publicly visible.
	PollStatusCompleted PollStatus = "COMPLETED"
	// Poll was manually ended ("terminated") by a user. Users cannot vote. Results are publicly visible.
	PollStatusTerminated PollStatus = "TERMINATED"
	// Poll has ended and is no longer publicly visible. Users cannot vote. Results are not publicly visible.
	PollStatusArchived PollStatus = "ARCHIVED"
	// Poll has been moderated by Twitch and is no longer viewable, even to the poll owner. Users cannot vote. Results are not visible to any user.
	PollStatusModerated PollStatus = "MODERATED"
)

var AllPollStatus = []PollStatus{
	PollStatusUnknown,
	PollStatusActive,
	PollStatusCompleted,
	PollStatusTerminated,
	PollStatusArchived,
	PollStatusModerated,
}

func (e PollStatus) IsValid() bool {
	switch e {
	case PollStatusUnknown, PollStatusActive, PollStatusCompleted, PollStatusTerminated, PollStatusArchived, PollStatusModerated:
		return true
	}
	return false
}

func (e PollStatus) String() string {
	return string(e)
}

func (e *PollStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PollStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PollStatus", str)
	}
	return nil
}

func (e PollStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible sort orders for lists of voters.
type PollVoterConnectionSort string

const (
	// Sort the voters by # of votes.
	PollVoterConnectionSortVotes PollVoterConnectionSort = "VOTES"
	// Sort the voters by time of creation.
	PollVoterConnectionSortCreatedDate PollVoterConnectionSort = "CREATED_DATE"
	// Sort the voters by amount of Bits on vote.
	PollVoterConnectionSortBits PollVoterConnectionSort = "BITS"
	// Sort the voters by amount of channel points.
	PollVoterConnectionSortChannelPoints PollVoterConnectionSort = "CHANNEL_POINTS"
)

var AllPollVoterConnectionSort = []PollVoterConnectionSort{
	PollVoterConnectionSortVotes,
	PollVoterConnectionSortCreatedDate,
	PollVoterConnectionSortBits,
	PollVoterConnectionSortChannelPoints,
}

func (e PollVoterConnectionSort) IsValid() bool {
	switch e {
	case PollVoterConnectionSortVotes, PollVoterConnectionSortCreatedDate, PollVoterConnectionSortBits, PollVoterConnectionSortChannelPoints:
		return true
	}
	return false
}

func (e PollVoterConnectionSort) String() string {
	return string(e)
}

func (e *PollVoterConnectionSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PollVoterConnectionSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PollVoterConnectionSort", str)
	}
	return nil
}

func (e PollVoterConnectionSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible sort directions for lists of voters.
type PollVoterConnectionSortDirection string

const (
	// Sort in descending order.
	PollVoterConnectionSortDirectionDesc PollVoterConnectionSortDirection = "DESC"
	// Sort in ascending order.
	PollVoterConnectionSortDirectionAsc PollVoterConnectionSortDirection = "ASC"
)

var AllPollVoterConnectionSortDirection = []PollVoterConnectionSortDirection{
	PollVoterConnectionSortDirectionDesc,
	PollVoterConnectionSortDirectionAsc,
}

func (e PollVoterConnectionSortDirection) IsValid() bool {
	switch e {
	case PollVoterConnectionSortDirectionDesc, PollVoterConnectionSortDirectionAsc:
		return true
	}
	return false
}

func (e PollVoterConnectionSortDirection) String() string {
	return string(e)
}

func (e *PollVoterConnectionSortDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PollVoterConnectionSortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PollVoterConnectionSortDirection", str)
	}
	return nil
}

func (e PollVoterConnectionSortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible statuses for a Prediction Event.
type PredictionEventStatus string

const (
	// Event is actively accepting new predictions.
	PredictionEventStatusActive PredictionEventStatus = "ACTIVE"
	// Event is no longer accepting new predictions, and is awaiting resolution.
	PredictionEventStatusLocked PredictionEventStatus = "LOCKED"
	// Event has been resolved, and is in the process of paying out winners.
	PredictionEventStatusResolvePending PredictionEventStatus = "RESOLVE_PENDING"
	// Event has been resolved, the winning Option has been determined, and winners have received their Channel Points.
	PredictionEventStatusResolved PredictionEventStatus = "RESOLVED"
	// Event has been canceled, and is in the process of refunding participants.
	PredictionEventStatusCancelPending PredictionEventStatus = "CANCEL_PENDING"
	// Event has been canceled and all users have been refunded.
	PredictionEventStatusCanceled PredictionEventStatus = "CANCELED"
)

var AllPredictionEventStatus = []PredictionEventStatus{
	PredictionEventStatusActive,
	PredictionEventStatusLocked,
	PredictionEventStatusResolvePending,
	PredictionEventStatusResolved,
	PredictionEventStatusCancelPending,
	PredictionEventStatusCanceled,
}

func (e PredictionEventStatus) IsValid() bool {
	switch e {
	case PredictionEventStatusActive, PredictionEventStatusLocked, PredictionEventStatusResolvePending, PredictionEventStatusResolved, PredictionEventStatusCancelPending, PredictionEventStatusCanceled:
		return true
	}
	return false
}

func (e PredictionEventStatus) String() string {
	return string(e)
}

func (e *PredictionEventStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PredictionEventStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PredictionEventStatus", str)
	}
	return nil
}

func (e PredictionEventStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible colors for a Prediction Outcome.
type PredictionOutcomeColor string

const (
	// Blue.
	PredictionOutcomeColorBlue PredictionOutcomeColor = "BLUE"
	// Pink.
	PredictionOutcomeColorPink PredictionOutcomeColor = "PINK"
	// Green.
	PredictionOutcomeColorGreen PredictionOutcomeColor = "GREEN"
	// Orange.
	PredictionOutcomeColorOrange PredictionOutcomeColor = "ORANGE"
	// Grey.
	PredictionOutcomeColorGrey PredictionOutcomeColor = "GREY"
	// Purple.
	PredictionOutcomeColorPurple PredictionOutcomeColor = "PURPLE"
)

var AllPredictionOutcomeColor = []PredictionOutcomeColor{
	PredictionOutcomeColorBlue,
	PredictionOutcomeColorPink,
	PredictionOutcomeColorGreen,
	PredictionOutcomeColorOrange,
	PredictionOutcomeColorGrey,
	PredictionOutcomeColorPurple,
}

func (e PredictionOutcomeColor) IsValid() bool {
	switch e {
	case PredictionOutcomeColorBlue, PredictionOutcomeColorPink, PredictionOutcomeColorGreen, PredictionOutcomeColorOrange, PredictionOutcomeColorGrey, PredictionOutcomeColorPurple:
		return true
	}
	return false
}

func (e PredictionOutcomeColor) String() string {
	return string(e)
}

func (e *PredictionOutcomeColor) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PredictionOutcomeColor(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PredictionOutcomeColor", str)
	}
	return nil
}

func (e PredictionOutcomeColor) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible result types for a Prediction.
type PredictionResult string

const (
	// The Prediction was incorrect.
	PredictionResultLose PredictionResult = "LOSE"
	// The Prediction was canceled and refunded.
	PredictionResultRefund PredictionResult = "REFUND"
	// The Prediction was correct.
	PredictionResultWin PredictionResult = "WIN"
)

var AllPredictionResult = []PredictionResult{
	PredictionResultLose,
	PredictionResultRefund,
	PredictionResultWin,
}

func (e PredictionResult) IsValid() bool {
	switch e {
	case PredictionResultLose, PredictionResultRefund, PredictionResultWin:
		return true
	}
	return false
}

func (e PredictionResult) String() string {
	return string(e)
}

func (e *PredictionResult) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PredictionResult(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PredictionResult", str)
	}
	return nil
}

func (e PredictionResult) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DEPRECATED.
type PremiereStatus string

const (
	// An unscheduled premiere.
	PremiereStatusUnscheduled PremiereStatus = "UNSCHEDULED"
	// A scheduled premiere.
	PremiereStatusScheduled PremiereStatus = "SCHEDULED"
	// A cancelled premiere.
	PremiereStatusCancelled PremiereStatus = "CANCELLED"
	// A premiere that has been started.
	PremiereStatusStarted PremiereStatus = "STARTED"
	// A successfully completed premiere.
	PremiereStatusSuccess PremiereStatus = "SUCCESS"
	// A failed premiere. Examples of failed premieres are premieres that attempt to run
	// prior to the video being processed (or failed processing,) or the event failing
	// in the middle due to technical difficulties.
	PremiereStatusFailed PremiereStatus = "FAILED"
	// An unknown status to ensure we are able to return something.
	PremiereStatusUnknown PremiereStatus = "UNKNOWN"
)

var AllPremiereStatus = []PremiereStatus{
	PremiereStatusUnscheduled,
	PremiereStatusScheduled,
	PremiereStatusCancelled,
	PremiereStatusStarted,
	PremiereStatusSuccess,
	PremiereStatusFailed,
	PremiereStatusUnknown,
}

func (e PremiereStatus) IsValid() bool {
	switch e {
	case PremiereStatusUnscheduled, PremiereStatusScheduled, PremiereStatusCancelled, PremiereStatusStarted, PremiereStatusSuccess, PremiereStatusFailed, PremiereStatusUnknown:
		return true
	}
	return false
}

func (e PremiereStatus) String() string {
	return string(e)
}

func (e *PremiereStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PremiereStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PremiereStatus", str)
	}
	return nil
}

func (e PremiereStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Domain of dev insights report.
type PresignDevInsightsReportURLDomain string

const (
	// Report for a game.
	PresignDevInsightsReportURLDomainGame PresignDevInsightsReportURLDomain = "GAME"
	// Report for an extension.
	PresignDevInsightsReportURLDomainExtension PresignDevInsightsReportURLDomain = "EXTENSION"
	// Report for a drop.
	PresignDevInsightsReportURLDomainDrop PresignDevInsightsReportURLDomain = "DROP"
)

var AllPresignDevInsightsReportURLDomain = []PresignDevInsightsReportURLDomain{
	PresignDevInsightsReportURLDomainGame,
	PresignDevInsightsReportURLDomainExtension,
	PresignDevInsightsReportURLDomainDrop,
}

func (e PresignDevInsightsReportURLDomain) IsValid() bool {
	switch e {
	case PresignDevInsightsReportURLDomainGame, PresignDevInsightsReportURLDomainExtension, PresignDevInsightsReportURLDomainDrop:
		return true
	}
	return false
}

func (e PresignDevInsightsReportURLDomain) String() string {
	return string(e)
}

func (e *PresignDevInsightsReportURLDomain) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PresignDevInsightsReportURLDomain(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PresignDevInsightsReportURLDomain", str)
	}
	return nil
}

func (e PresignDevInsightsReportURLDomain) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of dev insights report.
type PresignDevInsightsReportURLReportType string

const (
	// Default report type, used for games and extensions.
	PresignDevInsightsReportURLReportTypeOverviewV2 PresignDevInsightsReportURLReportType = "OVERVIEW_V2"
	// Drops report that returns top 10 streamers for campaigns.
	PresignDevInsightsReportURLReportTypeDropsCampaignsTopStreamers PresignDevInsightsReportURLReportType = "DROPS_CAMPAIGNS_TOP_STREAMERS"
	// Drops report that returns overview of campaigns.
	PresignDevInsightsReportURLReportTypeDropsCampaignsOverview PresignDevInsightsReportURLReportType = "DROPS_CAMPAIGNS_OVERVIEW"
	// Drops report that returns overview of drops.
	PresignDevInsightsReportURLReportTypeDropsCampaignsDropsOverview PresignDevInsightsReportURLReportType = "DROPS_CAMPAIGNS_DROPS_OVERVIEW"
)

var AllPresignDevInsightsReportURLReportType = []PresignDevInsightsReportURLReportType{
	PresignDevInsightsReportURLReportTypeOverviewV2,
	PresignDevInsightsReportURLReportTypeDropsCampaignsTopStreamers,
	PresignDevInsightsReportURLReportTypeDropsCampaignsOverview,
	PresignDevInsightsReportURLReportTypeDropsCampaignsDropsOverview,
}

func (e PresignDevInsightsReportURLReportType) IsValid() bool {
	switch e {
	case PresignDevInsightsReportURLReportTypeOverviewV2, PresignDevInsightsReportURLReportTypeDropsCampaignsTopStreamers, PresignDevInsightsReportURLReportTypeDropsCampaignsOverview, PresignDevInsightsReportURLReportTypeDropsCampaignsDropsOverview:
		return true
	}
	return false
}

func (e PresignDevInsightsReportURLReportType) String() string {
	return string(e)
}

func (e *PresignDevInsightsReportURLReportType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PresignDevInsightsReportURLReportType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PresignDevInsightsReportURLReportType", str)
	}
	return nil
}

func (e PresignDevInsightsReportURLReportType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The Names for the smilies Emoticon sets supported by Prime.
type PrimeEmoticonsSetName string

const (
	// Emotes that are granted to all users with Robot faces. Group id is #0 and emoticons start at id #1.
	PrimeEmoticonsSetNameRobots PrimeEmoticonsSetName = "ROBOTS"
	// Emotes that are granted via Prime with Turbo faces.
	PrimeEmoticonsSetNamePurple PrimeEmoticonsSetName = "PURPLE"
	// Emotes that are granted via Prime with Monkey faces.
	PrimeEmoticonsSetNameMonkeys PrimeEmoticonsSetName = "MONKEYS"
)

var AllPrimeEmoticonsSetName = []PrimeEmoticonsSetName{
	PrimeEmoticonsSetNameRobots,
	PrimeEmoticonsSetNamePurple,
	PrimeEmoticonsSetNameMonkeys,
}

func (e PrimeEmoticonsSetName) IsValid() bool {
	switch e {
	case PrimeEmoticonsSetNameRobots, PrimeEmoticonsSetNamePurple, PrimeEmoticonsSetNameMonkeys:
		return true
	}
	return false
}

func (e PrimeEmoticonsSetName) String() string {
	return string(e)
}

func (e *PrimeEmoticonsSetName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PrimeEmoticonsSetName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PrimeEmoticonsSetName", str)
	}
	return nil
}

func (e PrimeEmoticonsSetName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// PrivacyLawName is the privacy law.
type PrivacyLawName string

const (
	// Privacy law CCPA.
	PrivacyLawNameCcpa PrivacyLawName = "CCPA"
	// Privacy GDPR.
	PrivacyLawNameGdpr PrivacyLawName = "GDPR"
	// Rest of World.
	PrivacyLawNameRow PrivacyLawName = "ROW"
)

var AllPrivacyLawName = []PrivacyLawName{
	PrivacyLawNameCcpa,
	PrivacyLawNameGdpr,
	PrivacyLawNameRow,
}

func (e PrivacyLawName) IsValid() bool {
	switch e {
	case PrivacyLawNameCcpa, PrivacyLawNameGdpr, PrivacyLawNameRow:
		return true
	}
	return false
}

func (e PrivacyLawName) String() string {
	return string(e)
}

func (e *PrivacyLawName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PrivacyLawName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PrivacyLawName", str)
	}
	return nil
}

func (e PrivacyLawName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors when retrieving product purchase info.
type ProductPurchaseErrorCode string

const (
	// The user is unauthorized to retrieve the purchase info.
	ProductPurchaseErrorCodeUserUnauthorized ProductPurchaseErrorCode = "USER_UNAUTHORIZED"
	// PricingID not found.
	ProductPurchaseErrorCodePricingIDNotFound ProductPurchaseErrorCode = "PRICING_ID_NOT_FOUND"
	// Cannot determine the user residence.
	ProductPurchaseErrorCodeUnknownUserResidence ProductPurchaseErrorCode = "UNKNOWN_USER_RESIDENCE"
	// Billing info not found for the user.
	ProductPurchaseErrorCodeBillingInfoNotFound ProductPurchaseErrorCode = "BILLING_INFO_NOT_FOUND"
	// User ineligible to make corresponding purchase.
	ProductPurchaseErrorCodePurchaseIneligible ProductPurchaseErrorCode = "PURCHASE_INELIGIBLE"
	// Unexpected error occurred.
	ProductPurchaseErrorCodeUnknown ProductPurchaseErrorCode = "UNKNOWN"
)

var AllProductPurchaseErrorCode = []ProductPurchaseErrorCode{
	ProductPurchaseErrorCodeUserUnauthorized,
	ProductPurchaseErrorCodePricingIDNotFound,
	ProductPurchaseErrorCodeUnknownUserResidence,
	ProductPurchaseErrorCodeBillingInfoNotFound,
	ProductPurchaseErrorCodePurchaseIneligible,
	ProductPurchaseErrorCodeUnknown,
}

func (e ProductPurchaseErrorCode) IsValid() bool {
	switch e {
	case ProductPurchaseErrorCodeUserUnauthorized, ProductPurchaseErrorCodePricingIDNotFound, ProductPurchaseErrorCodeUnknownUserResidence, ProductPurchaseErrorCodeBillingInfoNotFound, ProductPurchaseErrorCodePurchaseIneligible, ProductPurchaseErrorCodeUnknown:
		return true
	}
	return false
}

func (e ProductPurchaseErrorCode) String() string {
	return string(e)
}

func (e *ProductPurchaseErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductPurchaseErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductPurchaseErrorCode", str)
	}
	return nil
}

func (e ProductPurchaseErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types that can only be displayed for an Offer Promotion.
type PromoDiscountType string

const (
	// No Discount type to be shown.
	PromoDiscountTypeDiscountTypeNone PromoDiscountType = "DISCOUNT_TYPE_NONE"
	// Percent Discount type to be shown.
	PromoDiscountTypeDiscountTypePercent PromoDiscountType = "DISCOUNT_TYPE_PERCENT"
)

var AllPromoDiscountType = []PromoDiscountType{
	PromoDiscountTypeDiscountTypeNone,
	PromoDiscountTypeDiscountTypePercent,
}

func (e PromoDiscountType) IsValid() bool {
	switch e {
	case PromoDiscountTypeDiscountTypeNone, PromoDiscountTypeDiscountTypePercent:
		return true
	}
	return false
}

func (e PromoDiscountType) String() string {
	return string(e)
}

func (e *PromoDiscountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PromoDiscountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PromoDiscountType", str)
	}
	return nil
}

func (e PromoDiscountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes returned for publishing subscription emotes.
type PublishSubscriptionEmoteErrorCode string

const (
	// The product has no available empty emote slots.
	PublishSubscriptionEmoteErrorCodeEmoteLimitReached PublishSubscriptionEmoteErrorCode = "EMOTE_LIMIT_REACHED"
	// Only the product owner is allowed to upload emotes.
	PublishSubscriptionEmoteErrorCodeInvalidOwner PublishSubscriptionEmoteErrorCode = "INVALID_OWNER"
	// The emote code submitted collides with an existing emote code.
	PublishSubscriptionEmoteErrorCodeEmoteCodeAlreadyExists PublishSubscriptionEmoteErrorCode = "EMOTE_CODE_ALREADY_EXISTS"
	// The emote code submitted is unacceptable (contains offensive, banned, or "bad" words, which violates guidelines).
	PublishSubscriptionEmoteErrorCodeEmoteCodeUnacceptable PublishSubscriptionEmoteErrorCode = "EMOTE_CODE_UNACCEPTABLE"
	// Data for least one of the image sizes is not provided or invalid.
	PublishSubscriptionEmoteErrorCodeIncompleteEmoteImageData PublishSubscriptionEmoteErrorCode = "INCOMPLETE_EMOTE_IMAGE_DATA"
	// The emote code suffix submitted contains invalid characters.
	PublishSubscriptionEmoteErrorCodeInvalidCodeSuffix PublishSubscriptionEmoteErrorCode = "INVALID_CODE_SUFFIX"
	// The upload emote image could not be parsed.
	PublishSubscriptionEmoteErrorCodeInvalidImageUpload PublishSubscriptionEmoteErrorCode = "INVALID_IMAGE_UPLOAD"
	// The uploaded emote image could not be found.
	PublishSubscriptionEmoteErrorCodeEmoteImageNotFound PublishSubscriptionEmoteErrorCode = "EMOTE_IMAGE_NOT_FOUND"
	// There were not enough image assets supplied for the selected asset type.
	PublishSubscriptionEmoteErrorCodeNotEnoughEmoteImageAssets PublishSubscriptionEmoteErrorCode = "NOT_ENOUGH_EMOTE_IMAGE_ASSETS"
	// There were more image assets supplied than required for the selected asset type.
	PublishSubscriptionEmoteErrorCodeTooManyEmoteImageAssets PublishSubscriptionEmoteErrorCode = "TOO_MANY_EMOTE_IMAGE_ASSETS"
	// The selected emote asset type was invalid.
	PublishSubscriptionEmoteErrorCodeInvalidEmoteAssetType PublishSubscriptionEmoteErrorCode = "INVALID_EMOTE_ASSET_TYPE"
	// A static image asset was not supplied, but is required for the selected asset type.
	PublishSubscriptionEmoteErrorCodeEmoteMissingStaticAsset PublishSubscriptionEmoteErrorCode = "EMOTE_MISSING_STATIC_ASSET"
	// An animated image asset was not supplied, but is required for the selected asset type.
	PublishSubscriptionEmoteErrorCodeEmoteMissingAnimatedAsset PublishSubscriptionEmoteErrorCode = "EMOTE_MISSING_ANIMATED_ASSET"
	// Other errors returned from the service.
	PublishSubscriptionEmoteErrorCodeUnknownError PublishSubscriptionEmoteErrorCode = "UNKNOWN_ERROR"
)

var AllPublishSubscriptionEmoteErrorCode = []PublishSubscriptionEmoteErrorCode{
	PublishSubscriptionEmoteErrorCodeEmoteLimitReached,
	PublishSubscriptionEmoteErrorCodeInvalidOwner,
	PublishSubscriptionEmoteErrorCodeEmoteCodeAlreadyExists,
	PublishSubscriptionEmoteErrorCodeEmoteCodeUnacceptable,
	PublishSubscriptionEmoteErrorCodeIncompleteEmoteImageData,
	PublishSubscriptionEmoteErrorCodeInvalidCodeSuffix,
	PublishSubscriptionEmoteErrorCodeInvalidImageUpload,
	PublishSubscriptionEmoteErrorCodeEmoteImageNotFound,
	PublishSubscriptionEmoteErrorCodeNotEnoughEmoteImageAssets,
	PublishSubscriptionEmoteErrorCodeTooManyEmoteImageAssets,
	PublishSubscriptionEmoteErrorCodeInvalidEmoteAssetType,
	PublishSubscriptionEmoteErrorCodeEmoteMissingStaticAsset,
	PublishSubscriptionEmoteErrorCodeEmoteMissingAnimatedAsset,
	PublishSubscriptionEmoteErrorCodeUnknownError,
}

func (e PublishSubscriptionEmoteErrorCode) IsValid() bool {
	switch e {
	case PublishSubscriptionEmoteErrorCodeEmoteLimitReached, PublishSubscriptionEmoteErrorCodeInvalidOwner, PublishSubscriptionEmoteErrorCodeEmoteCodeAlreadyExists, PublishSubscriptionEmoteErrorCodeEmoteCodeUnacceptable, PublishSubscriptionEmoteErrorCodeIncompleteEmoteImageData, PublishSubscriptionEmoteErrorCodeInvalidCodeSuffix, PublishSubscriptionEmoteErrorCodeInvalidImageUpload, PublishSubscriptionEmoteErrorCodeEmoteImageNotFound, PublishSubscriptionEmoteErrorCodeNotEnoughEmoteImageAssets, PublishSubscriptionEmoteErrorCodeTooManyEmoteImageAssets, PublishSubscriptionEmoteErrorCodeInvalidEmoteAssetType, PublishSubscriptionEmoteErrorCodeEmoteMissingStaticAsset, PublishSubscriptionEmoteErrorCodeEmoteMissingAnimatedAsset, PublishSubscriptionEmoteErrorCodeUnknownError:
		return true
	}
	return false
}

func (e PublishSubscriptionEmoteErrorCode) String() string {
	return string(e)
}

func (e *PublishSubscriptionEmoteErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PublishSubscriptionEmoteErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PublishSubscriptionEmoteErrorCode", str)
	}
	return nil
}

func (e PublishSubscriptionEmoteErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Set of purchase Ineligibility reasons.
type PurchaseIneligibilityReason string

const (
	// User already has an active subscription to this product.
	PurchaseIneligibilityReasonHasActiveSubscription PurchaseIneligibilityReason = "HAS_ACTIVE_SUBSCRIPTION"
	// Not applicable as user is eligible to make a purchase.
	PurchaseIneligibilityReasonNotApplicable PurchaseIneligibilityReason = "NOT_APPLICABLE"
)

var AllPurchaseIneligibilityReason = []PurchaseIneligibilityReason{
	PurchaseIneligibilityReasonHasActiveSubscription,
	PurchaseIneligibilityReasonNotApplicable,
}

func (e PurchaseIneligibilityReason) IsValid() bool {
	switch e {
	case PurchaseIneligibilityReasonHasActiveSubscription, PurchaseIneligibilityReasonNotApplicable:
		return true
	}
	return false
}

func (e PurchaseIneligibilityReason) String() string {
	return string(e)
}

func (e *PurchaseIneligibilityReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PurchaseIneligibilityReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PurchaseIneligibilityReason", str)
	}
	return nil
}

func (e PurchaseIneligibilityReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The enumerated error reasons when purchasing an offer.
type PurchaseOfferErrorCode string

const (
	// User is ineligible to purchase.
	PurchaseOfferErrorCodeIneligible PurchaseOfferErrorCode = "INELIGIBLE"
	// An unexpected internal server error occurred.
	PurchaseOfferErrorCodeInternalServerError PurchaseOfferErrorCode = "INTERNAL_SERVER_ERROR"
	// User's payment method is invalid.
	PurchaseOfferErrorCodeInvalidPaymentMethod PurchaseOfferErrorCode = "INVALID_PAYMENT_METHOD"
	// Must have auth credentials to purchase an offer.
	PurchaseOfferErrorCodeUnauthenticated PurchaseOfferErrorCode = "UNAUTHENTICATED"
)

var AllPurchaseOfferErrorCode = []PurchaseOfferErrorCode{
	PurchaseOfferErrorCodeIneligible,
	PurchaseOfferErrorCodeInternalServerError,
	PurchaseOfferErrorCodeInvalidPaymentMethod,
	PurchaseOfferErrorCodeUnauthenticated,
}

func (e PurchaseOfferErrorCode) IsValid() bool {
	switch e {
	case PurchaseOfferErrorCodeIneligible, PurchaseOfferErrorCodeInternalServerError, PurchaseOfferErrorCodeInvalidPaymentMethod, PurchaseOfferErrorCodeUnauthenticated:
		return true
	}
	return false
}

func (e PurchaseOfferErrorCode) String() string {
	return string(e)
}

func (e *PurchaseOfferErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PurchaseOfferErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PurchaseOfferErrorCode", str)
	}
	return nil
}

func (e PurchaseOfferErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The enumerated failure reasons for a purchase order failure.
type PurchaseOrderFailureReason string

const (
	// Bank declined the charge.
	PurchaseOrderFailureReasonBankDeclined PurchaseOrderFailureReason = "BANK_DECLINED"
	// Failed to entitle the benefit. User was refunded if a charge occurred.
	PurchaseOrderFailureReasonEntitlementFailed PurchaseOrderFailureReason = "ENTITLEMENT_FAILED"
	// User is ineligible to purchase.
	PurchaseOrderFailureReasonIneligible PurchaseOrderFailureReason = "INELIGIBLE"
	// User's payment method is invalid.
	PurchaseOrderFailureReasonInvalidPaymentMethod PurchaseOrderFailureReason = "INVALID_PAYMENT_METHOD"
	// System error.
	PurchaseOrderFailureReasonSystemError PurchaseOrderFailureReason = "SYSTEM_ERROR"
	// Unknown failure reason.
	PurchaseOrderFailureReasonUnknown PurchaseOrderFailureReason = "UNKNOWN"
)

var AllPurchaseOrderFailureReason = []PurchaseOrderFailureReason{
	PurchaseOrderFailureReasonBankDeclined,
	PurchaseOrderFailureReasonEntitlementFailed,
	PurchaseOrderFailureReasonIneligible,
	PurchaseOrderFailureReasonInvalidPaymentMethod,
	PurchaseOrderFailureReasonSystemError,
	PurchaseOrderFailureReasonUnknown,
}

func (e PurchaseOrderFailureReason) IsValid() bool {
	switch e {
	case PurchaseOrderFailureReasonBankDeclined, PurchaseOrderFailureReasonEntitlementFailed, PurchaseOrderFailureReasonIneligible, PurchaseOrderFailureReasonInvalidPaymentMethod, PurchaseOrderFailureReasonSystemError, PurchaseOrderFailureReasonUnknown:
		return true
	}
	return false
}

func (e PurchaseOrderFailureReason) String() string {
	return string(e)
}

func (e *PurchaseOrderFailureReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PurchaseOrderFailureReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PurchaseOrderFailureReason", str)
	}
	return nil
}

func (e PurchaseOrderFailureReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// PurchaseOrderState is the current state of the Purchase Order.
type PurchaseOrderState string

const (
	// The Purchase Order is in an unknown state.
	PurchaseOrderStateUnknown PurchaseOrderState = "UNKNOWN"
	// The Purchase Order flow has been initiated and is at its starting state.
	PurchaseOrderStateInitiated PurchaseOrderState = "INITIATED"
	// The Purchase Order has a scheduled future-dated payment to complete the purchase.
	PurchaseOrderStatePaymentPending PurchaseOrderState = "PAYMENT_PENDING"
	// The Purchase Order has been paid and fulfillment has been kicked off.
	PurchaseOrderStateFulfillmentInitiated PurchaseOrderState = "FULFILLMENT_INITIATED"
	// The Purchase Order has been successfully fulfilled.
	PurchaseOrderStateSuccess PurchaseOrderState = "SUCCESS"
	// The Purchase Order failed and requires 3DS2 verification.
	PurchaseOrderStateThreeDSecureChallengeRequired PurchaseOrderState = "THREE_D_SECURE_CHALLENGE_REQUIRED"
	// The Purchase Order failed.
	PurchaseOrderStateFailed PurchaseOrderState = "FAILED"
	// The Purchase Order's benefit cancellation has been kicked off.
	PurchaseOrderStateCancelBenefitsInitiated PurchaseOrderState = "CANCEL_BENEFITS_INITIATED"
	// The Purchase Order's benefits have been fully cancelled.
	PurchaseOrderStateBenefitsCancelled PurchaseOrderState = "BENEFITS_CANCELLED"
	// A refund has been kicked off for the Purchase Order.
	PurchaseOrderStateRefundInitiated PurchaseOrderState = "REFUND_INITIATED"
	// A refund has been successfully applied to the Purchase Order.
	PurchaseOrderStateRefundApplied PurchaseOrderState = "REFUND_APPLIED"
	// A refund has failed to the Purchase Order.
	PurchaseOrderStateRefundFailed PurchaseOrderState = "REFUND_FAILED"
)

var AllPurchaseOrderState = []PurchaseOrderState{
	PurchaseOrderStateUnknown,
	PurchaseOrderStateInitiated,
	PurchaseOrderStatePaymentPending,
	PurchaseOrderStateFulfillmentInitiated,
	PurchaseOrderStateSuccess,
	PurchaseOrderStateThreeDSecureChallengeRequired,
	PurchaseOrderStateFailed,
	PurchaseOrderStateCancelBenefitsInitiated,
	PurchaseOrderStateBenefitsCancelled,
	PurchaseOrderStateRefundInitiated,
	PurchaseOrderStateRefundApplied,
	PurchaseOrderStateRefundFailed,
}

func (e PurchaseOrderState) IsValid() bool {
	switch e {
	case PurchaseOrderStateUnknown, PurchaseOrderStateInitiated, PurchaseOrderStatePaymentPending, PurchaseOrderStateFulfillmentInitiated, PurchaseOrderStateSuccess, PurchaseOrderStateThreeDSecureChallengeRequired, PurchaseOrderStateFailed, PurchaseOrderStateCancelBenefitsInitiated, PurchaseOrderStateBenefitsCancelled, PurchaseOrderStateRefundInitiated, PurchaseOrderStateRefundApplied, PurchaseOrderStateRefundFailed:
		return true
	}
	return false
}

func (e PurchaseOrderState) String() string {
	return string(e)
}

func (e *PurchaseOrderState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PurchaseOrderState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PurchaseOrderState", str)
	}
	return nil
}

func (e PurchaseOrderState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PurchaseProfileState string

const (
	PurchaseProfileStateActive    PurchaseProfileState = "ACTIVE"
	PurchaseProfileStateCancelled PurchaseProfileState = "CANCELLED"
	PurchaseProfileStateInactive  PurchaseProfileState = "INACTIVE"
	PurchaseProfileStateMigrated  PurchaseProfileState = "MIGRATED"
)

var AllPurchaseProfileState = []PurchaseProfileState{
	PurchaseProfileStateActive,
	PurchaseProfileStateCancelled,
	PurchaseProfileStateInactive,
	PurchaseProfileStateMigrated,
}

func (e PurchaseProfileState) IsValid() bool {
	switch e {
	case PurchaseProfileStateActive, PurchaseProfileStateCancelled, PurchaseProfileStateInactive, PurchaseProfileStateMigrated:
		return true
	}
	return false
}

func (e PurchaseProfileState) String() string {
	return string(e)
}

func (e *PurchaseProfileState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PurchaseProfileState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PurchaseProfileState", str)
	}
	return nil
}

func (e PurchaseProfileState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Category of product that can be purchased.
type PurchaseableProductType string

const (
	// Subscription product.
	PurchaseableProductTypeSubscription PurchaseableProductType = "SUBSCRIPTION"
	// Bits product.
	PurchaseableProductTypeBits PurchaseableProductType = "BITS"
)

var AllPurchaseableProductType = []PurchaseableProductType{
	PurchaseableProductTypeSubscription,
	PurchaseableProductTypeBits,
}

func (e PurchaseableProductType) IsValid() bool {
	switch e {
	case PurchaseableProductTypeSubscription, PurchaseableProductTypeBits:
		return true
	}
	return false
}

func (e PurchaseableProductType) String() string {
	return string(e)
}

func (e *PurchaseableProductType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PurchaseableProductType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PurchaseableProductType", str)
	}
	return nil
}

func (e PurchaseableProductType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid Categories of quick actions.
type QuickActionCategory string

const (
	// Uncategorized quick action.
	QuickActionCategoryUncategorized QuickActionCategory = "UNCATEGORIZED"
	// Stream management quick actions.
	QuickActionCategoryManageYourStream QuickActionCategory = "MANAGE_YOUR_STREAM"
	// Monetization quick actions.
	QuickActionCategoryMonetizeYourStream QuickActionCategory = "MONETIZE_YOUR_STREAM"
	// Community growth quick actions.
	QuickActionCategoryGrowYourCommunity QuickActionCategory = "GROW_YOUR_COMMUNITY"
	// Chat management quick actions.
	QuickActionCategoryManageYourChat QuickActionCategory = "MANAGE_YOUR_CHAT"
	// extensions quick actions.
	QuickActionCategoryExtensions QuickActionCategory = "EXTENSIONS"
)

var AllQuickActionCategory = []QuickActionCategory{
	QuickActionCategoryUncategorized,
	QuickActionCategoryManageYourStream,
	QuickActionCategoryMonetizeYourStream,
	QuickActionCategoryGrowYourCommunity,
	QuickActionCategoryManageYourChat,
	QuickActionCategoryExtensions,
}

func (e QuickActionCategory) IsValid() bool {
	switch e {
	case QuickActionCategoryUncategorized, QuickActionCategoryManageYourStream, QuickActionCategoryMonetizeYourStream, QuickActionCategoryGrowYourCommunity, QuickActionCategoryManageYourChat, QuickActionCategoryExtensions:
		return true
	}
	return false
}

func (e QuickActionCategory) String() string {
	return string(e)
}

func (e *QuickActionCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = QuickActionCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid QuickActionCategory", str)
	}
	return nil
}

func (e QuickActionCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid names of quick actions.
type QuickActionName string

const (
	// Name of the edit stream info quick action.
	QuickActionNameEditStreamInfo QuickActionName = "EDIT_STREAM_INFO"
	// Name of the clip that quick action.
	QuickActionNameClipThat QuickActionName = "CLIP_THAT"
	// Name of the raid channel quick action.
	QuickActionNameRaidChannel QuickActionName = "RAID_CHANNEL"
	// Name of the start squad stream quick action.
	QuickActionNameStartSquadStream QuickActionName = "START_SQUAD_STREAM"
	// Name of the run 30s ad quick action.
	QuickActionNameRunAd30s QuickActionName = "RUN_AD_30S"
	// Name of the run 1m ad quick action.
	QuickActionNameRunAd1m QuickActionName = "RUN_AD_1M"
	// Name of the run 2m ad quick action.
	QuickActionNameRunAd2m QuickActionName = "RUN_AD_2M"
	// Name of the start bounty quick action.
	QuickActionNameStartBounty QuickActionName = "START_BOUNTY"
	// Name of the host channel quick action.
	QuickActionNameHostChannel QuickActionName = "HOST_CHANNEL"
	// Name of the gift subs quick action. This action doesn't specify an amount of subs to gift.
	QuickActionNameGiftSubs QuickActionName = "GIFT_SUBS"
	// Name of the gift 50 subs quick action.
	QuickActionNameGift50Subs QuickActionName = "GIFT_50_SUBS"
	// Name of the gift 100 subs quick action.
	QuickActionNameGift100Subs QuickActionName = "GIFT_100_SUBS"
	// Name of the add stream delay quick action.
	QuickActionNameAddStreamDelay QuickActionName = "ADD_STREAM_DELAY"
	// Name of the add stream marker quick action.
	QuickActionNameAddStreamMarker QuickActionName = "ADD_STREAM_MARKER"
	// Name of the schedule premiere quick action.
	QuickActionNameSchedulePremiere QuickActionName = "SCHEDULE_PREMIERE"
	// Name of the start rerun quick action.
	QuickActionNameStartRerun QuickActionName = "START_RERUN"
	// Name of the clear chat quick action.
	QuickActionNameClearChat QuickActionName = "CLEAR_CHAT"
	// Name of the quick action to set emote only chat.
	QuickActionNameEmoteOnlyChat QuickActionName = "EMOTE_ONLY_CHAT"
	// Name of the quick action to set sub only chat.
	QuickActionNameSubOnlyChat QuickActionName = "SUB_ONLY_CHAT"
	// Name of the quick action to set follow only chat.
	QuickActionNameFollowOnlyChat QuickActionName = "FOLLOW_ONLY_CHAT"
	// Name of the start watch party quick action.
	QuickActionNameStartWatchParty QuickActionName = "START_WATCH_PARTY"
)

var AllQuickActionName = []QuickActionName{
	QuickActionNameEditStreamInfo,
	QuickActionNameClipThat,
	QuickActionNameRaidChannel,
	QuickActionNameStartSquadStream,
	QuickActionNameRunAd30s,
	QuickActionNameRunAd1m,
	QuickActionNameRunAd2m,
	QuickActionNameStartBounty,
	QuickActionNameHostChannel,
	QuickActionNameGiftSubs,
	QuickActionNameGift50Subs,
	QuickActionNameGift100Subs,
	QuickActionNameAddStreamDelay,
	QuickActionNameAddStreamMarker,
	QuickActionNameSchedulePremiere,
	QuickActionNameStartRerun,
	QuickActionNameClearChat,
	QuickActionNameEmoteOnlyChat,
	QuickActionNameSubOnlyChat,
	QuickActionNameFollowOnlyChat,
	QuickActionNameStartWatchParty,
}

func (e QuickActionName) IsValid() bool {
	switch e {
	case QuickActionNameEditStreamInfo, QuickActionNameClipThat, QuickActionNameRaidChannel, QuickActionNameStartSquadStream, QuickActionNameRunAd30s, QuickActionNameRunAd1m, QuickActionNameRunAd2m, QuickActionNameStartBounty, QuickActionNameHostChannel, QuickActionNameGiftSubs, QuickActionNameGift50Subs, QuickActionNameGift100Subs, QuickActionNameAddStreamDelay, QuickActionNameAddStreamMarker, QuickActionNameSchedulePremiere, QuickActionNameStartRerun, QuickActionNameClearChat, QuickActionNameEmoteOnlyChat, QuickActionNameSubOnlyChat, QuickActionNameFollowOnlyChat, QuickActionNameStartWatchParty:
		return true
	}
	return false
}

func (e QuickActionName) String() string {
	return string(e)
}

func (e *QuickActionName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = QuickActionName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid QuickActionName", str)
	}
	return nil
}

func (e QuickActionName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid scopes of quick actions.
type QuickActionScope string

const (
	// global refers to QAs available to all users.
	QuickActionScopeGlobal QuickActionScope = "GLOBAL"
	// local scope refers to QAs unique to the user, i.e. extension QAs.
	QuickActionScopeLocal QuickActionScope = "LOCAL"
)

var AllQuickActionScope = []QuickActionScope{
	QuickActionScopeGlobal,
	QuickActionScopeLocal,
}

func (e QuickActionScope) IsValid() bool {
	switch e {
	case QuickActionScopeGlobal, QuickActionScopeLocal:
		return true
	}
	return false
}

func (e QuickActionScope) String() string {
	return string(e)
}

func (e *QuickActionScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = QuickActionScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid QuickActionScope", str)
	}
	return nil
}

func (e QuickActionScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The different Twitch Radio collection types that can be requested.
type RadioContentType string

const (
	// Retrieve playlists, can be filtered by ASIN.
	RadioContentTypePlaylist RadioContentType = "PLAYLIST"
	// Retrieve the user's recently played playlists.
	RadioContentTypeRecentlyPlayed RadioContentType = "RECENTLY_PLAYED"
)

var AllRadioContentType = []RadioContentType{
	RadioContentTypePlaylist,
	RadioContentTypeRecentlyPlayed,
}

func (e RadioContentType) IsValid() bool {
	switch e {
	case RadioContentTypePlaylist, RadioContentTypeRecentlyPlayed:
		return true
	}
	return false
}

func (e RadioContentType) String() string {
	return string(e)
}

func (e *RadioContentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RadioContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RadioContentType", str)
	}
	return nil
}

func (e RadioContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The types of content we can register current plays for.
type RadioCurrentlyPlayingType string

const (
	// A radio playlist.
	RadioCurrentlyPlayingTypePlaylist RadioCurrentlyPlayingType = "PLAYLIST"
	// A radio station.
	RadioCurrentlyPlayingTypeStation RadioCurrentlyPlayingType = "STATION"
)

var AllRadioCurrentlyPlayingType = []RadioCurrentlyPlayingType{
	RadioCurrentlyPlayingTypePlaylist,
	RadioCurrentlyPlayingTypeStation,
}

func (e RadioCurrentlyPlayingType) IsValid() bool {
	switch e {
	case RadioCurrentlyPlayingTypePlaylist, RadioCurrentlyPlayingTypeStation:
		return true
	}
	return false
}

func (e RadioCurrentlyPlayingType) String() string {
	return string(e)
}

func (e *RadioCurrentlyPlayingType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RadioCurrentlyPlayingType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RadioCurrentlyPlayingType", str)
	}
	return nil
}

func (e RadioCurrentlyPlayingType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Icon Formats for the media service.
type RadioIconFormat string

const (
	// PNG Icon for the media service.
	RadioIconFormatPng RadioIconFormat = "PNG"
	// SVG Icon for the media service.
	RadioIconFormatSvg RadioIconFormat = "SVG"
)

var AllRadioIconFormat = []RadioIconFormat{
	RadioIconFormatPng,
	RadioIconFormatSvg,
}

func (e RadioIconFormat) IsValid() bool {
	switch e {
	case RadioIconFormatPng, RadioIconFormatSvg:
		return true
	}
	return false
}

func (e RadioIconFormat) String() string {
	return string(e)
}

func (e *RadioIconFormat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RadioIconFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RadioIconFormat", str)
	}
	return nil
}

func (e RadioIconFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Filters for querying the playlists.
type RadioPlaylistFilter string

const (
	// Get all playlists.
	RadioPlaylistFilterAll RadioPlaylistFilter = "ALL"
	// Get only featured playlists.
	RadioPlaylistFilterFeatured RadioPlaylistFilter = "FEATURED"
)

var AllRadioPlaylistFilter = []RadioPlaylistFilter{
	RadioPlaylistFilterAll,
	RadioPlaylistFilterFeatured,
}

func (e RadioPlaylistFilter) IsValid() bool {
	switch e {
	case RadioPlaylistFilterAll, RadioPlaylistFilterFeatured:
		return true
	}
	return false
}

func (e RadioPlaylistFilter) String() string {
	return string(e)
}

func (e *RadioPlaylistFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RadioPlaylistFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RadioPlaylistFilter", str)
	}
	return nil
}

func (e RadioPlaylistFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Filter for recentlyPlayed.
type RadioRecentlyPlayedFilter string

const (
	// Get all recently played items.
	RadioRecentlyPlayedFilterAll RadioRecentlyPlayedFilter = "ALL"
	// Retrieve only playlists.
	RadioRecentlyPlayedFilterPlaylists RadioRecentlyPlayedFilter = "PLAYLISTS"
)

var AllRadioRecentlyPlayedFilter = []RadioRecentlyPlayedFilter{
	RadioRecentlyPlayedFilterAll,
	RadioRecentlyPlayedFilterPlaylists,
}

func (e RadioRecentlyPlayedFilter) IsValid() bool {
	switch e {
	case RadioRecentlyPlayedFilterAll, RadioRecentlyPlayedFilterPlaylists:
		return true
	}
	return false
}

func (e RadioRecentlyPlayedFilter) String() string {
	return string(e)
}

func (e *RadioRecentlyPlayedFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RadioRecentlyPlayedFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RadioRecentlyPlayedFilter", str)
	}
	return nil
}

func (e RadioRecentlyPlayedFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The types of content we can register recent plays for.
type RadioRecentlyPlayedType string

const (
	// A radio playlist.
	RadioRecentlyPlayedTypePlaylist RadioRecentlyPlayedType = "PLAYLIST"
	// A radio station.
	RadioRecentlyPlayedTypeStation RadioRecentlyPlayedType = "STATION"
)

var AllRadioRecentlyPlayedType = []RadioRecentlyPlayedType{
	RadioRecentlyPlayedTypePlaylist,
	RadioRecentlyPlayedTypeStation,
}

func (e RadioRecentlyPlayedType) IsValid() bool {
	switch e {
	case RadioRecentlyPlayedTypePlaylist, RadioRecentlyPlayedTypeStation:
		return true
	}
	return false
}

func (e RadioRecentlyPlayedType) String() string {
	return string(e)
}

func (e *RadioRecentlyPlayedType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RadioRecentlyPlayedType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RadioRecentlyPlayedType", str)
	}
	return nil
}

func (e RadioRecentlyPlayedType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors returned by the RateExtension mutation.
type RateExtensionError string

const (
	// Internal service error eg. database timeout.
	RateExtensionErrorInternalError RateExtensionError = "INTERNAL_ERROR"
)

var AllRateExtensionError = []RateExtensionError{
	RateExtensionErrorInternalError,
}

func (e RateExtensionError) IsValid() bool {
	switch e {
	case RateExtensionErrorInternalError:
		return true
	}
	return false
}

func (e RateExtensionError) String() string {
	return string(e)
}

func (e *RateExtensionError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RateExtensionError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RateExtensionError", str)
	}
	return nil
}

func (e RateExtensionError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for feedback.
type RecommendationFeedbackCategory string

const (
	// Only returned when there is an issue. Shouldn't be returned, should not be used for fetching.
	RecommendationFeedbackCategoryUnspecified RecommendationFeedbackCategory = "UNSPECIFIED"
	// The user is not interested in this type of content.
	RecommendationFeedbackCategoryNotInterested RecommendationFeedbackCategory = "NOT_INTERESTED"
	// The user finds this type of content to be offensive.
	RecommendationFeedbackCategoryOffensive RecommendationFeedbackCategory = "OFFENSIVE"
	// The user has already seen this content.
	RecommendationFeedbackCategoryAlreadyWatched RecommendationFeedbackCategory = "ALREADY_WATCHED"
	// Used when the other reasons do not capture the reason a user is giving feedback.
	RecommendationFeedbackCategoryOther RecommendationFeedbackCategory = "OTHER"
)

var AllRecommendationFeedbackCategory = []RecommendationFeedbackCategory{
	RecommendationFeedbackCategoryUnspecified,
	RecommendationFeedbackCategoryNotInterested,
	RecommendationFeedbackCategoryOffensive,
	RecommendationFeedbackCategoryAlreadyWatched,
	RecommendationFeedbackCategoryOther,
}

func (e RecommendationFeedbackCategory) IsValid() bool {
	switch e {
	case RecommendationFeedbackCategoryUnspecified, RecommendationFeedbackCategoryNotInterested, RecommendationFeedbackCategoryOffensive, RecommendationFeedbackCategoryAlreadyWatched, RecommendationFeedbackCategoryOther:
		return true
	}
	return false
}

func (e RecommendationFeedbackCategory) String() string {
	return string(e)
}

func (e *RecommendationFeedbackCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RecommendationFeedbackCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RecommendationFeedbackCategory", str)
	}
	return nil
}

func (e RecommendationFeedbackCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Feedback target type.
type RecommendationFeedbackType string

const (
	// Only returned when there is an issue. Shouldn't be returned, should not be used for fetching.
	RecommendationFeedbackTypeUnspecified RecommendationFeedbackType = "UNSPECIFIED"
	// Feedback given about channels.
	RecommendationFeedbackTypeChannel RecommendationFeedbackType = "CHANNEL"
	// Feedback given about a game / category.
	RecommendationFeedbackTypeCategory RecommendationFeedbackType = "CATEGORY"
	// Feedback given about a shelf.
	RecommendationFeedbackTypeShelf RecommendationFeedbackType = "SHELF"
	// Feedback given about a video.
	RecommendationFeedbackTypeVod RecommendationFeedbackType = "VOD"
)

var AllRecommendationFeedbackType = []RecommendationFeedbackType{
	RecommendationFeedbackTypeUnspecified,
	RecommendationFeedbackTypeChannel,
	RecommendationFeedbackTypeCategory,
	RecommendationFeedbackTypeShelf,
	RecommendationFeedbackTypeVod,
}

func (e RecommendationFeedbackType) IsValid() bool {
	switch e {
	case RecommendationFeedbackTypeUnspecified, RecommendationFeedbackTypeChannel, RecommendationFeedbackTypeCategory, RecommendationFeedbackTypeShelf, RecommendationFeedbackTypeVod:
		return true
	}
	return false
}

func (e RecommendationFeedbackType) String() string {
	return string(e)
}

func (e *RecommendationFeedbackType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RecommendationFeedbackType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RecommendationFeedbackType", str)
	}
	return nil
}

func (e RecommendationFeedbackType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of RecordAdEvent error status codes.
type RecordAdEventErrorCode string

const (
	// The RAd token in the request was not valid.
	RecordAdEventErrorCodeInvalidToken RecordAdEventErrorCode = "INVALID_TOKEN"
	// The event payload was invalid.
	RecordAdEventErrorCodeInvalidJSON RecordAdEventErrorCode = "INVALID_JSON"
	// An internal error has occurred, other than a 500.
	RecordAdEventErrorCodeUnknownError RecordAdEventErrorCode = "UNKNOWN_ERROR"
)

var AllRecordAdEventErrorCode = []RecordAdEventErrorCode{
	RecordAdEventErrorCodeInvalidToken,
	RecordAdEventErrorCodeInvalidJSON,
	RecordAdEventErrorCodeUnknownError,
}

func (e RecordAdEventErrorCode) IsValid() bool {
	switch e {
	case RecordAdEventErrorCodeInvalidToken, RecordAdEventErrorCodeInvalidJSON, RecordAdEventErrorCodeUnknownError:
		return true
	}
	return false
}

func (e RecordAdEventErrorCode) String() string {
	return string(e)
}

func (e *RecordAdEventErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RecordAdEventErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RecordAdEventErrorCode", str)
	}
	return nil
}

func (e RecordAdEventErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Redeem claimable error status codes.
type RedeemClaimableErrorCode string

const (
	// The request has been throttled.
	RedeemClaimableErrorCodeRequestThrottled RedeemClaimableErrorCode = "REQUEST_THROTTLED"
	// The user is not allowed to redeem this key.
	RedeemClaimableErrorCodeUnauthorized RedeemClaimableErrorCode = "UNAUTHORIZED"
	// The key has already been claimed.
	RedeemClaimableErrorCodeAlreadyClaimed RedeemClaimableErrorCode = "ALREADY_CLAIMED"
	// Unknown error being returned from service.
	RedeemClaimableErrorCodeUnknown RedeemClaimableErrorCode = "UNKNOWN"
	// Invalid PIN/Claimable.
	// Currently only used for Gift Card PINs.
	RedeemClaimableErrorCodeInvalidPin RedeemClaimableErrorCode = "INVALID_PIN"
	// PIN already redeemed.
	// Currently only used for Gift Card PINs.
	RedeemClaimableErrorCodeAlreadyRedeemed RedeemClaimableErrorCode = "ALREADY_REDEEMED"
	// User can't redeem due to wallet balance limit
	// Currently only used for Gift Card PINs.
	RedeemClaimableErrorCodeExceededWalletBalance RedeemClaimableErrorCode = "EXCEEDED_WALLET_BALANCE"
	// Two Factor Auth is required past a certain balance
	// for fraud mitigation. Currently only used for Gift Card PINs.
	RedeemClaimableErrorCodeTwoFactorRequired RedeemClaimableErrorCode = "TWO_FACTOR_REQUIRED"
	// Unsupported Country of Residence
	// Currently only used for Gift Card PINs.
	RedeemClaimableErrorCodeInvalidCountryOfResidence RedeemClaimableErrorCode = "INVALID_COUNTRY_OF_RESIDENCE"
	// User excedded redemption velocity limit.
	// Currently only used for Gift Card PINs.
	RedeemClaimableErrorCodeExceededVelocityLimit RedeemClaimableErrorCode = "EXCEEDED_VELOCITY_LIMIT"
)

var AllRedeemClaimableErrorCode = []RedeemClaimableErrorCode{
	RedeemClaimableErrorCodeRequestThrottled,
	RedeemClaimableErrorCodeUnauthorized,
	RedeemClaimableErrorCodeAlreadyClaimed,
	RedeemClaimableErrorCodeUnknown,
	RedeemClaimableErrorCodeInvalidPin,
	RedeemClaimableErrorCodeAlreadyRedeemed,
	RedeemClaimableErrorCodeExceededWalletBalance,
	RedeemClaimableErrorCodeTwoFactorRequired,
	RedeemClaimableErrorCodeInvalidCountryOfResidence,
	RedeemClaimableErrorCodeExceededVelocityLimit,
}

func (e RedeemClaimableErrorCode) IsValid() bool {
	switch e {
	case RedeemClaimableErrorCodeRequestThrottled, RedeemClaimableErrorCodeUnauthorized, RedeemClaimableErrorCodeAlreadyClaimed, RedeemClaimableErrorCodeUnknown, RedeemClaimableErrorCodeInvalidPin, RedeemClaimableErrorCodeAlreadyRedeemed, RedeemClaimableErrorCodeExceededWalletBalance, RedeemClaimableErrorCodeTwoFactorRequired, RedeemClaimableErrorCodeInvalidCountryOfResidence, RedeemClaimableErrorCodeExceededVelocityLimit:
		return true
	}
	return false
}

func (e RedeemClaimableErrorCode) String() string {
	return string(e)
}

func (e *RedeemClaimableErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RedeemClaimableErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RedeemClaimableErrorCode", str)
	}
	return nil
}

func (e RedeemClaimableErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons redeeming a custom Community Points reward in a channel could fail.
type RedeemCommunityPointsCustomRewardErrorCode string

const (
	// The reward was not found.
	RedeemCommunityPointsCustomRewardErrorCodeNotFound RedeemCommunityPointsCustomRewardErrorCode = "NOT_FOUND"
	// The current user is not allowed to redeem this reward in this channel.
	RedeemCommunityPointsCustomRewardErrorCodeForbidden RedeemCommunityPointsCustomRewardErrorCode = "FORBIDDEN"
	// The user does not have sufficient points to redeem the reward.
	RedeemCommunityPointsCustomRewardErrorCodeNotEnoughPoints RedeemCommunityPointsCustomRewardErrorCode = "NOT_ENOUGH_POINTS"
	// The client-provided properties (title, cost, or prompt) did not match the reward's true properties.
	RedeemCommunityPointsCustomRewardErrorCodePropertiesMismatch RedeemCommunityPointsCustomRewardErrorCode = "PROPERTIES_MISMATCH"
	// The client is retrying a redemption with a transaction id that has already been redeemed.
	RedeemCommunityPointsCustomRewardErrorCodeDuplicateTransaction RedeemCommunityPointsCustomRewardErrorCode = "DUPLICATE_TRANSACTION"
	// The client is retrying a redemption with a transaction id that is currently being redeemed in another request.
	RedeemCommunityPointsCustomRewardErrorCodeTransactionInProgress RedeemCommunityPointsCustomRewardErrorCode = "TRANSACTION_IN_PROGRESS"
	// The reward is disabled.
	RedeemCommunityPointsCustomRewardErrorCodeDisabled RedeemCommunityPointsCustomRewardErrorCode = "DISABLED"
	// The stream is not live.
	RedeemCommunityPointsCustomRewardErrorCodeStreamNotLive RedeemCommunityPointsCustomRewardErrorCode = "STREAM_NOT_LIVE"
	// The reward has hit its maximum number of redemptions per stream.
	RedeemCommunityPointsCustomRewardErrorCodeMaxPerStream RedeemCommunityPointsCustomRewardErrorCode = "MAX_PER_STREAM"
	// The user is banned and cannot redeem rewards.
	RedeemCommunityPointsCustomRewardErrorCodeUserBanned RedeemCommunityPointsCustomRewardErrorCode = "USER_BANNED"
	// The redemption message contained a blocked phrase.
	RedeemCommunityPointsCustomRewardErrorCodeChannelSettings RedeemCommunityPointsCustomRewardErrorCode = "CHANNEL_SETTINGS"
	// The redemption message starts with a '/' like a chat command.
	RedeemCommunityPointsCustomRewardErrorCodeMessageIsCommand RedeemCommunityPointsCustomRewardErrorCode = "MESSAGE_IS_COMMAND"
	// An unknown error occurred.
	RedeemCommunityPointsCustomRewardErrorCodeUnknown RedeemCommunityPointsCustomRewardErrorCode = "UNKNOWN"
	// The reward has hit its maximum number of redempetions per user per stream.
	RedeemCommunityPointsCustomRewardErrorCodeMaxPerUserPerStream RedeemCommunityPointsCustomRewardErrorCode = "MAX_PER_USER_PER_STREAM"
	// The reward is currently under a cooldown.
	RedeemCommunityPointsCustomRewardErrorCodeGlobalCooldown RedeemCommunityPointsCustomRewardErrorCode = "GLOBAL_COOLDOWN"
)

var AllRedeemCommunityPointsCustomRewardErrorCode = []RedeemCommunityPointsCustomRewardErrorCode{
	RedeemCommunityPointsCustomRewardErrorCodeNotFound,
	RedeemCommunityPointsCustomRewardErrorCodeForbidden,
	RedeemCommunityPointsCustomRewardErrorCodeNotEnoughPoints,
	RedeemCommunityPointsCustomRewardErrorCodePropertiesMismatch,
	RedeemCommunityPointsCustomRewardErrorCodeDuplicateTransaction,
	RedeemCommunityPointsCustomRewardErrorCodeTransactionInProgress,
	RedeemCommunityPointsCustomRewardErrorCodeDisabled,
	RedeemCommunityPointsCustomRewardErrorCodeStreamNotLive,
	RedeemCommunityPointsCustomRewardErrorCodeMaxPerStream,
	RedeemCommunityPointsCustomRewardErrorCodeUserBanned,
	RedeemCommunityPointsCustomRewardErrorCodeChannelSettings,
	RedeemCommunityPointsCustomRewardErrorCodeMessageIsCommand,
	RedeemCommunityPointsCustomRewardErrorCodeUnknown,
	RedeemCommunityPointsCustomRewardErrorCodeMaxPerUserPerStream,
	RedeemCommunityPointsCustomRewardErrorCodeGlobalCooldown,
}

func (e RedeemCommunityPointsCustomRewardErrorCode) IsValid() bool {
	switch e {
	case RedeemCommunityPointsCustomRewardErrorCodeNotFound, RedeemCommunityPointsCustomRewardErrorCodeForbidden, RedeemCommunityPointsCustomRewardErrorCodeNotEnoughPoints, RedeemCommunityPointsCustomRewardErrorCodePropertiesMismatch, RedeemCommunityPointsCustomRewardErrorCodeDuplicateTransaction, RedeemCommunityPointsCustomRewardErrorCodeTransactionInProgress, RedeemCommunityPointsCustomRewardErrorCodeDisabled, RedeemCommunityPointsCustomRewardErrorCodeStreamNotLive, RedeemCommunityPointsCustomRewardErrorCodeMaxPerStream, RedeemCommunityPointsCustomRewardErrorCodeUserBanned, RedeemCommunityPointsCustomRewardErrorCodeChannelSettings, RedeemCommunityPointsCustomRewardErrorCodeMessageIsCommand, RedeemCommunityPointsCustomRewardErrorCodeUnknown, RedeemCommunityPointsCustomRewardErrorCodeMaxPerUserPerStream, RedeemCommunityPointsCustomRewardErrorCodeGlobalCooldown:
		return true
	}
	return false
}

func (e RedeemCommunityPointsCustomRewardErrorCode) String() string {
	return string(e)
}

func (e *RedeemCommunityPointsCustomRewardErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RedeemCommunityPointsCustomRewardErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RedeemCommunityPointsCustomRewardErrorCode", str)
	}
	return nil
}

func (e RedeemCommunityPointsCustomRewardErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RedeemRitualTokenErrorCode string

const (
	// Token is not in a status that can be redeemed.
	RedeemRitualTokenErrorCodeTokenNotAvailable RedeemRitualTokenErrorCode = "TOKEN_NOT_AVAILABLE"
	// Token does not exist.
	RedeemRitualTokenErrorCodeTokenNotFound RedeemRitualTokenErrorCode = "TOKEN_NOT_FOUND"
	// User is not a follower and tried redeeming the token in a follower-only chat.
	RedeemRitualTokenErrorCodeFollowerOnlyModeEnforcementFailed RedeemRitualTokenErrorCode = "FOLLOWER_ONLY_MODE_ENFORCEMENT_FAILED"
	// User is not a subscriber and tried redeeming the token in a subs-only chat.
	RedeemRitualTokenErrorCodeSubOnlyModeEnforcementFailed RedeemRitualTokenErrorCode = "SUB_ONLY_MODE_ENFORCEMENT_FAILED"
	// User is banned in the channel.
	RedeemRitualTokenErrorCodeUserChatBanned RedeemRitualTokenErrorCode = "USER_CHAT_BANNED"
	// User is timed out in the channel.
	RedeemRitualTokenErrorCodeUserChatTimedOut RedeemRitualTokenErrorCode = "USER_CHAT_TIMED_OUT"
)

var AllRedeemRitualTokenErrorCode = []RedeemRitualTokenErrorCode{
	RedeemRitualTokenErrorCodeTokenNotAvailable,
	RedeemRitualTokenErrorCodeTokenNotFound,
	RedeemRitualTokenErrorCodeFollowerOnlyModeEnforcementFailed,
	RedeemRitualTokenErrorCodeSubOnlyModeEnforcementFailed,
	RedeemRitualTokenErrorCodeUserChatBanned,
	RedeemRitualTokenErrorCodeUserChatTimedOut,
}

func (e RedeemRitualTokenErrorCode) IsValid() bool {
	switch e {
	case RedeemRitualTokenErrorCodeTokenNotAvailable, RedeemRitualTokenErrorCodeTokenNotFound, RedeemRitualTokenErrorCodeFollowerOnlyModeEnforcementFailed, RedeemRitualTokenErrorCodeSubOnlyModeEnforcementFailed, RedeemRitualTokenErrorCodeUserChatBanned, RedeemRitualTokenErrorCodeUserChatTimedOut:
		return true
	}
	return false
}

func (e RedeemRitualTokenErrorCode) String() string {
	return string(e)
}

func (e *RedeemRitualTokenErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RedeemRitualTokenErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RedeemRitualTokenErrorCode", str)
	}
	return nil
}

func (e RedeemRitualTokenErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An Error indicating why the submit failed, if it did.
type RedeemSubscriptionResponseErrorCode string

const (
	// The Channel ID is invalid.
	RedeemSubscriptionResponseErrorCodeInvalidChannel RedeemSubscriptionResponseErrorCode = "INVALID_CHANNEL"
	// The User is not Eligible to Redeem Subscription to this Channel.
	RedeemSubscriptionResponseErrorCodeNotEligible RedeemSubscriptionResponseErrorCode = "NOT_ELIGIBLE"
	// Something unexpected occured when Redeeming the Subscription.
	RedeemSubscriptionResponseErrorCodeUnknown RedeemSubscriptionResponseErrorCode = "UNKNOWN"
	// The User has already redeemed the subscription offerd by the channel.
	RedeemSubscriptionResponseErrorCodeUserHasRedeemedSubscription RedeemSubscriptionResponseErrorCode = "USER_HAS_REDEEMED_SUBSCRIPTION"
	// The channel the user is trying to redeem from has not been off-boarded.
	RedeemSubscriptionResponseErrorCodeChannelNotOffBoarded RedeemSubscriptionResponseErrorCode = "CHANNEL_NOT_OFF_BOARDED"
	// The user already has an existing subscription to the target channel they are trying to redeem to.
	RedeemSubscriptionResponseErrorCodeUserHasExistingSubscription RedeemSubscriptionResponseErrorCode = "USER_HAS_EXISTING_SUBSCRIPTION"
	// The target Channel the user is trying to redeem to is Invalid.
	RedeemSubscriptionResponseErrorCodeRedeemChannelInvalid RedeemSubscriptionResponseErrorCode = "REDEEM_CHANNEL_INVALID"
	// The user is not subscribed to the channel that is being off-boarded.
	RedeemSubscriptionResponseErrorCodeUserNotSubscribedToOffBoardedChannel RedeemSubscriptionResponseErrorCode = "USER_NOT_SUBSCRIBED_TO_OFF_BOARDED_CHANNEL"
)

var AllRedeemSubscriptionResponseErrorCode = []RedeemSubscriptionResponseErrorCode{
	RedeemSubscriptionResponseErrorCodeInvalidChannel,
	RedeemSubscriptionResponseErrorCodeNotEligible,
	RedeemSubscriptionResponseErrorCodeUnknown,
	RedeemSubscriptionResponseErrorCodeUserHasRedeemedSubscription,
	RedeemSubscriptionResponseErrorCodeChannelNotOffBoarded,
	RedeemSubscriptionResponseErrorCodeUserHasExistingSubscription,
	RedeemSubscriptionResponseErrorCodeRedeemChannelInvalid,
	RedeemSubscriptionResponseErrorCodeUserNotSubscribedToOffBoardedChannel,
}

func (e RedeemSubscriptionResponseErrorCode) IsValid() bool {
	switch e {
	case RedeemSubscriptionResponseErrorCodeInvalidChannel, RedeemSubscriptionResponseErrorCodeNotEligible, RedeemSubscriptionResponseErrorCodeUnknown, RedeemSubscriptionResponseErrorCodeUserHasRedeemedSubscription, RedeemSubscriptionResponseErrorCodeChannelNotOffBoarded, RedeemSubscriptionResponseErrorCodeUserHasExistingSubscription, RedeemSubscriptionResponseErrorCodeRedeemChannelInvalid, RedeemSubscriptionResponseErrorCodeUserNotSubscribedToOffBoardedChannel:
		return true
	}
	return false
}

func (e RedeemSubscriptionResponseErrorCode) String() string {
	return string(e)
}

func (e *RedeemSubscriptionResponseErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RedeemSubscriptionResponseErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RedeemSubscriptionResponseErrorCode", str)
	}
	return nil
}

func (e RedeemSubscriptionResponseErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// How to group the referral sources.
type ReferralsDimension string

const (
	// Return referrals grouped by platforms.
	ReferralsDimensionPlatform ReferralsDimension = "PLATFORM"
	// Return referrals grouped by country.
	ReferralsDimensionCountry ReferralsDimension = "COUNTRY"
	// Return referrals grouped by channel.
	ReferralsDimensionChannel ReferralsDimension = "CHANNEL"
	// Return referrals grouped by internal source.
	ReferralsDimensionInternal ReferralsDimension = "INTERNAL"
	// Return referrals grouped by external source.
	ReferralsDimensionExternal ReferralsDimension = "EXTERNAL"
)

var AllReferralsDimension = []ReferralsDimension{
	ReferralsDimensionPlatform,
	ReferralsDimensionCountry,
	ReferralsDimensionChannel,
	ReferralsDimensionInternal,
	ReferralsDimensionExternal,
}

func (e ReferralsDimension) IsValid() bool {
	switch e {
	case ReferralsDimensionPlatform, ReferralsDimensionCountry, ReferralsDimensionChannel, ReferralsDimensionInternal, ReferralsDimensionExternal:
		return true
	}
	return false
}

func (e ReferralsDimension) String() string {
	return string(e)
}

func (e *ReferralsDimension) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReferralsDimension(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReferralsDimension", str)
	}
	return nil
}

func (e ReferralsDimension) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Which subset of referrals to return.
type ReferralsFilter string

const (
	// Return all referral sources.
	ReferralsFilterAll ReferralsFilter = "ALL"
	// Return live video play referrals from external sources, filtered by the web platform.
	ReferralsFilterExternalLiveWeb ReferralsFilter = "EXTERNAL_LIVE_WEB"
	// Return live video play referrals from internal channels, filtered by the web platform.
	ReferralsFilterInternalChannelLiveWeb ReferralsFilter = "INTERNAL_CHANNEL_LIVE_WEB"
	// Return live video play referrals from internal sources, filtered by the web platform.
	ReferralsFilterInternalLiveWeb ReferralsFilter = "INTERNAL_LIVE_WEB"
)

var AllReferralsFilter = []ReferralsFilter{
	ReferralsFilterAll,
	ReferralsFilterExternalLiveWeb,
	ReferralsFilterInternalChannelLiveWeb,
	ReferralsFilterInternalLiveWeb,
}

func (e ReferralsFilter) IsValid() bool {
	switch e {
	case ReferralsFilterAll, ReferralsFilterExternalLiveWeb, ReferralsFilterInternalChannelLiveWeb, ReferralsFilterInternalLiveWeb:
		return true
	}
	return false
}

func (e ReferralsFilter) String() string {
	return string(e)
}

func (e *ReferralsFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReferralsFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReferralsFilter", str)
	}
	return nil
}

func (e ReferralsFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumerates possible errors when registering payout information.
type RegisterPayoutInformationErrorCode string

const (
	// Must have auth credentials to register payout information.
	RegisterPayoutInformationErrorCodeUnauthenticated RegisterPayoutInformationErrorCode = "UNAUTHENTICATED"
	// User does not have permission to register payout information for the targeted user.
	RegisterPayoutInformationErrorCodeForbidden RegisterPayoutInformationErrorCode = "FORBIDDEN"
	// One or more fields have an invalid format.
	RegisterPayoutInformationErrorCodeInvalidFormat RegisterPayoutInformationErrorCode = "INVALID_FORMAT"
	// An internal error has occurred.
	RegisterPayoutInformationErrorCodeInternalError RegisterPayoutInformationErrorCode = "INTERNAL_ERROR"
)

var AllRegisterPayoutInformationErrorCode = []RegisterPayoutInformationErrorCode{
	RegisterPayoutInformationErrorCodeUnauthenticated,
	RegisterPayoutInformationErrorCodeForbidden,
	RegisterPayoutInformationErrorCodeInvalidFormat,
	RegisterPayoutInformationErrorCodeInternalError,
}

func (e RegisterPayoutInformationErrorCode) IsValid() bool {
	switch e {
	case RegisterPayoutInformationErrorCodeUnauthenticated, RegisterPayoutInformationErrorCodeForbidden, RegisterPayoutInformationErrorCodeInvalidFormat, RegisterPayoutInformationErrorCodeInternalError:
		return true
	}
	return false
}

func (e RegisterPayoutInformationErrorCode) String() string {
	return string(e)
}

func (e *RegisterPayoutInformationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RegisterPayoutInformationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RegisterPayoutInformationErrorCode", str)
	}
	return nil
}

func (e RegisterPayoutInformationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumerates vaid field names when registering payout information.
type RegisterPayoutInformationFieldName string

const (
	// Assigned if Birthdate is given in invalid format.
	RegisterPayoutInformationFieldNameBirthdate RegisterPayoutInformationFieldName = "BIRTHDATE"
	// Assigned if City is given in invalid format.
	RegisterPayoutInformationFieldNameCity RegisterPayoutInformationFieldName = "CITY"
	// Assigned if Company Name is given in invalid format.
	RegisterPayoutInformationFieldNameCompanyName RegisterPayoutInformationFieldName = "COMPANY_NAME"
	// Assigned if Country Code is given in invalid format.
	RegisterPayoutInformationFieldNameCountryCode RegisterPayoutInformationFieldName = "COUNTRY_CODE"
	// Assigned if Email is given in invalid format.
	RegisterPayoutInformationFieldNameEmail RegisterPayoutInformationFieldName = "EMAIL"
	// Assigned if First Name is given in invalid format.
	RegisterPayoutInformationFieldNameFirstName RegisterPayoutInformationFieldName = "FIRST_NAME"
	// Assigned if Last Name is given in invalid format.
	RegisterPayoutInformationFieldNameLastName RegisterPayoutInformationFieldName = "LAST_NAME"
	// Assigned if Middle Name is given in invalid format.
	RegisterPayoutInformationFieldNameMiddleName RegisterPayoutInformationFieldName = "MIDDLE_NAME"
	// Assigned if Postal is given in invalid format.
	RegisterPayoutInformationFieldNamePostal RegisterPayoutInformationFieldName = "POSTAL"
	// Assigned if State Code is given in invalid format.
	RegisterPayoutInformationFieldNameStateCode RegisterPayoutInformationFieldName = "STATE_CODE"
	// Assigned if Primary Address is given in invalid format.
	RegisterPayoutInformationFieldNameStreetAddress RegisterPayoutInformationFieldName = "STREET_ADDRESS"
	// Assigned if Secondary Address is given in invalid format.
	RegisterPayoutInformationFieldNameStreetAddress2 RegisterPayoutInformationFieldName = "STREET_ADDRESS_2"
	// Assigned if Parent Name is given in invalid format.
	RegisterPayoutInformationFieldNameParentName RegisterPayoutInformationFieldName = "PARENT_NAME"
	// Assigned if Parent Email is given in invalid format.
	RegisterPayoutInformationFieldNameParentEmail RegisterPayoutInformationFieldName = "PARENT_EMAIL"
)

var AllRegisterPayoutInformationFieldName = []RegisterPayoutInformationFieldName{
	RegisterPayoutInformationFieldNameBirthdate,
	RegisterPayoutInformationFieldNameCity,
	RegisterPayoutInformationFieldNameCompanyName,
	RegisterPayoutInformationFieldNameCountryCode,
	RegisterPayoutInformationFieldNameEmail,
	RegisterPayoutInformationFieldNameFirstName,
	RegisterPayoutInformationFieldNameLastName,
	RegisterPayoutInformationFieldNameMiddleName,
	RegisterPayoutInformationFieldNamePostal,
	RegisterPayoutInformationFieldNameStateCode,
	RegisterPayoutInformationFieldNameStreetAddress,
	RegisterPayoutInformationFieldNameStreetAddress2,
	RegisterPayoutInformationFieldNameParentName,
	RegisterPayoutInformationFieldNameParentEmail,
}

func (e RegisterPayoutInformationFieldName) IsValid() bool {
	switch e {
	case RegisterPayoutInformationFieldNameBirthdate, RegisterPayoutInformationFieldNameCity, RegisterPayoutInformationFieldNameCompanyName, RegisterPayoutInformationFieldNameCountryCode, RegisterPayoutInformationFieldNameEmail, RegisterPayoutInformationFieldNameFirstName, RegisterPayoutInformationFieldNameLastName, RegisterPayoutInformationFieldNameMiddleName, RegisterPayoutInformationFieldNamePostal, RegisterPayoutInformationFieldNameStateCode, RegisterPayoutInformationFieldNameStreetAddress, RegisterPayoutInformationFieldNameStreetAddress2, RegisterPayoutInformationFieldNameParentName, RegisterPayoutInformationFieldNameParentEmail:
		return true
	}
	return false
}

func (e RegisterPayoutInformationFieldName) String() string {
	return string(e)
}

func (e *RegisterPayoutInformationFieldName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RegisterPayoutInformationFieldName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RegisterPayoutInformationFieldName", str)
	}
	return nil
}

func (e RegisterPayoutInformationFieldName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible error enums returned while trying to confirm registeration for two factor authentication.
type RegisterTwoFactorConfirmationErrorCode string

const (
	// The user needs to re-authenticate to perform this operation.
	RegisterTwoFactorConfirmationErrorCodeReauthNeeded RegisterTwoFactorConfirmationErrorCode = "REAUTH_NEEDED"
	// The user cannot confirm two factor registration since the initial registration was never started or has expired.
	RegisterTwoFactorConfirmationErrorCodeRegistrationNotStarted RegisterTwoFactorConfirmationErrorCode = "REGISTRATION_NOT_STARTED"
	// The one time password provided is invalid.
	RegisterTwoFactorConfirmationErrorCodeInvalidOtp RegisterTwoFactorConfirmationErrorCode = "INVALID_OTP"
	// The one time password provided is missing.
	RegisterTwoFactorConfirmationErrorCodeMissingOtp RegisterTwoFactorConfirmationErrorCode = "MISSING_OTP"
	// Something unexpected occured.
	RegisterTwoFactorConfirmationErrorCodeUnknownError RegisterTwoFactorConfirmationErrorCode = "UNKNOWN_ERROR"
)

var AllRegisterTwoFactorConfirmationErrorCode = []RegisterTwoFactorConfirmationErrorCode{
	RegisterTwoFactorConfirmationErrorCodeReauthNeeded,
	RegisterTwoFactorConfirmationErrorCodeRegistrationNotStarted,
	RegisterTwoFactorConfirmationErrorCodeInvalidOtp,
	RegisterTwoFactorConfirmationErrorCodeMissingOtp,
	RegisterTwoFactorConfirmationErrorCodeUnknownError,
}

func (e RegisterTwoFactorConfirmationErrorCode) IsValid() bool {
	switch e {
	case RegisterTwoFactorConfirmationErrorCodeReauthNeeded, RegisterTwoFactorConfirmationErrorCodeRegistrationNotStarted, RegisterTwoFactorConfirmationErrorCodeInvalidOtp, RegisterTwoFactorConfirmationErrorCodeMissingOtp, RegisterTwoFactorConfirmationErrorCodeUnknownError:
		return true
	}
	return false
}

func (e RegisterTwoFactorConfirmationErrorCode) String() string {
	return string(e)
}

func (e *RegisterTwoFactorConfirmationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RegisterTwoFactorConfirmationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RegisterTwoFactorConfirmationErrorCode", str)
	}
	return nil
}

func (e RegisterTwoFactorConfirmationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible error enums returned while trying to register for two factor authentication.
type RegisterTwoFactorErrorCode string

const (
	// The user needs to re-authenticate to perform this operation.
	RegisterTwoFactorErrorCodeReauthNeeded RegisterTwoFactorErrorCode = "REAUTH_NEEDED"
	// Phone number was not provided.
	RegisterTwoFactorErrorCodeMissingPhoneNumber RegisterTwoFactorErrorCode = "MISSING_PHONE_NUMBER"
	// Phone number was not valid.
	RegisterTwoFactorErrorCodeInvalidPhoneNumber RegisterTwoFactorErrorCode = "INVALID_PHONE_NUMBER"
	// The user has requested to register for two factor authentication too many times.
	RegisterTwoFactorErrorCodeRequestThrottled RegisterTwoFactorErrorCode = "REQUEST_THROTTLED"
	// The phone number provided is used for too many Twitch accounts.
	RegisterTwoFactorErrorCodeLimitReached RegisterTwoFactorErrorCode = "LIMIT_REACHED"
	// Something unexpected occured.
	RegisterTwoFactorErrorCodeUnknownError RegisterTwoFactorErrorCode = "UNKNOWN_ERROR"
)

var AllRegisterTwoFactorErrorCode = []RegisterTwoFactorErrorCode{
	RegisterTwoFactorErrorCodeReauthNeeded,
	RegisterTwoFactorErrorCodeMissingPhoneNumber,
	RegisterTwoFactorErrorCodeInvalidPhoneNumber,
	RegisterTwoFactorErrorCodeRequestThrottled,
	RegisterTwoFactorErrorCodeLimitReached,
	RegisterTwoFactorErrorCodeUnknownError,
}

func (e RegisterTwoFactorErrorCode) IsValid() bool {
	switch e {
	case RegisterTwoFactorErrorCodeReauthNeeded, RegisterTwoFactorErrorCodeMissingPhoneNumber, RegisterTwoFactorErrorCodeInvalidPhoneNumber, RegisterTwoFactorErrorCodeRequestThrottled, RegisterTwoFactorErrorCodeLimitReached, RegisterTwoFactorErrorCodeUnknownError:
		return true
	}
	return false
}

func (e RegisterTwoFactorErrorCode) String() string {
	return string(e)
}

func (e *RegisterTwoFactorErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RegisterTwoFactorErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RegisterTwoFactorErrorCode", str)
	}
	return nil
}

func (e RegisterTwoFactorErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The registration type signifies the policy for participants to join the competition.
type RegistrationType string

const (
	// Competition that any Twitch user can join.
	RegistrationTypeOpen RegistrationType = "OPEN"
	// Competition that only invited participants can join.
	RegistrationTypeInvitational RegistrationType = "INVITATIONAL"
	// Open competition where only followers of the channel can join.
	RegistrationTypeFollowers RegistrationType = "FOLLOWERS"
	// Open competition where only subscribers of the channel can join.
	RegistrationTypeSubscribers RegistrationType = "SUBSCRIBERS"
	// Open competition where only followers and subscribers of the channel can join.
	RegistrationTypeFollowerAndSubscribers RegistrationType = "FOLLOWER_AND_SUBSCRIBERS"
	// Unknown type.
	RegistrationTypeUnknown RegistrationType = "UNKNOWN"
)

var AllRegistrationType = []RegistrationType{
	RegistrationTypeOpen,
	RegistrationTypeInvitational,
	RegistrationTypeFollowers,
	RegistrationTypeSubscribers,
	RegistrationTypeFollowerAndSubscribers,
	RegistrationTypeUnknown,
}

func (e RegistrationType) IsValid() bool {
	switch e {
	case RegistrationTypeOpen, RegistrationTypeInvitational, RegistrationTypeFollowers, RegistrationTypeSubscribers, RegistrationTypeFollowerAndSubscribers, RegistrationTypeUnknown:
		return true
	}
	return false
}

func (e RegistrationType) String() string {
	return string(e)
}

func (e *RegistrationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RegistrationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RegistrationType", str)
	}
	return nil
}

func (e RegistrationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors from this mutation.
type RejectSquadStreamInvitationErrorCode string

const (
	// Invitation to be rejected does not exist.
	RejectSquadStreamInvitationErrorCodeInvitationNotFound RejectSquadStreamInvitationErrorCode = "INVITATION_NOT_FOUND"
	// Squad associated with the invitation does not exist.
	RejectSquadStreamInvitationErrorCodeSquadNotFound RejectSquadStreamInvitationErrorCode = "SQUAD_NOT_FOUND"
	// User does not have permissions to reject invitation.
	RejectSquadStreamInvitationErrorCodeUnauthorized RejectSquadStreamInvitationErrorCode = "UNAUTHORIZED"
	// Invitation not in pending state cannot be rejected.
	RejectSquadStreamInvitationErrorCodeInvitationCannotBeRejected RejectSquadStreamInvitationErrorCode = "INVITATION_CANNOT_BE_REJECTED"
)

var AllRejectSquadStreamInvitationErrorCode = []RejectSquadStreamInvitationErrorCode{
	RejectSquadStreamInvitationErrorCodeInvitationNotFound,
	RejectSquadStreamInvitationErrorCodeSquadNotFound,
	RejectSquadStreamInvitationErrorCodeUnauthorized,
	RejectSquadStreamInvitationErrorCodeInvitationCannotBeRejected,
}

func (e RejectSquadStreamInvitationErrorCode) IsValid() bool {
	switch e {
	case RejectSquadStreamInvitationErrorCodeInvitationNotFound, RejectSquadStreamInvitationErrorCodeSquadNotFound, RejectSquadStreamInvitationErrorCodeUnauthorized, RejectSquadStreamInvitationErrorCodeInvitationCannotBeRejected:
		return true
	}
	return false
}

func (e RejectSquadStreamInvitationErrorCode) String() string {
	return string(e)
}

func (e *RejectSquadStreamInvitationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RejectSquadStreamInvitationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RejectSquadStreamInvitationErrorCode", str)
	}
	return nil
}

func (e RejectSquadStreamInvitationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// RejectSquadStreamOutOfNetworkInvitationsErrorCode are the possible errors that this mutation returns.
type RejectSquadStreamOutOfNetworkInvitationsErrorCode string

const (
	// The user is not authorized to reject invitations on behalf of the recipient.
	RejectSquadStreamOutOfNetworkInvitationsErrorCodeUnauthorized RejectSquadStreamOutOfNetworkInvitationsErrorCode = "UNAUTHORIZED"
)

var AllRejectSquadStreamOutOfNetworkInvitationsErrorCode = []RejectSquadStreamOutOfNetworkInvitationsErrorCode{
	RejectSquadStreamOutOfNetworkInvitationsErrorCodeUnauthorized,
}

func (e RejectSquadStreamOutOfNetworkInvitationsErrorCode) IsValid() bool {
	switch e {
	case RejectSquadStreamOutOfNetworkInvitationsErrorCodeUnauthorized:
		return true
	}
	return false
}

func (e RejectSquadStreamOutOfNetworkInvitationsErrorCode) String() string {
	return string(e)
}

func (e *RejectSquadStreamOutOfNetworkInvitationsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RejectSquadStreamOutOfNetworkInvitationsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RejectSquadStreamOutOfNetworkInvitationsErrorCode", str)
	}
	return nil
}

func (e RejectSquadStreamOutOfNetworkInvitationsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// RemoveEditorErrorCode defines a client error that occurred while removing an editor.
type RemoveEditorErrorCode string

const (
	// The channel does not exist.
	RemoveEditorErrorCodeChannelNotFound RemoveEditorErrorCode = "CHANNEL_NOT_FOUND"
	// The target user does not exist.
	RemoveEditorErrorCodeTargetUserNotFound RemoveEditorErrorCode = "TARGET_USER_NOT_FOUND"
)

var AllRemoveEditorErrorCode = []RemoveEditorErrorCode{
	RemoveEditorErrorCodeChannelNotFound,
	RemoveEditorErrorCodeTargetUserNotFound,
}

func (e RemoveEditorErrorCode) IsValid() bool {
	switch e {
	case RemoveEditorErrorCodeChannelNotFound, RemoveEditorErrorCodeTargetUserNotFound:
		return true
	}
	return false
}

func (e RemoveEditorErrorCode) String() string {
	return string(e)
}

func (e *RemoveEditorErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RemoveEditorErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RemoveEditorErrorCode", str)
	}
	return nil
}

func (e RemoveEditorErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// RemoveOrganizationMemberErrorCode defines a client error that occurred while removing an organization member.
type RemoveOrganizationMemberErrorCode string

const (
	// User does not have permission to remove another member.
	RemoveOrganizationMemberErrorCodePermissionDenied RemoveOrganizationMemberErrorCode = "PERMISSION_DENIED"
	// The user to be removed does not exist.
	RemoveOrganizationMemberErrorCodeUserNotFound RemoveOrganizationMemberErrorCode = "USER_NOT_FOUND"
	// Can not remove this user because it is assigned as an extension billing manager. Need to unassign first.
	RemoveOrganizationMemberErrorCodeAssignedBillingManager RemoveOrganizationMemberErrorCode = "ASSIGNED_BILLING_MANAGER"
	// Deprecated: code not used, a resolver error is returned instead.
	RemoveOrganizationMemberErrorCodeInternalError RemoveOrganizationMemberErrorCode = "INTERNAL_ERROR"
)

var AllRemoveOrganizationMemberErrorCode = []RemoveOrganizationMemberErrorCode{
	RemoveOrganizationMemberErrorCodePermissionDenied,
	RemoveOrganizationMemberErrorCodeUserNotFound,
	RemoveOrganizationMemberErrorCodeAssignedBillingManager,
	RemoveOrganizationMemberErrorCodeInternalError,
}

func (e RemoveOrganizationMemberErrorCode) IsValid() bool {
	switch e {
	case RemoveOrganizationMemberErrorCodePermissionDenied, RemoveOrganizationMemberErrorCodeUserNotFound, RemoveOrganizationMemberErrorCodeAssignedBillingManager, RemoveOrganizationMemberErrorCodeInternalError:
		return true
	}
	return false
}

func (e RemoveOrganizationMemberErrorCode) String() string {
	return string(e)
}

func (e *RemoveOrganizationMemberErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RemoveOrganizationMemberErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RemoveOrganizationMemberErrorCode", str)
	}
	return nil
}

func (e RemoveOrganizationMemberErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// RemoveSquadStreamMemberErrorCode are the possible errors that this mutation returns.
type RemoveSquadStreamMemberErrorCode string

const (
	// The user is not authorized to remove members from the squad.
	RemoveSquadStreamMemberErrorCodeUnauthorized RemoveSquadStreamMemberErrorCode = "UNAUTHORIZED"
	// The user to be removed is not in the squad specified.
	RemoveSquadStreamMemberErrorCodeUserNotInSquad RemoveSquadStreamMemberErrorCode = "USER_NOT_IN_SQUAD"
)

var AllRemoveSquadStreamMemberErrorCode = []RemoveSquadStreamMemberErrorCode{
	RemoveSquadStreamMemberErrorCodeUnauthorized,
	RemoveSquadStreamMemberErrorCodeUserNotInSquad,
}

func (e RemoveSquadStreamMemberErrorCode) IsValid() bool {
	switch e {
	case RemoveSquadStreamMemberErrorCodeUnauthorized, RemoveSquadStreamMemberErrorCodeUserNotInSquad:
		return true
	}
	return false
}

func (e RemoveSquadStreamMemberErrorCode) String() string {
	return string(e)
}

func (e *RemoveSquadStreamMemberErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RemoveSquadStreamMemberErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RemoveSquadStreamMemberErrorCode", str)
	}
	return nil
}

func (e RemoveSquadStreamMemberErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// RenewalPolicy defines whether the charge model will renew or not.
type RenewalPolicy string

const (
	// Will not renew automatically.
	RenewalPolicyNoRenew RenewalPolicy = "NO_RENEW"
	// Will renew automatically.
	RenewalPolicyAutoRenew RenewalPolicy = "AUTO_RENEW"
	// Unknown renewal policy.
	RenewalPolicyUnknown RenewalPolicy = "UNKNOWN"
)

var AllRenewalPolicy = []RenewalPolicy{
	RenewalPolicyNoRenew,
	RenewalPolicyAutoRenew,
	RenewalPolicyUnknown,
}

func (e RenewalPolicy) IsValid() bool {
	switch e {
	case RenewalPolicyNoRenew, RenewalPolicyAutoRenew, RenewalPolicyUnknown:
		return true
	}
	return false
}

func (e RenewalPolicy) String() string {
	return string(e)
}

func (e *RenewalPolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RenewalPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RenewalPolicy", str)
	}
	return nil
}

func (e RenewalPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid values for ReportContentNetzDGInput.contentDirectedTo.
type ReportContentNetzDGContentDirectedTo string

const (
	// The reported content is directed at the reporter.
	ReportContentNetzDGContentDirectedToMe ReportContentNetzDGContentDirectedTo = "ME"
	// The reported content is directed at someone the reporter represents.
	ReportContentNetzDGContentDirectedToSomeoneIRepresent ReportContentNetzDGContentDirectedTo = "SOMEONE_I_REPRESENT"
	// The reported content is directed at someone else.
	ReportContentNetzDGContentDirectedToSomeoneElse ReportContentNetzDGContentDirectedTo = "SOMEONE_ELSE"
)

var AllReportContentNetzDGContentDirectedTo = []ReportContentNetzDGContentDirectedTo{
	ReportContentNetzDGContentDirectedToMe,
	ReportContentNetzDGContentDirectedToSomeoneIRepresent,
	ReportContentNetzDGContentDirectedToSomeoneElse,
}

func (e ReportContentNetzDGContentDirectedTo) IsValid() bool {
	switch e {
	case ReportContentNetzDGContentDirectedToMe, ReportContentNetzDGContentDirectedToSomeoneIRepresent, ReportContentNetzDGContentDirectedToSomeoneElse:
		return true
	}
	return false
}

func (e ReportContentNetzDGContentDirectedTo) String() string {
	return string(e)
}

func (e *ReportContentNetzDGContentDirectedTo) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReportContentNetzDGContentDirectedTo(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReportContentNetzDGContentDirectedTo", str)
	}
	return nil
}

func (e ReportContentNetzDGContentDirectedTo) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid values for ReportContentNetzDGInput.ReportingFor.
type ReportContentNetzDGReportingFor string

const (
	// The reporter is reporting for themselves.
	ReportContentNetzDGReportingForMyself ReportContentNetzDGReportingFor = "MYSELF"
	// The reporter is reporting on behalf of a complaints office.
	ReportContentNetzDGReportingForComplaintsOffice ReportContentNetzDGReportingFor = "COMPLAINTS_OFFICE"
	// The report is reporting on behalf of an agency of the german government.
	ReportContentNetzDGReportingForGovernmentAgency ReportContentNetzDGReportingFor = "GOVERNMENT_AGENCY"
)

var AllReportContentNetzDGReportingFor = []ReportContentNetzDGReportingFor{
	ReportContentNetzDGReportingForMyself,
	ReportContentNetzDGReportingForComplaintsOffice,
	ReportContentNetzDGReportingForGovernmentAgency,
}

func (e ReportContentNetzDGReportingFor) IsValid() bool {
	switch e {
	case ReportContentNetzDGReportingForMyself, ReportContentNetzDGReportingForComplaintsOffice, ReportContentNetzDGReportingForGovernmentAgency:
		return true
	}
	return false
}

func (e ReportContentNetzDGReportingFor) String() string {
	return string(e)
}

func (e *ReportContentNetzDGReportingFor) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReportContentNetzDGReportingFor(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReportContentNetzDGReportingFor", str)
	}
	return nil
}

func (e ReportContentNetzDGReportingFor) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of content that can be reported.
type ReportContentType string

const (
	// Report against a channel feed comment.
	ReportContentTypeChannelFeedCommentReport ReportContentType = "CHANNEL_FEED_COMMENT_REPORT"
	// Report against a channel feed post.
	ReportContentTypeChannelFeedPostReport ReportContentType = "CHANNEL_FEED_POST_REPORT"
	// Report against a chat message.
	ReportContentTypeChatReport ReportContentType = "CHAT_REPORT"
	// Report against a channel's channel points.
	ReportContentTypeChannelPointsReport ReportContentType = "CHANNEL_POINTS_REPORT"
	// Report against a clip.
	ReportContentTypeClipReport ReportContentType = "CLIP_REPORT"
	// (Deprecated) Report against a vod collection.
	ReportContentTypeCollectionReport ReportContentType = "COLLECTION_REPORT"
	// (Deprecated) Report against a curse private group.
	ReportContentTypeCursePrivateGroup ReportContentType = "CURSE_PRIVATE_GROUP"
	// (Deprecated) Report against a curse public group.
	ReportContentTypeCursePublicGroup ReportContentType = "CURSE_PUBLIC_GROUP"
	// (Deprecated) Report against a curse whisper.
	ReportContentTypeCurseWhisper ReportContentType = "CURSE_WHISPER"
	// Report against an emote.
	ReportContentTypeEmoteReport ReportContentType = "EMOTE_REPORT"
	// Report against an oracle event.
	ReportContentTypeEventReport ReportContentType = "EVENT_REPORT"
	// Report against an extension.
	ReportContentTypeExtensionReport ReportContentType = "EXTENSION_REPORT"
	// Report against a live up notification.
	ReportContentTypeLiveUpReport ReportContentType = "LIVE_UP_REPORT"
	// Report against a livestream.
	ReportContentTypeLivestreamReport ReportContentType = "LIVESTREAM_REPORT"
	// Report against a poll.
	ReportContentTypePollReport ReportContentType = "POLL_REPORT"
	// Report against a raid.
	ReportContentTypeRaidReport ReportContentType = "RAID_REPORT"
	// Report against a reward redemption.
	ReportContentTypeRewardRedemptionReport ReportContentType = "REWARD_REDEMPTION_REPORT"
	// Report against a chatroom.
	ReportContentTypeRoomReport ReportContentType = "ROOM_REPORT"
	// Report against sings group name.
	ReportContentTypeSingsGroupNameReport ReportContentType = "SINGS_GROUP_NAME_REPORT"
	// Report against sings group biography.
	ReportContentTypeSingsGroupBioReport ReportContentType = "SINGS_GROUP_BIO_REPORT"
	// Report against sings group chat.
	ReportContentTypeSingsGroupChatReport ReportContentType = "SINGS_GROUP_CHAT_REPORT"
	// Report against a sings group vod comment.
	ReportContentTypeSingsVodCommentReport ReportContentType = "SINGS_VOD_COMMENT_REPORT"
	// Report against sings duet seed.
	ReportContentTypeSingsDuetSeedReport ReportContentType = "SINGS_DUET_SEED_REPORT"
	// Report against an unban request.
	ReportContentTypeUnbanRequestReport ReportContentType = "UNBAN_REQUEST_REPORT"
	// Report against a live user.
	ReportContentTypeUserReport ReportContentType = "USER_REPORT"
	// Report against a twitch vod comment.
	ReportContentTypeVodCommentReport ReportContentType = "VOD_COMMENT_REPORT"
	// Report against a twitch vod.
	ReportContentTypeVodReport ReportContentType = "VOD_REPORT"
	// Report against a whisper. Deprecated in favor of the whisperReport mutation.
	ReportContentTypeWhisperReport ReportContentType = "WHISPER_REPORT"
)

var AllReportContentType = []ReportContentType{
	ReportContentTypeChannelFeedCommentReport,
	ReportContentTypeChannelFeedPostReport,
	ReportContentTypeChatReport,
	ReportContentTypeChannelPointsReport,
	ReportContentTypeClipReport,
	ReportContentTypeCollectionReport,
	ReportContentTypeCursePrivateGroup,
	ReportContentTypeCursePublicGroup,
	ReportContentTypeCurseWhisper,
	ReportContentTypeEmoteReport,
	ReportContentTypeEventReport,
	ReportContentTypeExtensionReport,
	ReportContentTypeLiveUpReport,
	ReportContentTypeLivestreamReport,
	ReportContentTypePollReport,
	ReportContentTypeRaidReport,
	ReportContentTypeRewardRedemptionReport,
	ReportContentTypeRoomReport,
	ReportContentTypeSingsGroupNameReport,
	ReportContentTypeSingsGroupBioReport,
	ReportContentTypeSingsGroupChatReport,
	ReportContentTypeSingsVodCommentReport,
	ReportContentTypeSingsDuetSeedReport,
	ReportContentTypeUnbanRequestReport,
	ReportContentTypeUserReport,
	ReportContentTypeVodCommentReport,
	ReportContentTypeVodReport,
	ReportContentTypeWhisperReport,
}

func (e ReportContentType) IsValid() bool {
	switch e {
	case ReportContentTypeChannelFeedCommentReport, ReportContentTypeChannelFeedPostReport, ReportContentTypeChatReport, ReportContentTypeChannelPointsReport, ReportContentTypeClipReport, ReportContentTypeCollectionReport, ReportContentTypeCursePrivateGroup, ReportContentTypeCursePublicGroup, ReportContentTypeCurseWhisper, ReportContentTypeEmoteReport, ReportContentTypeEventReport, ReportContentTypeExtensionReport, ReportContentTypeLiveUpReport, ReportContentTypeLivestreamReport, ReportContentTypePollReport, ReportContentTypeRaidReport, ReportContentTypeRewardRedemptionReport, ReportContentTypeRoomReport, ReportContentTypeSingsGroupNameReport, ReportContentTypeSingsGroupBioReport, ReportContentTypeSingsGroupChatReport, ReportContentTypeSingsVodCommentReport, ReportContentTypeSingsDuetSeedReport, ReportContentTypeUnbanRequestReport, ReportContentTypeUserReport, ReportContentTypeVodCommentReport, ReportContentTypeVodReport, ReportContentTypeWhisperReport:
		return true
	}
	return false
}

func (e ReportContentType) String() string {
	return string(e)
}

func (e *ReportContentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReportContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReportContentType", str)
	}
	return nil
}

func (e ReportContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error reasons returned by reportWhisper mutation.
type ReportWhisperErrorReason string

const (
	// Invalid user ID.
	ReportWhisperErrorReasonInvalidUserID ReportWhisperErrorReason = "INVALID_USER_ID"
	// There are no whispers from the target user to the reporter.
	ReportWhisperErrorReasonNoWhispersFromTargetUser ReportWhisperErrorReason = "NO_WHISPERS_FROM_TARGET_USER"
	// The reporter is currently rate limited.
	ReportWhisperErrorReasonRateLimited ReportWhisperErrorReason = "RATE_LIMITED"
	// Unauthorized.
	ReportWhisperErrorReasonUnauthorized ReportWhisperErrorReason = "UNAUTHORIZED"
	// Unknown error.
	ReportWhisperErrorReasonUnknown ReportWhisperErrorReason = "UNKNOWN"
)

var AllReportWhisperErrorReason = []ReportWhisperErrorReason{
	ReportWhisperErrorReasonInvalidUserID,
	ReportWhisperErrorReasonNoWhispersFromTargetUser,
	ReportWhisperErrorReasonRateLimited,
	ReportWhisperErrorReasonUnauthorized,
	ReportWhisperErrorReasonUnknown,
}

func (e ReportWhisperErrorReason) IsValid() bool {
	switch e {
	case ReportWhisperErrorReasonInvalidUserID, ReportWhisperErrorReasonNoWhispersFromTargetUser, ReportWhisperErrorReasonRateLimited, ReportWhisperErrorReasonUnauthorized, ReportWhisperErrorReasonUnknown:
		return true
	}
	return false
}

func (e ReportWhisperErrorReason) String() string {
	return string(e)
}

func (e *ReportWhisperErrorReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReportWhisperErrorReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReportWhisperErrorReason", str)
	}
	return nil
}

func (e ReportWhisperErrorReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RequestRitualTokenErrorCode string

const (
	// Token is not in a status that can be requested.
	RequestRitualTokenErrorCodeTokenNotAvailable RequestRitualTokenErrorCode = "TOKEN_NOT_AVAILABLE"
	// Token does not exist.
	RequestRitualTokenErrorCodeTokenNotFound RequestRitualTokenErrorCode = "TOKEN_NOT_FOUND"
)

var AllRequestRitualTokenErrorCode = []RequestRitualTokenErrorCode{
	RequestRitualTokenErrorCodeTokenNotAvailable,
	RequestRitualTokenErrorCodeTokenNotFound,
}

func (e RequestRitualTokenErrorCode) IsValid() bool {
	switch e {
	case RequestRitualTokenErrorCodeTokenNotAvailable, RequestRitualTokenErrorCodeTokenNotFound:
		return true
	}
	return false
}

func (e RequestRitualTokenErrorCode) String() string {
	return string(e)
}

func (e *RequestRitualTokenErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RequestRitualTokenErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RequestRitualTokenErrorCode", str)
	}
	return nil
}

func (e RequestRitualTokenErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes returned from a username reset.
type ResetUsernameErrorCode string

const (
	// Authorization token is not valid.
	ResetUsernameErrorCodeTokenInvalid ResetUsernameErrorCode = "TOKEN_INVALID"
	// Too many attempts to update login.
	ResetUsernameErrorCodeRequestsThrottled ResetUsernameErrorCode = "REQUESTS_THROTTLED"
	// Login is not available.
	ResetUsernameErrorCodeLoginUnavailable ResetUsernameErrorCode = "LOGIN_UNAVAILABLE"
	// Login is too short.
	ResetUsernameErrorCodeLoginTooShort ResetUsernameErrorCode = "LOGIN_TOO_SHORT"
	// Login is too long.
	ResetUsernameErrorCodeLoginTooLong ResetUsernameErrorCode = "LOGIN_TOO_LONG"
	// Login contains characters that are not allowed.
	ResetUsernameErrorCodeLoginContainsInvalidCharacters ResetUsernameErrorCode = "LOGIN_CONTAINS_INVALID_CHARACTERS"
	// Unrecognized error returned from the backend service.
	ResetUsernameErrorCodeUnknownError ResetUsernameErrorCode = "UNKNOWN_ERROR"
)

var AllResetUsernameErrorCode = []ResetUsernameErrorCode{
	ResetUsernameErrorCodeTokenInvalid,
	ResetUsernameErrorCodeRequestsThrottled,
	ResetUsernameErrorCodeLoginUnavailable,
	ResetUsernameErrorCodeLoginTooShort,
	ResetUsernameErrorCodeLoginTooLong,
	ResetUsernameErrorCodeLoginContainsInvalidCharacters,
	ResetUsernameErrorCodeUnknownError,
}

func (e ResetUsernameErrorCode) IsValid() bool {
	switch e {
	case ResetUsernameErrorCodeTokenInvalid, ResetUsernameErrorCodeRequestsThrottled, ResetUsernameErrorCodeLoginUnavailable, ResetUsernameErrorCodeLoginTooShort, ResetUsernameErrorCodeLoginTooLong, ResetUsernameErrorCodeLoginContainsInvalidCharacters, ResetUsernameErrorCodeUnknownError:
		return true
	}
	return false
}

func (e ResetUsernameErrorCode) String() string {
	return string(e)
}

func (e *ResetUsernameErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResetUsernameErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResetUsernameErrorCode", str)
	}
	return nil
}

func (e ResetUsernameErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes from the resolvePredictionEvent mutation.
type ResolvePredictionEventErrorCode string

const (
	// The current user is forbidden from resolving this Prediction Event.
	ResolvePredictionEventErrorCodeForbidden ResolvePredictionEventErrorCode = "FORBIDDEN"
	// This Prediction Event has already either been resolved or canceled, and as such this action cannot be taken.
	ResolvePredictionEventErrorCodeEventEnded ResolvePredictionEventErrorCode = "EVENT_ENDED"
	// An unknown error occurred.
	ResolvePredictionEventErrorCodeUnknown ResolvePredictionEventErrorCode = "UNKNOWN"
)

var AllResolvePredictionEventErrorCode = []ResolvePredictionEventErrorCode{
	ResolvePredictionEventErrorCodeForbidden,
	ResolvePredictionEventErrorCodeEventEnded,
	ResolvePredictionEventErrorCodeUnknown,
}

func (e ResolvePredictionEventErrorCode) IsValid() bool {
	switch e {
	case ResolvePredictionEventErrorCodeForbidden, ResolvePredictionEventErrorCodeEventEnded, ResolvePredictionEventErrorCodeUnknown:
		return true
	}
	return false
}

func (e ResolvePredictionEventErrorCode) String() string {
	return string(e)
}

func (e *ResolvePredictionEventErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResolvePredictionEventErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResolvePredictionEventErrorCode", str)
	}
	return nil
}

func (e ResolvePredictionEventErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of the different exemption types.
type ResourceRestrictionExemptionType string

const (
	// The restriction is exempt for an unknown reason.
	ResourceRestrictionExemptionTypeUnknown ResourceRestrictionExemptionType = "UNKNOWN"
	// The restriction is exempt for all users.
	ResourceRestrictionExemptionTypeAll ResourceRestrictionExemptionType = "ALL"
	// The restriction is exempt for staff accounts.
	ResourceRestrictionExemptionTypeStaff ResourceRestrictionExemptionType = "STAFF"
	// The restriction is exempt for site admins.
	ResourceRestrictionExemptionTypeSiteAdmin ResourceRestrictionExemptionType = "SITE_ADMIN"
	// The restriction is exempt for owning a product.
	ResourceRestrictionExemptionTypeProduct ResourceRestrictionExemptionType = "PRODUCT"
	// The restriction is exempt for viewers that are in the same org as the channel owner.
	ResourceRestrictionExemptionTypeOrganizationMember ResourceRestrictionExemptionType = "ORGANIZATION_MEMBER"
	// The restriction is exempt for the preview duration.
	ResourceRestrictionExemptionTypePreview ResourceRestrictionExemptionType = "PREVIEW"
	// The restriction is exempt for channel moderators.
	ResourceRestrictionExemptionTypeChannelModerator ResourceRestrictionExemptionType = "CHANNEL_MODERATOR"
	// The restriction is exempt for channel VIPs.
	ResourceRestrictionExemptionTypeChannelVip ResourceRestrictionExemptionType = "CHANNEL_VIP"
)

var AllResourceRestrictionExemptionType = []ResourceRestrictionExemptionType{
	ResourceRestrictionExemptionTypeUnknown,
	ResourceRestrictionExemptionTypeAll,
	ResourceRestrictionExemptionTypeStaff,
	ResourceRestrictionExemptionTypeSiteAdmin,
	ResourceRestrictionExemptionTypeProduct,
	ResourceRestrictionExemptionTypeOrganizationMember,
	ResourceRestrictionExemptionTypePreview,
	ResourceRestrictionExemptionTypeChannelModerator,
	ResourceRestrictionExemptionTypeChannelVip,
}

func (e ResourceRestrictionExemptionType) IsValid() bool {
	switch e {
	case ResourceRestrictionExemptionTypeUnknown, ResourceRestrictionExemptionTypeAll, ResourceRestrictionExemptionTypeStaff, ResourceRestrictionExemptionTypeSiteAdmin, ResourceRestrictionExemptionTypeProduct, ResourceRestrictionExemptionTypeOrganizationMember, ResourceRestrictionExemptionTypePreview, ResourceRestrictionExemptionTypeChannelModerator, ResourceRestrictionExemptionTypeChannelVip:
		return true
	}
	return false
}

func (e ResourceRestrictionExemptionType) String() string {
	return string(e)
}

func (e *ResourceRestrictionExemptionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceRestrictionExemptionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceRestrictionExemptionType", str)
	}
	return nil
}

func (e ResourceRestrictionExemptionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of the different restriction options.
type ResourceRestrictionOption string

const (
	// Allows users holding the channel VIP role to access the resource.
	ResourceRestrictionOptionAllowChannelVip ResourceRestrictionOption = "ALLOW_CHANNEL_VIP"
	// Allows users holding the channel moderator role to access the resource.
	ResourceRestrictionOptionAllowChannelModerator ResourceRestrictionOption = "ALLOW_CHANNEL_MODERATOR"
	// Allows only users with tier 3 subscriptions to access the resource.
	ResourceRestrictionOptionAllowTier3Only ResourceRestrictionOption = "ALLOW_TIER_3_ONLY"
	// Allows only users with tier 2 and 3 subscriptions to access the resource.
	ResourceRestrictionOptionAllowTier2And3Only ResourceRestrictionOption = "ALLOW_TIER_2_AND_3_ONLY"
	// Allows users with any tier subscriptions to access the resource.
	ResourceRestrictionOptionAllowAllTiers ResourceRestrictionOption = "ALLOW_ALL_TIERS"
)

var AllResourceRestrictionOption = []ResourceRestrictionOption{
	ResourceRestrictionOptionAllowChannelVip,
	ResourceRestrictionOptionAllowChannelModerator,
	ResourceRestrictionOptionAllowTier3Only,
	ResourceRestrictionOptionAllowTier2And3Only,
	ResourceRestrictionOptionAllowAllTiers,
}

func (e ResourceRestrictionOption) IsValid() bool {
	switch e {
	case ResourceRestrictionOptionAllowChannelVip, ResourceRestrictionOptionAllowChannelModerator, ResourceRestrictionOptionAllowTier3Only, ResourceRestrictionOptionAllowTier2And3Only, ResourceRestrictionOptionAllowAllTiers:
		return true
	}
	return false
}

func (e ResourceRestrictionOption) String() string {
	return string(e)
}

func (e *ResourceRestrictionOption) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceRestrictionOption(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceRestrictionOption", str)
	}
	return nil
}

func (e ResourceRestrictionOption) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of the different restriction types.
type ResourceRestrictionType string

const (
	// The resource is restricted for an unknown reason.
	ResourceRestrictionTypeUnknown ResourceRestrictionType = "UNKNOWN"
	// The resource is restricted by a subscription.
	ResourceRestrictionTypeSubOnlyLive ResourceRestrictionType = "SUB_ONLY_LIVE"
	// The resource is restricted by the All-Access Pass.
	ResourceRestrictionTypeAllAccessPass ResourceRestrictionType = "ALL_ACCESS_PASS"
	// The resource is restricted by the organization membership logic in RBAC.
	ResourceRestrictionTypeOrganizationAccessOnly ResourceRestrictionType = "ORGANIZATION_ACCESS_ONLY"
)

var AllResourceRestrictionType = []ResourceRestrictionType{
	ResourceRestrictionTypeUnknown,
	ResourceRestrictionTypeSubOnlyLive,
	ResourceRestrictionTypeAllAccessPass,
	ResourceRestrictionTypeOrganizationAccessOnly,
}

func (e ResourceRestrictionType) IsValid() bool {
	switch e {
	case ResourceRestrictionTypeUnknown, ResourceRestrictionTypeSubOnlyLive, ResourceRestrictionTypeAllAccessPass, ResourceRestrictionTypeOrganizationAccessOnly:
		return true
	}
	return false
}

func (e ResourceRestrictionType) String() string {
	return string(e)
}

func (e *ResourceRestrictionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceRestrictionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceRestrictionType", str)
	}
	return nil
}

func (e ResourceRestrictionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of the different restriction types.
type RestrictionResource string

const (
	// For non-live video content, e.g. VODs.
	RestrictionResourceVideo RestrictionResource = "VIDEO"
	// For live video content.
	RestrictionResourceLive RestrictionResource = "LIVE"
)

var AllRestrictionResource = []RestrictionResource{
	RestrictionResourceVideo,
	RestrictionResourceLive,
}

func (e RestrictionResource) IsValid() bool {
	switch e {
	case RestrictionResourceVideo, RestrictionResourceLive:
		return true
	}
	return false
}

func (e RestrictionResource) String() string {
	return string(e)
}

func (e *RestrictionResource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RestrictionResource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RestrictionResource", str)
	}
	return nil
}

func (e RestrictionResource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible erors when resuming a schedule.
type ResumeScheduleError string

const (
	// Not authorized to resume this schedule.
	ResumeScheduleErrorPermissionDenied ResumeScheduleError = "PERMISSION_DENIED"
	// The schedule was not found.
	ResumeScheduleErrorNotFound ResumeScheduleError = "NOT_FOUND"
)

var AllResumeScheduleError = []ResumeScheduleError{
	ResumeScheduleErrorPermissionDenied,
	ResumeScheduleErrorNotFound,
}

func (e ResumeScheduleError) IsValid() bool {
	switch e {
	case ResumeScheduleErrorPermissionDenied, ResumeScheduleErrorNotFound:
		return true
	}
	return false
}

func (e ResumeScheduleError) String() string {
	return string(e)
}

func (e *ResumeScheduleError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResumeScheduleError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResumeScheduleError", str)
	}
	return nil
}

func (e ResumeScheduleError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// RevokeVIPErrorCode defines a client error that occurred while revoking a VIP status.
type RevokeVIPErrorCode string

const (
	// The channel does not exist.
	RevokeVIPErrorCodeChannelNotFound RevokeVIPErrorCode = "CHANNEL_NOT_FOUND"
	// The revoker does not have permission to revoke the VIP status in this channel.
	RevokeVIPErrorCodeForbidden RevokeVIPErrorCode = "FORBIDDEN"
	// The user whose VIP status is to be revoked does not exist.
	RevokeVIPErrorCodeRevokeeNotFound RevokeVIPErrorCode = "REVOKEE_NOT_FOUND"
	// The user whose VIP statu is to be revoked does not actually have the VIP status to be revoked.
	RevokeVIPErrorCodeRevokeeNotVip RevokeVIPErrorCode = "REVOKEE_NOT_VIP"
)

var AllRevokeVIPErrorCode = []RevokeVIPErrorCode{
	RevokeVIPErrorCodeChannelNotFound,
	RevokeVIPErrorCodeForbidden,
	RevokeVIPErrorCodeRevokeeNotFound,
	RevokeVIPErrorCodeRevokeeNotVip,
}

func (e RevokeVIPErrorCode) IsValid() bool {
	switch e {
	case RevokeVIPErrorCodeChannelNotFound, RevokeVIPErrorCodeForbidden, RevokeVIPErrorCodeRevokeeNotFound, RevokeVIPErrorCodeRevokeeNotVip:
		return true
	}
	return false
}

func (e RevokeVIPErrorCode) String() string {
	return string(e)
}

func (e *RevokeVIPErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RevokeVIPErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RevokeVIPErrorCode", str)
	}
	return nil
}

func (e RevokeVIPErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RitualTokenStatus string

const (
	// ELIGIBLE means a user does not have this token, but can request one.
	RitualTokenStatusEligible RitualTokenStatus = "ELIGIBLE"
	// AVAILABLE means a user has been granted this token and it can be redeemed.
	RitualTokenStatusAvailable RitualTokenStatus = "AVAILABLE"
	// DISMISSED means a user has opted out of redeeming this token.
	RitualTokenStatusDismissed RitualTokenStatus = "DISMISSED"
	// REDEEMED means a user has successfully consumed this token.
	RitualTokenStatusRedeemed RitualTokenStatus = "REDEEMED"
)

var AllRitualTokenStatus = []RitualTokenStatus{
	RitualTokenStatusEligible,
	RitualTokenStatusAvailable,
	RitualTokenStatusDismissed,
	RitualTokenStatusRedeemed,
}

func (e RitualTokenStatus) IsValid() bool {
	switch e {
	case RitualTokenStatusEligible, RitualTokenStatusAvailable, RitualTokenStatusDismissed, RitualTokenStatusRedeemed:
		return true
	}
	return false
}

func (e RitualTokenStatus) String() string {
	return string(e)
}

func (e *RitualTokenStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RitualTokenStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RitualTokenStatus", str)
	}
	return nil
}

func (e RitualTokenStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RitualTokenType string

const (
	// NEW_CHATTER is granted 5 minutes after a user joins a channel for the first time.
	RitualTokenTypeNewChatter RitualTokenType = "NEW_CHATTER"
)

var AllRitualTokenType = []RitualTokenType{
	RitualTokenTypeNewChatter,
}

func (e RitualTokenType) IsValid() bool {
	switch e {
	case RitualTokenTypeNewChatter:
		return true
	}
	return false
}

func (e RitualTokenType) String() string {
	return string(e)
}

func (e *RitualTokenType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RitualTokenType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RitualTokenType", str)
	}
	return nil
}

func (e RitualTokenType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DEPRECATED
// Type of user for grouping users in the rooms member list.
type RoomMemberType string

const (
	// User that is the broadcaster.
	RoomMemberTypeBroadcaster RoomMemberType = "BROADCASTER"
	// User that is staff.
	RoomMemberTypeStaff RoomMemberType = "STAFF"
	// User that is admin.
	RoomMemberTypeAdmin RoomMemberType = "ADMIN"
	// User that is global moderator.
	RoomMemberTypeGlobalmod RoomMemberType = "GLOBALMOD"
	// User that is a channel moderator.
	RoomMemberTypeMod RoomMemberType = "MOD"
	// User that has no special role.
	RoomMemberTypeRegular RoomMemberType = "REGULAR"
)

var AllRoomMemberType = []RoomMemberType{
	RoomMemberTypeBroadcaster,
	RoomMemberTypeStaff,
	RoomMemberTypeAdmin,
	RoomMemberTypeGlobalmod,
	RoomMemberTypeMod,
	RoomMemberTypeRegular,
}

func (e RoomMemberType) IsValid() bool {
	switch e {
	case RoomMemberTypeBroadcaster, RoomMemberTypeStaff, RoomMemberTypeAdmin, RoomMemberTypeGlobalmod, RoomMemberTypeMod, RoomMemberTypeRegular:
		return true
	}
	return false
}

func (e RoomMemberType) String() string {
	return string(e)
}

func (e *RoomMemberType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoomMemberType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoomMemberType", str)
	}
	return nil
}

func (e RoomMemberType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents a group mention, such as @here.
type RoomMessageMentionType string

const (
	// An @here mention.
	RoomMessageMentionTypeHere RoomMessageMentionType = "HERE"
)

var AllRoomMessageMentionType = []RoomMessageMentionType{
	RoomMessageMentionTypeHere,
}

func (e RoomMessageMentionType) IsValid() bool {
	switch e {
	case RoomMessageMentionTypeHere:
		return true
	}
	return false
}

func (e RoomMessageMentionType) String() string {
	return string(e)
}

func (e *RoomMessageMentionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoomMessageMentionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoomMessageMentionType", str)
	}
	return nil
}

func (e RoomMessageMentionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DEPRECATED
// Describes the role a user must be in order to perform an action, such as sending messages. Roles are
// hierarchical, so users that meet a role also meet all lower roles as well. For example, a moderator
// meets the subscriber role, even if they are not subscribed to the channel. Roles are defined in order
// from highest to lowest in the enum.
type RoomRole string

const (
	// The channel owner.
	RoomRoleBroadcaster RoomRole = "BROADCASTER"
	// A moderator for the channel.
	RoomRoleModerator RoomRole = "MODERATOR"
	// A subscriber of the channel.
	RoomRoleSubscriber RoomRole = "SUBSCRIBER"
	// All users.
	RoomRoleEveryone RoomRole = "EVERYONE"
)

var AllRoomRole = []RoomRole{
	RoomRoleBroadcaster,
	RoomRoleModerator,
	RoomRoleSubscriber,
	RoomRoleEveryone,
}

func (e RoomRole) IsValid() bool {
	switch e {
	case RoomRoleBroadcaster, RoomRoleModerator, RoomRoleSubscriber, RoomRoleEveryone:
		return true
	}
	return false
}

func (e RoomRole) String() string {
	return string(e)
}

func (e *RoomRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoomRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoomRole", str)
	}
	return nil
}

func (e RoomRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An error describing why the issue happened, when relevant.
type RotateExtensionSecretsError string

const (
	// User has indicated an invalid extension id.
	RotateExtensionSecretsErrorInvalidClient RotateExtensionSecretsError = "INVALID_CLIENT"
	// User is unable to delete the extension secrets.
	RotateExtensionSecretsErrorUnauthorized RotateExtensionSecretsError = "UNAUTHORIZED"
	// User indicated an Invalid delay; must be greater than zero.
	RotateExtensionSecretsErrorInvalidDelay RotateExtensionSecretsError = "INVALID_DELAY"
)

var AllRotateExtensionSecretsError = []RotateExtensionSecretsError{
	RotateExtensionSecretsErrorInvalidClient,
	RotateExtensionSecretsErrorUnauthorized,
	RotateExtensionSecretsErrorInvalidDelay,
}

func (e RotateExtensionSecretsError) IsValid() bool {
	switch e {
	case RotateExtensionSecretsErrorInvalidClient, RotateExtensionSecretsErrorUnauthorized, RotateExtensionSecretsErrorInvalidDelay:
		return true
	}
	return false
}

func (e RotateExtensionSecretsError) String() string {
	return string(e)
}

func (e *RotateExtensionSecretsError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RotateExtensionSecretsError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RotateExtensionSecretsError", str)
	}
	return nil
}

func (e RotateExtensionSecretsError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Errors that can result from running multiplayer ads.
type RunMultiplayerAdErrorCode string

const (
	// The channel is not live, so ads cannot be run on it.
	RunMultiplayerAdErrorCodeChannelNotLive RunMultiplayerAdErrorCode = "CHANNEL_NOT_LIVE"
	// At least one of the multiplayer ad offers has expired.
	RunMultiplayerAdErrorCodeOfferExpired RunMultiplayerAdErrorCode = "OFFER_EXPIRED"
	// At least one of the multiplayer ad offers was not found.
	RunMultiplayerAdErrorCodeOfferNotFound RunMultiplayerAdErrorCode = "OFFER_NOT_FOUND"
	// An unknown error has occurred.
	RunMultiplayerAdErrorCodeUnknown RunMultiplayerAdErrorCode = "UNKNOWN"
)

var AllRunMultiplayerAdErrorCode = []RunMultiplayerAdErrorCode{
	RunMultiplayerAdErrorCodeChannelNotLive,
	RunMultiplayerAdErrorCodeOfferExpired,
	RunMultiplayerAdErrorCodeOfferNotFound,
	RunMultiplayerAdErrorCodeUnknown,
}

func (e RunMultiplayerAdErrorCode) IsValid() bool {
	switch e {
	case RunMultiplayerAdErrorCodeChannelNotLive, RunMultiplayerAdErrorCodeOfferExpired, RunMultiplayerAdErrorCodeOfferNotFound, RunMultiplayerAdErrorCodeUnknown:
		return true
	}
	return false
}

func (e RunMultiplayerAdErrorCode) String() string {
	return string(e)
}

func (e *RunMultiplayerAdErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RunMultiplayerAdErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RunMultiplayerAdErrorCode", str)
	}
	return nil
}

func (e RunMultiplayerAdErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SaveExtensionManifestError is an error associated with the saveExtensionManifest mutation.
type SaveExtensionManifestError string

const (
	// User is unable to make modifications to the extension.
	SaveExtensionManifestErrorUnauthorized SaveExtensionManifestError = "UNAUTHORIZED"
	// Version specified is invalid.
	SaveExtensionManifestErrorInvalidVersion SaveExtensionManifestError = "INVALID_VERSION"
	// At least one anchor must be specified.
	SaveExtensionManifestErrorAnchorRequired SaveExtensionManifestError = "ANCHOR_REQUIRED"
	// HasZoom was specified but ZoomPixels is missing.
	SaveExtensionManifestErrorInvalidZoom SaveExtensionManifestError = "INVALID_ZOOM"
	// The number of whitelisted broadcasters exceeds the limit.
	SaveExtensionManifestErrorMaxBroadcasters SaveExtensionManifestError = "MAX_BROADCASTERS"
	// The number of whitelisted testing users exceeds the limit.
	SaveExtensionManifestErrorMaxTesters SaveExtensionManifestError = "MAX_TESTERS"
	// The number of whitelisted config URLs exceeds the limit.
	SaveExtensionManifestErrorMaxWhitelistedConfigURLS SaveExtensionManifestError = "MAX_WHITELISTED_CONFIG_URLS"
	// The number of whitelisted panel URLs exceeds the limit.
	SaveExtensionManifestErrorMaxWhitelistedPanelURLS SaveExtensionManifestError = "MAX_WHITELISTED_PANEL_URLS"
	// Extension names must be shorter than 40 characters.
	SaveExtensionManifestErrorInvalidNameLength SaveExtensionManifestError = "INVALID_NAME_LENGTH"
	// Extension description must be shorter than 1024 characters.
	SaveExtensionManifestErrorInvalidDescriptionLength SaveExtensionManifestError = "INVALID_DESCRIPTION_LENGTH"
	// Extension summary must be shorter than 140 characters.
	SaveExtensionManifestErrorInvalidSummaryLength SaveExtensionManifestError = "INVALID_SUMMARY_LENGTH"
	// Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
	SaveExtensionManifestErrorInvalidAuthorEmail SaveExtensionManifestError = "INVALID_AUTHOR_EMAIL"
	// Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
	SaveExtensionManifestErrorInvalidSupportEmail SaveExtensionManifestError = "INVALID_SUPPORT_EMAIL"
	// Extension author name length must be > 40.
	SaveExtensionManifestErrorInvalidAuthorNameLength SaveExtensionManifestError = "INVALID_AUTHOR_NAME_LENGTH"
	// Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
	SaveExtensionManifestErrorInvalidTestingBaseURI SaveExtensionManifestError = "INVALID_TESTING_BASE_URI"
	// Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
	SaveExtensionManifestErrorInvalidTermsURI SaveExtensionManifestError = "INVALID_TERMS_URI"
	// Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
	SaveExtensionManifestErrorInvalidPrivacyURI SaveExtensionManifestError = "INVALID_PRIVACY_URI"
	// Extension component viewer path must not be nil. Format should be BaseUri/Extension_Path.
	SaveExtensionManifestErrorInvalidComponentViewerPath SaveExtensionManifestError = "INVALID_COMPONENT_VIEWER_PATH"
	// Extension panel viewer path must not be nil. Format should be BaseUri/Extension_Path.
	SaveExtensionManifestErrorInvalidPanelViewerPath SaveExtensionManifestError = "INVALID_PANEL_VIEWER_PATH"
	// Extension video overlay viewer path must not be nil. Format should be BaseUri/Extension_Path.
	SaveExtensionManifestErrorInvalidVideoOverlayViewerPath SaveExtensionManifestError = "INVALID_VIDEO_OVERLAY_VIEWER_PATH"
	// Extension config viewer path must not be nil. Format should be BaseUri/Extension_Path.
	SaveExtensionManifestErrorInvalidConfigViewerPath SaveExtensionManifestError = "INVALID_CONFIG_VIEWER_PATH"
	// Extension live config viewer path must not be nil. Format should be BaseUri/Extension_Path.
	SaveExtensionManifestErrorInvalidLiveConfigViewerPath SaveExtensionManifestError = "INVALID_LIVE_CONFIG_VIEWER_PATH"
	// Extension mobile viewer path must not be nil. Format should be BaseUri/Extension_Path.
	SaveExtensionManifestErrorInvalidMobileViewerPath SaveExtensionManifestError = "INVALID_MOBILE_VIEWER_PATH"
	// Extension component aspect width must be < 50 or > 1.
	SaveExtensionManifestErrorInvalidComponentAspectWidth SaveExtensionManifestError = "INVALID_COMPONENT_ASPECT_WIDTH"
	// Extension component aspect height must be < 50 or > 1.
	SaveExtensionManifestErrorInvalidComponentAspectHeight SaveExtensionManifestError = "INVALID_COMPONENT_ASPECT_HEIGHT"
	// Extension panel hiehgt must be < 500 or > 100.
	SaveExtensionManifestErrorInvalidPanelHeight SaveExtensionManifestError = "INVALID_PANEL_HEIGHT"
	// Extension Bits Support Level must ba valid member of the BitsSupportLevelEnum.
	SaveExtensionManifestErrorInvalidBitsSupportLevel SaveExtensionManifestError = "INVALID_BITS_SUPPORT_LEVEL"
	// Scale pixels must be set to a positive integer when autoscale is true.
	SaveExtensionManifestErrorInvalidScalingPixels SaveExtensionManifestError = "INVALID_SCALING_PIXELS"
	// Aspect Ratio X must be set to a positive integer.
	SaveExtensionManifestErrorInvalidComponentAspectRatioX SaveExtensionManifestError = "INVALID_COMPONENT_ASPECT_RATIO_X"
	// Aspect Ratio Y must be set to a positive integer.
	SaveExtensionManifestErrorInvalidComponentAspectRatioY SaveExtensionManifestError = "INVALID_COMPONENT_ASPECT_RATIO_Y"
	// Target Height must be set to a positve integer.
	SaveExtensionManifestErrorInvalidComponentTargetHeight SaveExtensionManifestError = "INVALID_COMPONENT_TARGET_HEIGHT"
	// Extension viewer summary must be shorter than 140 characters.
	SaveExtensionManifestErrorInvalidViewerSummaryLength SaveExtensionManifestError = "INVALID_VIEWER_SUMMARY_LENGTH"
)

var AllSaveExtensionManifestError = []SaveExtensionManifestError{
	SaveExtensionManifestErrorUnauthorized,
	SaveExtensionManifestErrorInvalidVersion,
	SaveExtensionManifestErrorAnchorRequired,
	SaveExtensionManifestErrorInvalidZoom,
	SaveExtensionManifestErrorMaxBroadcasters,
	SaveExtensionManifestErrorMaxTesters,
	SaveExtensionManifestErrorMaxWhitelistedConfigURLS,
	SaveExtensionManifestErrorMaxWhitelistedPanelURLS,
	SaveExtensionManifestErrorInvalidNameLength,
	SaveExtensionManifestErrorInvalidDescriptionLength,
	SaveExtensionManifestErrorInvalidSummaryLength,
	SaveExtensionManifestErrorInvalidAuthorEmail,
	SaveExtensionManifestErrorInvalidSupportEmail,
	SaveExtensionManifestErrorInvalidAuthorNameLength,
	SaveExtensionManifestErrorInvalidTestingBaseURI,
	SaveExtensionManifestErrorInvalidTermsURI,
	SaveExtensionManifestErrorInvalidPrivacyURI,
	SaveExtensionManifestErrorInvalidComponentViewerPath,
	SaveExtensionManifestErrorInvalidPanelViewerPath,
	SaveExtensionManifestErrorInvalidVideoOverlayViewerPath,
	SaveExtensionManifestErrorInvalidConfigViewerPath,
	SaveExtensionManifestErrorInvalidLiveConfigViewerPath,
	SaveExtensionManifestErrorInvalidMobileViewerPath,
	SaveExtensionManifestErrorInvalidComponentAspectWidth,
	SaveExtensionManifestErrorInvalidComponentAspectHeight,
	SaveExtensionManifestErrorInvalidPanelHeight,
	SaveExtensionManifestErrorInvalidBitsSupportLevel,
	SaveExtensionManifestErrorInvalidScalingPixels,
	SaveExtensionManifestErrorInvalidComponentAspectRatioX,
	SaveExtensionManifestErrorInvalidComponentAspectRatioY,
	SaveExtensionManifestErrorInvalidComponentTargetHeight,
	SaveExtensionManifestErrorInvalidViewerSummaryLength,
}

func (e SaveExtensionManifestError) IsValid() bool {
	switch e {
	case SaveExtensionManifestErrorUnauthorized, SaveExtensionManifestErrorInvalidVersion, SaveExtensionManifestErrorAnchorRequired, SaveExtensionManifestErrorInvalidZoom, SaveExtensionManifestErrorMaxBroadcasters, SaveExtensionManifestErrorMaxTesters, SaveExtensionManifestErrorMaxWhitelistedConfigURLS, SaveExtensionManifestErrorMaxWhitelistedPanelURLS, SaveExtensionManifestErrorInvalidNameLength, SaveExtensionManifestErrorInvalidDescriptionLength, SaveExtensionManifestErrorInvalidSummaryLength, SaveExtensionManifestErrorInvalidAuthorEmail, SaveExtensionManifestErrorInvalidSupportEmail, SaveExtensionManifestErrorInvalidAuthorNameLength, SaveExtensionManifestErrorInvalidTestingBaseURI, SaveExtensionManifestErrorInvalidTermsURI, SaveExtensionManifestErrorInvalidPrivacyURI, SaveExtensionManifestErrorInvalidComponentViewerPath, SaveExtensionManifestErrorInvalidPanelViewerPath, SaveExtensionManifestErrorInvalidVideoOverlayViewerPath, SaveExtensionManifestErrorInvalidConfigViewerPath, SaveExtensionManifestErrorInvalidLiveConfigViewerPath, SaveExtensionManifestErrorInvalidMobileViewerPath, SaveExtensionManifestErrorInvalidComponentAspectWidth, SaveExtensionManifestErrorInvalidComponentAspectHeight, SaveExtensionManifestErrorInvalidPanelHeight, SaveExtensionManifestErrorInvalidBitsSupportLevel, SaveExtensionManifestErrorInvalidScalingPixels, SaveExtensionManifestErrorInvalidComponentAspectRatioX, SaveExtensionManifestErrorInvalidComponentAspectRatioY, SaveExtensionManifestErrorInvalidComponentTargetHeight, SaveExtensionManifestErrorInvalidViewerSummaryLength:
		return true
	}
	return false
}

func (e SaveExtensionManifestError) String() string {
	return string(e)
}

func (e *SaveExtensionManifestError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SaveExtensionManifestError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SaveExtensionManifestError", str)
	}
	return nil
}

func (e SaveExtensionManifestError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The reason of an interruption of a schedule.
type ScheduleInterruptionReason string

const (
	// The user is on vacation.
	ScheduleInterruptionReasonVacation ScheduleInterruptionReason = "VACATION"
	// Fallback value for reason unknown to the GQL schema.
	ScheduleInterruptionReasonOther ScheduleInterruptionReason = "OTHER"
)

var AllScheduleInterruptionReason = []ScheduleInterruptionReason{
	ScheduleInterruptionReasonVacation,
	ScheduleInterruptionReasonOther,
}

func (e ScheduleInterruptionReason) IsValid() bool {
	switch e {
	case ScheduleInterruptionReasonVacation, ScheduleInterruptionReasonOther:
		return true
	}
	return false
}

func (e ScheduleInterruptionReason) String() string {
	return string(e)
}

func (e *ScheduleInterruptionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScheduleInterruptionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScheduleInterruptionReason", str)
	}
	return nil
}

func (e ScheduleInterruptionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The days.
type ScheduleSegmentDay string

const (
	// SUNDAY.
	ScheduleSegmentDaySunday ScheduleSegmentDay = "SUNDAY"
	// MONDAY.
	ScheduleSegmentDayMonday ScheduleSegmentDay = "MONDAY"
	// TUESDAY.
	ScheduleSegmentDayTuesday ScheduleSegmentDay = "TUESDAY"
	// WEDNESDAY.
	ScheduleSegmentDayWednesday ScheduleSegmentDay = "WEDNESDAY"
	// THURSDAY.
	ScheduleSegmentDayThursday ScheduleSegmentDay = "THURSDAY"
	// FRIDAY.
	ScheduleSegmentDayFriday ScheduleSegmentDay = "FRIDAY"
	// SATURDAY.
	ScheduleSegmentDaySaturday ScheduleSegmentDay = "SATURDAY"
)

var AllScheduleSegmentDay = []ScheduleSegmentDay{
	ScheduleSegmentDaySunday,
	ScheduleSegmentDayMonday,
	ScheduleSegmentDayTuesday,
	ScheduleSegmentDayWednesday,
	ScheduleSegmentDayThursday,
	ScheduleSegmentDayFriday,
	ScheduleSegmentDaySaturday,
}

func (e ScheduleSegmentDay) IsValid() bool {
	switch e {
	case ScheduleSegmentDaySunday, ScheduleSegmentDayMonday, ScheduleSegmentDayTuesday, ScheduleSegmentDayWednesday, ScheduleSegmentDayThursday, ScheduleSegmentDayFriday, ScheduleSegmentDaySaturday:
		return true
	}
	return false
}

func (e ScheduleSegmentDay) String() string {
	return string(e)
}

func (e *ScheduleSegmentDay) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScheduleSegmentDay(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScheduleSegmentDay", str)
	}
	return nil
}

func (e ScheduleSegmentDay) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Whether the image should be set on a benefit or campaign.
type Scope string

const (
	// Image is for a benefit.
	ScopeBenefit Scope = "BENEFIT"
	// Image is for a campaign.
	ScopeCampaign Scope = "CAMPAIGN"
)

var AllScope = []Scope{
	ScopeBenefit,
	ScopeCampaign,
}

func (e Scope) IsValid() bool {
	switch e {
	case ScopeBenefit, ScopeCampaign:
		return true
	}
	return false
}

func (e Scope) String() string {
	return string(e)
}

func (e *Scope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Scope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Scope", str)
	}
	return nil
}

func (e Scope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of indexes a search query can target.
type SearchIndex string

const (
	// Game index.
	SearchIndexGame SearchIndex = "GAME"
	// User index.
	SearchIndexUser SearchIndex = "USER"
	// Video on demand index.
	SearchIndexVod SearchIndex = "VOD"
	// Live channel index.
	SearchIndexLive SearchIndex = "LIVE"
	// Channel index.
	SearchIndexChannel SearchIndex = "CHANNEL"
)

var AllSearchIndex = []SearchIndex{
	SearchIndexGame,
	SearchIndexUser,
	SearchIndexVod,
	SearchIndexLive,
	SearchIndexChannel,
}

func (e SearchIndex) IsValid() bool {
	switch e {
	case SearchIndexGame, SearchIndexUser, SearchIndexVod, SearchIndexLive, SearchIndexChannel:
		return true
	}
	return false
}

func (e SearchIndex) String() string {
	return string(e)
}

func (e *SearchIndex) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchIndex(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchIndex", str)
	}
	return nil
}

func (e SearchIndex) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of the statuses of suggested segments.
type SegmentsStatusType string

const (
	// The suggested segments have successfully been created.
	SegmentsStatusTypeCompleted SegmentsStatusType = "COMPLETED"
	// There wasn't enough data to generate suggested segments.
	SegmentsStatusTypeNotEnoughData SegmentsStatusType = "NOT_ENOUGH_DATA"
	// The vod is currently being processed for suggested segments.
	SegmentsStatusTypeInProgress SegmentsStatusType = "IN_PROGRESS"
	// The backend failed to generate suggested segments.
	SegmentsStatusTypeFailed SegmentsStatusType = "FAILED"
)

var AllSegmentsStatusType = []SegmentsStatusType{
	SegmentsStatusTypeCompleted,
	SegmentsStatusTypeNotEnoughData,
	SegmentsStatusTypeInProgress,
	SegmentsStatusTypeFailed,
}

func (e SegmentsStatusType) IsValid() bool {
	switch e {
	case SegmentsStatusTypeCompleted, SegmentsStatusTypeNotEnoughData, SegmentsStatusTypeInProgress, SegmentsStatusTypeFailed:
		return true
	}
	return false
}

func (e SegmentsStatusType) String() string {
	return string(e)
}

func (e *SegmentsStatusType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SegmentsStatusType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SegmentsStatusType", str)
	}
	return nil
}

func (e SegmentsStatusType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Validation error status codes.
type SendCheerValidationErrorCode string

const (
	// Bits amount is below the minimum.
	SendCheerValidationErrorCodeAmountBelowMinBits SendCheerValidationErrorCode = "AMOUNT_BELOW_MIN_BITS"
	// The message was auto modded.
	SendCheerValidationErrorCodeAutoModMessage SendCheerValidationErrorCode = "AUTO_MOD_MESSAGE"
	// The channel was ineligible for receiving bits.
	SendCheerValidationErrorCodeChannelIneligible SendCheerValidationErrorCode = "CHANNEL_INELIGIBLE"
	// The emote amount was below the minimum bits emote amount.
	SendCheerValidationErrorCodeEmoteAmountBelowMinBits SendCheerValidationErrorCode = "EMOTE_AMOUNT_BELOW_MIN_BITS"
	// The user has insufficient balance.
	SendCheerValidationErrorCodeInsufficientBalance SendCheerValidationErrorCode = "INSUFFICIENT_BALANCE"
	// The bits amount is invalid.
	SendCheerValidationErrorCodeInvalidBitsAmount SendCheerValidationErrorCode = "INVALID_BITS_AMOUNT"
	// The bits message is invalid.
	SendCheerValidationErrorCodeInvalidBitsMessage SendCheerValidationErrorCode = "INVALID_BITS_MESSAGE"
	// The event ID is invalid, probably because it's been used.
	SendCheerValidationErrorCodeInvalidEventID SendCheerValidationErrorCode = "INVALID_EVENT_ID"
	// The message length is greater than the max message length.
	SendCheerValidationErrorCodeMessageLengthExceeded SendCheerValidationErrorCode = "MESSAGE_LENGTH_EXCEEDED"
	// The request has been throttled.
	SendCheerValidationErrorCodeRequestThrottled SendCheerValidationErrorCode = "REQUEST_THROTTLED"
	// The bits emotes that were sent were greater than the max allowed.
	SendCheerValidationErrorCodeTooLargeBitsEmote SendCheerValidationErrorCode = "TOO_LARGE_BITS_EMOTE"
	// The cheer was over the maximum cheer limit.
	SendCheerValidationErrorCodeTooLargeCheer SendCheerValidationErrorCode = "TOO_LARGE_CHEER"
	// An unknown error has occurred, but it was a validation error.
	SendCheerValidationErrorCodeUnknown SendCheerValidationErrorCode = "UNKNOWN"
	// The user is banned from bits.
	SendCheerValidationErrorCodeUserBanned SendCheerValidationErrorCode = "USER_BANNED"
	// The user is ineligible to send bits.
	SendCheerValidationErrorCodeUserIneligible SendCheerValidationErrorCode = "USER_INELIGIBLE"
	// The use is suspended from sending bits.
	SendCheerValidationErrorCodeUserSuspended SendCheerValidationErrorCode = "USER_SUSPENDED"
	// The message contained Zalgo text.
	SendCheerValidationErrorCodeZalgoMessage SendCheerValidationErrorCode = "ZALGO_MESSAGE"
	// The message was not processed due to an automodded pending cheer.
	SendCheerValidationErrorCodeAutoModPending SendCheerValidationErrorCode = "AUTO_MOD_PENDING"
	// The message contained term(s) blocked by the channel.
	SendCheerValidationErrorCodeChannelBlockedTerms SendCheerValidationErrorCode = "CHANNEL_BLOCKED_TERMS"
	// The anonymous message contained text that is invalid.
	SendCheerValidationErrorCodeInvalidAnonymousMessage SendCheerValidationErrorCode = "INVALID_ANONYMOUS_MESSAGE"
	// The bits message contained an anonymous cheermote when it's not allowed (ex: in public cheers).
	SendCheerValidationErrorCodeAnonymousCheermoteNotAllowed SendCheerValidationErrorCode = "ANONYMOUS_CHEERMOTE_NOT_ALLOWED"
)

var AllSendCheerValidationErrorCode = []SendCheerValidationErrorCode{
	SendCheerValidationErrorCodeAmountBelowMinBits,
	SendCheerValidationErrorCodeAutoModMessage,
	SendCheerValidationErrorCodeChannelIneligible,
	SendCheerValidationErrorCodeEmoteAmountBelowMinBits,
	SendCheerValidationErrorCodeInsufficientBalance,
	SendCheerValidationErrorCodeInvalidBitsAmount,
	SendCheerValidationErrorCodeInvalidBitsMessage,
	SendCheerValidationErrorCodeInvalidEventID,
	SendCheerValidationErrorCodeMessageLengthExceeded,
	SendCheerValidationErrorCodeRequestThrottled,
	SendCheerValidationErrorCodeTooLargeBitsEmote,
	SendCheerValidationErrorCodeTooLargeCheer,
	SendCheerValidationErrorCodeUnknown,
	SendCheerValidationErrorCodeUserBanned,
	SendCheerValidationErrorCodeUserIneligible,
	SendCheerValidationErrorCodeUserSuspended,
	SendCheerValidationErrorCodeZalgoMessage,
	SendCheerValidationErrorCodeAutoModPending,
	SendCheerValidationErrorCodeChannelBlockedTerms,
	SendCheerValidationErrorCodeInvalidAnonymousMessage,
	SendCheerValidationErrorCodeAnonymousCheermoteNotAllowed,
}

func (e SendCheerValidationErrorCode) IsValid() bool {
	switch e {
	case SendCheerValidationErrorCodeAmountBelowMinBits, SendCheerValidationErrorCodeAutoModMessage, SendCheerValidationErrorCodeChannelIneligible, SendCheerValidationErrorCodeEmoteAmountBelowMinBits, SendCheerValidationErrorCodeInsufficientBalance, SendCheerValidationErrorCodeInvalidBitsAmount, SendCheerValidationErrorCodeInvalidBitsMessage, SendCheerValidationErrorCodeInvalidEventID, SendCheerValidationErrorCodeMessageLengthExceeded, SendCheerValidationErrorCodeRequestThrottled, SendCheerValidationErrorCodeTooLargeBitsEmote, SendCheerValidationErrorCodeTooLargeCheer, SendCheerValidationErrorCodeUnknown, SendCheerValidationErrorCodeUserBanned, SendCheerValidationErrorCodeUserIneligible, SendCheerValidationErrorCodeUserSuspended, SendCheerValidationErrorCodeZalgoMessage, SendCheerValidationErrorCodeAutoModPending, SendCheerValidationErrorCodeChannelBlockedTerms, SendCheerValidationErrorCodeInvalidAnonymousMessage, SendCheerValidationErrorCodeAnonymousCheermoteNotAllowed:
		return true
	}
	return false
}

func (e SendCheerValidationErrorCode) String() string {
	return string(e)
}

func (e *SendCheerValidationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SendCheerValidationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SendCheerValidationErrorCode", str)
	}
	return nil
}

func (e SendCheerValidationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors from redeeming a chat message Channel Points reward.
type SendCopoMessageErrorCode string

const (
	// User has previously sent an identical message.
	SendCopoMessageErrorCodeMsgDuplicate SendCopoMessageErrorCode = "MSG_DUPLICATE"
	// The user is suspended from Twitch.
	SendCopoMessageErrorCodeUserSuspended SendCopoMessageErrorCode = "USER_SUSPENDED"
	// The user is banned in the channel.
	SendCopoMessageErrorCodeUserBanned SendCopoMessageErrorCode = "USER_BANNED"
	// The user is timed out in the channel.
	SendCopoMessageErrorCodeUserTimedOut SendCopoMessageErrorCode = "USER_TIMED_OUT"
	// The chat is emote-only mode and the message contained text.
	SendCopoMessageErrorCodeEmoteOnly SendCopoMessageErrorCode = "EMOTE_ONLY"
	// The chat is in slow mode and the user has recently sent a message.
	SendCopoMessageErrorCodeSlowMode SendCopoMessageErrorCode = "SLOW_MODE"
	// The chat is in followers-only mode and the user has not been following long enough.
	SendCopoMessageErrorCodeFollowersOnly SendCopoMessageErrorCode = "FOLLOWERS_ONLY"
	// The chat is in followers-only mode and the user is not following.
	SendCopoMessageErrorCodeFollowersOnlyZero SendCopoMessageErrorCode = "FOLLOWERS_ONLY_ZERO"
	// The chat is in subs-only mode and the user is not subbed.
	SendCopoMessageErrorCodeSubsOnly SendCopoMessageErrorCode = "SUBS_ONLY"
	// The chat is in r9k-only mode (relatively unique messages) and the message was not unique.
	SendCopoMessageErrorCodeR9kMode SendCopoMessageErrorCode = "R9K_MODE"
	// The chat is in Blizzard connect mode and the user does not have their Blizzard account connected.
	SendCopoMessageErrorCodeBlizzardConnectMode SendCopoMessageErrorCode = "BLIZZARD_CONNECT_MODE"
	// The chat is in verified account mode and the user's account is not verified.
	SendCopoMessageErrorCodeVerifiedAccount SendCopoMessageErrorCode = "VERIFIED_ACCOUNT"
	// The user's message contained a blocked phrase.
	SendCopoMessageErrorCodeChannelSettings SendCopoMessageErrorCode = "CHANNEL_SETTINGS"
	// The user's message was flagged by Automod and is being reviewed.
	SendCopoMessageErrorCodeAutomodHeld SendCopoMessageErrorCode = "AUTOMOD_HELD"
	// The user's message was rejected for another reason- possibly intentionally hidden, such as IP block.
	SendCopoMessageErrorCodeMessageRejected SendCopoMessageErrorCode = "MESSAGE_REJECTED"
	// The request failed due to an underlying server error.
	SendCopoMessageErrorCodeServerError SendCopoMessageErrorCode = "SERVER_ERROR"
	// The user does not have sufficient points to redeem the reward.
	SendCopoMessageErrorCodeInsufficientPoints SendCopoMessageErrorCode = "INSUFFICIENT_POINTS"
	// The client is retrying a redemption with a transaction id that has already been redeemed.
	SendCopoMessageErrorCodeTransactionAlreadyCommitted SendCopoMessageErrorCode = "TRANSACTION_ALREADY_COMMITTED"
	// The client is retrying a redemption with a transaction id that is currently being redeemed in another request.
	SendCopoMessageErrorCodeTransactionInProgress SendCopoMessageErrorCode = "TRANSACTION_IN_PROGRESS"
	// The reward cost has changed since the user has tried to redeem it.
	SendCopoMessageErrorCodeRewardCostMismatch SendCopoMessageErrorCode = "REWARD_COST_MISMATCH"
	// The reward is currently disabled.
	SendCopoMessageErrorCodeRewardDisabled SendCopoMessageErrorCode = "REWARD_DISABLED"
	// The user is not allowed to redeem this reward on this channel.
	SendCopoMessageErrorCodeRewardForbidden SendCopoMessageErrorCode = "REWARD_FORBIDDEN"
	// The user's message starts with a '/' like a chat command.
	SendCopoMessageErrorCodeMessageIsCommand SendCopoMessageErrorCode = "MESSAGE_IS_COMMAND"
	// An unknown error occurred.
	SendCopoMessageErrorCodeUnknown SendCopoMessageErrorCode = "UNKNOWN"
)

var AllSendCopoMessageErrorCode = []SendCopoMessageErrorCode{
	SendCopoMessageErrorCodeMsgDuplicate,
	SendCopoMessageErrorCodeUserSuspended,
	SendCopoMessageErrorCodeUserBanned,
	SendCopoMessageErrorCodeUserTimedOut,
	SendCopoMessageErrorCodeEmoteOnly,
	SendCopoMessageErrorCodeSlowMode,
	SendCopoMessageErrorCodeFollowersOnly,
	SendCopoMessageErrorCodeFollowersOnlyZero,
	SendCopoMessageErrorCodeSubsOnly,
	SendCopoMessageErrorCodeR9kMode,
	SendCopoMessageErrorCodeBlizzardConnectMode,
	SendCopoMessageErrorCodeVerifiedAccount,
	SendCopoMessageErrorCodeChannelSettings,
	SendCopoMessageErrorCodeAutomodHeld,
	SendCopoMessageErrorCodeMessageRejected,
	SendCopoMessageErrorCodeServerError,
	SendCopoMessageErrorCodeInsufficientPoints,
	SendCopoMessageErrorCodeTransactionAlreadyCommitted,
	SendCopoMessageErrorCodeTransactionInProgress,
	SendCopoMessageErrorCodeRewardCostMismatch,
	SendCopoMessageErrorCodeRewardDisabled,
	SendCopoMessageErrorCodeRewardForbidden,
	SendCopoMessageErrorCodeMessageIsCommand,
	SendCopoMessageErrorCodeUnknown,
}

func (e SendCopoMessageErrorCode) IsValid() bool {
	switch e {
	case SendCopoMessageErrorCodeMsgDuplicate, SendCopoMessageErrorCodeUserSuspended, SendCopoMessageErrorCodeUserBanned, SendCopoMessageErrorCodeUserTimedOut, SendCopoMessageErrorCodeEmoteOnly, SendCopoMessageErrorCodeSlowMode, SendCopoMessageErrorCodeFollowersOnly, SendCopoMessageErrorCodeFollowersOnlyZero, SendCopoMessageErrorCodeSubsOnly, SendCopoMessageErrorCodeR9kMode, SendCopoMessageErrorCodeBlizzardConnectMode, SendCopoMessageErrorCodeVerifiedAccount, SendCopoMessageErrorCodeChannelSettings, SendCopoMessageErrorCodeAutomodHeld, SendCopoMessageErrorCodeMessageRejected, SendCopoMessageErrorCodeServerError, SendCopoMessageErrorCodeInsufficientPoints, SendCopoMessageErrorCodeTransactionAlreadyCommitted, SendCopoMessageErrorCodeTransactionInProgress, SendCopoMessageErrorCodeRewardCostMismatch, SendCopoMessageErrorCodeRewardDisabled, SendCopoMessageErrorCodeRewardForbidden, SendCopoMessageErrorCodeMessageIsCommand, SendCopoMessageErrorCodeUnknown:
		return true
	}
	return false
}

func (e SendCopoMessageErrorCode) String() string {
	return string(e)
}

func (e *SendCopoMessageErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SendCopoMessageErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SendCopoMessageErrorCode", str)
	}
	return nil
}

func (e SendCopoMessageErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error reasons returned by sendExtensionMessage mutation.
type SendExtensionMessageErrorCode string

const (
	// Unauthorized.
	SendExtensionMessageErrorCodeUnauthorized SendExtensionMessageErrorCode = "UNAUTHORIZED"
	// Unknown error.
	SendExtensionMessageErrorCodeUnknown SendExtensionMessageErrorCode = "UNKNOWN"
)

var AllSendExtensionMessageErrorCode = []SendExtensionMessageErrorCode{
	SendExtensionMessageErrorCodeUnauthorized,
	SendExtensionMessageErrorCodeUnknown,
}

func (e SendExtensionMessageErrorCode) IsValid() bool {
	switch e {
	case SendExtensionMessageErrorCodeUnauthorized, SendExtensionMessageErrorCodeUnknown:
		return true
	}
	return false
}

func (e SendExtensionMessageErrorCode) String() string {
	return string(e)
}

func (e *SendExtensionMessageErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SendExtensionMessageErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SendExtensionMessageErrorCode", str)
	}
	return nil
}

func (e SendExtensionMessageErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SendRoomMessageErrorCode string

const (
	// User not allowed to chat in room.
	SendRoomMessageErrorCodeForbidden SendRoomMessageErrorCode = "FORBIDDEN"
	// Message failed automod check.
	SendRoomMessageErrorCodeAutoModEnforcementFailed SendRoomMessageErrorCode = "AUTO_MOD_ENFORCEMENT_FAILED"
	// Room is in emotes only mode and message contained non-emote text.
	SendRoomMessageErrorCodeEmoteOnlyModeEnforcementFailed SendRoomMessageErrorCode = "EMOTE_ONLY_MODE_ENFORCEMENT_FAILED"
	// Room is in R9K mode and message was not unique.
	SendRoomMessageErrorCodeR9kModeEnforcementFailed SendRoomMessageErrorCode = "R9K_MODE_ENFORCEMENT_FAILED"
	// User is rate limited.
	SendRoomMessageErrorCodeRateLimitFailed SendRoomMessageErrorCode = "RATE_LIMIT_FAILED"
	// Room is in slow mode and user tried to send a message to quickly.
	SendRoomMessageErrorCodeSlowModeEnforcementFailed SendRoomMessageErrorCode = "SLOW_MODE_ENFORCEMENT_FAILED"
	// Message failed spam check.
	SendRoomMessageErrorCodeSpamEnforcementFailed SendRoomMessageErrorCode = "SPAM_ENFORCEMENT_FAILED"
	// Message contained zalgo characters.
	SendRoomMessageErrorCodeZalgoEnforcementFailed SendRoomMessageErrorCode = "ZALGO_ENFORCEMENT_FAILED"
	// User is banned in the channel.
	SendRoomMessageErrorCodeUserChatBanned SendRoomMessageErrorCode = "USER_CHAT_BANNED"
	// User is timed out in the channel.
	SendRoomMessageErrorCodeUserChatTimedOut SendRoomMessageErrorCode = "USER_CHAT_TIMED_OUT"
	// User is suspended from Twitch.
	SendRoomMessageErrorCodeUserSuspended SendRoomMessageErrorCode = "USER_SUSPENDED"
)

var AllSendRoomMessageErrorCode = []SendRoomMessageErrorCode{
	SendRoomMessageErrorCodeForbidden,
	SendRoomMessageErrorCodeAutoModEnforcementFailed,
	SendRoomMessageErrorCodeEmoteOnlyModeEnforcementFailed,
	SendRoomMessageErrorCodeR9kModeEnforcementFailed,
	SendRoomMessageErrorCodeRateLimitFailed,
	SendRoomMessageErrorCodeSlowModeEnforcementFailed,
	SendRoomMessageErrorCodeSpamEnforcementFailed,
	SendRoomMessageErrorCodeZalgoEnforcementFailed,
	SendRoomMessageErrorCodeUserChatBanned,
	SendRoomMessageErrorCodeUserChatTimedOut,
	SendRoomMessageErrorCodeUserSuspended,
}

func (e SendRoomMessageErrorCode) IsValid() bool {
	switch e {
	case SendRoomMessageErrorCodeForbidden, SendRoomMessageErrorCodeAutoModEnforcementFailed, SendRoomMessageErrorCodeEmoteOnlyModeEnforcementFailed, SendRoomMessageErrorCodeR9kModeEnforcementFailed, SendRoomMessageErrorCodeRateLimitFailed, SendRoomMessageErrorCodeSlowModeEnforcementFailed, SendRoomMessageErrorCodeSpamEnforcementFailed, SendRoomMessageErrorCodeZalgoEnforcementFailed, SendRoomMessageErrorCodeUserChatBanned, SendRoomMessageErrorCodeUserChatTimedOut, SendRoomMessageErrorCodeUserSuspended:
		return true
	}
	return false
}

func (e SendRoomMessageErrorCode) String() string {
	return string(e)
}

func (e *SendRoomMessageErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SendRoomMessageErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SendRoomMessageErrorCode", str)
	}
	return nil
}

func (e SendRoomMessageErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors returned by the sendWhisper mutation.
type SendWhisperErrorCode string

const (
	// Target is banned.
	SendWhisperErrorCodeTargetBanned SendWhisperErrorCode = "TARGET_BANNED"
	// Message body is empty.
	SendWhisperErrorCodeBodyEmpty SendWhisperErrorCode = "BODY_EMPTY"
	// Target's settings prevent them from receiving message.
	SendWhisperErrorCodeTargetRestricted SendWhisperErrorCode = "TARGET_RESTRICTED"
	// Sender does not have a verified account.
	SendWhisperErrorCodeSenderNotVerified SendWhisperErrorCode = "SENDER_NOT_VERIFIED"
	// Whisper was not delivered for an unspecified reason.
	SendWhisperErrorCodeNotDelivered SendWhisperErrorCode = "NOT_DELIVERED"
)

var AllSendWhisperErrorCode = []SendWhisperErrorCode{
	SendWhisperErrorCodeTargetBanned,
	SendWhisperErrorCodeBodyEmpty,
	SendWhisperErrorCodeTargetRestricted,
	SendWhisperErrorCodeSenderNotVerified,
	SendWhisperErrorCodeNotDelivered,
}

func (e SendWhisperErrorCode) IsValid() bool {
	switch e {
	case SendWhisperErrorCodeTargetBanned, SendWhisperErrorCodeBodyEmpty, SendWhisperErrorCodeTargetRestricted, SendWhisperErrorCodeSenderNotVerified, SendWhisperErrorCodeNotDelivered:
		return true
	}
	return false
}

func (e SendWhisperErrorCode) String() string {
	return string(e)
}

func (e *SendWhisperErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SendWhisperErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SendWhisperErrorCode", str)
	}
	return nil
}

func (e SendWhisperErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SetChannelTrailerErrorCode are the types of errors that the setChannelTrailer mutation may return.
type SetChannelTrailerErrorCode string

const (
	// The caller is not authorized to update the user's trailer settings.
	SetChannelTrailerErrorCodeUnauthorized SetChannelTrailerErrorCode = "UNAUTHORIZED"
	// The vod is longer than 60 seconds (max time for channel trailers).
	SetChannelTrailerErrorCodeVodTooLong SetChannelTrailerErrorCode = "VOD_TOO_LONG"
)

var AllSetChannelTrailerErrorCode = []SetChannelTrailerErrorCode{
	SetChannelTrailerErrorCodeUnauthorized,
	SetChannelTrailerErrorCodeVodTooLong,
}

func (e SetChannelTrailerErrorCode) IsValid() bool {
	switch e {
	case SetChannelTrailerErrorCodeUnauthorized, SetChannelTrailerErrorCodeVodTooLong:
		return true
	}
	return false
}

func (e SetChannelTrailerErrorCode) String() string {
	return string(e)
}

func (e *SetChannelTrailerErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SetChannelTrailerErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SetChannelTrailerErrorCode", str)
	}
	return nil
}

func (e SetChannelTrailerErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SetDashboardAlertQueueActivityStatusErrorCode are the possible errors that this mutation returns.
type SetDashboardAlertQueueActivityStatusErrorCode string

const (
	// The input activity ID is invalid.
	SetDashboardAlertQueueActivityStatusErrorCodeInvalidActivityID SetDashboardAlertQueueActivityStatusErrorCode = "INVALID_ACTIVITY_ID"
	// The input alert status is invalid.
	SetDashboardAlertQueueActivityStatusErrorCodeInvalidAlertStatus SetDashboardAlertQueueActivityStatusErrorCode = "INVALID_ALERT_STATUS"
	// The input channel ID is invalid.
	SetDashboardAlertQueueActivityStatusErrorCodeInvalidChannelID SetDashboardAlertQueueActivityStatusErrorCode = "INVALID_CHANNEL_ID"
	// The alert is not found.
	SetDashboardAlertQueueActivityStatusErrorCodeNotFound SetDashboardAlertQueueActivityStatusErrorCode = "NOT_FOUND"
)

var AllSetDashboardAlertQueueActivityStatusErrorCode = []SetDashboardAlertQueueActivityStatusErrorCode{
	SetDashboardAlertQueueActivityStatusErrorCodeInvalidActivityID,
	SetDashboardAlertQueueActivityStatusErrorCodeInvalidAlertStatus,
	SetDashboardAlertQueueActivityStatusErrorCodeInvalidChannelID,
	SetDashboardAlertQueueActivityStatusErrorCodeNotFound,
}

func (e SetDashboardAlertQueueActivityStatusErrorCode) IsValid() bool {
	switch e {
	case SetDashboardAlertQueueActivityStatusErrorCodeInvalidActivityID, SetDashboardAlertQueueActivityStatusErrorCodeInvalidAlertStatus, SetDashboardAlertQueueActivityStatusErrorCodeInvalidChannelID, SetDashboardAlertQueueActivityStatusErrorCodeNotFound:
		return true
	}
	return false
}

func (e SetDashboardAlertQueueActivityStatusErrorCode) String() string {
	return string(e)
}

func (e *SetDashboardAlertQueueActivityStatusErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SetDashboardAlertQueueActivityStatusErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SetDashboardAlertQueueActivityStatusErrorCode", str)
	}
	return nil
}

func (e SetDashboardAlertQueueActivityStatusErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SetDashboardAlertQueuePreferenceErrorCode are the possible errors that this mutation returns.
type SetDashboardAlertQueuePreferenceErrorCode string

const (
	// The input channel ID is invalid.
	SetDashboardAlertQueuePreferenceErrorCodeInvalidChannelID SetDashboardAlertQueuePreferenceErrorCode = "INVALID_CHANNEL_ID"
)

var AllSetDashboardAlertQueuePreferenceErrorCode = []SetDashboardAlertQueuePreferenceErrorCode{
	SetDashboardAlertQueuePreferenceErrorCodeInvalidChannelID,
}

func (e SetDashboardAlertQueuePreferenceErrorCode) IsValid() bool {
	switch e {
	case SetDashboardAlertQueuePreferenceErrorCodeInvalidChannelID:
		return true
	}
	return false
}

func (e SetDashboardAlertQueuePreferenceErrorCode) String() string {
	return string(e)
}

func (e *SetDashboardAlertQueuePreferenceErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SetDashboardAlertQueuePreferenceErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SetDashboardAlertQueuePreferenceErrorCode", str)
	}
	return nil
}

func (e SetDashboardAlertQueuePreferenceErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumerates possible errors when setting a default payment method.
type SetDefaultPaymentMethodErrorCode string

const (
	// Must have auth credentials to set default payment method.
	SetDefaultPaymentMethodErrorCodeUnauthenticated SetDefaultPaymentMethodErrorCode = "UNAUTHENTICATED"
	// User does not have permission to set default payment method for the targeted user.
	SetDefaultPaymentMethodErrorCodeForbidden SetDefaultPaymentMethodErrorCode = "FORBIDDEN"
	// One or more fields are invalid or missing.
	SetDefaultPaymentMethodErrorCodeInvalidRequest SetDefaultPaymentMethodErrorCode = "INVALID_REQUEST"
	// An internal error has occurred.
	SetDefaultPaymentMethodErrorCodeInternalError SetDefaultPaymentMethodErrorCode = "INTERNAL_ERROR"
)

var AllSetDefaultPaymentMethodErrorCode = []SetDefaultPaymentMethodErrorCode{
	SetDefaultPaymentMethodErrorCodeUnauthenticated,
	SetDefaultPaymentMethodErrorCodeForbidden,
	SetDefaultPaymentMethodErrorCodeInvalidRequest,
	SetDefaultPaymentMethodErrorCodeInternalError,
}

func (e SetDefaultPaymentMethodErrorCode) IsValid() bool {
	switch e {
	case SetDefaultPaymentMethodErrorCodeUnauthenticated, SetDefaultPaymentMethodErrorCodeForbidden, SetDefaultPaymentMethodErrorCodeInvalidRequest, SetDefaultPaymentMethodErrorCodeInternalError:
		return true
	}
	return false
}

func (e SetDefaultPaymentMethodErrorCode) String() string {
	return string(e)
}

func (e *SetDefaultPaymentMethodErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SetDefaultPaymentMethodErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SetDefaultPaymentMethodErrorCode", str)
	}
	return nil
}

func (e SetDefaultPaymentMethodErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes from this mutation.
type SetEmoteModifierGroupsErrorCode string

const (
	// An unexpected internal server error occurred.
	SetEmoteModifierGroupsErrorCodeInternalServerError SetEmoteModifierGroupsErrorCode = "INTERNAL_SERVER_ERROR"
	// The provided input is invalid.
	SetEmoteModifierGroupsErrorCodeInvalidArgument SetEmoteModifierGroupsErrorCode = "INVALID_ARGUMENT"
	// The user is not authorized to set emote modifiers.
	SetEmoteModifierGroupsErrorCodeUserUnauthorized SetEmoteModifierGroupsErrorCode = "USER_UNAUTHORIZED"
	// Unknown error returned from service.
	SetEmoteModifierGroupsErrorCodeUnknown SetEmoteModifierGroupsErrorCode = "UNKNOWN"
)

var AllSetEmoteModifierGroupsErrorCode = []SetEmoteModifierGroupsErrorCode{
	SetEmoteModifierGroupsErrorCodeInternalServerError,
	SetEmoteModifierGroupsErrorCodeInvalidArgument,
	SetEmoteModifierGroupsErrorCodeUserUnauthorized,
	SetEmoteModifierGroupsErrorCodeUnknown,
}

func (e SetEmoteModifierGroupsErrorCode) IsValid() bool {
	switch e {
	case SetEmoteModifierGroupsErrorCodeInternalServerError, SetEmoteModifierGroupsErrorCodeInvalidArgument, SetEmoteModifierGroupsErrorCodeUserUnauthorized, SetEmoteModifierGroupsErrorCodeUnknown:
		return true
	}
	return false
}

func (e SetEmoteModifierGroupsErrorCode) String() string {
	return string(e)
}

func (e *SetEmoteModifierGroupsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SetEmoteModifierGroupsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SetEmoteModifierGroupsErrorCode", str)
	}
	return nil
}

func (e SetEmoteModifierGroupsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The standardized codes used by the frontend.
type SetExtensionConfigurationErrorCode string

const (
	// User is unable to set the configuration.
	SetExtensionConfigurationErrorCodeUnauthorized SetExtensionConfigurationErrorCode = "UNAUTHORIZED"
	// An unknown error occurred.
	SetExtensionConfigurationErrorCodeUnknown SetExtensionConfigurationErrorCode = "UNKNOWN"
)

var AllSetExtensionConfigurationErrorCode = []SetExtensionConfigurationErrorCode{
	SetExtensionConfigurationErrorCodeUnauthorized,
	SetExtensionConfigurationErrorCodeUnknown,
}

func (e SetExtensionConfigurationErrorCode) IsValid() bool {
	switch e {
	case SetExtensionConfigurationErrorCodeUnauthorized, SetExtensionConfigurationErrorCodeUnknown:
		return true
	}
	return false
}

func (e SetExtensionConfigurationErrorCode) String() string {
	return string(e)
}

func (e *SetExtensionConfigurationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SetExtensionConfigurationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SetExtensionConfigurationErrorCode", str)
	}
	return nil
}

func (e SetExtensionConfigurationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SetExtensionFeatureFlagsErrorCode is an error code associated with SetExtensionFeatureFlagsError.
type SetExtensionFeatureFlagsErrorCode string

const (
	// User is unable to make modifications to the extension.
	SetExtensionFeatureFlagsErrorCodeUnauthorized SetExtensionFeatureFlagsErrorCode = "UNAUTHORIZED"
	// Channel id is invalid, for example, is empty.
	SetExtensionFeatureFlagsErrorCodeInvalidChannelID SetExtensionFeatureFlagsErrorCode = "INVALID_CHANNEL_ID"
	// The extension is not installed on the channel.
	SetExtensionFeatureFlagsErrorCodeExtensionNotInstalled SetExtensionFeatureFlagsErrorCode = "EXTENSION_NOT_INSTALLED"
)

var AllSetExtensionFeatureFlagsErrorCode = []SetExtensionFeatureFlagsErrorCode{
	SetExtensionFeatureFlagsErrorCodeUnauthorized,
	SetExtensionFeatureFlagsErrorCodeInvalidChannelID,
	SetExtensionFeatureFlagsErrorCodeExtensionNotInstalled,
}

func (e SetExtensionFeatureFlagsErrorCode) IsValid() bool {
	switch e {
	case SetExtensionFeatureFlagsErrorCodeUnauthorized, SetExtensionFeatureFlagsErrorCodeInvalidChannelID, SetExtensionFeatureFlagsErrorCodeExtensionNotInstalled:
		return true
	}
	return false
}

func (e SetExtensionFeatureFlagsErrorCode) String() string {
	return string(e)
}

func (e *SetExtensionFeatureFlagsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SetExtensionFeatureFlagsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SetExtensionFeatureFlagsErrorCode", str)
	}
	return nil
}

func (e SetExtensionFeatureFlagsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error types recognized by the SetOverwatchLeagueTeamPreference mutation.
type SetOverwatchTeamPreferenceErrorCode string

const (
	// Unknown error being returned from service.
	SetOverwatchTeamPreferenceErrorCodeUnknown SetOverwatchTeamPreferenceErrorCode = "UNKNOWN"
)

var AllSetOverwatchTeamPreferenceErrorCode = []SetOverwatchTeamPreferenceErrorCode{
	SetOverwatchTeamPreferenceErrorCodeUnknown,
}

func (e SetOverwatchTeamPreferenceErrorCode) IsValid() bool {
	switch e {
	case SetOverwatchTeamPreferenceErrorCodeUnknown:
		return true
	}
	return false
}

func (e SetOverwatchTeamPreferenceErrorCode) String() string {
	return string(e)
}

func (e *SetOverwatchTeamPreferenceErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SetOverwatchTeamPreferenceErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SetOverwatchTeamPreferenceErrorCode", str)
	}
	return nil
}

func (e SetOverwatchTeamPreferenceErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors that this mutation can return.
type SetQuickActionLayoutErrorCode string

const (
	// The input channel ID is invalid.
	SetQuickActionLayoutErrorCodeInvalidChannelID SetQuickActionLayoutErrorCode = "INVALID_CHANNEL_ID"
	// The input owner ID is invalid.
	SetQuickActionLayoutErrorCodeInvalidOwnerID SetQuickActionLayoutErrorCode = "INVALID_OWNER_ID"
	// One of the input quick actions IDs is invalid/does not exist.
	SetQuickActionLayoutErrorCodeInvalidQuickActionID SetQuickActionLayoutErrorCode = "INVALID_QUICK_ACTION_ID"
)

var AllSetQuickActionLayoutErrorCode = []SetQuickActionLayoutErrorCode{
	SetQuickActionLayoutErrorCodeInvalidChannelID,
	SetQuickActionLayoutErrorCodeInvalidOwnerID,
	SetQuickActionLayoutErrorCodeInvalidQuickActionID,
}

func (e SetQuickActionLayoutErrorCode) IsValid() bool {
	switch e {
	case SetQuickActionLayoutErrorCodeInvalidChannelID, SetQuickActionLayoutErrorCodeInvalidOwnerID, SetQuickActionLayoutErrorCodeInvalidQuickActionID:
		return true
	}
	return false
}

func (e SetQuickActionLayoutErrorCode) String() string {
	return string(e)
}

func (e *SetQuickActionLayoutErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SetQuickActionLayoutErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SetQuickActionLayoutErrorCode", str)
	}
	return nil
}

func (e SetQuickActionLayoutErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Currently playing error codes.
type SetRadioCurrentlyPlayingErrorCode string

const (
	// The ID provided was malformed.
	SetRadioCurrentlyPlayingErrorCodeInvalidID SetRadioCurrentlyPlayingErrorCode = "INVALID_ID"
	// Permission denied to add/update a currently playing item.
	SetRadioCurrentlyPlayingErrorCodePermissionDenied SetRadioCurrentlyPlayingErrorCode = "PERMISSION_DENIED"
	// No record found for the request params.
	SetRadioCurrentlyPlayingErrorCodeNoRecord SetRadioCurrentlyPlayingErrorCode = "NO_RECORD"
)

var AllSetRadioCurrentlyPlayingErrorCode = []SetRadioCurrentlyPlayingErrorCode{
	SetRadioCurrentlyPlayingErrorCodeInvalidID,
	SetRadioCurrentlyPlayingErrorCodePermissionDenied,
	SetRadioCurrentlyPlayingErrorCodeNoRecord,
}

func (e SetRadioCurrentlyPlayingErrorCode) IsValid() bool {
	switch e {
	case SetRadioCurrentlyPlayingErrorCodeInvalidID, SetRadioCurrentlyPlayingErrorCodePermissionDenied, SetRadioCurrentlyPlayingErrorCodeNoRecord:
		return true
	}
	return false
}

func (e SetRadioCurrentlyPlayingErrorCode) String() string {
	return string(e)
}

func (e *SetRadioCurrentlyPlayingErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SetRadioCurrentlyPlayingErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SetRadioCurrentlyPlayingErrorCode", str)
	}
	return nil
}

func (e SetRadioCurrentlyPlayingErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for set schedule reminders errors.
type SetScheduleReminderErrorCode string

const (
	// The error code is unknown.
	SetScheduleReminderErrorCodeUnknown SetScheduleReminderErrorCode = "UNKNOWN"
	// The request for setting a reminder was invalid.
	SetScheduleReminderErrorCodeInvalidArgument SetScheduleReminderErrorCode = "INVALID_ARGUMENT"
	// The schedule segment you're attempting to set a reminder for was not found.
	SetScheduleReminderErrorCodeNotFound SetScheduleReminderErrorCode = "NOT_FOUND"
	// The schedule segment you're attempting to set a reminder for was cancelled.
	SetScheduleReminderErrorCodeFailedPrecondition SetScheduleReminderErrorCode = "FAILED_PRECONDITION"
)

var AllSetScheduleReminderErrorCode = []SetScheduleReminderErrorCode{
	SetScheduleReminderErrorCodeUnknown,
	SetScheduleReminderErrorCodeInvalidArgument,
	SetScheduleReminderErrorCodeNotFound,
	SetScheduleReminderErrorCodeFailedPrecondition,
}

func (e SetScheduleReminderErrorCode) IsValid() bool {
	switch e {
	case SetScheduleReminderErrorCodeUnknown, SetScheduleReminderErrorCodeInvalidArgument, SetScheduleReminderErrorCodeNotFound, SetScheduleReminderErrorCodeFailedPrecondition:
		return true
	}
	return false
}

func (e SetScheduleReminderErrorCode) String() string {
	return string(e)
}

func (e *SetScheduleReminderErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SetScheduleReminderErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SetScheduleReminderErrorCode", str)
	}
	return nil
}

func (e SetScheduleReminderErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error codes for from set unban requests settings mutation.
type SetUnbanRequestsSettingsErrorCode string

const (
	// Unknown error.
	SetUnbanRequestsSettingsErrorCodeUnknown SetUnbanRequestsSettingsErrorCode = "UNKNOWN"
	// User is not authorized to set unban request settings on the channel.
	SetUnbanRequestsSettingsErrorCodeUnauthorized SetUnbanRequestsSettingsErrorCode = "UNAUTHORIZED"
	// User attempted to set with an invalid value.
	SetUnbanRequestsSettingsErrorCodeInvalidValue SetUnbanRequestsSettingsErrorCode = "INVALID_VALUE"
)

var AllSetUnbanRequestsSettingsErrorCode = []SetUnbanRequestsSettingsErrorCode{
	SetUnbanRequestsSettingsErrorCodeUnknown,
	SetUnbanRequestsSettingsErrorCodeUnauthorized,
	SetUnbanRequestsSettingsErrorCodeInvalidValue,
}

func (e SetUnbanRequestsSettingsErrorCode) IsValid() bool {
	switch e {
	case SetUnbanRequestsSettingsErrorCodeUnknown, SetUnbanRequestsSettingsErrorCodeUnauthorized, SetUnbanRequestsSettingsErrorCodeInvalidValue:
		return true
	}
	return false
}

func (e SetUnbanRequestsSettingsErrorCode) String() string {
	return string(e)
}

func (e *SetUnbanRequestsSettingsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SetUnbanRequestsSettingsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SetUnbanRequestsSettingsErrorCode", str)
	}
	return nil
}

func (e SetUnbanRequestsSettingsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The platform from which the short video feed is requested.
type ShortVideoFeedPlatform string

const (
	// The mobile web site.
	ShortVideoFeedPlatformMobileWeb ShortVideoFeedPlatform = "MOBILE_WEB"
	// The iOS app.
	ShortVideoFeedPlatformIos ShortVideoFeedPlatform = "IOS"
	// The Android app.
	ShortVideoFeedPlatformAndroid ShortVideoFeedPlatform = "ANDROID"
)

var AllShortVideoFeedPlatform = []ShortVideoFeedPlatform{
	ShortVideoFeedPlatformMobileWeb,
	ShortVideoFeedPlatformIos,
	ShortVideoFeedPlatformAndroid,
}

func (e ShortVideoFeedPlatform) IsValid() bool {
	switch e {
	case ShortVideoFeedPlatformMobileWeb, ShortVideoFeedPlatformIos, ShortVideoFeedPlatformAndroid:
		return true
	}
	return false
}

func (e ShortVideoFeedPlatform) String() string {
	return string(e)
}

func (e *ShortVideoFeedPlatform) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShortVideoFeedPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShortVideoFeedPlatform", str)
	}
	return nil
}

func (e ShortVideoFeedPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of short form video feed.
type ShortVideoFeedType string

const (
	// Return a video feed based off the channels the user is following.
	ShortVideoFeedTypeFollowing ShortVideoFeedType = "FOLLOWING"
	// Return a video feed based off an recommendations model.
	ShortVideoFeedTypeRecommended ShortVideoFeedType = "RECOMMENDED"
)

var AllShortVideoFeedType = []ShortVideoFeedType{
	ShortVideoFeedTypeFollowing,
	ShortVideoFeedTypeRecommended,
}

func (e ShortVideoFeedType) IsValid() bool {
	switch e {
	case ShortVideoFeedTypeFollowing, ShortVideoFeedTypeRecommended:
		return true
	}
	return false
}

func (e ShortVideoFeedType) String() string {
	return string(e)
}

func (e *ShortVideoFeedType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShortVideoFeedType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShortVideoFeedType", str)
	}
	return nil
}

func (e ShortVideoFeedType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sort direction.
type SortOrder string

const (
	// Ascending (A-Z, 1-9).
	SortOrderAsc SortOrder = "ASC"
	// Descending (Z-A, 9-1).
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of source the shelf content is coming from.
type SourceType string

const (
	// The target source is from promotional campaign that is free.
	SourceTypePromotion SourceType = "PROMOTION"
	// The target source is from recommendations.
	SourceTypeRecommended SourceType = "RECOMMENDED"
	// The target source is from a promotional campaign that is paid.
	SourceTypeSponsored SourceType = "SPONSORED"
	// The target source is from a fallback candidate.
	SourceTypePopular SourceType = "POPULAR"
	// The target source is from a boost promotional campaign.
	SourceTypeCommunityBoost SourceType = "COMMUNITY_BOOST"
	// The target source is unknown so we default to UNKNOWN.
	SourceTypeUnknownSourceType SourceType = "UNKNOWN_SOURCE_TYPE"
)

var AllSourceType = []SourceType{
	SourceTypePromotion,
	SourceTypeRecommended,
	SourceTypeSponsored,
	SourceTypePopular,
	SourceTypeCommunityBoost,
	SourceTypeUnknownSourceType,
}

func (e SourceType) IsValid() bool {
	switch e {
	case SourceTypePromotion, SourceTypeRecommended, SourceTypeSponsored, SourceTypePopular, SourceTypeCommunityBoost, SourceTypeUnknownSourceType:
		return true
	}
	return false
}

func (e SourceType) String() string {
	return string(e)
}

func (e *SourceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SourceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SourceType", str)
	}
	return nil
}

func (e SourceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes returned when attempting to spend subscription credit.
type SpendSubscriptionCreditErrorCode string

const (
	// Occurs if a Twitch Prime user attempts to spend subscription credit that is (still) unavailable.
	SpendSubscriptionCreditErrorCodeUnableToSpend SpendSubscriptionCreditErrorCode = "UNABLE_TO_SPEND"
	// Occurs if a Twitch Prime user attempts to spend multiple times, acting as a flag for fraud.
	SpendSubscriptionCreditErrorCodeTooManyRecentSpends SpendSubscriptionCreditErrorCode = "TOO_MANY_RECENT_SPENDS"
)

var AllSpendSubscriptionCreditErrorCode = []SpendSubscriptionCreditErrorCode{
	SpendSubscriptionCreditErrorCodeUnableToSpend,
	SpendSubscriptionCreditErrorCodeTooManyRecentSpends,
}

func (e SpendSubscriptionCreditErrorCode) IsValid() bool {
	switch e {
	case SpendSubscriptionCreditErrorCodeUnableToSpend, SpendSubscriptionCreditErrorCodeTooManyRecentSpends:
		return true
	}
	return false
}

func (e SpendSubscriptionCreditErrorCode) String() string {
	return string(e)
}

func (e *SpendSubscriptionCreditErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SpendSubscriptionCreditErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SpendSubscriptionCreditErrorCode", str)
	}
	return nil
}

func (e SpendSubscriptionCreditErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Determines who can send the user invitations to join a squad stream.
type SquadStreamIncomingInvitePolicy string

const (
	// This user should never receive invitations.
	SquadStreamIncomingInvitePolicyNone SquadStreamIncomingInvitePolicy = "NONE"
	// This user can receive invitations from friends, teammates and followed channels.
	SquadStreamIncomingInvitePolicyNetwork SquadStreamIncomingInvitePolicy = "NETWORK"
	// This user can receive invitations from anyone.
	SquadStreamIncomingInvitePolicyAll SquadStreamIncomingInvitePolicy = "ALL"
)

var AllSquadStreamIncomingInvitePolicy = []SquadStreamIncomingInvitePolicy{
	SquadStreamIncomingInvitePolicyNone,
	SquadStreamIncomingInvitePolicyNetwork,
	SquadStreamIncomingInvitePolicyAll,
}

func (e SquadStreamIncomingInvitePolicy) IsValid() bool {
	switch e {
	case SquadStreamIncomingInvitePolicyNone, SquadStreamIncomingInvitePolicyNetwork, SquadStreamIncomingInvitePolicyAll:
		return true
	}
	return false
}

func (e SquadStreamIncomingInvitePolicy) String() string {
	return string(e)
}

func (e *SquadStreamIncomingInvitePolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SquadStreamIncomingInvitePolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SquadStreamIncomingInvitePolicy", str)
	}
	return nil
}

func (e SquadStreamIncomingInvitePolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes the network type of a squad stream invitation.
type SquadStreamInvitationNetworkType string

const (
	// The invitation is from within the recipient's network (friends, teammates and followed channels).
	SquadStreamInvitationNetworkTypeInNetwork SquadStreamInvitationNetworkType = "IN_NETWORK"
	// The invitation is from outside of the recipient's network.
	SquadStreamInvitationNetworkTypeOutOfNetwork SquadStreamInvitationNetworkType = "OUT_OF_NETWORK"
)

var AllSquadStreamInvitationNetworkType = []SquadStreamInvitationNetworkType{
	SquadStreamInvitationNetworkTypeInNetwork,
	SquadStreamInvitationNetworkTypeOutOfNetwork,
}

func (e SquadStreamInvitationNetworkType) IsValid() bool {
	switch e {
	case SquadStreamInvitationNetworkTypeInNetwork, SquadStreamInvitationNetworkTypeOutOfNetwork:
		return true
	}
	return false
}

func (e SquadStreamInvitationNetworkType) String() string {
	return string(e)
}

func (e *SquadStreamInvitationNetworkType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SquadStreamInvitationNetworkType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SquadStreamInvitationNetworkType", str)
	}
	return nil
}

func (e SquadStreamInvitationNetworkType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes the reason a squad stream invitation was rejected.
type SquadStreamInvitationRejectedReason string

const (
	// The recipient rejected the invitation.
	SquadStreamInvitationRejectedReasonRecipientRejected SquadStreamInvitationRejectedReason = "RECIPIENT_REJECTED"
	// The recipient cannot access the squad stream product (e.g. due to missing transcode, partner-only launch).
	SquadStreamInvitationRejectedReasonRecipientCannotAccessSquadStream SquadStreamInvitationRejectedReason = "RECIPIENT_CANNOT_ACCESS_SQUAD_STREAM"
	// The recipient does not allow the sender of the invitation to invite them (e.g. due to their squad stream settings).
	SquadStreamInvitationRejectedReasonRecipientCannotBeInvited SquadStreamInvitationRejectedReason = "RECIPIENT_CANNOT_BE_INVITED"
)

var AllSquadStreamInvitationRejectedReason = []SquadStreamInvitationRejectedReason{
	SquadStreamInvitationRejectedReasonRecipientRejected,
	SquadStreamInvitationRejectedReasonRecipientCannotAccessSquadStream,
	SquadStreamInvitationRejectedReasonRecipientCannotBeInvited,
}

func (e SquadStreamInvitationRejectedReason) IsValid() bool {
	switch e {
	case SquadStreamInvitationRejectedReasonRecipientRejected, SquadStreamInvitationRejectedReasonRecipientCannotAccessSquadStream, SquadStreamInvitationRejectedReasonRecipientCannotBeInvited:
		return true
	}
	return false
}

func (e SquadStreamInvitationRejectedReason) String() string {
	return string(e)
}

func (e *SquadStreamInvitationRejectedReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SquadStreamInvitationRejectedReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SquadStreamInvitationRejectedReason", str)
	}
	return nil
}

func (e SquadStreamInvitationRejectedReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes the current state of a squad stream invitation.
type SquadStreamInvitationStatus string

const (
	// The recipient has accepted the invitation.
	SquadStreamInvitationStatusAccepted SquadStreamInvitationStatus = "ACCEPTED"
	// A squad stream owner has deleted the invitation.
	SquadStreamInvitationStatusDeleted SquadStreamInvitationStatus = "DELETED"
	// The invitation has been sent to the recipient and the sender is waiting for a response.
	SquadStreamInvitationStatusPending SquadStreamInvitationStatus = "PENDING"
	// The recipient has rejected the invitation.
	SquadStreamInvitationStatusRejected SquadStreamInvitationStatus = "REJECTED"
	// The invitation has an unknown status.
	SquadStreamInvitationStatusUnknown SquadStreamInvitationStatus = "UNKNOWN"
)

var AllSquadStreamInvitationStatus = []SquadStreamInvitationStatus{
	SquadStreamInvitationStatusAccepted,
	SquadStreamInvitationStatusDeleted,
	SquadStreamInvitationStatusPending,
	SquadStreamInvitationStatusRejected,
	SquadStreamInvitationStatusUnknown,
}

func (e SquadStreamInvitationStatus) IsValid() bool {
	switch e {
	case SquadStreamInvitationStatusAccepted, SquadStreamInvitationStatusDeleted, SquadStreamInvitationStatusPending, SquadStreamInvitationStatusRejected, SquadStreamInvitationStatusUnknown:
		return true
	}
	return false
}

func (e SquadStreamInvitationStatus) String() string {
	return string(e)
}

func (e *SquadStreamInvitationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SquadStreamInvitationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SquadStreamInvitationStatus", str)
	}
	return nil
}

func (e SquadStreamInvitationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes the status of a squad stream.
type SquadStreamStatus string

const (
	// The squad stream is live and is being broadcast to viewers.
	SquadStreamStatusLive SquadStreamStatus = "LIVE"
	// The squad stream is being set up, and should not be shown to viewers.
	SquadStreamStatusPending SquadStreamStatus = "PENDING"
	// The squad stream has ended.
	SquadStreamStatusEnded SquadStreamStatus = "ENDED"
	// The squad stream has an unknown status.
	SquadStreamStatusUnknown SquadStreamStatus = "UNKNOWN"
)

var AllSquadStreamStatus = []SquadStreamStatus{
	SquadStreamStatusLive,
	SquadStreamStatusPending,
	SquadStreamStatusEnded,
	SquadStreamStatusUnknown,
}

func (e SquadStreamStatus) IsValid() bool {
	switch e {
	case SquadStreamStatusLive, SquadStreamStatusPending, SquadStreamStatusEnded, SquadStreamStatusUnknown:
		return true
	}
	return false
}

func (e SquadStreamStatus) String() string {
	return string(e)
}

func (e *SquadStreamStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SquadStreamStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SquadStreamStatus", str)
	}
	return nil
}

func (e SquadStreamStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// StartAdErrorCode ...
type StartAdErrorCode string

const (
	// The user has requested an ad break before the rate limit timer has expired.
	StartAdErrorCodeRateLimited StartAdErrorCode = "RATE_LIMITED"
	// The user is not authorized to run an ad break on the requested channel.
	StartAdErrorCodeUserNotAuthorized StartAdErrorCode = "USER_NOT_AUTHORIZED"
	// An unknown error occured while trying to run an ad break.
	StartAdErrorCodeUnknownError StartAdErrorCode = "UNKNOWN_ERROR"
)

var AllStartAdErrorCode = []StartAdErrorCode{
	StartAdErrorCodeRateLimited,
	StartAdErrorCodeUserNotAuthorized,
	StartAdErrorCodeUnknownError,
}

func (e StartAdErrorCode) IsValid() bool {
	switch e {
	case StartAdErrorCodeRateLimited, StartAdErrorCodeUserNotAuthorized, StartAdErrorCodeUnknownError:
		return true
	}
	return false
}

func (e StartAdErrorCode) String() string {
	return string(e)
}

func (e *StartAdErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StartAdErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StartAdErrorCode", str)
	}
	return nil
}

func (e StartAdErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error types recognized.
type StartBountyErrorCode string

const (
	// Invalid parameter in the request.
	StartBountyErrorCodeInvalidParameter StartBountyErrorCode = "INVALID_PARAMETER"
	// The bounty cannot be started because it is not live.
	StartBountyErrorCodeBountyNotLive StartBountyErrorCode = "BOUNTY_NOT_LIVE"
	// The stream title contains banned words.
	StartBountyErrorCodeStreamTitleBannedWords StartBountyErrorCode = "STREAM_TITLE_BANNED_WORDS"
	// The stream title is too long.
	StartBountyErrorCodeStreamTitleTooLong StartBountyErrorCode = "STREAM_TITLE_TOO_LONG"
	// The user is not authorized to start the bounty.
	StartBountyErrorCodeUnauthorized StartBountyErrorCode = "UNAUTHORIZED"
	// Unknown error being returned from service.
	StartBountyErrorCodeUnknownError StartBountyErrorCode = "UNKNOWN_ERROR"
)

var AllStartBountyErrorCode = []StartBountyErrorCode{
	StartBountyErrorCodeInvalidParameter,
	StartBountyErrorCodeBountyNotLive,
	StartBountyErrorCodeStreamTitleBannedWords,
	StartBountyErrorCodeStreamTitleTooLong,
	StartBountyErrorCodeUnauthorized,
	StartBountyErrorCodeUnknownError,
}

func (e StartBountyErrorCode) IsValid() bool {
	switch e {
	case StartBountyErrorCodeInvalidParameter, StartBountyErrorCodeBountyNotLive, StartBountyErrorCodeStreamTitleBannedWords, StartBountyErrorCodeStreamTitleTooLong, StartBountyErrorCodeUnauthorized, StartBountyErrorCodeUnknownError:
		return true
	}
	return false
}

func (e StartBountyErrorCode) String() string {
	return string(e)
}

func (e *StartBountyErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StartBountyErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StartBountyErrorCode", str)
	}
	return nil
}

func (e StartBountyErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Errors returned by attempting to start a cloud broadcast.
type StartCloudBroadcastErrorCause string

const (
	// No subscription was found for the given channel and provider.
	StartCloudBroadcastErrorCauseNoSubscription StartCloudBroadcastErrorCause = "NO_SUBSCRIPTION"
	// An unknown error occurred, use message for more information.
	StartCloudBroadcastErrorCauseUnknown StartCloudBroadcastErrorCause = "UNKNOWN"
)

var AllStartCloudBroadcastErrorCause = []StartCloudBroadcastErrorCause{
	StartCloudBroadcastErrorCauseNoSubscription,
	StartCloudBroadcastErrorCauseUnknown,
}

func (e StartCloudBroadcastErrorCause) IsValid() bool {
	switch e {
	case StartCloudBroadcastErrorCauseNoSubscription, StartCloudBroadcastErrorCauseUnknown:
		return true
	}
	return false
}

func (e StartCloudBroadcastErrorCause) String() string {
	return string(e)
}

func (e *StartCloudBroadcastErrorCause) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StartCloudBroadcastErrorCause(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StartCloudBroadcastErrorCause", str)
	}
	return nil
}

func (e StartCloudBroadcastErrorCause) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error types recognized.
type StopBountyErrorCode string

const (
	// Invalid parameter in the request.
	StopBountyErrorCodeInvalidParameter StopBountyErrorCode = "INVALID_PARAMETER"
	// The user is not authorized to stop the bounty.
	StopBountyErrorCodeUnauthorized StopBountyErrorCode = "UNAUTHORIZED"
	// Unknown error being returned from service.
	StopBountyErrorCodeUnknownError StopBountyErrorCode = "UNKNOWN_ERROR"
)

var AllStopBountyErrorCode = []StopBountyErrorCode{
	StopBountyErrorCodeInvalidParameter,
	StopBountyErrorCodeUnauthorized,
	StopBountyErrorCodeUnknownError,
}

func (e StopBountyErrorCode) IsValid() bool {
	switch e {
	case StopBountyErrorCodeInvalidParameter, StopBountyErrorCodeUnauthorized, StopBountyErrorCodeUnknownError:
		return true
	}
	return false
}

func (e StopBountyErrorCode) String() string {
	return string(e)
}

func (e *StopBountyErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StopBountyErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StopBountyErrorCode", str)
	}
	return nil
}

func (e StopBountyErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Errors returned by attempting to stop a cloud broadcast.
type StopCloudBroadcastErrorCause string

const (
	// No broadcast was found for the given channel and provider.
	// Either because the broadcast is stopped or because the provider did not know about the user.
	StopCloudBroadcastErrorCauseBroadcastNotFound StopCloudBroadcastErrorCause = "BROADCAST_NOT_FOUND"
	// An unknown error message occurred, see message for more information.
	StopCloudBroadcastErrorCauseUnknown StopCloudBroadcastErrorCause = "UNKNOWN"
)

var AllStopCloudBroadcastErrorCause = []StopCloudBroadcastErrorCause{
	StopCloudBroadcastErrorCauseBroadcastNotFound,
	StopCloudBroadcastErrorCauseUnknown,
}

func (e StopCloudBroadcastErrorCause) IsValid() bool {
	switch e {
	case StopCloudBroadcastErrorCauseBroadcastNotFound, StopCloudBroadcastErrorCauseUnknown:
		return true
	}
	return false
}

func (e StopCloudBroadcastErrorCause) String() string {
	return string(e)
}

func (e *StopCloudBroadcastErrorCause) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StopCloudBroadcastErrorCause(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StopCloudBroadcastErrorCause", str)
	}
	return nil
}

func (e StopCloudBroadcastErrorCause) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StreamRecommendationType string

const (
	// A SocialStream.
	StreamRecommendationTypeSocial StreamRecommendationType = "SOCIAL"
)

var AllStreamRecommendationType = []StreamRecommendationType{
	StreamRecommendationTypeSocial,
}

func (e StreamRecommendationType) IsValid() bool {
	switch e {
	case StreamRecommendationTypeSocial:
		return true
	}
	return false
}

func (e StreamRecommendationType) String() string {
	return string(e)
}

func (e *StreamRecommendationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StreamRecommendationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StreamRecommendationType", str)
	}
	return nil
}

func (e StreamRecommendationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of restricted stream. Currently used as inputs for user.followedLiveUsers, StreamOptions, and GameStreamOptions.
type StreamRestrictionType string

const (
	// Represents streams that are restricted by OWL all-access pass.
	StreamRestrictionTypeOwlAllAccessPass StreamRestrictionType = "OWL_ALL_ACCESS_PASS"
	// Represents streams that are restricted to sub-only.
	StreamRestrictionTypeSubOnlyLive StreamRestrictionType = "SUB_ONLY_LIVE"
)

var AllStreamRestrictionType = []StreamRestrictionType{
	StreamRestrictionTypeOwlAllAccessPass,
	StreamRestrictionTypeSubOnlyLive,
}

func (e StreamRestrictionType) IsValid() bool {
	switch e {
	case StreamRestrictionTypeOwlAllAccessPass, StreamRestrictionTypeSubOnlyLive:
		return true
	}
	return false
}

func (e StreamRestrictionType) String() string {
	return string(e)
}

func (e *StreamRestrictionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StreamRestrictionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StreamRestrictionType", str)
	}
	return nil
}

func (e StreamRestrictionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible ways of sorting collections of live streams.
type StreamSort string

const (
	// Sort streams by number of concurrent viewers, descending (most viewers first).
	// This is the default if StreamSort is not set or is a deprecated field.
	StreamSortViewerCount StreamSort = "VIEWER_COUNT"
	// Sort streams by number of concurrent viewers, ascending (least viewers first).
	StreamSortViewerCountAsc StreamSort = "VIEWER_COUNT_ASC"
	// Sort by stream creation time, most recently started streams first.
	StreamSortRecent StreamSort = "RECENT"
	// Sort by relevance to the current user.
	StreamSortRelevance StreamSort = "RELEVANCE"
	// Sort streams for the game "Counter-Strike: Global Offensive" by skill, descending (highest skill first).
	// Other streams are included last, sorted at random.
	// Deprecated: this sort option no longer exists.
	StreamSortCsgoSkill StreamSort = "CSGO_SKILL"
	// Sort streams for the game "League of Legends" by summoner rank, descending (highest rank first).
	// Other streams are included last, sorted at random.
	// Deprecated: this sort option no longer exists.
	StreamSortLolSummonerRank StreamSort = "LOL_SUMMONER_RANK"
)

var AllStreamSort = []StreamSort{
	StreamSortViewerCount,
	StreamSortViewerCountAsc,
	StreamSortRecent,
	StreamSortRelevance,
	StreamSortCsgoSkill,
	StreamSortLolSummonerRank,
}

func (e StreamSort) IsValid() bool {
	switch e {
	case StreamSortViewerCount, StreamSortViewerCountAsc, StreamSortRecent, StreamSortRelevance, StreamSortCsgoSkill, StreamSortLolSummonerRank:
		return true
	}
	return false
}

func (e StreamSort) String() string {
	return string(e)
}

func (e *StreamSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StreamSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StreamSort", str)
	}
	return nil
}

func (e StreamSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of streamer shelf to display.
type StreamerShelfType string

const (
	// Shows the streamer's autohost list.
	StreamerShelfTypeAutohost StreamerShelfType = "AUTOHOST"
	// Shows the streamer's team members.
	StreamerShelfTypeTeam StreamerShelfType = "TEAM"
	// Disables the shelf.
	StreamerShelfTypeDisabled StreamerShelfType = "DISABLED"
)

var AllStreamerShelfType = []StreamerShelfType{
	StreamerShelfTypeAutohost,
	StreamerShelfTypeTeam,
	StreamerShelfTypeDisabled,
}

func (e StreamerShelfType) IsValid() bool {
	switch e {
	case StreamerShelfTypeAutohost, StreamerShelfTypeTeam, StreamerShelfTypeDisabled:
		return true
	}
	return false
}

func (e StreamerShelfType) String() string {
	return string(e)
}

func (e *StreamerShelfType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StreamerShelfType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StreamerShelfType", str)
	}
	return nil
}

func (e StreamerShelfType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The state a stucco can be in.
type StuccoState string

const (
	// - Active: part of a stucco pack.
	StuccoStateActive StuccoState = "ACTIVE"
	// - Inactive: available in the library.
	StuccoStateInactive StuccoState = "INACTIVE"
	// - Moderated: stucco was moderated and is no longer available to the broadcaster or viewers.
	StuccoStateModerated StuccoState = "MODERATED"
	// - Pending: stucco is currently going through moderation.
	StuccoStatePending StuccoState = "PENDING"
	// - Archived: Archived stucco, no longer visible.
	StuccoStateArchived StuccoState = "ARCHIVED"
)

var AllStuccoState = []StuccoState{
	StuccoStateActive,
	StuccoStateInactive,
	StuccoStateModerated,
	StuccoStatePending,
	StuccoStateArchived,
}

func (e StuccoState) IsValid() bool {
	switch e {
	case StuccoStateActive, StuccoStateInactive, StuccoStateModerated, StuccoStatePending, StuccoStateArchived:
		return true
	}
	return false
}

func (e StuccoState) String() string {
	return string(e)
}

func (e *StuccoState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StuccoState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StuccoState", str)
	}
	return nil
}

func (e StuccoState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes returned by the submitCSATFeedback mutation.
type SubmitCSATFeedbackErrorCode string

const (
	// Unkown backend error.
	SubmitCSATFeedbackErrorCodeUnknown SubmitCSATFeedbackErrorCode = "UNKNOWN"
	// Invalid argument error, such as exceeding max characters in feedback or providing an invalid GUID.
	SubmitCSATFeedbackErrorCodeInvalidArgument SubmitCSATFeedbackErrorCode = "INVALID_ARGUMENT"
)

var AllSubmitCSATFeedbackErrorCode = []SubmitCSATFeedbackErrorCode{
	SubmitCSATFeedbackErrorCodeUnknown,
	SubmitCSATFeedbackErrorCodeInvalidArgument,
}

func (e SubmitCSATFeedbackErrorCode) IsValid() bool {
	switch e {
	case SubmitCSATFeedbackErrorCodeUnknown, SubmitCSATFeedbackErrorCodeInvalidArgument:
		return true
	}
	return false
}

func (e SubmitCSATFeedbackErrorCode) String() string {
	return string(e)
}

func (e *SubmitCSATFeedbackErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubmitCSATFeedbackErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubmitCSATFeedbackErrorCode", str)
	}
	return nil
}

func (e SubmitCSATFeedbackErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A code indicating why the prefix submit failed, if it did.
type SubmitEmotePrefixResponseCode string

const (
	// Only eligible users can update their emoticon prefix.
	SubmitEmotePrefixResponseCodeErrInvalidUser SubmitEmotePrefixResponseCode = "ERR_INVALID_USER"
	// The prefix submitted was not the correct length.
	SubmitEmotePrefixResponseCodeErrInvalidPrefixLength SubmitEmotePrefixResponseCode = "ERR_INVALID_PREFIX_LENGTH"
	// The prefix submitted does not meet the regular expression requirements.
	SubmitEmotePrefixResponseCodeErrInvalidPrefixRegex SubmitEmotePrefixResponseCode = "ERR_INVALID_PREFIX_REGEX"
	// The prefix is not in a state that it can be updated.
	SubmitEmotePrefixResponseCodeErrInvalidPrefixState SubmitEmotePrefixResponseCode = "ERR_INVALID_PREFIX_STATE"
	// Emote prefixes must be unique across the website.
	SubmitEmotePrefixResponseCodeErrPrefixNotUnique SubmitEmotePrefixResponseCode = "ERR_PREFIX_NOT_UNIQUE"
	// The prefix was updated recently and can't be updated again for a while.
	SubmitEmotePrefixResponseCodeErrPrefixUpdateTooSoon SubmitEmotePrefixResponseCode = "ERR_PREFIX_UPDATE_TOO_SOON"
	// The user is not in good standing and therefore cannot update their emoticon prefix.
	SubmitEmotePrefixResponseCodeErrNotInGoodStanding SubmitEmotePrefixResponseCode = "ERR_NOT_IN_GOOD_STANDING"
	// Something unexpected happened when submitting the emote prefix.
	SubmitEmotePrefixResponseCodeErrUnknown SubmitEmotePrefixResponseCode = "ERR_UNKNOWN"
	// The prefix for the affiliate can not be updated. Affiliates can update prefix once every name change.
	SubmitEmotePrefixResponseCodeErrAffiliatePrefixUpdateTooSoon SubmitEmotePrefixResponseCode = "ERR_AFFILIATE_PREFIX_UPDATE_TOO_SOON"
	// The prefix submitted for the affiliate does not match the auto generated prefix.
	SubmitEmotePrefixResponseCodeErrSubmittedPrefixDoesNotMatchAutoGeneratedPrefix SubmitEmotePrefixResponseCode = "ERR_SUBMITTED_PREFIX_DOES_NOT_MATCH_AUTO_GENERATED_PREFIX"
)

var AllSubmitEmotePrefixResponseCode = []SubmitEmotePrefixResponseCode{
	SubmitEmotePrefixResponseCodeErrInvalidUser,
	SubmitEmotePrefixResponseCodeErrInvalidPrefixLength,
	SubmitEmotePrefixResponseCodeErrInvalidPrefixRegex,
	SubmitEmotePrefixResponseCodeErrInvalidPrefixState,
	SubmitEmotePrefixResponseCodeErrPrefixNotUnique,
	SubmitEmotePrefixResponseCodeErrPrefixUpdateTooSoon,
	SubmitEmotePrefixResponseCodeErrNotInGoodStanding,
	SubmitEmotePrefixResponseCodeErrUnknown,
	SubmitEmotePrefixResponseCodeErrAffiliatePrefixUpdateTooSoon,
	SubmitEmotePrefixResponseCodeErrSubmittedPrefixDoesNotMatchAutoGeneratedPrefix,
}

func (e SubmitEmotePrefixResponseCode) IsValid() bool {
	switch e {
	case SubmitEmotePrefixResponseCodeErrInvalidUser, SubmitEmotePrefixResponseCodeErrInvalidPrefixLength, SubmitEmotePrefixResponseCodeErrInvalidPrefixRegex, SubmitEmotePrefixResponseCodeErrInvalidPrefixState, SubmitEmotePrefixResponseCodeErrPrefixNotUnique, SubmitEmotePrefixResponseCodeErrPrefixUpdateTooSoon, SubmitEmotePrefixResponseCodeErrNotInGoodStanding, SubmitEmotePrefixResponseCodeErrUnknown, SubmitEmotePrefixResponseCodeErrAffiliatePrefixUpdateTooSoon, SubmitEmotePrefixResponseCodeErrSubmittedPrefixDoesNotMatchAutoGeneratedPrefix:
		return true
	}
	return false
}

func (e SubmitEmotePrefixResponseCode) String() string {
	return string(e)
}

func (e *SubmitEmotePrefixResponseCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubmitEmotePrefixResponseCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubmitEmotePrefixResponseCode", str)
	}
	return nil
}

func (e SubmitEmotePrefixResponseCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors returned by the SubmitExtensionFeedback mutation.
type SubmitExtensionFeedbackError string

const (
	// Internal service error eg. database timeout.
	SubmitExtensionFeedbackErrorInternalError SubmitExtensionFeedbackError = "INTERNAL_ERROR"
)

var AllSubmitExtensionFeedbackError = []SubmitExtensionFeedbackError{
	SubmitExtensionFeedbackErrorInternalError,
}

func (e SubmitExtensionFeedbackError) IsValid() bool {
	switch e {
	case SubmitExtensionFeedbackErrorInternalError:
		return true
	}
	return false
}

func (e SubmitExtensionFeedbackError) String() string {
	return string(e)
}

func (e *SubmitExtensionFeedbackError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubmitExtensionFeedbackError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubmitExtensionFeedbackError", str)
	}
	return nil
}

func (e SubmitExtensionFeedbackError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Set of ways to filter subscription benefit paginated results.
type SubscriptionBenefitFilter string

const (
	// Only subscriptions purchased on a platform, specified in the input as platform.
	SubscriptionBenefitFilterPlatform SubscriptionBenefitFilter = "PLATFORM"
	// Only Subscriptions received through gifts from another Twitch user.
	SubscriptionBenefitFilterGift SubscriptionBenefitFilter = "GIFT"
	// All active subscriptions.
	SubscriptionBenefitFilterAll SubscriptionBenefitFilter = "ALL"
)

var AllSubscriptionBenefitFilter = []SubscriptionBenefitFilter{
	SubscriptionBenefitFilterPlatform,
	SubscriptionBenefitFilterGift,
	SubscriptionBenefitFilterAll,
}

func (e SubscriptionBenefitFilter) IsValid() bool {
	switch e {
	case SubscriptionBenefitFilterPlatform, SubscriptionBenefitFilterGift, SubscriptionBenefitFilterAll:
		return true
	}
	return false
}

func (e SubscriptionBenefitFilter) String() string {
	return string(e)
}

func (e *SubscriptionBenefitFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionBenefitFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionBenefitFilter", str)
	}
	return nil
}

func (e SubscriptionBenefitFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The logic state of the Subscription Benefit.
type SubscriptionBenefitState string

const (
	// Unknown (0-value) state.
	SubscriptionBenefitStateUnknown SubscriptionBenefitState = "UNKNOWN"
	// Active (recurring) state.
	SubscriptionBenefitStateActive SubscriptionBenefitState = "ACTIVE"
	// State when a user has initiated a DNR request.
	SubscriptionBenefitStateDnrInitiated SubscriptionBenefitState = "DNR_INITIATED"
	// State for when Twitch has completed a DNR request.
	SubscriptionBenefitStateWillNotRenew SubscriptionBenefitState = "WILL_NOT_RENEW"
	// State for when Twitch has initiated a refund request.
	SubscriptionBenefitStateCancelInitiated SubscriptionBenefitState = "CANCEL_INITIATED"
	// State for when Twitch has completed a refund request.
	SubscriptionBenefitStateCancelled SubscriptionBenefitState = "CANCELLED"
	// State for when a Subscription has been paused (used to support Android account hold feature).
	SubscriptionBenefitStateOnHold SubscriptionBenefitState = "ON_HOLD"
)

var AllSubscriptionBenefitState = []SubscriptionBenefitState{
	SubscriptionBenefitStateUnknown,
	SubscriptionBenefitStateActive,
	SubscriptionBenefitStateDnrInitiated,
	SubscriptionBenefitStateWillNotRenew,
	SubscriptionBenefitStateCancelInitiated,
	SubscriptionBenefitStateCancelled,
	SubscriptionBenefitStateOnHold,
}

func (e SubscriptionBenefitState) IsValid() bool {
	switch e {
	case SubscriptionBenefitStateUnknown, SubscriptionBenefitStateActive, SubscriptionBenefitStateDnrInitiated, SubscriptionBenefitStateWillNotRenew, SubscriptionBenefitStateCancelInitiated, SubscriptionBenefitStateCancelled, SubscriptionBenefitStateOnHold:
		return true
	}
	return false
}

func (e SubscriptionBenefitState) String() string {
	return string(e)
}

func (e *SubscriptionBenefitState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionBenefitState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionBenefitState", str)
	}
	return nil
}

func (e SubscriptionBenefitState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes the type of community gifting Offer that is being resolved.
type SubscriptionCommunityGiftingType string

const (
	// An unknown gifting type.
	SubscriptionCommunityGiftingTypeUnknown SubscriptionCommunityGiftingType = "UNKNOWN"
	// A preset bundle of fixed-quantity community gift subscriptions.
	SubscriptionCommunityGiftingTypeBundle SubscriptionCommunityGiftingType = "BUNDLE"
	// An offer that allows the user to choose how many gift subscriptions they would like to purchase.
	SubscriptionCommunityGiftingTypeCustom SubscriptionCommunityGiftingType = "CUSTOM"
)

var AllSubscriptionCommunityGiftingType = []SubscriptionCommunityGiftingType{
	SubscriptionCommunityGiftingTypeUnknown,
	SubscriptionCommunityGiftingTypeBundle,
	SubscriptionCommunityGiftingTypeCustom,
}

func (e SubscriptionCommunityGiftingType) IsValid() bool {
	switch e {
	case SubscriptionCommunityGiftingTypeUnknown, SubscriptionCommunityGiftingTypeBundle, SubscriptionCommunityGiftingTypeCustom:
		return true
	}
	return false
}

func (e SubscriptionCommunityGiftingType) String() string {
	return string(e)
}

func (e *SubscriptionCommunityGiftingType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionCommunityGiftingType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionCommunityGiftingType", str)
	}
	return nil
}

func (e SubscriptionCommunityGiftingType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The different types of platforms available for gift offers.
type SubscriptionGiftOfferPlatform string

const (
	// Gift offers available for the web clients.
	SubscriptionGiftOfferPlatformWeb SubscriptionGiftOfferPlatform = "WEB"
	// Gift offers available for the Android clients.
	SubscriptionGiftOfferPlatformAndroid SubscriptionGiftOfferPlatform = "ANDROID"
)

var AllSubscriptionGiftOfferPlatform = []SubscriptionGiftOfferPlatform{
	SubscriptionGiftOfferPlatformWeb,
	SubscriptionGiftOfferPlatformAndroid,
}

func (e SubscriptionGiftOfferPlatform) IsValid() bool {
	switch e {
	case SubscriptionGiftOfferPlatformWeb, SubscriptionGiftOfferPlatformAndroid:
		return true
	}
	return false
}

func (e SubscriptionGiftOfferPlatform) String() string {
	return string(e)
}

func (e *SubscriptionGiftOfferPlatform) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionGiftOfferPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionGiftOfferPlatform", str)
	}
	return nil
}

func (e SubscriptionGiftOfferPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The different types of subscription gifting.
type SubscriptionGiftType string

const (
	// Unknown or no gift type.
	SubscriptionGiftTypeNone SubscriptionGiftType = "NONE"
	// Standard gifts are gifts to a specific user given by a user.
	SubscriptionGiftTypeStandard SubscriptionGiftType = "STANDARD"
	// Community gifts are one or more gifts given to one or more users by a user.
	SubscriptionGiftTypeCommunity SubscriptionGiftType = "COMMUNITY"
)

var AllSubscriptionGiftType = []SubscriptionGiftType{
	SubscriptionGiftTypeNone,
	SubscriptionGiftTypeStandard,
	SubscriptionGiftTypeCommunity,
}

func (e SubscriptionGiftType) IsValid() bool {
	switch e {
	case SubscriptionGiftTypeNone, SubscriptionGiftTypeStandard, SubscriptionGiftTypeCommunity:
		return true
	}
	return false
}

func (e SubscriptionGiftType) String() string {
	return string(e)
}

func (e *SubscriptionGiftType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionGiftType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionGiftType", str)
	}
	return nil
}

func (e SubscriptionGiftType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Denotes the unit of the period of a subscription product.
type SubscriptionIntervalUnit string

const (
	// This subscription product length is unknown.
	SubscriptionIntervalUnitUnknown SubscriptionIntervalUnit = "UNKNOWN"
	// This subscription product lasts X weeks.
	SubscriptionIntervalUnitWeek SubscriptionIntervalUnit = "WEEK"
	// This subscription product lasts X months.
	SubscriptionIntervalUnitMonth SubscriptionIntervalUnit = "MONTH"
	// This subscription product lasts X years.
	SubscriptionIntervalUnitYear SubscriptionIntervalUnit = "YEAR"
	// This subscription product lasts forever.
	SubscriptionIntervalUnitOneTime SubscriptionIntervalUnit = "ONE_TIME"
)

var AllSubscriptionIntervalUnit = []SubscriptionIntervalUnit{
	SubscriptionIntervalUnitUnknown,
	SubscriptionIntervalUnitWeek,
	SubscriptionIntervalUnitMonth,
	SubscriptionIntervalUnitYear,
	SubscriptionIntervalUnitOneTime,
}

func (e SubscriptionIntervalUnit) IsValid() bool {
	switch e {
	case SubscriptionIntervalUnitUnknown, SubscriptionIntervalUnitWeek, SubscriptionIntervalUnitMonth, SubscriptionIntervalUnitYear, SubscriptionIntervalUnitOneTime:
		return true
	}
	return false
}

func (e SubscriptionIntervalUnit) String() string {
	return string(e)
}

func (e *SubscriptionIntervalUnit) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionIntervalUnit(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionIntervalUnit", str)
	}
	return nil
}

func (e SubscriptionIntervalUnit) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// SubscriptionPlatform enumerates platform options such as WEB, IOS, ANDROID.
type SubscriptionPlatform string

const (
	// Unknown or no platform.
	SubscriptionPlatformNone SubscriptionPlatform = "NONE"
	// Access from the browser.                                           ).
	SubscriptionPlatformWeb SubscriptionPlatform = "WEB"
	// Access from the Twitch iOS application.
	SubscriptionPlatformIos SubscriptionPlatform = "IOS"
	// Access from the Twitch Android application.
	SubscriptionPlatformAndroid SubscriptionPlatform = "ANDROID"
	// Access from all Twitch Mobile applications (ANDROID + IOS).
	SubscriptionPlatformMobileAll SubscriptionPlatform = "MOBILE_ALL"
)

var AllSubscriptionPlatform = []SubscriptionPlatform{
	SubscriptionPlatformNone,
	SubscriptionPlatformWeb,
	SubscriptionPlatformIos,
	SubscriptionPlatformAndroid,
	SubscriptionPlatformMobileAll,
}

func (e SubscriptionPlatform) IsValid() bool {
	switch e {
	case SubscriptionPlatformNone, SubscriptionPlatformWeb, SubscriptionPlatformIos, SubscriptionPlatformAndroid, SubscriptionPlatformMobileAll:
		return true
	}
	return false
}

func (e SubscriptionPlatform) String() string {
	return string(e)
}

func (e *SubscriptionPlatform) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionPlatform", str)
	}
	return nil
}

func (e SubscriptionPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The types of subscription products that can be purchased.
type SubscriptionProductType string

const (
	// Channel sub.
	SubscriptionProductTypeChansub SubscriptionProductType = "CHANSUB"
	// Team sub.
	SubscriptionProductTypeTeamsub SubscriptionProductType = "TEAMSUB"
	// Turbo sub.
	SubscriptionProductTypeTurbo SubscriptionProductType = "TURBO"
)

var AllSubscriptionProductType = []SubscriptionProductType{
	SubscriptionProductTypeChansub,
	SubscriptionProductTypeTeamsub,
	SubscriptionProductTypeTurbo,
}

func (e SubscriptionProductType) IsValid() bool {
	switch e {
	case SubscriptionProductTypeChansub, SubscriptionProductTypeTeamsub, SubscriptionProductTypeTurbo:
		return true
	}
	return false
}

func (e SubscriptionProductType) String() string {
	return string(e)
}

func (e *SubscriptionProductType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionProductType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionProductType", str)
	}
	return nil
}

func (e SubscriptionProductType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Codes representing subscription products error states clients can respond to.
type SubscriptionProductsErrorCode string

const (
	// Default code.
	SubscriptionProductsErrorCodeUnknown SubscriptionProductsErrorCode = "UNKNOWN"
	// Code indicating server error occurred while retrieving subscription products.
	SubscriptionProductsErrorCodeError SubscriptionProductsErrorCode = "ERROR"
	// Code indicating subscription products could not be found.
	SubscriptionProductsErrorCodeMissing SubscriptionProductsErrorCode = "MISSING"
)

var AllSubscriptionProductsErrorCode = []SubscriptionProductsErrorCode{
	SubscriptionProductsErrorCodeUnknown,
	SubscriptionProductsErrorCodeError,
	SubscriptionProductsErrorCodeMissing,
}

func (e SubscriptionProductsErrorCode) IsValid() bool {
	switch e {
	case SubscriptionProductsErrorCodeUnknown, SubscriptionProductsErrorCodeError, SubscriptionProductsErrorCodeMissing:
		return true
	}
	return false
}

func (e SubscriptionProductsErrorCode) String() string {
	return string(e)
}

func (e *SubscriptionProductsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionProductsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionProductsErrorCode", str)
	}
	return nil
}

func (e SubscriptionProductsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Valid discount types for Subscription promotion.
type SubscriptionPromotionDiscountType string

const (
	// No discount on subscription product.
	SubscriptionPromotionDiscountTypeNone SubscriptionPromotionDiscountType = "NONE"
	// Percent off discount on subscription product.
	SubscriptionPromotionDiscountTypePercentOff SubscriptionPromotionDiscountType = "PERCENT_OFF"
	// Fixed price discount on subscription product.
	SubscriptionPromotionDiscountTypeFixedValueOff SubscriptionPromotionDiscountType = "FIXED_VALUE_OFF"
)

var AllSubscriptionPromotionDiscountType = []SubscriptionPromotionDiscountType{
	SubscriptionPromotionDiscountTypeNone,
	SubscriptionPromotionDiscountTypePercentOff,
	SubscriptionPromotionDiscountTypeFixedValueOff,
}

func (e SubscriptionPromotionDiscountType) IsValid() bool {
	switch e {
	case SubscriptionPromotionDiscountTypeNone, SubscriptionPromotionDiscountTypePercentOff, SubscriptionPromotionDiscountTypeFixedValueOff:
		return true
	}
	return false
}

func (e SubscriptionPromotionDiscountType) String() string {
	return string(e)
}

func (e *SubscriptionPromotionDiscountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionPromotionDiscountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionPromotionDiscountType", str)
	}
	return nil
}

func (e SubscriptionPromotionDiscountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The various states of the subscription purchase receipt.
type SubscriptionPurchaseState string

const (
	// Active subscription purchase. It could be non-renewing or renewing.
	SubscriptionPurchaseStateActive SubscriptionPurchaseState = "ACTIVE"
	// Cancelled subscription purchase.
	SubscriptionPurchaseStateCancelled SubscriptionPurchaseState = "CANCELLED"
	// Inactive subscription purchase. User's subscription benefit from the original purchase has ended
	// and has not renewed.
	SubscriptionPurchaseStateInactive SubscriptionPurchaseState = "INACTIVE"
)

var AllSubscriptionPurchaseState = []SubscriptionPurchaseState{
	SubscriptionPurchaseStateActive,
	SubscriptionPurchaseStateCancelled,
	SubscriptionPurchaseStateInactive,
}

func (e SubscriptionPurchaseState) IsValid() bool {
	switch e {
	case SubscriptionPurchaseStateActive, SubscriptionPurchaseStateCancelled, SubscriptionPurchaseStateInactive:
		return true
	}
	return false
}

func (e SubscriptionPurchaseState) String() string {
	return string(e)
}

func (e *SubscriptionPurchaseState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionPurchaseState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionPurchaseState", str)
	}
	return nil
}

func (e SubscriptionPurchaseState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The availability state of a subscription product.
type SubscriptionState string

const (
	// Active state.
	SubscriptionStateActive SubscriptionState = "ACTIVE"
	// Inactive state.
	SubscriptionStateInactive SubscriptionState = "INACTIVE"
	// Unknown state.
	SubscriptionStateUnknown SubscriptionState = "UNKNOWN"
)

var AllSubscriptionState = []SubscriptionState{
	SubscriptionStateActive,
	SubscriptionStateInactive,
	SubscriptionStateUnknown,
}

func (e SubscriptionState) IsValid() bool {
	switch e {
	case SubscriptionStateActive, SubscriptionStateInactive, SubscriptionStateUnknown:
		return true
	}
	return false
}

func (e SubscriptionState) String() string {
	return string(e)
}

func (e *SubscriptionState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionState", str)
	}
	return nil
}

func (e SubscriptionState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Tier of subscription.
type SubscriptionSummaryTier string

const (
	// First tier, $4.99 for US market.
	SubscriptionSummaryTierTier1 SubscriptionSummaryTier = "TIER_1"
	// Second tier, $9.99 for US market.
	SubscriptionSummaryTierTier2 SubscriptionSummaryTier = "TIER_2"
	// Third tier, $24.99 for US market.
	SubscriptionSummaryTierTier3 SubscriptionSummaryTier = "TIER_3"
)

var AllSubscriptionSummaryTier = []SubscriptionSummaryTier{
	SubscriptionSummaryTierTier1,
	SubscriptionSummaryTierTier2,
	SubscriptionSummaryTierTier3,
}

func (e SubscriptionSummaryTier) IsValid() bool {
	switch e {
	case SubscriptionSummaryTierTier1, SubscriptionSummaryTierTier2, SubscriptionSummaryTierTier3:
		return true
	}
	return false
}

func (e SubscriptionSummaryTier) String() string {
	return string(e)
}

func (e *SubscriptionSummaryTier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionSummaryTier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionSummaryTier", str)
	}
	return nil
}

func (e SubscriptionSummaryTier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A type of tenure to a subscription product.
type SubscriptionTenureMethod string

const (
	// Tenure data calculated cumulatively.
	SubscriptionTenureMethodCumulative SubscriptionTenureMethod = "CUMULATIVE"
	// Tenure data calculated streak-based.
	SubscriptionTenureMethodStreak SubscriptionTenureMethod = "STREAK"
)

var AllSubscriptionTenureMethod = []SubscriptionTenureMethod{
	SubscriptionTenureMethodCumulative,
	SubscriptionTenureMethodStreak,
}

func (e SubscriptionTenureMethod) IsValid() bool {
	switch e {
	case SubscriptionTenureMethodCumulative, SubscriptionTenureMethodStreak:
		return true
	}
	return false
}

func (e SubscriptionTenureMethod) String() string {
	return string(e)
}

func (e *SubscriptionTenureMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionTenureMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionTenureMethod", str)
	}
	return nil
}

func (e SubscriptionTenureMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A channel could have multiple subscription products at varying tiers.
// Each value will always map to the respective tier for every channel that has the given tier available as a product.
//
// Example:
// A channel with a "tier 2" subscription product will always have the tier represented as T_2000.
type SubscriptionTier string

const (
	// Custom tier.
	SubscriptionTierCustom SubscriptionTier = "CUSTOM"
	// Subscribed with Twitch Prime.
	SubscriptionTierPrime SubscriptionTier = "PRIME"
	// Tier "1000".
	SubscriptionTierT1000 SubscriptionTier = "T_1000"
	// Tier "2000".
	SubscriptionTierT2000 SubscriptionTier = "T_2000"
	// Tier "3000".
	SubscriptionTierT3000 SubscriptionTier = "T_3000"
)

var AllSubscriptionTier = []SubscriptionTier{
	SubscriptionTierCustom,
	SubscriptionTierPrime,
	SubscriptionTierT1000,
	SubscriptionTierT2000,
	SubscriptionTierT3000,
}

func (e SubscriptionTier) IsValid() bool {
	switch e {
	case SubscriptionTierCustom, SubscriptionTierPrime, SubscriptionTierT1000, SubscriptionTierT2000, SubscriptionTierT3000:
		return true
	}
	return false
}

func (e SubscriptionTier) String() string {
	return string(e)
}

func (e *SubscriptionTier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionTier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionTier", str)
	}
	return nil
}

func (e SubscriptionTier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration on the different scope of a tag.
type TagScope string

const (
	// Tags that can be applied to all content types.
	TagScopeAll TagScope = "ALL"
	// Tags that can only be applied to the CATEGORY content type.
	TagScopeCategory TagScope = "CATEGORY"
)

var AllTagScope = []TagScope{
	TagScopeAll,
	TagScopeCategory,
}

func (e TagScope) IsValid() bool {
	switch e {
	case TagScopeAll, TagScopeCategory:
		return true
	}
	return false
}

func (e TagScope) String() string {
	return string(e)
}

func (e *TagScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagScope", str)
	}
	return nil
}

func (e TagScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration on the different tag types of a category.
type TagType string

const (
	// Tags applied to the category.
	TagTypeContent TagType = "CONTENT"
	// The most popular tags used by other channels streaming this game/category.
	TagTypeTop TagType = "TOP"
)

var AllTagType = []TagType{
	TagTypeContent,
	TagTypeTop,
}

func (e TagType) IsValid() bool {
	switch e {
	case TagTypeContent, TagTypeTop:
		return true
	}
	return false
}

func (e TagType) String() string {
	return string(e)
}

func (e *TagType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagType", str)
	}
	return nil
}

func (e TagType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// TaxInterviewType enumerates valid Amazon tax interview types.
type TaxInterviewType string

const (
	// Describes an Amazon tax interview that would allow users to receive royalty income through licensed content.
	TaxInterviewTypeRoyalty TaxInterviewType = "ROYALTY"
	// Describes an Amazon tax interview that would allow users to receive income for their goods and services.
	TaxInterviewTypeService TaxInterviewType = "SERVICE"
)

var AllTaxInterviewType = []TaxInterviewType{
	TaxInterviewTypeRoyalty,
	TaxInterviewTypeService,
}

func (e TaxInterviewType) IsValid() bool {
	switch e {
	case TaxInterviewTypeRoyalty, TaxInterviewTypeService:
		return true
	}
	return false
}

func (e TaxInterviewType) String() string {
	return string(e)
}

func (e *TaxInterviewType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaxInterviewType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaxInterviewType", str)
	}
	return nil
}

func (e TaxInterviewType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// TaxMismatchError enumerates valid registration and tax interview field names for payout onboarding.
type TaxMismatchError string

const (
	// Applied when the user submits a name that does not match the name on their registration.
	// If provided, the company name will be compared intead of the user's full legal name.
	TaxMismatchErrorName TaxMismatchError = "NAME"
	// Applied when the user submits a country that does not match the country on their registration.
	TaxMismatchErrorCountry TaxMismatchError = "COUNTRY"
	// Applied when the user submits an email that does not match the email on their registration.
	TaxMismatchErrorEmail TaxMismatchError = "EMAIL"
	// Applied when the user submits a street address that does not match the street address on their registration.
	TaxMismatchErrorStreetAddress TaxMismatchError = "STREET_ADDRESS"
	// Applied when the user submits a street address 2 that does not match the street address 2 on their registration.
	TaxMismatchErrorStreetAddress2 TaxMismatchError = "STREET_ADDRESS_2"
	// Applied when the user submits a city that does not match the city on their registration.
	TaxMismatchErrorCity TaxMismatchError = "CITY"
	// Applied when the user submits a state that does not match the state on their registration.
	TaxMismatchErrorState TaxMismatchError = "STATE"
	// Applied when the user submits a postal that does not match the postal on their registration.
	TaxMismatchErrorPostal TaxMismatchError = "POSTAL"
)

var AllTaxMismatchError = []TaxMismatchError{
	TaxMismatchErrorName,
	TaxMismatchErrorCountry,
	TaxMismatchErrorEmail,
	TaxMismatchErrorStreetAddress,
	TaxMismatchErrorStreetAddress2,
	TaxMismatchErrorCity,
	TaxMismatchErrorState,
	TaxMismatchErrorPostal,
}

func (e TaxMismatchError) IsValid() bool {
	switch e {
	case TaxMismatchErrorName, TaxMismatchErrorCountry, TaxMismatchErrorEmail, TaxMismatchErrorStreetAddress, TaxMismatchErrorStreetAddress2, TaxMismatchErrorCity, TaxMismatchErrorState, TaxMismatchErrorPostal:
		return true
	}
	return false
}

func (e TaxMismatchError) String() string {
	return string(e)
}

func (e *TaxMismatchError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaxMismatchError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaxMismatchError", str)
	}
	return nil
}

func (e TaxMismatchError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible labels for extra points awarded to resolve ties.
type TiebreakerLabel string

const (
	// Tiebreaker Points are awarded for a kill, useful in BR games.
	TiebreakerLabelKills TiebreakerLabel = "KILLS"
	// Tiebreaker Points are a generic bonus field determined by the CO.
	TiebreakerLabelBonus TiebreakerLabel = "BONUS"
	// An unknown label was provided.
	TiebreakerLabelUnknown TiebreakerLabel = "UNKNOWN"
)

var AllTiebreakerLabel = []TiebreakerLabel{
	TiebreakerLabelKills,
	TiebreakerLabelBonus,
	TiebreakerLabelUnknown,
}

func (e TiebreakerLabel) IsValid() bool {
	switch e {
	case TiebreakerLabelKills, TiebreakerLabelBonus, TiebreakerLabelUnknown:
		return true
	}
	return false
}

func (e TiebreakerLabel) String() string {
	return string(e)
}

func (e *TiebreakerLabel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TiebreakerLabel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TiebreakerLabel", str)
	}
	return nil
}

func (e TiebreakerLabel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The subcount series is able to display each datapoint according to the following durations.
type TimeSeriesPeriod string

const (
	// Period of one day per datapoint.
	TimeSeriesPeriodDay TimeSeriesPeriod = "DAY"
	// Period of one month per datapoint.
	TimeSeriesPeriodMonth TimeSeriesPeriod = "MONTH"
)

var AllTimeSeriesPeriod = []TimeSeriesPeriod{
	TimeSeriesPeriodDay,
	TimeSeriesPeriodMonth,
}

func (e TimeSeriesPeriod) IsValid() bool {
	switch e {
	case TimeSeriesPeriodDay, TimeSeriesPeriodMonth:
		return true
	}
	return false
}

func (e TimeSeriesPeriod) String() string {
	return string(e)
}

func (e *TimeSeriesPeriod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeSeriesPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeSeriesPeriod", str)
	}
	return nil
}

func (e TimeSeriesPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the tracking pixel.
type TrackingPixelType string

const (
	// Digital Ad Ratings, a Nielsen product that provides demographic data.
	TrackingPixelTypeDar TrackingPixelType = "DAR"
	// DoubleClick Campaign Manager, a Google product to track ad performance.
	TrackingPixelTypeDcm TrackingPixelType = "DCM"
	// An impression tracking product.
	TrackingPixelTypeSizmek TrackingPixelType = "SIZMEK"
)

var AllTrackingPixelType = []TrackingPixelType{
	TrackingPixelTypeDar,
	TrackingPixelTypeDcm,
	TrackingPixelTypeSizmek,
}

func (e TrackingPixelType) IsValid() bool {
	switch e {
	case TrackingPixelTypeDar, TrackingPixelTypeDcm, TrackingPixelTypeSizmek:
		return true
	}
	return false
}

func (e TrackingPixelType) String() string {
	return string(e)
}

func (e *TrackingPixelType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrackingPixelType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrackingPixelType", str)
	}
	return nil
}

func (e TrackingPixelType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// TransitionExtensionStateError is an error associated with the transitionExtensionState mutation.
type TransitionExtensionStateError string

const (
	// User is unable to make modifications to the extension.
	TransitionExtensionStateErrorUnauthorized TransitionExtensionStateError = "UNAUTHORIZED"
	// The version does not have an asset hash and it must for the transition.
	TransitionExtensionStateErrorMissingAssetHash TransitionExtensionStateError = "MISSING_ASSET_HASH"
	// Review notes were not specified when transitioning an extension to IN_REVIEW.
	TransitionExtensionStateErrorMissingReviewNotes TransitionExtensionStateError = "MISSING_REVIEW_NOTES"
	// Test channel was not specified when transitioning an extension to IN_REVIEW.
	TransitionExtensionStateErrorMissingTestChannel TransitionExtensionStateError = "MISSING_TEST_CHANNEL"
	// Only one version of an Extension can be in a review state (APPROVED, or in IN_REVIEW) at a time.
	TransitionExtensionStateErrorMultipleVersionsInReview TransitionExtensionStateError = "MULTIPLE_VERSIONS_IN_REVIEW"
	// Author email cannot be empty when transit to READY_FOR_REVIEW.
	TransitionExtensionStateErrorTransitionMissingAuthorEmail TransitionExtensionStateError = "TRANSITION_MISSING_AUTHOR_EMAIL"
	// Author name cannot be empty when transit to READY_FOR_REVIEW.
	TransitionExtensionStateErrorTransitionMissingAuthorName TransitionExtensionStateError = "TRANSITION_MISSING_AUTHOR_NAME"
	// Category cannot be empty when transit to READY_FOR_REVIEW.
	TransitionExtensionStateErrorTransitionMissingCategory TransitionExtensionStateError = "TRANSITION_MISSING_CATEGORY"
	// Support email cannot be empty when transit to READY_FOR_REVIEW.
	TransitionExtensionStateErrorTransitionMissingSupportEmail TransitionExtensionStateError = "TRANSITION_MISSING_SUPPORT_EMAIL"
	// Name cannot be empty when transit to READY_FOR_REVIEW.
	TransitionExtensionStateErrorTransitionMissingName TransitionExtensionStateError = "TRANSITION_MISSING_NAME"
	// Version cannot be empty when transit to READY_FOR_REVIEW.
	TransitionExtensionStateErrorTransitionMissingVersion TransitionExtensionStateError = "TRANSITION_MISSING_VERSION"
	// Testing base URI cannot be empty when transit to READY_FOR_REVIEW.
	TransitionExtensionStateErrorTransitionMissingTestingBaseURI TransitionExtensionStateError = "TRANSITION_MISSING_TESTING_BASE_URI"
	// Summary cannot be empty when transit to READY_FOR_REVIEW.
	TransitionExtensionStateErrorTransitionMissingSummary TransitionExtensionStateError = "TRANSITION_MISSING_SUMMARY"
	// Description cannot be empty when transit to READY_FOR_REVIEW.
	TransitionExtensionStateErrorTransitionMissingDescription TransitionExtensionStateError = "TRANSITION_MISSING_DESCRIPTION"
	// Screenshot URLs cannot be empy when transit to READY_FOR_REVIEW.
	TransitionExtensionStateErrorTransitionMissingScreenshotURLS TransitionExtensionStateError = "TRANSITION_MISSING_SCREENSHOT_URLS"
	// Invalid state transition.
	TransitionExtensionStateErrorInvalidStateTransition TransitionExtensionStateError = "INVALID_STATE_TRANSITION"
	// Version specified is invalid.
	TransitionExtensionStateErrorInvalidVersion TransitionExtensionStateError = "INVALID_VERSION"
	// At least one anchor must be specified.
	TransitionExtensionStateErrorAnchorRequired TransitionExtensionStateError = "ANCHOR_REQUIRED"
	// HasZoom was specified but ZoomPixels is missing.
	TransitionExtensionStateErrorInvalidZoom TransitionExtensionStateError = "INVALID_ZOOM"
	// The number of whitelisted broadcasters exceeds the limit.
	TransitionExtensionStateErrorMaxBroadcasters TransitionExtensionStateError = "MAX_BROADCASTERS"
	// The number of whitelisted testing users exceeds the limit.
	TransitionExtensionStateErrorMaxTesters TransitionExtensionStateError = "MAX_TESTERS"
	// The number of whitelisted config URLs exceeds the limit.
	TransitionExtensionStateErrorMaxWhitelistedConfigURLS TransitionExtensionStateError = "MAX_WHITELISTED_CONFIG_URLS"
	// The number of whitelisted panel URLs exceeds the limit.
	TransitionExtensionStateErrorMaxWhitelistedPanelURLS TransitionExtensionStateError = "MAX_WHITELISTED_PANEL_URLS"
	// Extension names must be shorter than 40 characters.
	TransitionExtensionStateErrorInvalidNameLength TransitionExtensionStateError = "INVALID_NAME_LENGTH"
	// Extension description must be shorter than 1024 characters.
	TransitionExtensionStateErrorInvalidDescriptionLength TransitionExtensionStateError = "INVALID_DESCRIPTION_LENGTH"
	// Extension summary must be shorter than 140 characters.
	TransitionExtensionStateErrorInvalidSummaryLength TransitionExtensionStateError = "INVALID_SUMMARY_LENGTH"
	// Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
	TransitionExtensionStateErrorInvalidAuthorEmail TransitionExtensionStateError = "INVALID_AUTHOR_EMAIL"
	// Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
	TransitionExtensionStateErrorInvalidSupportEmail TransitionExtensionStateError = "INVALID_SUPPORT_EMAIL"
	// Extension author name length must be > 40.
	TransitionExtensionStateErrorInvalidAuthorNameLength TransitionExtensionStateError = "INVALID_AUTHOR_NAME_LENGTH"
	// Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
	TransitionExtensionStateErrorInvalidTestingBaseURI TransitionExtensionStateError = "INVALID_TESTING_BASE_URI"
	// Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
	TransitionExtensionStateErrorInvalidTermsURI TransitionExtensionStateError = "INVALID_TERMS_URI"
	// Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
	TransitionExtensionStateErrorInvalidPrivacyURI TransitionExtensionStateError = "INVALID_PRIVACY_URI"
	// Extension component viewer path must not be nil. Format should be BaseUri/Extension_Path.
	TransitionExtensionStateErrorInvalidComponentViewerPath TransitionExtensionStateError = "INVALID_COMPONENT_VIEWER_PATH"
	// Extension panel viewer path must not be nil. Format should be BaseUri/Extension_Path.
	TransitionExtensionStateErrorInvalidPanelViewerPath TransitionExtensionStateError = "INVALID_PANEL_VIEWER_PATH"
	// Extension video overlay viewer path must not be nil. Format should be BaseUri/Extension_Path.
	TransitionExtensionStateErrorInvalidVideoOverlayViewerPath TransitionExtensionStateError = "INVALID_VIDEO_OVERLAY_VIEWER_PATH"
	// Extension config viewer path must not be nil. Format should be BaseUri/Extension_Path.
	TransitionExtensionStateErrorInvalidConfigViewerPath TransitionExtensionStateError = "INVALID_CONFIG_VIEWER_PATH"
	// Extension live config viewer path must not be nil. Format should be BaseUri/Extension_Path.
	TransitionExtensionStateErrorInvalidLiveConfigViewerPath TransitionExtensionStateError = "INVALID_LIVE_CONFIG_VIEWER_PATH"
	// Extension mobile viewer path must not be nil. Format should be BaseUri/Extension_Path.
	TransitionExtensionStateErrorInvalidMobileViewerPath TransitionExtensionStateError = "INVALID_MOBILE_VIEWER_PATH"
	// Extension component aspect width must be < 50 or > 1.
	TransitionExtensionStateErrorInvalidComponentAspectWidth TransitionExtensionStateError = "INVALID_COMPONENT_ASPECT_WIDTH"
	// Extension component aspect height must be < 50 or > 1.
	TransitionExtensionStateErrorInvalidComponentAspectHeight TransitionExtensionStateError = "INVALID_COMPONENT_ASPECT_HEIGHT"
	// Extension panel hiehgt must be < 500 or > 100.
	TransitionExtensionStateErrorInvalidPanelHeight TransitionExtensionStateError = "INVALID_PANEL_HEIGHT"
	// Extension Bits Support Level must ba valid member of the BitsSupportLevelEnum.
	TransitionExtensionStateErrorInvalidBitsSupportLevel TransitionExtensionStateError = "INVALID_BITS_SUPPORT_LEVEL"
	// Scale pixels must be set to a positive integer when autoscale is true.
	TransitionExtensionStateErrorInvalidScalingPixels TransitionExtensionStateError = "INVALID_SCALING_PIXELS"
	// Aspect Ratio X must be set to a positive integer.
	TransitionExtensionStateErrorInvalidComponentAspectRatioX TransitionExtensionStateError = "INVALID_COMPONENT_ASPECT_RATIO_X"
	// Aspect Ratio Y must be set to a positive integer.
	TransitionExtensionStateErrorInvalidComponentAspectRatioY TransitionExtensionStateError = "INVALID_COMPONENT_ASPECT_RATIO_Y"
	// Target Height must be set to a positve integer.
	TransitionExtensionStateErrorInvalidComponentTargetHeight TransitionExtensionStateError = "INVALID_COMPONENT_TARGET_HEIGHT"
)

var AllTransitionExtensionStateError = []TransitionExtensionStateError{
	TransitionExtensionStateErrorUnauthorized,
	TransitionExtensionStateErrorMissingAssetHash,
	TransitionExtensionStateErrorMissingReviewNotes,
	TransitionExtensionStateErrorMissingTestChannel,
	TransitionExtensionStateErrorMultipleVersionsInReview,
	TransitionExtensionStateErrorTransitionMissingAuthorEmail,
	TransitionExtensionStateErrorTransitionMissingAuthorName,
	TransitionExtensionStateErrorTransitionMissingCategory,
	TransitionExtensionStateErrorTransitionMissingSupportEmail,
	TransitionExtensionStateErrorTransitionMissingName,
	TransitionExtensionStateErrorTransitionMissingVersion,
	TransitionExtensionStateErrorTransitionMissingTestingBaseURI,
	TransitionExtensionStateErrorTransitionMissingSummary,
	TransitionExtensionStateErrorTransitionMissingDescription,
	TransitionExtensionStateErrorTransitionMissingScreenshotURLS,
	TransitionExtensionStateErrorInvalidStateTransition,
	TransitionExtensionStateErrorInvalidVersion,
	TransitionExtensionStateErrorAnchorRequired,
	TransitionExtensionStateErrorInvalidZoom,
	TransitionExtensionStateErrorMaxBroadcasters,
	TransitionExtensionStateErrorMaxTesters,
	TransitionExtensionStateErrorMaxWhitelistedConfigURLS,
	TransitionExtensionStateErrorMaxWhitelistedPanelURLS,
	TransitionExtensionStateErrorInvalidNameLength,
	TransitionExtensionStateErrorInvalidDescriptionLength,
	TransitionExtensionStateErrorInvalidSummaryLength,
	TransitionExtensionStateErrorInvalidAuthorEmail,
	TransitionExtensionStateErrorInvalidSupportEmail,
	TransitionExtensionStateErrorInvalidAuthorNameLength,
	TransitionExtensionStateErrorInvalidTestingBaseURI,
	TransitionExtensionStateErrorInvalidTermsURI,
	TransitionExtensionStateErrorInvalidPrivacyURI,
	TransitionExtensionStateErrorInvalidComponentViewerPath,
	TransitionExtensionStateErrorInvalidPanelViewerPath,
	TransitionExtensionStateErrorInvalidVideoOverlayViewerPath,
	TransitionExtensionStateErrorInvalidConfigViewerPath,
	TransitionExtensionStateErrorInvalidLiveConfigViewerPath,
	TransitionExtensionStateErrorInvalidMobileViewerPath,
	TransitionExtensionStateErrorInvalidComponentAspectWidth,
	TransitionExtensionStateErrorInvalidComponentAspectHeight,
	TransitionExtensionStateErrorInvalidPanelHeight,
	TransitionExtensionStateErrorInvalidBitsSupportLevel,
	TransitionExtensionStateErrorInvalidScalingPixels,
	TransitionExtensionStateErrorInvalidComponentAspectRatioX,
	TransitionExtensionStateErrorInvalidComponentAspectRatioY,
	TransitionExtensionStateErrorInvalidComponentTargetHeight,
}

func (e TransitionExtensionStateError) IsValid() bool {
	switch e {
	case TransitionExtensionStateErrorUnauthorized, TransitionExtensionStateErrorMissingAssetHash, TransitionExtensionStateErrorMissingReviewNotes, TransitionExtensionStateErrorMissingTestChannel, TransitionExtensionStateErrorMultipleVersionsInReview, TransitionExtensionStateErrorTransitionMissingAuthorEmail, TransitionExtensionStateErrorTransitionMissingAuthorName, TransitionExtensionStateErrorTransitionMissingCategory, TransitionExtensionStateErrorTransitionMissingSupportEmail, TransitionExtensionStateErrorTransitionMissingName, TransitionExtensionStateErrorTransitionMissingVersion, TransitionExtensionStateErrorTransitionMissingTestingBaseURI, TransitionExtensionStateErrorTransitionMissingSummary, TransitionExtensionStateErrorTransitionMissingDescription, TransitionExtensionStateErrorTransitionMissingScreenshotURLS, TransitionExtensionStateErrorInvalidStateTransition, TransitionExtensionStateErrorInvalidVersion, TransitionExtensionStateErrorAnchorRequired, TransitionExtensionStateErrorInvalidZoom, TransitionExtensionStateErrorMaxBroadcasters, TransitionExtensionStateErrorMaxTesters, TransitionExtensionStateErrorMaxWhitelistedConfigURLS, TransitionExtensionStateErrorMaxWhitelistedPanelURLS, TransitionExtensionStateErrorInvalidNameLength, TransitionExtensionStateErrorInvalidDescriptionLength, TransitionExtensionStateErrorInvalidSummaryLength, TransitionExtensionStateErrorInvalidAuthorEmail, TransitionExtensionStateErrorInvalidSupportEmail, TransitionExtensionStateErrorInvalidAuthorNameLength, TransitionExtensionStateErrorInvalidTestingBaseURI, TransitionExtensionStateErrorInvalidTermsURI, TransitionExtensionStateErrorInvalidPrivacyURI, TransitionExtensionStateErrorInvalidComponentViewerPath, TransitionExtensionStateErrorInvalidPanelViewerPath, TransitionExtensionStateErrorInvalidVideoOverlayViewerPath, TransitionExtensionStateErrorInvalidConfigViewerPath, TransitionExtensionStateErrorInvalidLiveConfigViewerPath, TransitionExtensionStateErrorInvalidMobileViewerPath, TransitionExtensionStateErrorInvalidComponentAspectWidth, TransitionExtensionStateErrorInvalidComponentAspectHeight, TransitionExtensionStateErrorInvalidPanelHeight, TransitionExtensionStateErrorInvalidBitsSupportLevel, TransitionExtensionStateErrorInvalidScalingPixels, TransitionExtensionStateErrorInvalidComponentAspectRatioX, TransitionExtensionStateErrorInvalidComponentAspectRatioY, TransitionExtensionStateErrorInvalidComponentTargetHeight:
		return true
	}
	return false
}

func (e TransitionExtensionStateError) String() string {
	return string(e)
}

func (e *TransitionExtensionStateError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransitionExtensionStateError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransitionExtensionStateError", str)
	}
	return nil
}

func (e TransitionExtensionStateError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Trigger type determines what type of events activate the trigger.
type TriggerType string

const (
	// CHEER type trigger is activated by cheer events.
	TriggerTypeCheer TriggerType = "CHEER"
)

var AllTriggerType = []TriggerType{
	TriggerTypeCheer,
}

func (e TriggerType) IsValid() bool {
	switch e {
	case TriggerTypeCheer:
		return true
	}
	return false
}

func (e TriggerType) String() string {
	return string(e)
}

func (e *TriggerType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TriggerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TriggerType", str)
	}
	return nil
}

func (e TriggerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// TutorialState represents the possible states of the user's viewing of the mod view tutorial.
type TutorialState string

const (
	// DISMISSED occurs when a user dismisses the tutorial.
	TutorialStateDismissed TutorialState = "DISMISSED"
	// SEEN occurs when a user has seen every step in a tutorial.
	TutorialStateSeen TutorialState = "SEEN"
	// UNSEEN is the initial state, before a user has either dismissed or viewed the tutorial entirely.
	TutorialStateUnseen TutorialState = "UNSEEN"
)

var AllTutorialState = []TutorialState{
	TutorialStateDismissed,
	TutorialStateSeen,
	TutorialStateUnseen,
}

func (e TutorialState) IsValid() bool {
	switch e {
	case TutorialStateDismissed, TutorialStateSeen, TutorialStateUnseen:
		return true
	}
	return false
}

func (e TutorialState) String() string {
	return string(e)
}

func (e *TutorialState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TutorialState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TutorialState", str)
	}
	return nil
}

func (e TutorialState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Two Factor Methods the user can have enabled.
type TwoFactorMethod string

const (
	// The user has 2fa enabled but does not have the authy app installed. Only way for the user to receive the 2fa verification code is SMS.
	TwoFactorMethodAuthySms TwoFactorMethod = "AUTHY_SMS"
	// The user has 2fa enabled and has the authy app installed. The 2fa verification code can be retreived from the authy app OR SMS.
	TwoFactorMethodAuthyApp TwoFactorMethod = "AUTHY_APP"
	// The user has 2fa enabled and has gone through the totp onboarding process successfully. The 2fa verification code can be retreived from the authenticator app the user chose during onboarding.
	TwoFactorMethodAuthyTotp TwoFactorMethod = "AUTHY_TOTP"
	// unknown 2fa method.
	TwoFactorMethodUnknown TwoFactorMethod = "UNKNOWN"
)

var AllTwoFactorMethod = []TwoFactorMethod{
	TwoFactorMethodAuthySms,
	TwoFactorMethodAuthyApp,
	TwoFactorMethodAuthyTotp,
	TwoFactorMethodUnknown,
}

func (e TwoFactorMethod) IsValid() bool {
	switch e {
	case TwoFactorMethodAuthySms, TwoFactorMethodAuthyApp, TwoFactorMethodAuthyTotp, TwoFactorMethodUnknown:
		return true
	}
	return false
}

func (e TwoFactorMethod) String() string {
	return string(e)
}

func (e *TwoFactorMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TwoFactorMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TwoFactorMethod", str)
	}
	return nil
}

func (e TwoFactorMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Subscrption state of the reported unacknowledged events.
type UnacknowledgedSubscriptionEventState string

const (
	// The subscription is active.
	UnacknowledgedSubscriptionEventStateActive UnacknowledgedSubscriptionEventState = "ACTIVE"
	// Subscription will not renew, but may still be active.
	UnacknowledgedSubscriptionEventStateWillNotRenew UnacknowledgedSubscriptionEventState = "WILL_NOT_RENEW"
	// Subscription will not renew and is not active.
	UnacknowledgedSubscriptionEventStateCancelled UnacknowledgedSubscriptionEventState = "CANCELLED"
	// Subscription that is on hold.
	UnacknowledgedSubscriptionEventStateOnHold UnacknowledgedSubscriptionEventState = "ON_HOLD"
)

var AllUnacknowledgedSubscriptionEventState = []UnacknowledgedSubscriptionEventState{
	UnacknowledgedSubscriptionEventStateActive,
	UnacknowledgedSubscriptionEventStateWillNotRenew,
	UnacknowledgedSubscriptionEventStateCancelled,
	UnacknowledgedSubscriptionEventStateOnHold,
}

func (e UnacknowledgedSubscriptionEventState) IsValid() bool {
	switch e {
	case UnacknowledgedSubscriptionEventStateActive, UnacknowledgedSubscriptionEventStateWillNotRenew, UnacknowledgedSubscriptionEventStateCancelled, UnacknowledgedSubscriptionEventStateOnHold:
		return true
	}
	return false
}

func (e UnacknowledgedSubscriptionEventState) String() string {
	return string(e)
}

func (e *UnacknowledgedSubscriptionEventState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnacknowledgedSubscriptionEventState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnacknowledgedSubscriptionEventState", str)
	}
	return nil
}

func (e UnacknowledgedSubscriptionEventState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible errors arising from an update unban request mutation.
type UnbanRequestErrorCode string

const (
	// User does not have the permissions required to update the Unban Request.
	UnbanRequestErrorCodeUnauthorized UnbanRequestErrorCode = "UNAUTHORIZED"
	// Unban Request was not found.
	UnbanRequestErrorCodeRequestNotFound UnbanRequestErrorCode = "REQUEST_NOT_FOUND"
	// Attempted status update was not valid.
	UnbanRequestErrorCodeInvalidUpdate UnbanRequestErrorCode = "INVALID_UPDATE"
	// Unknown error.
	UnbanRequestErrorCodeUnknown UnbanRequestErrorCode = "UNKNOWN"
)

var AllUnbanRequestErrorCode = []UnbanRequestErrorCode{
	UnbanRequestErrorCodeUnauthorized,
	UnbanRequestErrorCodeRequestNotFound,
	UnbanRequestErrorCodeInvalidUpdate,
	UnbanRequestErrorCodeUnknown,
}

func (e UnbanRequestErrorCode) IsValid() bool {
	switch e {
	case UnbanRequestErrorCodeUnauthorized, UnbanRequestErrorCodeRequestNotFound, UnbanRequestErrorCodeInvalidUpdate, UnbanRequestErrorCodeUnknown:
		return true
	}
	return false
}

func (e UnbanRequestErrorCode) String() string {
	return string(e)
}

func (e *UnbanRequestErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnbanRequestErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnbanRequestErrorCode", str)
	}
	return nil
}

func (e UnbanRequestErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reasons why a user may be restricted from requesting an unban.
type UnbanRequestRestrictionReason string

const (
	// User has already created an unban request for the current ban.
	UnbanRequestRestrictionReasonAlreadyCreated UnbanRequestRestrictionReason = "ALREADY_CREATED"
	// User is not banned on the channel.
	UnbanRequestRestrictionReasonNotBanned UnbanRequestRestrictionReason = "NOT_BANNED"
	// User is attempting to create a request too since their ban. Must wait for cooldown period to end.
	UnbanRequestRestrictionReasonTooSoonSinceBan UnbanRequestRestrictionReason = "TOO_SOON_SINCE_BAN"
	// Channel is not receiving unban requests.
	UnbanRequestRestrictionReasonUnbanRequestsDisabled UnbanRequestRestrictionReason = "UNBAN_REQUESTS_DISABLED"
	// User must be logged in to be able to request an unban.
	UnbanRequestRestrictionReasonUnauthenticated UnbanRequestRestrictionReason = "UNAUTHENTICATED"
	// Unknown restricted reason.
	UnbanRequestRestrictionReasonUnknown UnbanRequestRestrictionReason = "UNKNOWN"
)

var AllUnbanRequestRestrictionReason = []UnbanRequestRestrictionReason{
	UnbanRequestRestrictionReasonAlreadyCreated,
	UnbanRequestRestrictionReasonNotBanned,
	UnbanRequestRestrictionReasonTooSoonSinceBan,
	UnbanRequestRestrictionReasonUnbanRequestsDisabled,
	UnbanRequestRestrictionReasonUnauthenticated,
	UnbanRequestRestrictionReasonUnknown,
}

func (e UnbanRequestRestrictionReason) IsValid() bool {
	switch e {
	case UnbanRequestRestrictionReasonAlreadyCreated, UnbanRequestRestrictionReasonNotBanned, UnbanRequestRestrictionReasonTooSoonSinceBan, UnbanRequestRestrictionReasonUnbanRequestsDisabled, UnbanRequestRestrictionReasonUnauthenticated, UnbanRequestRestrictionReasonUnknown:
		return true
	}
	return false
}

func (e UnbanRequestRestrictionReason) String() string {
	return string(e)
}

func (e *UnbanRequestRestrictionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnbanRequestRestrictionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnbanRequestRestrictionReason", str)
	}
	return nil
}

func (e UnbanRequestRestrictionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible statuses of an unban request.
type UnbanRequestStatus string

const (
	// Default status. Is an invalid status state. Used as zero value when no specific status is specified.
	UnbanRequestStatusNone UnbanRequestStatus = "NONE"
	// Approved; user is unbanned from the channel.
	UnbanRequestStatusApproved UnbanRequestStatus = "APPROVED"
	// User's unban request is denied; user remains banned in the channel.
	UnbanRequestStatusDenied UnbanRequestStatus = "DENIED"
	// A moderator decision has not been made on the Unban Request.
	UnbanRequestStatusPending UnbanRequestStatus = "PENDING"
	// The user has had their unban request approved, and has acknowledged
	// the rules on the channel.
	UnbanRequestStatusAcknowledged UnbanRequestStatus = "ACKNOWLEDGED"
	// The user has canceled their unban request.
	UnbanRequestStatusCanceled UnbanRequestStatus = "CANCELED"
)

var AllUnbanRequestStatus = []UnbanRequestStatus{
	UnbanRequestStatusNone,
	UnbanRequestStatusApproved,
	UnbanRequestStatusDenied,
	UnbanRequestStatusPending,
	UnbanRequestStatusAcknowledged,
	UnbanRequestStatusCanceled,
}

func (e UnbanRequestStatus) IsValid() bool {
	switch e {
	case UnbanRequestStatusNone, UnbanRequestStatusApproved, UnbanRequestStatusDenied, UnbanRequestStatusPending, UnbanRequestStatusAcknowledged, UnbanRequestStatusCanceled:
		return true
	}
	return false
}

func (e UnbanRequestStatus) String() string {
	return string(e)
}

func (e *UnbanRequestStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnbanRequestStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnbanRequestStatus", str)
	}
	return nil
}

func (e UnbanRequestStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Ways to sort Unban Requests.
type UnbanRequestsSortOrder string

const (
	// The oldest request first.
	UnbanRequestsSortOrderOldest UnbanRequestsSortOrder = "OLDEST"
	// The newest request first.
	UnbanRequestsSortOrderNewest UnbanRequestsSortOrder = "NEWEST"
)

var AllUnbanRequestsSortOrder = []UnbanRequestsSortOrder{
	UnbanRequestsSortOrderOldest,
	UnbanRequestsSortOrderNewest,
}

func (e UnbanRequestsSortOrder) IsValid() bool {
	switch e {
	case UnbanRequestsSortOrderOldest, UnbanRequestsSortOrderNewest:
		return true
	}
	return false
}

func (e UnbanRequestsSortOrder) String() string {
	return string(e)
}

func (e *UnbanRequestsSortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnbanRequestsSortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnbanRequestsSortOrder", str)
	}
	return nil
}

func (e UnbanRequestsSortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UnbanUserFromChatRoomErrorCode string

const (
	// User does not have permission to unban in channel.
	UnbanUserFromChatRoomErrorCodeForbidden UnbanUserFromChatRoomErrorCode = "FORBIDDEN"
	// Target does not exist.
	UnbanUserFromChatRoomErrorCodeTargetNotFound UnbanUserFromChatRoomErrorCode = "TARGET_NOT_FOUND"
	// Target is not banned in channel.
	UnbanUserFromChatRoomErrorCodeTargetNotBanned UnbanUserFromChatRoomErrorCode = "TARGET_NOT_BANNED"
)

var AllUnbanUserFromChatRoomErrorCode = []UnbanUserFromChatRoomErrorCode{
	UnbanUserFromChatRoomErrorCodeForbidden,
	UnbanUserFromChatRoomErrorCodeTargetNotFound,
	UnbanUserFromChatRoomErrorCodeTargetNotBanned,
}

func (e UnbanUserFromChatRoomErrorCode) IsValid() bool {
	switch e {
	case UnbanUserFromChatRoomErrorCodeForbidden, UnbanUserFromChatRoomErrorCodeTargetNotFound, UnbanUserFromChatRoomErrorCodeTargetNotBanned:
		return true
	}
	return false
}

func (e UnbanUserFromChatRoomErrorCode) String() string {
	return string(e)
}

func (e *UnbanUserFromChatRoomErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnbanUserFromChatRoomErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnbanUserFromChatRoomErrorCode", str)
	}
	return nil
}

func (e UnbanUserFromChatRoomErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// UninstallExtensionErrorCode is an error code associated with UninstallExtensionError.
type UninstallExtensionErrorCode string

const (
	// User is unable to make modifications to the extension.
	UninstallExtensionErrorCodeUnauthorized UninstallExtensionErrorCode = "UNAUTHORIZED"
	// Channel id is invalid, for example, is empty.
	UninstallExtensionErrorCodeInvalidChannelID UninstallExtensionErrorCode = "INVALID_CHANNEL_ID"
	// The extension is not installed on the channel.
	UninstallExtensionErrorCodeExtensionNotInstalled UninstallExtensionErrorCode = "EXTENSION_NOT_INSTALLED"
)

var AllUninstallExtensionErrorCode = []UninstallExtensionErrorCode{
	UninstallExtensionErrorCodeUnauthorized,
	UninstallExtensionErrorCodeInvalidChannelID,
	UninstallExtensionErrorCodeExtensionNotInstalled,
}

func (e UninstallExtensionErrorCode) IsValid() bool {
	switch e {
	case UninstallExtensionErrorCodeUnauthorized, UninstallExtensionErrorCodeInvalidChannelID, UninstallExtensionErrorCodeExtensionNotInstalled:
		return true
	}
	return false
}

func (e UninstallExtensionErrorCode) String() string {
	return string(e)
}

func (e *UninstallExtensionErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UninstallExtensionErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UninstallExtensionErrorCode", str)
	}
	return nil
}

func (e UninstallExtensionErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// UnmodUserErrorCode defines a client error that occurred while remove a moderator.
type UnmodUserErrorCode string

const (
	// The requesting user does not have permission to add a moderator in this channel.
	UnmodUserErrorCodeForbidden UnmodUserErrorCode = "FORBIDDEN"
	// The target user does not exist or has a suspended account.
	UnmodUserErrorCodeTargetNotFound UnmodUserErrorCode = "TARGET_NOT_FOUND"
	// The channel does not exist.
	UnmodUserErrorCodeChannelNotFound UnmodUserErrorCode = "CHANNEL_NOT_FOUND"
	// The target user is not a moderator.
	UnmodUserErrorCodeTargetNotMod UnmodUserErrorCode = "TARGET_NOT_MOD"
)

var AllUnmodUserErrorCode = []UnmodUserErrorCode{
	UnmodUserErrorCodeForbidden,
	UnmodUserErrorCodeTargetNotFound,
	UnmodUserErrorCodeChannelNotFound,
	UnmodUserErrorCodeTargetNotMod,
}

func (e UnmodUserErrorCode) IsValid() bool {
	switch e {
	case UnmodUserErrorCodeForbidden, UnmodUserErrorCodeTargetNotFound, UnmodUserErrorCodeChannelNotFound, UnmodUserErrorCodeTargetNotMod:
		return true
	}
	return false
}

func (e UnmodUserErrorCode) String() string {
	return string(e)
}

func (e *UnmodUserErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnmodUserErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnmodUserErrorCode", str)
	}
	return nil
}

func (e UnmodUserErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes returned for updating bits badges.
type UpdateBitsBadgeTiersErrorCode string

const (
	// Invalid parameters in the request.
	UpdateBitsBadgeTiersErrorCodeInvalidParameter UpdateBitsBadgeTiersErrorCode = "INVALID_PARAMETER"
	// Badge title is too long.
	UpdateBitsBadgeTiersErrorCodeBadgeTitleExceedsCharacterLimit UpdateBitsBadgeTiersErrorCode = "BADGE_TITLE_EXCEEDS_CHARACTER_LIMIT"
	// Badge title did not pass moderation check.
	UpdateBitsBadgeTiersErrorCodeBadgeTitleFailedModeration UpdateBitsBadgeTiersErrorCode = "BADGE_TITLE_FAILED_MODERATION"
	// The emote code submitted collides with an existing emote code.
	UpdateBitsBadgeTiersErrorCodeEmoteCodeAlreadyExists UpdateBitsBadgeTiersErrorCode = "EMOTE_CODE_ALREADY_EXISTS"
	// The emote code submitted is unacceptable (contains offensive, banned, or "bad" words, which violates guidelines).
	UpdateBitsBadgeTiersErrorCodeEmoteCodeUnacceptable UpdateBitsBadgeTiersErrorCode = "EMOTE_CODE_UNACCEPTABLE"
	// Data for least one of the image sizes is not provided.
	UpdateBitsBadgeTiersErrorCodeIncompleteBadgeImageData UpdateBitsBadgeTiersErrorCode = "INCOMPLETE_BADGE_IMAGE_DATA"
	// Other errors returned from the service.
	UpdateBitsBadgeTiersErrorCodeUnknownError UpdateBitsBadgeTiersErrorCode = "UNKNOWN_ERROR"
)

var AllUpdateBitsBadgeTiersErrorCode = []UpdateBitsBadgeTiersErrorCode{
	UpdateBitsBadgeTiersErrorCodeInvalidParameter,
	UpdateBitsBadgeTiersErrorCodeBadgeTitleExceedsCharacterLimit,
	UpdateBitsBadgeTiersErrorCodeBadgeTitleFailedModeration,
	UpdateBitsBadgeTiersErrorCodeEmoteCodeAlreadyExists,
	UpdateBitsBadgeTiersErrorCodeEmoteCodeUnacceptable,
	UpdateBitsBadgeTiersErrorCodeIncompleteBadgeImageData,
	UpdateBitsBadgeTiersErrorCodeUnknownError,
}

func (e UpdateBitsBadgeTiersErrorCode) IsValid() bool {
	switch e {
	case UpdateBitsBadgeTiersErrorCodeInvalidParameter, UpdateBitsBadgeTiersErrorCodeBadgeTitleExceedsCharacterLimit, UpdateBitsBadgeTiersErrorCodeBadgeTitleFailedModeration, UpdateBitsBadgeTiersErrorCodeEmoteCodeAlreadyExists, UpdateBitsBadgeTiersErrorCodeEmoteCodeUnacceptable, UpdateBitsBadgeTiersErrorCodeIncompleteBadgeImageData, UpdateBitsBadgeTiersErrorCodeUnknownError:
		return true
	}
	return false
}

func (e UpdateBitsBadgeTiersErrorCode) String() string {
	return string(e)
}

func (e *UpdateBitsBadgeTiersErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateBitsBadgeTiersErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateBitsBadgeTiersErrorCode", str)
	}
	return nil
}

func (e UpdateBitsBadgeTiersErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error types recognized.
type UpdateBoostSettingsErrorCode string

const (
	// Invalid parameter in the request.
	UpdateBoostSettingsErrorCodeInvalidParameter UpdateBoostSettingsErrorCode = "INVALID_PARAMETER"
	// Internal error being returned from service.
	UpdateBoostSettingsErrorCodeInternalError UpdateBoostSettingsErrorCode = "INTERNAL_ERROR"
)

var AllUpdateBoostSettingsErrorCode = []UpdateBoostSettingsErrorCode{
	UpdateBoostSettingsErrorCodeInvalidParameter,
	UpdateBoostSettingsErrorCodeInternalError,
}

func (e UpdateBoostSettingsErrorCode) IsValid() bool {
	switch e {
	case UpdateBoostSettingsErrorCodeInvalidParameter, UpdateBoostSettingsErrorCodeInternalError:
		return true
	}
	return false
}

func (e UpdateBoostSettingsErrorCode) String() string {
	return string(e)
}

func (e *UpdateBoostSettingsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateBoostSettingsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateBoostSettingsErrorCode", str)
	}
	return nil
}

func (e UpdateBoostSettingsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes returned from updating broadcast settings.
type UpdateBroadcastSettingsErrorCode string

const (
	// User is not authorized to update broadcast settings for this channel.
	UpdateBroadcastSettingsErrorCodeAuthFailure UpdateBroadcastSettingsErrorCode = "AUTH_FAILURE"
	// Too many attempts to update broadcast settings.
	UpdateBroadcastSettingsErrorCodeRequestsThrottled UpdateBroadcastSettingsErrorCode = "REQUESTS_THROTTLED"
	// Language is invalid.
	UpdateBroadcastSettingsErrorCodeLanguageNotValid UpdateBroadcastSettingsErrorCode = "LANGUAGE_NOT_VALID"
	// Streaming status is too long.
	UpdateBroadcastSettingsErrorCodeStatusTooLong UpdateBroadcastSettingsErrorCode = "STATUS_TOO_LONG"
	// Streaming status uses banned words.
	UpdateBroadcastSettingsErrorCodeStatusUsesBannedWords UpdateBroadcastSettingsErrorCode = "STATUS_USES_BANNED_WORDS"
	// Game name is too long.
	UpdateBroadcastSettingsErrorCodeGameNameTooLong UpdateBroadcastSettingsErrorCode = "GAME_NAME_TOO_LONG"
	// Unrecognized error returned from the backend service.
	UpdateBroadcastSettingsErrorCodeUnknownError UpdateBroadcastSettingsErrorCode = "UNKNOWN_ERROR"
)

var AllUpdateBroadcastSettingsErrorCode = []UpdateBroadcastSettingsErrorCode{
	UpdateBroadcastSettingsErrorCodeAuthFailure,
	UpdateBroadcastSettingsErrorCodeRequestsThrottled,
	UpdateBroadcastSettingsErrorCodeLanguageNotValid,
	UpdateBroadcastSettingsErrorCodeStatusTooLong,
	UpdateBroadcastSettingsErrorCodeStatusUsesBannedWords,
	UpdateBroadcastSettingsErrorCodeGameNameTooLong,
	UpdateBroadcastSettingsErrorCodeUnknownError,
}

func (e UpdateBroadcastSettingsErrorCode) IsValid() bool {
	switch e {
	case UpdateBroadcastSettingsErrorCodeAuthFailure, UpdateBroadcastSettingsErrorCodeRequestsThrottled, UpdateBroadcastSettingsErrorCodeLanguageNotValid, UpdateBroadcastSettingsErrorCodeStatusTooLong, UpdateBroadcastSettingsErrorCodeStatusUsesBannedWords, UpdateBroadcastSettingsErrorCodeGameNameTooLong, UpdateBroadcastSettingsErrorCodeUnknownError:
		return true
	}
	return false
}

func (e UpdateBroadcastSettingsErrorCode) String() string {
	return string(e)
}

func (e *UpdateBroadcastSettingsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateBroadcastSettingsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateBroadcastSettingsErrorCode", str)
	}
	return nil
}

func (e UpdateBroadcastSettingsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible error returned.
type UpdateChannelCategoryShelfError string

const (
	// The user making the update is not authorized to do so.
	UpdateChannelCategoryShelfErrorForbidden UpdateChannelCategoryShelfError = "FORBIDDEN"
	// One or more of the category IDs in the input are invalid.
	UpdateChannelCategoryShelfErrorInvalidCategory UpdateChannelCategoryShelfError = "INVALID_CATEGORY"
	// The same category ID cannot be both shown and hidden.
	UpdateChannelCategoryShelfErrorCannotShowAndHideCategory UpdateChannelCategoryShelfError = "CANNOT_SHOW_AND_HIDE_CATEGORY"
)

var AllUpdateChannelCategoryShelfError = []UpdateChannelCategoryShelfError{
	UpdateChannelCategoryShelfErrorForbidden,
	UpdateChannelCategoryShelfErrorInvalidCategory,
	UpdateChannelCategoryShelfErrorCannotShowAndHideCategory,
}

func (e UpdateChannelCategoryShelfError) IsValid() bool {
	switch e {
	case UpdateChannelCategoryShelfErrorForbidden, UpdateChannelCategoryShelfErrorInvalidCategory, UpdateChannelCategoryShelfErrorCannotShowAndHideCategory:
		return true
	}
	return false
}

func (e UpdateChannelCategoryShelfError) String() string {
	return string(e)
}

func (e *UpdateChannelCategoryShelfError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateChannelCategoryShelfError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateChannelCategoryShelfError", str)
	}
	return nil
}

func (e UpdateChannelCategoryShelfError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes from the updateChannelPredictionSettings mutation.
type UpdateChannelPredictionSettingsErrorCode string

const (
	// The authorized user is not allowed to update prediction settings for this channel.
	UpdateChannelPredictionSettingsErrorCodeForbidden UpdateChannelPredictionSettingsErrorCode = "FORBIDDEN"
	// An unknown error occurred.
	UpdateChannelPredictionSettingsErrorCodeUnknown UpdateChannelPredictionSettingsErrorCode = "UNKNOWN"
)

var AllUpdateChannelPredictionSettingsErrorCode = []UpdateChannelPredictionSettingsErrorCode{
	UpdateChannelPredictionSettingsErrorCodeForbidden,
	UpdateChannelPredictionSettingsErrorCodeUnknown,
}

func (e UpdateChannelPredictionSettingsErrorCode) IsValid() bool {
	switch e {
	case UpdateChannelPredictionSettingsErrorCodeForbidden, UpdateChannelPredictionSettingsErrorCodeUnknown:
		return true
	}
	return false
}

func (e UpdateChannelPredictionSettingsErrorCode) String() string {
	return string(e)
}

func (e *UpdateChannelPredictionSettingsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateChannelPredictionSettingsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateChannelPredictionSettingsErrorCode", str)
	}
	return nil
}

func (e UpdateChannelPredictionSettingsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons updating an automatic Community Points reward in a channel could fail.
type UpdateCommunityPointsAutomaticRewardErrorCode string

const (
	// An unexpected error occurred.
	UpdateCommunityPointsAutomaticRewardErrorCodeUnknown UpdateCommunityPointsAutomaticRewardErrorCode = "UNKNOWN"
	// The current user is not allowed to update a reward in this channel.
	UpdateCommunityPointsAutomaticRewardErrorCodeForbidden UpdateCommunityPointsAutomaticRewardErrorCode = "FORBIDDEN"
	// The cost is below the minimum.
	UpdateCommunityPointsAutomaticRewardErrorCodeCostTooLow UpdateCommunityPointsAutomaticRewardErrorCode = "COST_TOO_LOW"
	// The cost is invalid. Must be a positive integer.
	UpdateCommunityPointsAutomaticRewardErrorCodeCostInvalid UpdateCommunityPointsAutomaticRewardErrorCode = "COST_INVALID"
	// The background color is invalid. Backgrounds must be a valid hex color, for example "FF0000".
	UpdateCommunityPointsAutomaticRewardErrorCodeBackgroundColorInvalid UpdateCommunityPointsAutomaticRewardErrorCode = "BACKGROUND_COLOR_INVALID"
)

var AllUpdateCommunityPointsAutomaticRewardErrorCode = []UpdateCommunityPointsAutomaticRewardErrorCode{
	UpdateCommunityPointsAutomaticRewardErrorCodeUnknown,
	UpdateCommunityPointsAutomaticRewardErrorCodeForbidden,
	UpdateCommunityPointsAutomaticRewardErrorCodeCostTooLow,
	UpdateCommunityPointsAutomaticRewardErrorCodeCostInvalid,
	UpdateCommunityPointsAutomaticRewardErrorCodeBackgroundColorInvalid,
}

func (e UpdateCommunityPointsAutomaticRewardErrorCode) IsValid() bool {
	switch e {
	case UpdateCommunityPointsAutomaticRewardErrorCodeUnknown, UpdateCommunityPointsAutomaticRewardErrorCodeForbidden, UpdateCommunityPointsAutomaticRewardErrorCodeCostTooLow, UpdateCommunityPointsAutomaticRewardErrorCodeCostInvalid, UpdateCommunityPointsAutomaticRewardErrorCodeBackgroundColorInvalid:
		return true
	}
	return false
}

func (e UpdateCommunityPointsAutomaticRewardErrorCode) String() string {
	return string(e)
}

func (e *UpdateCommunityPointsAutomaticRewardErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateCommunityPointsAutomaticRewardErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateCommunityPointsAutomaticRewardErrorCode", str)
	}
	return nil
}

func (e UpdateCommunityPointsAutomaticRewardErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons updating a channel's Community Points channel settings could fail.
type UpdateCommunityPointsChannelSettingsErrorCode string

const (
	// An unexpected error occurred.
	UpdateCommunityPointsChannelSettingsErrorCodeUnknown UpdateCommunityPointsChannelSettingsErrorCode = "UNKNOWN"
	// The current user is not allowed to update this channel's settings.
	UpdateCommunityPointsChannelSettingsErrorCodeForbidden UpdateCommunityPointsChannelSettingsErrorCode = "FORBIDDEN"
	// The custom name failed AutoMod.
	UpdateCommunityPointsChannelSettingsErrorCodeNameAutomodFailed UpdateCommunityPointsChannelSettingsErrorCode = "NAME_AUTOMOD_FAILED"
)

var AllUpdateCommunityPointsChannelSettingsErrorCode = []UpdateCommunityPointsChannelSettingsErrorCode{
	UpdateCommunityPointsChannelSettingsErrorCodeUnknown,
	UpdateCommunityPointsChannelSettingsErrorCodeForbidden,
	UpdateCommunityPointsChannelSettingsErrorCodeNameAutomodFailed,
}

func (e UpdateCommunityPointsChannelSettingsErrorCode) IsValid() bool {
	switch e {
	case UpdateCommunityPointsChannelSettingsErrorCodeUnknown, UpdateCommunityPointsChannelSettingsErrorCodeForbidden, UpdateCommunityPointsChannelSettingsErrorCodeNameAutomodFailed:
		return true
	}
	return false
}

func (e UpdateCommunityPointsChannelSettingsErrorCode) String() string {
	return string(e)
}

func (e *UpdateCommunityPointsChannelSettingsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateCommunityPointsChannelSettingsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateCommunityPointsChannelSettingsErrorCode", str)
	}
	return nil
}

func (e UpdateCommunityPointsChannelSettingsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Update community goal error code.
type UpdateCommunityPointsCommunityGoalErrorCode string

const (
	// Goal already exists.
	UpdateCommunityPointsCommunityGoalErrorCodeDuplicateGoal UpdateCommunityPointsCommunityGoalErrorCode = "DUPLICATE_GOAL"
	// Goal title failed automod.
	UpdateCommunityPointsCommunityGoalErrorCodeTitleAutomodFailed UpdateCommunityPointsCommunityGoalErrorCode = "TITLE_AUTOMOD_FAILED"
	// Goal title is invalid.
	UpdateCommunityPointsCommunityGoalErrorCodeTitleInvalid UpdateCommunityPointsCommunityGoalErrorCode = "TITLE_INVALID"
	// Goal description failed automod.
	UpdateCommunityPointsCommunityGoalErrorCodeDescriptionAutomodFailed UpdateCommunityPointsCommunityGoalErrorCode = "DESCRIPTION_AUTOMOD_FAILED"
	// Goal description is invalid.
	UpdateCommunityPointsCommunityGoalErrorCodeDescriptionInvalid UpdateCommunityPointsCommunityGoalErrorCode = "DESCRIPTION_INVALID"
	// Goal amount is invalid.
	UpdateCommunityPointsCommunityGoalErrorCodeGoalAmountInvalid UpdateCommunityPointsCommunityGoalErrorCode = "GOAL_AMOUNT_INVALID"
	// Goal duration is invalid.
	UpdateCommunityPointsCommunityGoalErrorCodeDurationInvalid UpdateCommunityPointsCommunityGoalErrorCode = "DURATION_INVALID"
	// Goal background color is invalid.
	UpdateCommunityPointsCommunityGoalErrorCodeBackgroundColorInvalid UpdateCommunityPointsCommunityGoalErrorCode = "BACKGROUND_COLOR_INVALID"
	// Goal cannot be updated since it has already been started.
	UpdateCommunityPointsCommunityGoalErrorCodeGoalStarted UpdateCommunityPointsCommunityGoalErrorCode = "GOAL_STARTED"
	// Goal status change invalid.
	UpdateCommunityPointsCommunityGoalErrorCodeInvalidStatusChange UpdateCommunityPointsCommunityGoalErrorCode = "INVALID_STATUS_CHANGE"
	// Goal was not found.
	UpdateCommunityPointsCommunityGoalErrorCodeNotFound UpdateCommunityPointsCommunityGoalErrorCode = "NOT_FOUND"
	// The current user is not allowed to update goals for this channel.
	UpdateCommunityPointsCommunityGoalErrorCodeForbidden UpdateCommunityPointsCommunityGoalErrorCode = "FORBIDDEN"
	// An unknown error occurred.
	UpdateCommunityPointsCommunityGoalErrorCodeUnknown UpdateCommunityPointsCommunityGoalErrorCode = "UNKNOWN"
)

var AllUpdateCommunityPointsCommunityGoalErrorCode = []UpdateCommunityPointsCommunityGoalErrorCode{
	UpdateCommunityPointsCommunityGoalErrorCodeDuplicateGoal,
	UpdateCommunityPointsCommunityGoalErrorCodeTitleAutomodFailed,
	UpdateCommunityPointsCommunityGoalErrorCodeTitleInvalid,
	UpdateCommunityPointsCommunityGoalErrorCodeDescriptionAutomodFailed,
	UpdateCommunityPointsCommunityGoalErrorCodeDescriptionInvalid,
	UpdateCommunityPointsCommunityGoalErrorCodeGoalAmountInvalid,
	UpdateCommunityPointsCommunityGoalErrorCodeDurationInvalid,
	UpdateCommunityPointsCommunityGoalErrorCodeBackgroundColorInvalid,
	UpdateCommunityPointsCommunityGoalErrorCodeGoalStarted,
	UpdateCommunityPointsCommunityGoalErrorCodeInvalidStatusChange,
	UpdateCommunityPointsCommunityGoalErrorCodeNotFound,
	UpdateCommunityPointsCommunityGoalErrorCodeForbidden,
	UpdateCommunityPointsCommunityGoalErrorCodeUnknown,
}

func (e UpdateCommunityPointsCommunityGoalErrorCode) IsValid() bool {
	switch e {
	case UpdateCommunityPointsCommunityGoalErrorCodeDuplicateGoal, UpdateCommunityPointsCommunityGoalErrorCodeTitleAutomodFailed, UpdateCommunityPointsCommunityGoalErrorCodeTitleInvalid, UpdateCommunityPointsCommunityGoalErrorCodeDescriptionAutomodFailed, UpdateCommunityPointsCommunityGoalErrorCodeDescriptionInvalid, UpdateCommunityPointsCommunityGoalErrorCodeGoalAmountInvalid, UpdateCommunityPointsCommunityGoalErrorCodeDurationInvalid, UpdateCommunityPointsCommunityGoalErrorCodeBackgroundColorInvalid, UpdateCommunityPointsCommunityGoalErrorCodeGoalStarted, UpdateCommunityPointsCommunityGoalErrorCodeInvalidStatusChange, UpdateCommunityPointsCommunityGoalErrorCodeNotFound, UpdateCommunityPointsCommunityGoalErrorCodeForbidden, UpdateCommunityPointsCommunityGoalErrorCodeUnknown:
		return true
	}
	return false
}

func (e UpdateCommunityPointsCommunityGoalErrorCode) String() string {
	return string(e)
}

func (e *UpdateCommunityPointsCommunityGoalErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateCommunityPointsCommunityGoalErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateCommunityPointsCommunityGoalErrorCode", str)
	}
	return nil
}

func (e UpdateCommunityPointsCommunityGoalErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons updating a custom Community Points reward in a channel could fail.
type UpdateCommunityPointsCustomRewardErrorCode string

const (
	// An unexpected error occurred.
	UpdateCommunityPointsCustomRewardErrorCodeUnknown UpdateCommunityPointsCustomRewardErrorCode = "UNKNOWN"
	// The current user is not allowed to update a reward in this channel.
	UpdateCommunityPointsCustomRewardErrorCodeForbidden UpdateCommunityPointsCustomRewardErrorCode = "FORBIDDEN"
	// The reward was not found.
	UpdateCommunityPointsCustomRewardErrorCodeNotFound UpdateCommunityPointsCustomRewardErrorCode = "NOT_FOUND"
	// The title failed AutoMod.
	UpdateCommunityPointsCustomRewardErrorCodeTitleAutomodFailed UpdateCommunityPointsCustomRewardErrorCode = "TITLE_AUTOMOD_FAILED"
	// The prompt failed AutoMod.
	UpdateCommunityPointsCustomRewardErrorCodePromptAutomodFailed UpdateCommunityPointsCustomRewardErrorCode = "PROMPT_AUTOMOD_FAILED"
	// The cost is invalid. Costs must be greater than 0.
	UpdateCommunityPointsCustomRewardErrorCodeCostInvalid UpdateCommunityPointsCustomRewardErrorCode = "COST_INVALID"
	// The maxPerStream is invalid. maxPerStream must be greater than 0.
	UpdateCommunityPointsCustomRewardErrorCodeMaxPerStreamInvalid UpdateCommunityPointsCustomRewardErrorCode = "MAX_PER_STREAM_INVALID"
	// The title is invalid. Titles must not be empty and must be at most 45 characters long.
	UpdateCommunityPointsCustomRewardErrorCodeTitleInvalid UpdateCommunityPointsCustomRewardErrorCode = "TITLE_INVALID"
	// The background color is invalid. Backgrounds must be a valid hex color, for example "FF0000".
	UpdateCommunityPointsCustomRewardErrorCodeBackgroundColorInvalid UpdateCommunityPointsCustomRewardErrorCode = "BACKGROUND_COLOR_INVALID"
	// A reward with the provided title already exists. Custom reward titles must be unique.
	UpdateCommunityPointsCustomRewardErrorCodeDuplicateReward UpdateCommunityPointsCustomRewardErrorCode = "DUPLICATE_REWARD"
	// The maxPerUserPerStream is invalid. maxPerUserPerStream must be greater than 0.
	UpdateCommunityPointsCustomRewardErrorCodeMaxPerUserPerStreamInvalid UpdateCommunityPointsCustomRewardErrorCode = "MAX_PER_USER_PER_STREAM_INVALID"
	// The globalCooldown is invalid. globalCooldown must be greater tham 0.
	UpdateCommunityPointsCustomRewardErrorCodeGlobalCooldownInvalid UpdateCommunityPointsCustomRewardErrorCode = "GLOBAL_COOLDOWN_INVALID"
)

var AllUpdateCommunityPointsCustomRewardErrorCode = []UpdateCommunityPointsCustomRewardErrorCode{
	UpdateCommunityPointsCustomRewardErrorCodeUnknown,
	UpdateCommunityPointsCustomRewardErrorCodeForbidden,
	UpdateCommunityPointsCustomRewardErrorCodeNotFound,
	UpdateCommunityPointsCustomRewardErrorCodeTitleAutomodFailed,
	UpdateCommunityPointsCustomRewardErrorCodePromptAutomodFailed,
	UpdateCommunityPointsCustomRewardErrorCodeCostInvalid,
	UpdateCommunityPointsCustomRewardErrorCodeMaxPerStreamInvalid,
	UpdateCommunityPointsCustomRewardErrorCodeTitleInvalid,
	UpdateCommunityPointsCustomRewardErrorCodeBackgroundColorInvalid,
	UpdateCommunityPointsCustomRewardErrorCodeDuplicateReward,
	UpdateCommunityPointsCustomRewardErrorCodeMaxPerUserPerStreamInvalid,
	UpdateCommunityPointsCustomRewardErrorCodeGlobalCooldownInvalid,
}

func (e UpdateCommunityPointsCustomRewardErrorCode) IsValid() bool {
	switch e {
	case UpdateCommunityPointsCustomRewardErrorCodeUnknown, UpdateCommunityPointsCustomRewardErrorCodeForbidden, UpdateCommunityPointsCustomRewardErrorCodeNotFound, UpdateCommunityPointsCustomRewardErrorCodeTitleAutomodFailed, UpdateCommunityPointsCustomRewardErrorCodePromptAutomodFailed, UpdateCommunityPointsCustomRewardErrorCodeCostInvalid, UpdateCommunityPointsCustomRewardErrorCodeMaxPerStreamInvalid, UpdateCommunityPointsCustomRewardErrorCodeTitleInvalid, UpdateCommunityPointsCustomRewardErrorCodeBackgroundColorInvalid, UpdateCommunityPointsCustomRewardErrorCodeDuplicateReward, UpdateCommunityPointsCustomRewardErrorCodeMaxPerUserPerStreamInvalid, UpdateCommunityPointsCustomRewardErrorCodeGlobalCooldownInvalid:
		return true
	}
	return false
}

func (e UpdateCommunityPointsCustomRewardErrorCode) String() string {
	return string(e)
}

func (e *UpdateCommunityPointsCustomRewardErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateCommunityPointsCustomRewardErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateCommunityPointsCustomRewardErrorCode", str)
	}
	return nil
}

func (e UpdateCommunityPointsCustomRewardErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons acting on a Community Points redemption could fail.
type UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode string

const (
	// The redemption was not found.
	UpdateCommunityPointsCustomRewardRedemptionStatusErrorCodeNotFound UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode = "NOT_FOUND"
	// The current user is not allowed to update the status of this redemption.
	UpdateCommunityPointsCustomRewardRedemptionStatusErrorCodeForbidden UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode = "FORBIDDEN"
)

var AllUpdateCommunityPointsCustomRewardRedemptionStatusErrorCode = []UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode{
	UpdateCommunityPointsCustomRewardRedemptionStatusErrorCodeNotFound,
	UpdateCommunityPointsCustomRewardRedemptionStatusErrorCodeForbidden,
}

func (e UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode) IsValid() bool {
	switch e {
	case UpdateCommunityPointsCustomRewardRedemptionStatusErrorCodeNotFound, UpdateCommunityPointsCustomRewardRedemptionStatusErrorCodeForbidden:
		return true
	}
	return false
}

func (e UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode) String() string {
	return string(e)
}

func (e *UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode", str)
	}
	return nil
}

func (e UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons acting on a Community Points redemption could fail.
type UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode string

const (
	// An unexpected error occured.
	UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCodeUnknown UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode = "UNKNOWN"
	// The current user is not allowed to update the statuses of these redemptions.
	UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCodeForbidden UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode = "FORBIDDEN"
	// There is already a bulk update in progress for this reward / all rewards. Only one can be	processed at a time.
	UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCodeInProgress UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode = "IN_PROGRESS"
)

var AllUpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode = []UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode{
	UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCodeUnknown,
	UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCodeForbidden,
	UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCodeInProgress,
}

func (e UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode) IsValid() bool {
	switch e {
	case UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCodeUnknown, UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCodeForbidden, UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCodeInProgress:
		return true
	}
	return false
}

func (e UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode) String() string {
	return string(e)
}

func (e *UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode", str)
	}
	return nil
}

func (e UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An error returned when updating a user's enrollment in Community Points early access.
type UpdateCommunityPointsEarlyAccessErrorCode string

const (
	// The user is not allowed to opt in to the Community Points early access program.
	UpdateCommunityPointsEarlyAccessErrorCodeForbidden UpdateCommunityPointsEarlyAccessErrorCode = "FORBIDDEN"
	// There was some other error updating the user's enrollment.
	UpdateCommunityPointsEarlyAccessErrorCodeUnknown UpdateCommunityPointsEarlyAccessErrorCode = "UNKNOWN"
)

var AllUpdateCommunityPointsEarlyAccessErrorCode = []UpdateCommunityPointsEarlyAccessErrorCode{
	UpdateCommunityPointsEarlyAccessErrorCodeForbidden,
	UpdateCommunityPointsEarlyAccessErrorCodeUnknown,
}

func (e UpdateCommunityPointsEarlyAccessErrorCode) IsValid() bool {
	switch e {
	case UpdateCommunityPointsEarlyAccessErrorCodeForbidden, UpdateCommunityPointsEarlyAccessErrorCodeUnknown:
		return true
	}
	return false
}

func (e UpdateCommunityPointsEarlyAccessErrorCode) String() string {
	return string(e)
}

func (e *UpdateCommunityPointsEarlyAccessErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateCommunityPointsEarlyAccessErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateCommunityPointsEarlyAccessErrorCode", str)
	}
	return nil
}

func (e UpdateCommunityPointsEarlyAccessErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons updating the last viewed community points content timestamps on a channel could fail.
type UpdateCommunityPointsLastViewedContentErrorCode string

const (
	// An unexpected error occurred.
	UpdateCommunityPointsLastViewedContentErrorCodeUnknown UpdateCommunityPointsLastViewedContentErrorCode = "UNKNOWN"
	// The current user is not allowed to update last viewed timestamps for this channel.
	UpdateCommunityPointsLastViewedContentErrorCodeForbidden UpdateCommunityPointsLastViewedContentErrorCode = "FORBIDDEN"
)

var AllUpdateCommunityPointsLastViewedContentErrorCode = []UpdateCommunityPointsLastViewedContentErrorCode{
	UpdateCommunityPointsLastViewedContentErrorCodeUnknown,
	UpdateCommunityPointsLastViewedContentErrorCodeForbidden,
}

func (e UpdateCommunityPointsLastViewedContentErrorCode) IsValid() bool {
	switch e {
	case UpdateCommunityPointsLastViewedContentErrorCodeUnknown, UpdateCommunityPointsLastViewedContentErrorCodeForbidden:
		return true
	}
	return false
}

func (e UpdateCommunityPointsLastViewedContentErrorCode) String() string {
	return string(e)
}

func (e *UpdateCommunityPointsLastViewedContentErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateCommunityPointsLastViewedContentErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateCommunityPointsLastViewedContentErrorCode", str)
	}
	return nil
}

func (e UpdateCommunityPointsLastViewedContentErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons updating a Community Points Smart Costs Acknowledgement in a channel could fail.
type UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode string

const (
	// An unexpected error occurred.
	UpdateCommunityPointsSmartCostsAcknowledgementsErrorCodeUnknown UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode = "UNKNOWN"
	// The current user is not allowed to update a smart costs acknowledgement in this channel.
	UpdateCommunityPointsSmartCostsAcknowledgementsErrorCodeForbidden UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode = "FORBIDDEN"
	// The cost is invalid. Must be a positive integer.
	UpdateCommunityPointsSmartCostsAcknowledgementsErrorCodeLastAcknowledgedCostInvalid UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode = "LAST_ACKNOWLEDGED_COST_INVALID"
)

var AllUpdateCommunityPointsSmartCostsAcknowledgementsErrorCode = []UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode{
	UpdateCommunityPointsSmartCostsAcknowledgementsErrorCodeUnknown,
	UpdateCommunityPointsSmartCostsAcknowledgementsErrorCodeForbidden,
	UpdateCommunityPointsSmartCostsAcknowledgementsErrorCodeLastAcknowledgedCostInvalid,
}

func (e UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode) IsValid() bool {
	switch e {
	case UpdateCommunityPointsSmartCostsAcknowledgementsErrorCodeUnknown, UpdateCommunityPointsSmartCostsAcknowledgementsErrorCodeForbidden, UpdateCommunityPointsSmartCostsAcknowledgementsErrorCodeLastAcknowledgedCostInvalid:
		return true
	}
	return false
}

func (e UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode) String() string {
	return string(e)
}

func (e *UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode", str)
	}
	return nil
}

func (e UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Client Error Code.
type UpdateConsentErrorCode string

const (
	// Invalid vendor name or law name or consent status.
	UpdateConsentErrorCodeInvalidVendorLawConsentStatus UpdateConsentErrorCode = "INVALID_VENDOR_LAW_CONSENT_STATUS"
)

var AllUpdateConsentErrorCode = []UpdateConsentErrorCode{
	UpdateConsentErrorCodeInvalidVendorLawConsentStatus,
}

func (e UpdateConsentErrorCode) IsValid() bool {
	switch e {
	case UpdateConsentErrorCodeInvalidVendorLawConsentStatus:
		return true
	}
	return false
}

func (e UpdateConsentErrorCode) String() string {
	return string(e)
}

func (e *UpdateConsentErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateConsentErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateConsentErrorCode", str)
	}
	return nil
}

func (e UpdateConsentErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The expected errors that can be returned from the UpdateEmoteOrders mutation.
type UpdateEmoteOrdersErrorCode string

const (
	// The user is not permitted to update the orders of the requested emotes or group.
	UpdateEmoteOrdersErrorCodeUnauthorized UpdateEmoteOrdersErrorCode = "UNAUTHORIZED"
	// No emote was found with the requested emote ID.
	UpdateEmoteOrdersErrorCodeBadEmoteRequest UpdateEmoteOrdersErrorCode = "BAD_EMOTE_REQUEST"
	// No group was found with the requested group ID.
	UpdateEmoteOrdersErrorCodeBadGroupRequest UpdateEmoteOrdersErrorCode = "BAD_GROUP_REQUEST"
	// The orders provided result in an invalid set of orders in a particular group.
	UpdateEmoteOrdersErrorCodeBadNonUniqueOrdersRequest UpdateEmoteOrdersErrorCode = "BAD_NON_UNIQUE_ORDERS_REQUEST"
	// An unexpected error occurred.
	UpdateEmoteOrdersErrorCodeUnknownError UpdateEmoteOrdersErrorCode = "UNKNOWN_ERROR"
)

var AllUpdateEmoteOrdersErrorCode = []UpdateEmoteOrdersErrorCode{
	UpdateEmoteOrdersErrorCodeUnauthorized,
	UpdateEmoteOrdersErrorCodeBadEmoteRequest,
	UpdateEmoteOrdersErrorCodeBadGroupRequest,
	UpdateEmoteOrdersErrorCodeBadNonUniqueOrdersRequest,
	UpdateEmoteOrdersErrorCodeUnknownError,
}

func (e UpdateEmoteOrdersErrorCode) IsValid() bool {
	switch e {
	case UpdateEmoteOrdersErrorCodeUnauthorized, UpdateEmoteOrdersErrorCodeBadEmoteRequest, UpdateEmoteOrdersErrorCodeBadGroupRequest, UpdateEmoteOrdersErrorCodeBadNonUniqueOrdersRequest, UpdateEmoteOrdersErrorCodeUnknownError:
		return true
	}
	return false
}

func (e UpdateEmoteOrdersErrorCode) String() string {
	return string(e)
}

func (e *UpdateEmoteOrdersErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateEmoteOrdersErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateEmoteOrdersErrorCode", str)
	}
	return nil
}

func (e UpdateEmoteOrdersErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// UpdateExtensionDiscoveryDataError is an error associated with the updateExtensionDiscoveryData mutation.
type UpdateExtensionDiscoveryDataError string

const (
	// User is unable to make modifications to the extension.
	UpdateExtensionDiscoveryDataErrorUnauthorized UpdateExtensionDiscoveryDataError = "UNAUTHORIZED"
	// Version specified is invalid.
	UpdateExtensionDiscoveryDataErrorInvalidVersion UpdateExtensionDiscoveryDataError = "INVALID_VERSION"
	// Extension names must be shorter than 40 characters.
	UpdateExtensionDiscoveryDataErrorInvalidNameLength UpdateExtensionDiscoveryDataError = "INVALID_NAME_LENGTH"
	// Extension description must be shorter than 1024 characters.
	UpdateExtensionDiscoveryDataErrorInvalidDescriptionLength UpdateExtensionDiscoveryDataError = "INVALID_DESCRIPTION_LENGTH"
	// Extension summary must be shorter than 140 characters.
	UpdateExtensionDiscoveryDataErrorInvalidSummaryLength UpdateExtensionDiscoveryDataError = "INVALID_SUMMARY_LENGTH"
	// Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
	UpdateExtensionDiscoveryDataErrorInvalidAuthorEmail UpdateExtensionDiscoveryDataError = "INVALID_AUTHOR_EMAIL"
	// Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
	UpdateExtensionDiscoveryDataErrorInvalidSupportEmail UpdateExtensionDiscoveryDataError = "INVALID_SUPPORT_EMAIL"
	// Extension author name length must be > 40.
	UpdateExtensionDiscoveryDataErrorInvalidAuthorNameLength UpdateExtensionDiscoveryDataError = "INVALID_AUTHOR_NAME_LENGTH"
	// Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
	UpdateExtensionDiscoveryDataErrorInvalidTestingBaseURI UpdateExtensionDiscoveryDataError = "INVALID_TESTING_BASE_URI"
	// Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
	UpdateExtensionDiscoveryDataErrorInvalidTermsURI UpdateExtensionDiscoveryDataError = "INVALID_TERMS_URI"
	// Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
	UpdateExtensionDiscoveryDataErrorInvalidPrivacyURI UpdateExtensionDiscoveryDataError = "INVALID_PRIVACY_URI"
)

var AllUpdateExtensionDiscoveryDataError = []UpdateExtensionDiscoveryDataError{
	UpdateExtensionDiscoveryDataErrorUnauthorized,
	UpdateExtensionDiscoveryDataErrorInvalidVersion,
	UpdateExtensionDiscoveryDataErrorInvalidNameLength,
	UpdateExtensionDiscoveryDataErrorInvalidDescriptionLength,
	UpdateExtensionDiscoveryDataErrorInvalidSummaryLength,
	UpdateExtensionDiscoveryDataErrorInvalidAuthorEmail,
	UpdateExtensionDiscoveryDataErrorInvalidSupportEmail,
	UpdateExtensionDiscoveryDataErrorInvalidAuthorNameLength,
	UpdateExtensionDiscoveryDataErrorInvalidTestingBaseURI,
	UpdateExtensionDiscoveryDataErrorInvalidTermsURI,
	UpdateExtensionDiscoveryDataErrorInvalidPrivacyURI,
}

func (e UpdateExtensionDiscoveryDataError) IsValid() bool {
	switch e {
	case UpdateExtensionDiscoveryDataErrorUnauthorized, UpdateExtensionDiscoveryDataErrorInvalidVersion, UpdateExtensionDiscoveryDataErrorInvalidNameLength, UpdateExtensionDiscoveryDataErrorInvalidDescriptionLength, UpdateExtensionDiscoveryDataErrorInvalidSummaryLength, UpdateExtensionDiscoveryDataErrorInvalidAuthorEmail, UpdateExtensionDiscoveryDataErrorInvalidSupportEmail, UpdateExtensionDiscoveryDataErrorInvalidAuthorNameLength, UpdateExtensionDiscoveryDataErrorInvalidTestingBaseURI, UpdateExtensionDiscoveryDataErrorInvalidTermsURI, UpdateExtensionDiscoveryDataErrorInvalidPrivacyURI:
		return true
	}
	return false
}

func (e UpdateExtensionDiscoveryDataError) String() string {
	return string(e)
}

func (e *UpdateExtensionDiscoveryDataError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateExtensionDiscoveryDataError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateExtensionDiscoveryDataError", str)
	}
	return nil
}

func (e UpdateExtensionDiscoveryDataError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// UpdateExtensionManifestError is an error associated with the updateExtensionManifest mutation.
type UpdateExtensionManifestError string

const (
	// User is unable to make modifications to the extension.
	UpdateExtensionManifestErrorUnauthorized UpdateExtensionManifestError = "UNAUTHORIZED"
	// Version specified is invalid.
	UpdateExtensionManifestErrorInvalidVersion UpdateExtensionManifestError = "INVALID_VERSION"
	// At least one anchor must be specified.
	UpdateExtensionManifestErrorAnchorRequired UpdateExtensionManifestError = "ANCHOR_REQUIRED"
	// HasZoom was specified but ZoomPixels is missing.
	UpdateExtensionManifestErrorInvalidZoom UpdateExtensionManifestError = "INVALID_ZOOM"
	// The number of whitelisted broadcasters exceeds the limit.
	UpdateExtensionManifestErrorMaxBroadcasters UpdateExtensionManifestError = "MAX_BROADCASTERS"
	// The number of whitelisted testing users exceeds the limit.
	UpdateExtensionManifestErrorMaxTesters UpdateExtensionManifestError = "MAX_TESTERS"
	// The number of whitelisted config URLs exceeds the limit.
	UpdateExtensionManifestErrorMaxWhitelistedConfigURLS UpdateExtensionManifestError = "MAX_WHITELISTED_CONFIG_URLS"
	// The number of whitelisted panel URLs exceeds the limit.
	UpdateExtensionManifestErrorMaxWhitelistedPanelURLS UpdateExtensionManifestError = "MAX_WHITELISTED_PANEL_URLS"
	// Extension names must be shorter than 40 characters.
	UpdateExtensionManifestErrorInvalidNameLength UpdateExtensionManifestError = "INVALID_NAME_LENGTH"
	// Extension description must be shorter than 1024 characters.
	UpdateExtensionManifestErrorInvalidDescriptionLength UpdateExtensionManifestError = "INVALID_DESCRIPTION_LENGTH"
	// Extension summary must be shorter than 140 characters.
	UpdateExtensionManifestErrorInvalidSummaryLength UpdateExtensionManifestError = "INVALID_SUMMARY_LENGTH"
	// Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
	UpdateExtensionManifestErrorInvalidAuthorEmail UpdateExtensionManifestError = "INVALID_AUTHOR_EMAIL"
	// Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
	UpdateExtensionManifestErrorInvalidSupportEmail UpdateExtensionManifestError = "INVALID_SUPPORT_EMAIL"
	// Extension author name length must be > 40.
	UpdateExtensionManifestErrorInvalidAuthorNameLength UpdateExtensionManifestError = "INVALID_AUTHOR_NAME_LENGTH"
	// Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
	UpdateExtensionManifestErrorInvalidTestingBaseURI UpdateExtensionManifestError = "INVALID_TESTING_BASE_URI"
	// Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
	UpdateExtensionManifestErrorInvalidTermsURI UpdateExtensionManifestError = "INVALID_TERMS_URI"
	// Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
	UpdateExtensionManifestErrorInvalidPrivacyURI UpdateExtensionManifestError = "INVALID_PRIVACY_URI"
	// Extension component viewer path must not be nil. Format should be BaseUri/Extension_Path.
	UpdateExtensionManifestErrorInvalidComponentViewerPath UpdateExtensionManifestError = "INVALID_COMPONENT_VIEWER_PATH"
	// Extension panel viewer path must not be nil. Format should be BaseUri/Extension_Path.
	UpdateExtensionManifestErrorInvalidPanelViewerPath UpdateExtensionManifestError = "INVALID_PANEL_VIEWER_PATH"
	// Extension video overlay viewer path must not be nil. Format should be BaseUri/Extension_Path.
	UpdateExtensionManifestErrorInvalidVideoOverlayViewerPath UpdateExtensionManifestError = "INVALID_VIDEO_OVERLAY_VIEWER_PATH"
	// Extension config viewer path must not be nil. Format should be BaseUri/Extension_Path.
	UpdateExtensionManifestErrorInvalidConfigViewerPath UpdateExtensionManifestError = "INVALID_CONFIG_VIEWER_PATH"
	// Extension live config viewer path must not be nil. Format should be BaseUri/Extension_Path.
	UpdateExtensionManifestErrorInvalidLiveConfigViewerPath UpdateExtensionManifestError = "INVALID_LIVE_CONFIG_VIEWER_PATH"
	// Extension mobile viewer path must not be nil. Format should be BaseUri/Extension_Path.
	UpdateExtensionManifestErrorInvalidMobileViewerPath UpdateExtensionManifestError = "INVALID_MOBILE_VIEWER_PATH"
	// Extension component aspect width must be < 50 or > 1.
	UpdateExtensionManifestErrorInvalidComponentAspectWidth UpdateExtensionManifestError = "INVALID_COMPONENT_ASPECT_WIDTH"
	// Extension component aspect height must be < 50 or > 1.
	UpdateExtensionManifestErrorInvalidComponentAspectHeight UpdateExtensionManifestError = "INVALID_COMPONENT_ASPECT_HEIGHT"
	// Extension panel hiehgt must be < 500 or > 100.
	UpdateExtensionManifestErrorInvalidPanelHeight UpdateExtensionManifestError = "INVALID_PANEL_HEIGHT"
	// Extension Bits Support Level must ba valid member of the BitsSupportLevelEnum.
	UpdateExtensionManifestErrorInvalidBitsSupportLevel UpdateExtensionManifestError = "INVALID_BITS_SUPPORT_LEVEL"
)

var AllUpdateExtensionManifestError = []UpdateExtensionManifestError{
	UpdateExtensionManifestErrorUnauthorized,
	UpdateExtensionManifestErrorInvalidVersion,
	UpdateExtensionManifestErrorAnchorRequired,
	UpdateExtensionManifestErrorInvalidZoom,
	UpdateExtensionManifestErrorMaxBroadcasters,
	UpdateExtensionManifestErrorMaxTesters,
	UpdateExtensionManifestErrorMaxWhitelistedConfigURLS,
	UpdateExtensionManifestErrorMaxWhitelistedPanelURLS,
	UpdateExtensionManifestErrorInvalidNameLength,
	UpdateExtensionManifestErrorInvalidDescriptionLength,
	UpdateExtensionManifestErrorInvalidSummaryLength,
	UpdateExtensionManifestErrorInvalidAuthorEmail,
	UpdateExtensionManifestErrorInvalidSupportEmail,
	UpdateExtensionManifestErrorInvalidAuthorNameLength,
	UpdateExtensionManifestErrorInvalidTestingBaseURI,
	UpdateExtensionManifestErrorInvalidTermsURI,
	UpdateExtensionManifestErrorInvalidPrivacyURI,
	UpdateExtensionManifestErrorInvalidComponentViewerPath,
	UpdateExtensionManifestErrorInvalidPanelViewerPath,
	UpdateExtensionManifestErrorInvalidVideoOverlayViewerPath,
	UpdateExtensionManifestErrorInvalidConfigViewerPath,
	UpdateExtensionManifestErrorInvalidLiveConfigViewerPath,
	UpdateExtensionManifestErrorInvalidMobileViewerPath,
	UpdateExtensionManifestErrorInvalidComponentAspectWidth,
	UpdateExtensionManifestErrorInvalidComponentAspectHeight,
	UpdateExtensionManifestErrorInvalidPanelHeight,
	UpdateExtensionManifestErrorInvalidBitsSupportLevel,
}

func (e UpdateExtensionManifestError) IsValid() bool {
	switch e {
	case UpdateExtensionManifestErrorUnauthorized, UpdateExtensionManifestErrorInvalidVersion, UpdateExtensionManifestErrorAnchorRequired, UpdateExtensionManifestErrorInvalidZoom, UpdateExtensionManifestErrorMaxBroadcasters, UpdateExtensionManifestErrorMaxTesters, UpdateExtensionManifestErrorMaxWhitelistedConfigURLS, UpdateExtensionManifestErrorMaxWhitelistedPanelURLS, UpdateExtensionManifestErrorInvalidNameLength, UpdateExtensionManifestErrorInvalidDescriptionLength, UpdateExtensionManifestErrorInvalidSummaryLength, UpdateExtensionManifestErrorInvalidAuthorEmail, UpdateExtensionManifestErrorInvalidSupportEmail, UpdateExtensionManifestErrorInvalidAuthorNameLength, UpdateExtensionManifestErrorInvalidTestingBaseURI, UpdateExtensionManifestErrorInvalidTermsURI, UpdateExtensionManifestErrorInvalidPrivacyURI, UpdateExtensionManifestErrorInvalidComponentViewerPath, UpdateExtensionManifestErrorInvalidPanelViewerPath, UpdateExtensionManifestErrorInvalidVideoOverlayViewerPath, UpdateExtensionManifestErrorInvalidConfigViewerPath, UpdateExtensionManifestErrorInvalidLiveConfigViewerPath, UpdateExtensionManifestErrorInvalidMobileViewerPath, UpdateExtensionManifestErrorInvalidComponentAspectWidth, UpdateExtensionManifestErrorInvalidComponentAspectHeight, UpdateExtensionManifestErrorInvalidPanelHeight, UpdateExtensionManifestErrorInvalidBitsSupportLevel:
		return true
	}
	return false
}

func (e UpdateExtensionManifestError) String() string {
	return string(e)
}

func (e *UpdateExtensionManifestError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateExtensionManifestError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateExtensionManifestError", str)
	}
	return nil
}

func (e UpdateExtensionManifestError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Validation error status codes.
type UpdateLiveUpNotificationValidationErrorCode string

const (
	// The notification text sent did not pass auto mod.
	UpdateLiveUpNotificationValidationErrorCodeFailedAutomod UpdateLiveUpNotificationValidationErrorCode = "FAILED_AUTOMOD"
	// The notification text sent is too long.
	UpdateLiveUpNotificationValidationErrorCodeTooLong UpdateLiveUpNotificationValidationErrorCode = "TOO_LONG"
	// The target user is not found.
	UpdateLiveUpNotificationValidationErrorCodeUserNotFound UpdateLiveUpNotificationValidationErrorCode = "USER_NOT_FOUND"
)

var AllUpdateLiveUpNotificationValidationErrorCode = []UpdateLiveUpNotificationValidationErrorCode{
	UpdateLiveUpNotificationValidationErrorCodeFailedAutomod,
	UpdateLiveUpNotificationValidationErrorCodeTooLong,
	UpdateLiveUpNotificationValidationErrorCodeUserNotFound,
}

func (e UpdateLiveUpNotificationValidationErrorCode) IsValid() bool {
	switch e {
	case UpdateLiveUpNotificationValidationErrorCodeFailedAutomod, UpdateLiveUpNotificationValidationErrorCodeTooLong, UpdateLiveUpNotificationValidationErrorCodeUserNotFound:
		return true
	}
	return false
}

func (e UpdateLiveUpNotificationValidationErrorCode) String() string {
	return string(e)
}

func (e *UpdateLiveUpNotificationValidationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateLiveUpNotificationValidationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateLiveUpNotificationValidationErrorCode", str)
	}
	return nil
}

func (e UpdateLiveUpNotificationValidationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// UpdateOrganizationMemberRoleErrorCode is the client error type that occurred during the UpdateOrganizationMemberRole mutation.
type UpdateOrganizationMemberRoleErrorCode string

const (
	// The user is not a member of the organization, or the organization does not exist.
	UpdateOrganizationMemberRoleErrorCodeMemberNotFound UpdateOrganizationMemberRoleErrorCode = "MEMBER_NOT_FOUND"
	// The user doesn't meet the requirements to have this role. For example, when trying to assign the
	// "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
	UpdateOrganizationMemberRoleErrorCodeMemberIneligible UpdateOrganizationMemberRoleErrorCode = "MEMBER_INELIGIBLE"
	// Current user not allowed to update the role.
	// For example, developers can not assign roles, and no one can assign the owner role to another user.
	UpdateOrganizationMemberRoleErrorCodePermissionDenied UpdateOrganizationMemberRoleErrorCode = "PERMISSION_DENIED"
	// One of the input parameters is malformed. This should not happen when properly using the UI.
	UpdateOrganizationMemberRoleErrorCodeInvalidArgument UpdateOrganizationMemberRoleErrorCode = "INVALID_ARGUMENT"
)

var AllUpdateOrganizationMemberRoleErrorCode = []UpdateOrganizationMemberRoleErrorCode{
	UpdateOrganizationMemberRoleErrorCodeMemberNotFound,
	UpdateOrganizationMemberRoleErrorCodeMemberIneligible,
	UpdateOrganizationMemberRoleErrorCodePermissionDenied,
	UpdateOrganizationMemberRoleErrorCodeInvalidArgument,
}

func (e UpdateOrganizationMemberRoleErrorCode) IsValid() bool {
	switch e {
	case UpdateOrganizationMemberRoleErrorCodeMemberNotFound, UpdateOrganizationMemberRoleErrorCodeMemberIneligible, UpdateOrganizationMemberRoleErrorCodePermissionDenied, UpdateOrganizationMemberRoleErrorCodeInvalidArgument:
		return true
	}
	return false
}

func (e UpdateOrganizationMemberRoleErrorCode) String() string {
	return string(e)
}

func (e *UpdateOrganizationMemberRoleErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateOrganizationMemberRoleErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateOrganizationMemberRoleErrorCode", str)
	}
	return nil
}

func (e UpdateOrganizationMemberRoleErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible error enums returned while trying to change a users phone number.
type UpdatePhoneNumberConfirmationErrorCode string

const (
	// The user needs to re-authenticate to perform this operation.
	UpdatePhoneNumberConfirmationErrorCodeReauthNeeded UpdatePhoneNumberConfirmationErrorCode = "REAUTH_NEEDED"
	// Phone number was not valid.
	UpdatePhoneNumberConfirmationErrorCodeInvalidPhoneNumber UpdatePhoneNumberConfirmationErrorCode = "INVALID_PHONE_NUMBER"
	// The phone number has requested checks on too many verification codes.
	UpdatePhoneNumberConfirmationErrorCodeRequestThrottled UpdatePhoneNumberConfirmationErrorCode = "REQUEST_THROTTLED"
	// The phone number provided is used for too many Twitch accounts.
	UpdatePhoneNumberConfirmationErrorCodeLimitReached UpdatePhoneNumberConfirmationErrorCode = "LIMIT_REACHED"
	// The one time password provided is invalid.
	UpdatePhoneNumberConfirmationErrorCodeInvalidOtp UpdatePhoneNumberConfirmationErrorCode = "INVALID_OTP"
	// The one time password provided is missing. A SMS to the phone number will be triggered when this error occurs.
	UpdatePhoneNumberConfirmationErrorCodeMissingOtp UpdatePhoneNumberConfirmationErrorCode = "MISSING_OTP"
	// Something unexpected occured.
	UpdatePhoneNumberConfirmationErrorCodeUnknownError UpdatePhoneNumberConfirmationErrorCode = "UNKNOWN_ERROR"
)

var AllUpdatePhoneNumberConfirmationErrorCode = []UpdatePhoneNumberConfirmationErrorCode{
	UpdatePhoneNumberConfirmationErrorCodeReauthNeeded,
	UpdatePhoneNumberConfirmationErrorCodeInvalidPhoneNumber,
	UpdatePhoneNumberConfirmationErrorCodeRequestThrottled,
	UpdatePhoneNumberConfirmationErrorCodeLimitReached,
	UpdatePhoneNumberConfirmationErrorCodeInvalidOtp,
	UpdatePhoneNumberConfirmationErrorCodeMissingOtp,
	UpdatePhoneNumberConfirmationErrorCodeUnknownError,
}

func (e UpdatePhoneNumberConfirmationErrorCode) IsValid() bool {
	switch e {
	case UpdatePhoneNumberConfirmationErrorCodeReauthNeeded, UpdatePhoneNumberConfirmationErrorCodeInvalidPhoneNumber, UpdatePhoneNumberConfirmationErrorCodeRequestThrottled, UpdatePhoneNumberConfirmationErrorCodeLimitReached, UpdatePhoneNumberConfirmationErrorCodeInvalidOtp, UpdatePhoneNumberConfirmationErrorCodeMissingOtp, UpdatePhoneNumberConfirmationErrorCodeUnknownError:
		return true
	}
	return false
}

func (e UpdatePhoneNumberConfirmationErrorCode) String() string {
	return string(e)
}

func (e *UpdatePhoneNumberConfirmationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdatePhoneNumberConfirmationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdatePhoneNumberConfirmationErrorCode", str)
	}
	return nil
}

func (e UpdatePhoneNumberConfirmationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible error enums returned while trying to change a users phone number.
type UpdatePhoneNumberErrorCode string

const (
	// The user needs to re-authenticate to perform this operation.
	UpdatePhoneNumberErrorCodeReauthNeeded UpdatePhoneNumberErrorCode = "REAUTH_NEEDED"
	// Phone number was not valid.
	UpdatePhoneNumberErrorCodeInvalidPhoneNumber UpdatePhoneNumberErrorCode = "INVALID_PHONE_NUMBER"
	// The phone number has requested too many verification codes.
	UpdatePhoneNumberErrorCodeRequestThrottled UpdatePhoneNumberErrorCode = "REQUEST_THROTTLED"
	// The phone number provided is used for too many Twitch accounts.
	UpdatePhoneNumberErrorCodeLimitReached UpdatePhoneNumberErrorCode = "LIMIT_REACHED"
	// Something unexpected occured.
	UpdatePhoneNumberErrorCodeUnknownError UpdatePhoneNumberErrorCode = "UNKNOWN_ERROR"
)

var AllUpdatePhoneNumberErrorCode = []UpdatePhoneNumberErrorCode{
	UpdatePhoneNumberErrorCodeReauthNeeded,
	UpdatePhoneNumberErrorCodeInvalidPhoneNumber,
	UpdatePhoneNumberErrorCodeRequestThrottled,
	UpdatePhoneNumberErrorCodeLimitReached,
	UpdatePhoneNumberErrorCodeUnknownError,
}

func (e UpdatePhoneNumberErrorCode) IsValid() bool {
	switch e {
	case UpdatePhoneNumberErrorCodeReauthNeeded, UpdatePhoneNumberErrorCodeInvalidPhoneNumber, UpdatePhoneNumberErrorCodeRequestThrottled, UpdatePhoneNumberErrorCodeLimitReached, UpdatePhoneNumberErrorCodeUnknownError:
		return true
	}
	return false
}

func (e UpdatePhoneNumberErrorCode) String() string {
	return string(e)
}

func (e *UpdatePhoneNumberErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdatePhoneNumberErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdatePhoneNumberErrorCode", str)
	}
	return nil
}

func (e UpdatePhoneNumberErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error types recognized.
type UpdatePrimeOfferStatusErrorCode string

const (
	// Status when the offers fail to be updated.
	UpdatePrimeOfferStatusErrorCodeOffersFailedToUpdate UpdatePrimeOfferStatusErrorCode = "OFFERS_FAILED_TO_UPDATE"
	// Unknown error being returned from service.
	UpdatePrimeOfferStatusErrorCodeUnknown UpdatePrimeOfferStatusErrorCode = "UNKNOWN"
)

var AllUpdatePrimeOfferStatusErrorCode = []UpdatePrimeOfferStatusErrorCode{
	UpdatePrimeOfferStatusErrorCodeOffersFailedToUpdate,
	UpdatePrimeOfferStatusErrorCodeUnknown,
}

func (e UpdatePrimeOfferStatusErrorCode) IsValid() bool {
	switch e {
	case UpdatePrimeOfferStatusErrorCodeOffersFailedToUpdate, UpdatePrimeOfferStatusErrorCodeUnknown:
		return true
	}
	return false
}

func (e UpdatePrimeOfferStatusErrorCode) String() string {
	return string(e)
}

func (e *UpdatePrimeOfferStatusErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdatePrimeOfferStatusErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdatePrimeOfferStatusErrorCode", str)
	}
	return nil
}

func (e UpdatePrimeOfferStatusErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpdateRoomErrorCode string

const (
	// User does not have permission to update room.
	UpdateRoomErrorCodeForbidden UpdateRoomErrorCode = "FORBIDDEN"
	// Could not find a room with the given room ID.
	UpdateRoomErrorCodeRoomNotFound UpdateRoomErrorCode = "ROOM_NOT_FOUND"
	// Name too short or too long.
	UpdateRoomErrorCodeNameLengthInvalid UpdateRoomErrorCode = "NAME_LENGTH_INVALID"
	// Name contains invalid characters (e.g. spaces).
	UpdateRoomErrorCodeNameContainsInvalidCharacters UpdateRoomErrorCode = "NAME_CONTAINS_INVALID_CHARACTERS"
	// Name failed automod check.
	UpdateRoomErrorCodeNameInappropriate UpdateRoomErrorCode = "NAME_INAPPROPRIATE"
	// Name was not unique to channel.
	UpdateRoomErrorCodeNameNotUnique UpdateRoomErrorCode = "NAME_NOT_UNIQUE"
	// Topic too short or too long.
	UpdateRoomErrorCodeTopicLengthInvalid UpdateRoomErrorCode = "TOPIC_LENGTH_INVALID"
	// Topic failed automod check.
	UpdateRoomErrorCodeTopicInappropriate UpdateRoomErrorCode = "TOPIC_INAPPROPRIATE"
	// Invalid roles specified (e.g. a more permissive role for send than read).
	UpdateRoomErrorCodeRolesInvalid UpdateRoomErrorCode = "ROLES_INVALID"
)

var AllUpdateRoomErrorCode = []UpdateRoomErrorCode{
	UpdateRoomErrorCodeForbidden,
	UpdateRoomErrorCodeRoomNotFound,
	UpdateRoomErrorCodeNameLengthInvalid,
	UpdateRoomErrorCodeNameContainsInvalidCharacters,
	UpdateRoomErrorCodeNameInappropriate,
	UpdateRoomErrorCodeNameNotUnique,
	UpdateRoomErrorCodeTopicLengthInvalid,
	UpdateRoomErrorCodeTopicInappropriate,
	UpdateRoomErrorCodeRolesInvalid,
}

func (e UpdateRoomErrorCode) IsValid() bool {
	switch e {
	case UpdateRoomErrorCodeForbidden, UpdateRoomErrorCodeRoomNotFound, UpdateRoomErrorCodeNameLengthInvalid, UpdateRoomErrorCodeNameContainsInvalidCharacters, UpdateRoomErrorCodeNameInappropriate, UpdateRoomErrorCodeNameNotUnique, UpdateRoomErrorCodeTopicLengthInvalid, UpdateRoomErrorCodeTopicInappropriate, UpdateRoomErrorCodeRolesInvalid:
		return true
	}
	return false
}

func (e UpdateRoomErrorCode) String() string {
	return string(e)
}

func (e *UpdateRoomErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateRoomErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateRoomErrorCode", str)
	}
	return nil
}

func (e UpdateRoomErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpdateRoomModesErrorCode string

const (
	// RoomID referred to an invalid or the user does not have permissions to see the room.
	UpdateRoomModesErrorCodeRoomNotFound UpdateRoomModesErrorCode = "ROOM_NOT_FOUND"
	// User did not have permission to update room modes.
	UpdateRoomModesErrorCodeForbidden UpdateRoomModesErrorCode = "FORBIDDEN"
	// Slow mode duration was too short, too long, or not a number.
	UpdateRoomModesErrorCodeSlowModeDurationInvalid UpdateRoomModesErrorCode = "SLOW_MODE_DURATION_INVALID"
)

var AllUpdateRoomModesErrorCode = []UpdateRoomModesErrorCode{
	UpdateRoomModesErrorCodeRoomNotFound,
	UpdateRoomModesErrorCodeForbidden,
	UpdateRoomModesErrorCodeSlowModeDurationInvalid,
}

func (e UpdateRoomModesErrorCode) IsValid() bool {
	switch e {
	case UpdateRoomModesErrorCodeRoomNotFound, UpdateRoomModesErrorCodeForbidden, UpdateRoomModesErrorCodeSlowModeDurationInvalid:
		return true
	}
	return false
}

func (e UpdateRoomModesErrorCode) String() string {
	return string(e)
}

func (e *UpdateRoomModesErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateRoomModesErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateRoomModesErrorCode", str)
	}
	return nil
}

func (e UpdateRoomModesErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible error returned.
type UpdateScheduleSegmentErrorCode string

const (
	// Not authorized to update this segment.
	UpdateScheduleSegmentErrorCodePermissionDenied UpdateScheduleSegmentErrorCode = "PERMISSION_DENIED"
	// The number of categories is invalid. Refer to the error for min and max acceptable values.
	UpdateScheduleSegmentErrorCodeInvalidCategoryCount UpdateScheduleSegmentErrorCode = "INVALID_CATEGORY_COUNT"
	// The specified segment could not be found.
	UpdateScheduleSegmentErrorCodeNotFound UpdateScheduleSegmentErrorCode = "NOT_FOUND"
	// No update was made because no updated attributes were provided.
	UpdateScheduleSegmentErrorCodeNoUpdatedAttributesProvided UpdateScheduleSegmentErrorCode = "NO_UPDATED_ATTRIBUTES_PROVIDED"
	// No update was made because the update would cause a segment overlap.
	UpdateScheduleSegmentErrorCodeOverlappingSegments UpdateScheduleSegmentErrorCode = "OVERLAPPING_SEGMENTS"
	// The title length is invalid. Refer to the error for min and max acceptable values.
	UpdateScheduleSegmentErrorCodeInvalidTitle UpdateScheduleSegmentErrorCode = "INVALID_TITLE"
	// The title failed the moderation check.
	UpdateScheduleSegmentErrorCodeTitleFailedModeration UpdateScheduleSegmentErrorCode = "TITLE_FAILED_MODERATION"
	// The timezone is not valid.
	UpdateScheduleSegmentErrorCodeInvalidTimezone UpdateScheduleSegmentErrorCode = "INVALID_TIMEZONE"
	// The categories are not valid.
	UpdateScheduleSegmentErrorCodeInvalidCategories UpdateScheduleSegmentErrorCode = "INVALID_CATEGORIES"
	// The segment start day is invalid.
	UpdateScheduleSegmentErrorCodeInvalidStartDay UpdateScheduleSegmentErrorCode = "INVALID_START_DAY"
	// The segment start hour is invalid.
	UpdateScheduleSegmentErrorCodeInvalidStartHour UpdateScheduleSegmentErrorCode = "INVALID_START_HOUR"
	// The segment start minute is invalid.
	UpdateScheduleSegmentErrorCodeInvalidStartMinute UpdateScheduleSegmentErrorCode = "INVALID_START_MINUTE"
	// The duration is invalid. Refer to the error for min and max acceptable values.
	UpdateScheduleSegmentErrorCodeInvalidDuration UpdateScheduleSegmentErrorCode = "INVALID_DURATION"
	// The segment is invalid.
	UpdateScheduleSegmentErrorCodeInvalidSegment UpdateScheduleSegmentErrorCode = "INVALID_SEGMENT"
	// The input is not valid.
	UpdateScheduleSegmentErrorCodeInvalidArgument UpdateScheduleSegmentErrorCode = "INVALID_ARGUMENT"
)

var AllUpdateScheduleSegmentErrorCode = []UpdateScheduleSegmentErrorCode{
	UpdateScheduleSegmentErrorCodePermissionDenied,
	UpdateScheduleSegmentErrorCodeInvalidCategoryCount,
	UpdateScheduleSegmentErrorCodeNotFound,
	UpdateScheduleSegmentErrorCodeNoUpdatedAttributesProvided,
	UpdateScheduleSegmentErrorCodeOverlappingSegments,
	UpdateScheduleSegmentErrorCodeInvalidTitle,
	UpdateScheduleSegmentErrorCodeTitleFailedModeration,
	UpdateScheduleSegmentErrorCodeInvalidTimezone,
	UpdateScheduleSegmentErrorCodeInvalidCategories,
	UpdateScheduleSegmentErrorCodeInvalidStartDay,
	UpdateScheduleSegmentErrorCodeInvalidStartHour,
	UpdateScheduleSegmentErrorCodeInvalidStartMinute,
	UpdateScheduleSegmentErrorCodeInvalidDuration,
	UpdateScheduleSegmentErrorCodeInvalidSegment,
	UpdateScheduleSegmentErrorCodeInvalidArgument,
}

func (e UpdateScheduleSegmentErrorCode) IsValid() bool {
	switch e {
	case UpdateScheduleSegmentErrorCodePermissionDenied, UpdateScheduleSegmentErrorCodeInvalidCategoryCount, UpdateScheduleSegmentErrorCodeNotFound, UpdateScheduleSegmentErrorCodeNoUpdatedAttributesProvided, UpdateScheduleSegmentErrorCodeOverlappingSegments, UpdateScheduleSegmentErrorCodeInvalidTitle, UpdateScheduleSegmentErrorCodeTitleFailedModeration, UpdateScheduleSegmentErrorCodeInvalidTimezone, UpdateScheduleSegmentErrorCodeInvalidCategories, UpdateScheduleSegmentErrorCodeInvalidStartDay, UpdateScheduleSegmentErrorCodeInvalidStartHour, UpdateScheduleSegmentErrorCodeInvalidStartMinute, UpdateScheduleSegmentErrorCodeInvalidDuration, UpdateScheduleSegmentErrorCodeInvalidSegment, UpdateScheduleSegmentErrorCodeInvalidArgument:
		return true
	}
	return false
}

func (e UpdateScheduleSegmentErrorCode) String() string {
	return string(e)
}

func (e *UpdateScheduleSegmentErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateScheduleSegmentErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateScheduleSegmentErrorCode", str)
	}
	return nil
}

func (e UpdateScheduleSegmentErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// UpdateSocialMediaError is a user error while creating a social media.
type UpdateSocialMediaError string

const (
	// The title failed moderation.
	UpdateSocialMediaErrorFailedTitleModeration UpdateSocialMediaError = "FAILED_TITLE_MODERATION"
	// The provided title was too long.
	UpdateSocialMediaErrorTitleTooLong UpdateSocialMediaError = "TITLE_TOO_LONG"
	// The provided url is invalid.
	UpdateSocialMediaErrorInvalidURL UpdateSocialMediaError = "INVALID_URL"
	// The social medias does not exist.
	UpdateSocialMediaErrorNotFound UpdateSocialMediaError = "NOT_FOUND"
)

var AllUpdateSocialMediaError = []UpdateSocialMediaError{
	UpdateSocialMediaErrorFailedTitleModeration,
	UpdateSocialMediaErrorTitleTooLong,
	UpdateSocialMediaErrorInvalidURL,
	UpdateSocialMediaErrorNotFound,
}

func (e UpdateSocialMediaError) IsValid() bool {
	switch e {
	case UpdateSocialMediaErrorFailedTitleModeration, UpdateSocialMediaErrorTitleTooLong, UpdateSocialMediaErrorInvalidURL, UpdateSocialMediaErrorNotFound:
		return true
	}
	return false
}

func (e UpdateSocialMediaError) String() string {
	return string(e)
}

func (e *UpdateSocialMediaError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateSocialMediaError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateSocialMediaError", str)
	}
	return nil
}

func (e UpdateSocialMediaError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// UpdateSquadInvitePolicyErrorCode are the possible errors that this mutation returns.
type UpdateSquadInvitePolicyErrorCode string

const (
	// The caller is not authorized to update the user's squad invite policy.
	UpdateSquadInvitePolicyErrorCodeUnauthorized UpdateSquadInvitePolicyErrorCode = "UNAUTHORIZED"
)

var AllUpdateSquadInvitePolicyErrorCode = []UpdateSquadInvitePolicyErrorCode{
	UpdateSquadInvitePolicyErrorCodeUnauthorized,
}

func (e UpdateSquadInvitePolicyErrorCode) IsValid() bool {
	switch e {
	case UpdateSquadInvitePolicyErrorCodeUnauthorized:
		return true
	}
	return false
}

func (e UpdateSquadInvitePolicyErrorCode) String() string {
	return string(e)
}

func (e *UpdateSquadInvitePolicyErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateSquadInvitePolicyErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateSquadInvitePolicyErrorCode", str)
	}
	return nil
}

func (e UpdateSquadInvitePolicyErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// UpdateSquadStreamErrorCode are the possible errors that this mutation returns.
type UpdateSquadStreamErrorCode string

const (
	// The squad is not found.
	UpdateSquadStreamErrorCodeSquadNotFound UpdateSquadStreamErrorCode = "SQUAD_NOT_FOUND"
	// The squad cannot be updated (e.g. squad is not in pending status).
	UpdateSquadStreamErrorCodeSquadCannotBeUpdated UpdateSquadStreamErrorCode = "SQUAD_CANNOT_BE_UPDATED"
	// The squad has too few members to be updated to live.
	UpdateSquadStreamErrorCodeSquadTooFewMembers UpdateSquadStreamErrorCode = "SQUAD_TOO_FEW_MEMBERS"
	// The user is not authorized to update the squad.
	UpdateSquadStreamErrorCodeUnauthorized UpdateSquadStreamErrorCode = "UNAUTHORIZED"
)

var AllUpdateSquadStreamErrorCode = []UpdateSquadStreamErrorCode{
	UpdateSquadStreamErrorCodeSquadNotFound,
	UpdateSquadStreamErrorCodeSquadCannotBeUpdated,
	UpdateSquadStreamErrorCodeSquadTooFewMembers,
	UpdateSquadStreamErrorCodeUnauthorized,
}

func (e UpdateSquadStreamErrorCode) IsValid() bool {
	switch e {
	case UpdateSquadStreamErrorCodeSquadNotFound, UpdateSquadStreamErrorCodeSquadCannotBeUpdated, UpdateSquadStreamErrorCodeSquadTooFewMembers, UpdateSquadStreamErrorCodeUnauthorized:
		return true
	}
	return false
}

func (e UpdateSquadStreamErrorCode) String() string {
	return string(e)
}

func (e *UpdateSquadStreamErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateSquadStreamErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateSquadStreamErrorCode", str)
	}
	return nil
}

func (e UpdateSquadStreamErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible types of error codes returned.
type UpdateUserColorsErrorCode string

const (
	// Hex string is invalid.
	UpdateUserColorsErrorCodeInvalidHexColor UpdateUserColorsErrorCode = "INVALID_HEX_COLOR"
)

var AllUpdateUserColorsErrorCode = []UpdateUserColorsErrorCode{
	UpdateUserColorsErrorCodeInvalidHexColor,
}

func (e UpdateUserColorsErrorCode) IsValid() bool {
	switch e {
	case UpdateUserColorsErrorCodeInvalidHexColor:
		return true
	}
	return false
}

func (e UpdateUserColorsErrorCode) String() string {
	return string(e)
}

func (e *UpdateUserColorsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateUserColorsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateUserColorsErrorCode", str)
	}
	return nil
}

func (e UpdateUserColorsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible error codes returned from updating a user.
type UpdateUserErrorCode string

const (
	// User is not authorized to update this user.
	UpdateUserErrorCodeAuthFailure UpdateUserErrorCode = "AUTH_FAILURE"
	// Too many attempts to update user.
	UpdateUserErrorCodeRequestsThrottled UpdateUserErrorCode = "REQUESTS_THROTTLED"
	// User cannot be found.
	UpdateUserErrorCodeUserNotFound UpdateUserErrorCode = "USER_NOT_FOUND"
	// Sudo token expired, prompt the user to log in again.
	UpdateUserErrorCodeReauthNeeded UpdateUserErrorCode = "REAUTH_NEEDED"
	// Display name not available.
	UpdateUserErrorCodeDisplayNameNotAvailable UpdateUserErrorCode = "DISPLAY_NAME_NOT_AVAILABLE"
	// Display name is too short.
	UpdateUserErrorCodeDisplayNameTooShort UpdateUserErrorCode = "DISPLAY_NAME_TOO_SHORT"
	// Display name is too long.
	UpdateUserErrorCodeDisplayNameTooLong UpdateUserErrorCode = "DISPLAY_NAME_TOO_LONG"
	// Display name contains invalid characters.
	UpdateUserErrorCodeInvalidCharsInDisplayName UpdateUserErrorCode = "INVALID_CHARS_IN_DISPLAY_NAME"
	// User is not allowed to change their display name again.
	UpdateUserErrorCodeDisplayNameChangeAgain UpdateUserErrorCode = "DISPLAY_NAME_CHANGE_AGAIN"
	// User can only change the capitalization of their display name.
	UpdateUserErrorCodeDisplayNameOnlyCap UpdateUserErrorCode = "DISPLAY_NAME_ONLY_CAP"
	// Unexpected error during displayname override.
	UpdateUserErrorCodeDisplayNameUnexpectedErr UpdateUserErrorCode = "DISPLAY_NAME_UNEXPECTED_ERR"
	// The login you selected is not available.
	UpdateUserErrorCodeLoginNotAvailable UpdateUserErrorCode = "LOGIN_NOT_AVAILABLE"
	// The login you selected is not yet available for re-use.
	UpdateUserErrorCodeLoginBlocked UpdateUserErrorCode = "LOGIN_BLOCKED"
	// Login change rate limited.
	UpdateUserErrorCodeNotAllowedToChangeLogin UpdateUserErrorCode = "NOT_ALLOWED_TO_CHANGE_LOGIN"
	// The login you selected is too short.
	UpdateUserErrorCodeLoginTooShort UpdateUserErrorCode = "LOGIN_TOO_SHORT"
	// The login you selected is too long.
	UpdateUserErrorCodeLoginTooLong UpdateUserErrorCode = "LOGIN_TOO_LONG"
	// The login you selected contains invalid characters.
	UpdateUserErrorCodeInvalidCharsInLogin UpdateUserErrorCode = "INVALID_CHARS_IN_LOGIN"
	// Login contains banned words.
	UpdateUserErrorCodeLoginUseBannedWords UpdateUserErrorCode = "LOGIN_USE_BANNED_WORDS"
	// Login contains variations on banned words.
	UpdateUserErrorCodeLoginUseVariationOnBannedWords UpdateUserErrorCode = "LOGIN_USE_VARIATION_ON_BANNED_WORDS"
	// User exists but was excluded by filter criteria.
	UpdateUserErrorCodeFilteredUserRequested UpdateUserErrorCode = "FILTERED_USER_REQUESTED"
	// The IP is blocked.
	UpdateUserErrorCodeIPBlocked UpdateUserErrorCode = "IP_BLOCKED"
	// Too many users associated with the email.
	UpdateUserErrorCodeTooManyUsersForEmail UpdateUserErrorCode = "TOO_MANY_USERS_FOR_EMAIL"
	// Email disabled for reuse.
	UpdateUserErrorCodeEmailDisabledForReuse UpdateUserErrorCode = "EMAIL_DISABLED_FOR_REUSE"
	// Email address is not valid.
	UpdateUserErrorCodeInvalidEmail UpdateUserErrorCode = "INVALID_EMAIL"
	// Admins must use their work email.
	UpdateUserErrorCodeWorkEmailRequired UpdateUserErrorCode = "WORK_EMAIL_REQUIRED"
	// Email address uses an invalid domain.
	UpdateUserErrorCodeInvalidEmailDomain UpdateUserErrorCode = "INVALID_EMAIL_DOMAIN"
	// Email change cooldown.
	UpdateUserErrorCodeNotAllowedToChangeEmail UpdateUserErrorCode = "NOT_ALLOWED_TO_CHANGE_EMAIL"
	// Phone number is invalid.
	UpdateUserErrorCodePhoneNumberInvalid UpdateUserErrorCode = "PHONE_NUMBER_INVALID"
	// Phone number cannot contain letters.
	UpdateUserErrorCodePhoneNumberHasLetters UpdateUserErrorCode = "PHONE_NUMBER_HAS_LETTERS"
	// Description field is too long.
	UpdateUserErrorCodeDescriptionTooLong UpdateUserErrorCode = "DESCRIPTION_TOO_LONG"
	// No properties found for this user identifier.
	UpdateUserErrorCodeNoProperties UpdateUserErrorCode = "NO_PROPERTIES"
	// Reservation does not exist in db.
	UpdateUserErrorCodeReservationNotExits UpdateUserErrorCode = "RESERVATION_NOT_EXITS"
	// The specified locale is invalid.
	UpdateUserErrorCodeLanguageNotValid UpdateUserErrorCode = "LANGUAGE_NOT_VALID"
	// Age cannot be under 13 years.
	UpdateUserErrorCodeInvalidBirthday UpdateUserErrorCode = "INVALID_BIRTHDAY"
	// Last Login doesn't follow format "%Y-%m-%d %H:%M:%S".
	UpdateUserErrorCodeInvalidLastLogin UpdateUserErrorCode = "INVALID_LAST_LOGIN"
	// Phone number or email update cannot be combined with delete pohone number.
	UpdateUserErrorCodeInvalidParameterCombination UpdateUserErrorCode = "INVALID_PARAMETER_COMBINATION"
	// Phone number can only be removed for an account with a verifed email.
	UpdateUserErrorCodeNotAllowedToDeletePhoneNumber UpdateUserErrorCode = "NOT_ALLOWED_TO_DELETE_PHONE_NUMBER"
	// Phone number already exists.
	UpdateUserErrorCodePhoneNumberAlreadyExists UpdateUserErrorCode = "PHONE_NUMBER_ALREADY_EXISTS"
	// Hex color is not valid.
	UpdateUserErrorCodeInvalidHexColor UpdateUserErrorCode = "INVALID_HEX_COLOR"
	// Unknown error.
	UpdateUserErrorCodeUnknown UpdateUserErrorCode = "UNKNOWN"
)

var AllUpdateUserErrorCode = []UpdateUserErrorCode{
	UpdateUserErrorCodeAuthFailure,
	UpdateUserErrorCodeRequestsThrottled,
	UpdateUserErrorCodeUserNotFound,
	UpdateUserErrorCodeReauthNeeded,
	UpdateUserErrorCodeDisplayNameNotAvailable,
	UpdateUserErrorCodeDisplayNameTooShort,
	UpdateUserErrorCodeDisplayNameTooLong,
	UpdateUserErrorCodeInvalidCharsInDisplayName,
	UpdateUserErrorCodeDisplayNameChangeAgain,
	UpdateUserErrorCodeDisplayNameOnlyCap,
	UpdateUserErrorCodeDisplayNameUnexpectedErr,
	UpdateUserErrorCodeLoginNotAvailable,
	UpdateUserErrorCodeLoginBlocked,
	UpdateUserErrorCodeNotAllowedToChangeLogin,
	UpdateUserErrorCodeLoginTooShort,
	UpdateUserErrorCodeLoginTooLong,
	UpdateUserErrorCodeInvalidCharsInLogin,
	UpdateUserErrorCodeLoginUseBannedWords,
	UpdateUserErrorCodeLoginUseVariationOnBannedWords,
	UpdateUserErrorCodeFilteredUserRequested,
	UpdateUserErrorCodeIPBlocked,
	UpdateUserErrorCodeTooManyUsersForEmail,
	UpdateUserErrorCodeEmailDisabledForReuse,
	UpdateUserErrorCodeInvalidEmail,
	UpdateUserErrorCodeWorkEmailRequired,
	UpdateUserErrorCodeInvalidEmailDomain,
	UpdateUserErrorCodeNotAllowedToChangeEmail,
	UpdateUserErrorCodePhoneNumberInvalid,
	UpdateUserErrorCodePhoneNumberHasLetters,
	UpdateUserErrorCodeDescriptionTooLong,
	UpdateUserErrorCodeNoProperties,
	UpdateUserErrorCodeReservationNotExits,
	UpdateUserErrorCodeLanguageNotValid,
	UpdateUserErrorCodeInvalidBirthday,
	UpdateUserErrorCodeInvalidLastLogin,
	UpdateUserErrorCodeInvalidParameterCombination,
	UpdateUserErrorCodeNotAllowedToDeletePhoneNumber,
	UpdateUserErrorCodePhoneNumberAlreadyExists,
	UpdateUserErrorCodeInvalidHexColor,
	UpdateUserErrorCodeUnknown,
}

func (e UpdateUserErrorCode) IsValid() bool {
	switch e {
	case UpdateUserErrorCodeAuthFailure, UpdateUserErrorCodeRequestsThrottled, UpdateUserErrorCodeUserNotFound, UpdateUserErrorCodeReauthNeeded, UpdateUserErrorCodeDisplayNameNotAvailable, UpdateUserErrorCodeDisplayNameTooShort, UpdateUserErrorCodeDisplayNameTooLong, UpdateUserErrorCodeInvalidCharsInDisplayName, UpdateUserErrorCodeDisplayNameChangeAgain, UpdateUserErrorCodeDisplayNameOnlyCap, UpdateUserErrorCodeDisplayNameUnexpectedErr, UpdateUserErrorCodeLoginNotAvailable, UpdateUserErrorCodeLoginBlocked, UpdateUserErrorCodeNotAllowedToChangeLogin, UpdateUserErrorCodeLoginTooShort, UpdateUserErrorCodeLoginTooLong, UpdateUserErrorCodeInvalidCharsInLogin, UpdateUserErrorCodeLoginUseBannedWords, UpdateUserErrorCodeLoginUseVariationOnBannedWords, UpdateUserErrorCodeFilteredUserRequested, UpdateUserErrorCodeIPBlocked, UpdateUserErrorCodeTooManyUsersForEmail, UpdateUserErrorCodeEmailDisabledForReuse, UpdateUserErrorCodeInvalidEmail, UpdateUserErrorCodeWorkEmailRequired, UpdateUserErrorCodeInvalidEmailDomain, UpdateUserErrorCodeNotAllowedToChangeEmail, UpdateUserErrorCodePhoneNumberInvalid, UpdateUserErrorCodePhoneNumberHasLetters, UpdateUserErrorCodeDescriptionTooLong, UpdateUserErrorCodeNoProperties, UpdateUserErrorCodeReservationNotExits, UpdateUserErrorCodeLanguageNotValid, UpdateUserErrorCodeInvalidBirthday, UpdateUserErrorCodeInvalidLastLogin, UpdateUserErrorCodeInvalidParameterCombination, UpdateUserErrorCodeNotAllowedToDeletePhoneNumber, UpdateUserErrorCodePhoneNumberAlreadyExists, UpdateUserErrorCodeInvalidHexColor, UpdateUserErrorCodeUnknown:
		return true
	}
	return false
}

func (e UpdateUserErrorCode) String() string {
	return string(e)
}

func (e *UpdateUserErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateUserErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateUserErrorCode", str)
	}
	return nil
}

func (e UpdateUserErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes from the updateUserPredictionSettings mutation.
type UpdateUserPredictionSettingsErrorCode string

const (
	// An unknown error occurred.
	UpdateUserPredictionSettingsErrorCodeUnknown UpdateUserPredictionSettingsErrorCode = "UNKNOWN"
)

var AllUpdateUserPredictionSettingsErrorCode = []UpdateUserPredictionSettingsErrorCode{
	UpdateUserPredictionSettingsErrorCodeUnknown,
}

func (e UpdateUserPredictionSettingsErrorCode) IsValid() bool {
	switch e {
	case UpdateUserPredictionSettingsErrorCodeUnknown:
		return true
	}
	return false
}

func (e UpdateUserPredictionSettingsErrorCode) String() string {
	return string(e)
}

func (e *UpdateUserPredictionSettingsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateUserPredictionSettingsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateUserPredictionSettingsErrorCode", str)
	}
	return nil
}

func (e UpdateUserPredictionSettingsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// UpdateVideoStreamSettingsErrorCode is the client error type that occurred during the UpdateVideoStreamSettings mutation.
type UpdateVideoStreamSettingsErrorCode string

const (
	// The broadcaster is not found.
	UpdateVideoStreamSettingsErrorCodeChannelNotFound UpdateVideoStreamSettingsErrorCode = "CHANNEL_NOT_FOUND"
	// Permission denied to add an authorized user.
	UpdateVideoStreamSettingsErrorCodePermissionDenied UpdateVideoStreamSettingsErrorCode = "PERMISSION_DENIED"
	// Invalid argument to add an authorized user.
	UpdateVideoStreamSettingsErrorCodeInvalidArgument UpdateVideoStreamSettingsErrorCode = "INVALID_ARGUMENT"
)

var AllUpdateVideoStreamSettingsErrorCode = []UpdateVideoStreamSettingsErrorCode{
	UpdateVideoStreamSettingsErrorCodeChannelNotFound,
	UpdateVideoStreamSettingsErrorCodePermissionDenied,
	UpdateVideoStreamSettingsErrorCodeInvalidArgument,
}

func (e UpdateVideoStreamSettingsErrorCode) IsValid() bool {
	switch e {
	case UpdateVideoStreamSettingsErrorCodeChannelNotFound, UpdateVideoStreamSettingsErrorCodePermissionDenied, UpdateVideoStreamSettingsErrorCodeInvalidArgument:
		return true
	}
	return false
}

func (e UpdateVideoStreamSettingsErrorCode) String() string {
	return string(e)
}

func (e *UpdateVideoStreamSettingsErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateVideoStreamSettingsErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateVideoStreamSettingsErrorCode", str)
	}
	return nil
}

func (e UpdateVideoStreamSettingsErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum that specifies which role the user is taking when querying for competitions.
type UserCompetitionRelationship string

const (
	// Player in a competition.
	UserCompetitionRelationshipPlayer UserCompetitionRelationship = "PLAYER"
	// Owner of a competition.
	UserCompetitionRelationshipOwner UserCompetitionRelationship = "OWNER"
	// Unknown competition role.
	UserCompetitionRelationshipUnknown UserCompetitionRelationship = "UNKNOWN"
)

var AllUserCompetitionRelationship = []UserCompetitionRelationship{
	UserCompetitionRelationshipPlayer,
	UserCompetitionRelationshipOwner,
	UserCompetitionRelationshipUnknown,
}

func (e UserCompetitionRelationship) IsValid() bool {
	switch e {
	case UserCompetitionRelationshipPlayer, UserCompetitionRelationshipOwner, UserCompetitionRelationshipUnknown:
		return true
	}
	return false
}

func (e UserCompetitionRelationship) String() string {
	return string(e)
}

func (e *UserCompetitionRelationship) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserCompetitionRelationship(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserCompetitionRelationship", str)
	}
	return nil
}

func (e UserCompetitionRelationship) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The available types of lookups for a user query.
type UserLookupType string

const (
	// Retrieves only active users without TOS/DMCA violations.
	UserLookupTypeActive UserLookupType = "ACTIVE"
	// Includes suspended or deleted users in the results.
	UserLookupTypeAll UserLookupType = "ALL"
)

var AllUserLookupType = []UserLookupType{
	UserLookupTypeActive,
	UserLookupTypeAll,
}

func (e UserLookupType) IsValid() bool {
	switch e {
	case UserLookupTypeActive, UserLookupTypeAll:
		return true
	}
	return false
}

func (e UserLookupType) String() string {
	return string(e)
}

func (e *UserLookupType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserLookupType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserLookupType", str)
	}
	return nil
}

func (e UserLookupType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error types for verification.
type ValidateVerificationCodeErrorCode string

const (
	// Verification failed because provided code does not match.
	ValidateVerificationCodeErrorCodeIncorrectCode ValidateVerificationCodeErrorCode = "INCORRECT_CODE"
	// Validation code was incorrect and the code has been regenerated and resent due to too many failed attempts.
	ValidateVerificationCodeErrorCodeTooManyFailedAttempts ValidateVerificationCodeErrorCode = "TOO_MANY_FAILED_ATTEMPTS"
	// Verification failed due to being rate limited.
	ValidateVerificationCodeErrorCodeRateLimited ValidateVerificationCodeErrorCode = "RATE_LIMITED"
	// Verification failed due to some unknown, unclassified error.
	ValidateVerificationCodeErrorCodeUnknown ValidateVerificationCodeErrorCode = "UNKNOWN"
)

var AllValidateVerificationCodeErrorCode = []ValidateVerificationCodeErrorCode{
	ValidateVerificationCodeErrorCodeIncorrectCode,
	ValidateVerificationCodeErrorCodeTooManyFailedAttempts,
	ValidateVerificationCodeErrorCodeRateLimited,
	ValidateVerificationCodeErrorCodeUnknown,
}

func (e ValidateVerificationCodeErrorCode) IsValid() bool {
	switch e {
	case ValidateVerificationCodeErrorCodeIncorrectCode, ValidateVerificationCodeErrorCodeTooManyFailedAttempts, ValidateVerificationCodeErrorCodeRateLimited, ValidateVerificationCodeErrorCodeUnknown:
		return true
	}
	return false
}

func (e ValidateVerificationCodeErrorCode) String() string {
	return string(e)
}

func (e *ValidateVerificationCodeErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidateVerificationCodeErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidateVerificationCodeErrorCode", str)
	}
	return nil
}

func (e ValidateVerificationCodeErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// VendorName is the vendor name.
type VendorName string

const (
	// AMAZON is Amazon.
	VendorNameAmazon VendorName = "AMAZON"
	// BRANCH is Branch.
	VendorNameBranch VendorName = "BRANCH"
	// COMSCORE is ComScore.
	VendorNameComscore VendorName = "COMSCORE"
	// GOOGLE is Google.
	VendorNameGoogle VendorName = "GOOGLE"
	// NIELSEN is Nielsen.
	VendorNameNielsen VendorName = "NIELSEN"
	// SALESFORCE_DMP is Salesforce_DMP.
	VendorNameSalesforceDmp VendorName = "SALESFORCE_DMP"
)

var AllVendorName = []VendorName{
	VendorNameAmazon,
	VendorNameBranch,
	VendorNameComscore,
	VendorNameGoogle,
	VendorNameNielsen,
	VendorNameSalesforceDmp,
}

func (e VendorName) IsValid() bool {
	switch e {
	case VendorNameAmazon, VendorNameBranch, VendorNameComscore, VendorNameGoogle, VendorNameNielsen, VendorNameSalesforceDmp:
		return true
	}
	return false
}

func (e VendorName) String() string {
	return string(e)
}

func (e *VendorName) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VendorName(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VendorName", str)
	}
	return nil
}

func (e VendorName) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a given verification request.
type VerificationStatus string

const (
	// Unknown is used as a safe fallback status.
	VerificationStatusUnknown VerificationStatus = "UNKNOWN"
	// Pending indicates not yet successfully verified.
	VerificationStatusPending VerificationStatus = "PENDING"
	// Verified indicates successfully verified.
	VerificationStatusVerified VerificationStatus = "VERIFIED"
	// Rejected indicates we were unable to send a verification request to the given address, for example if we received a hard bounce from SES.
	VerificationStatusRejected VerificationStatus = "REJECTED"
)

var AllVerificationStatus = []VerificationStatus{
	VerificationStatusUnknown,
	VerificationStatusPending,
	VerificationStatusVerified,
	VerificationStatusRejected,
}

func (e VerificationStatus) IsValid() bool {
	switch e {
	case VerificationStatusUnknown, VerificationStatusPending, VerificationStatusVerified, VerificationStatusRejected:
		return true
	}
	return false
}

func (e VerificationStatus) String() string {
	return string(e)
}

func (e *VerificationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VerificationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VerificationStatus", str)
	}
	return nil
}

func (e VerificationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible error enums returned while trying to verify a one time password.
type VerifyOneTimePasswordErrorCode string

const (
	// The one time password submitted is invalid.
	VerifyOneTimePasswordErrorCodeInvalidOtp VerifyOneTimePasswordErrorCode = "INVALID_OTP"
	// The user does not have two factor enabled and cannot verify a one time password.
	VerifyOneTimePasswordErrorCodeNoTwoFactor VerifyOneTimePasswordErrorCode = "NO_TWO_FACTOR"
	// Something unexpected occured.
	VerifyOneTimePasswordErrorCodeUnknownError VerifyOneTimePasswordErrorCode = "UNKNOWN_ERROR"
)

var AllVerifyOneTimePasswordErrorCode = []VerifyOneTimePasswordErrorCode{
	VerifyOneTimePasswordErrorCodeInvalidOtp,
	VerifyOneTimePasswordErrorCodeNoTwoFactor,
	VerifyOneTimePasswordErrorCodeUnknownError,
}

func (e VerifyOneTimePasswordErrorCode) IsValid() bool {
	switch e {
	case VerifyOneTimePasswordErrorCodeInvalidOtp, VerifyOneTimePasswordErrorCodeNoTwoFactor, VerifyOneTimePasswordErrorCodeUnknownError:
		return true
	}
	return false
}

func (e VerifyOneTimePasswordErrorCode) String() string {
	return string(e)
}

func (e *VerifyOneTimePasswordErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VerifyOneTimePasswordErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VerifyOneTimePasswordErrorCode", str)
	}
	return nil
}

func (e VerifyOneTimePasswordErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error types for captcha verification.
type VerifyRewardedVideoEligibilityCaptchaErrorCode string

const (
	// The input provided by the user was rejected.
	VerifyRewardedVideoEligibilityCaptchaErrorCodeInvalidParameter VerifyRewardedVideoEligibilityCaptchaErrorCode = "INVALID_PARAMETER"
	// The service had an issue unrelated to your input.
	VerifyRewardedVideoEligibilityCaptchaErrorCodeInternalError VerifyRewardedVideoEligibilityCaptchaErrorCode = "INTERNAL_ERROR"
)

var AllVerifyRewardedVideoEligibilityCaptchaErrorCode = []VerifyRewardedVideoEligibilityCaptchaErrorCode{
	VerifyRewardedVideoEligibilityCaptchaErrorCodeInvalidParameter,
	VerifyRewardedVideoEligibilityCaptchaErrorCodeInternalError,
}

func (e VerifyRewardedVideoEligibilityCaptchaErrorCode) IsValid() bool {
	switch e {
	case VerifyRewardedVideoEligibilityCaptchaErrorCodeInvalidParameter, VerifyRewardedVideoEligibilityCaptchaErrorCodeInternalError:
		return true
	}
	return false
}

func (e VerifyRewardedVideoEligibilityCaptchaErrorCode) String() string {
	return string(e)
}

func (e *VerifyRewardedVideoEligibilityCaptchaErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VerifyRewardedVideoEligibilityCaptchaErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VerifyRewardedVideoEligibilityCaptchaErrorCode", str)
	}
	return nil
}

func (e VerifyRewardedVideoEligibilityCaptchaErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The types of vertical shelves supported.
type VerticalShelfType string

const (
	// A list of categories to be selected.
	VerticalShelfTypeCategorySelector VerticalShelfType = "CATEGORY_SELECTOR"
	// Live matches.
	VerticalShelfTypeLiveMatches VerticalShelfType = "LIVE_MATCHES"
	// Live professionals.
	VerticalShelfTypeLivePros VerticalShelfType = "LIVE_PROS"
	// Replays.
	VerticalShelfTypeReplays VerticalShelfType = "REPLAYS"
	// Collection.
	VerticalShelfTypeCollection VerticalShelfType = "COLLECTION"
)

var AllVerticalShelfType = []VerticalShelfType{
	VerticalShelfTypeCategorySelector,
	VerticalShelfTypeLiveMatches,
	VerticalShelfTypeLivePros,
	VerticalShelfTypeReplays,
	VerticalShelfTypeCollection,
}

func (e VerticalShelfType) IsValid() bool {
	switch e {
	case VerticalShelfTypeCategorySelector, VerticalShelfTypeLiveMatches, VerticalShelfTypeLivePros, VerticalShelfTypeReplays, VerticalShelfTypeCollection:
		return true
	}
	return false
}

func (e VerticalShelfType) String() string {
	return string(e)
}

func (e *VerticalShelfType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VerticalShelfType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VerticalShelfType", str)
	}
	return nil
}

func (e VerticalShelfType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// VideoBookmarkConnectionErrorCode are the possible errors that this query returns.
type VideoBookmarkConnectionErrorCode string

const (
	// An unexpected internal server error occurred.
	VideoBookmarkConnectionErrorCodeInternalServerError VideoBookmarkConnectionErrorCode = "INTERNAL_SERVER_ERROR"
	// The user is unauthorized to fetch bookmarks for the channel.
	VideoBookmarkConnectionErrorCodeUserUnauthorized VideoBookmarkConnectionErrorCode = "USER_UNAUTHORIZED"
)

var AllVideoBookmarkConnectionErrorCode = []VideoBookmarkConnectionErrorCode{
	VideoBookmarkConnectionErrorCodeInternalServerError,
	VideoBookmarkConnectionErrorCodeUserUnauthorized,
}

func (e VideoBookmarkConnectionErrorCode) IsValid() bool {
	switch e {
	case VideoBookmarkConnectionErrorCodeInternalServerError, VideoBookmarkConnectionErrorCodeUserUnauthorized:
		return true
	}
	return false
}

func (e VideoBookmarkConnectionErrorCode) String() string {
	return string(e)
}

func (e *VideoBookmarkConnectionErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoBookmarkConnectionErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoBookmarkConnectionErrorCode", str)
	}
	return nil
}

func (e VideoBookmarkConnectionErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Where a video comment originated.
type VideoCommentSource string

const (
	// The comment originated from the live broadcast.
	VideoCommentSourceChat VideoCommentSource = "CHAT"
	// The comment was manually created by a commenter.
	VideoCommentSourceComment VideoCommentSource = "COMMENT"
	// The comment source is unknown.
	VideoCommentSourceUnknown VideoCommentSource = "UNKNOWN"
)

var AllVideoCommentSource = []VideoCommentSource{
	VideoCommentSourceChat,
	VideoCommentSourceComment,
	VideoCommentSourceUnknown,
}

func (e VideoCommentSource) IsValid() bool {
	switch e {
	case VideoCommentSourceChat, VideoCommentSourceComment, VideoCommentSourceUnknown:
		return true
	}
	return false
}

func (e VideoCommentSource) String() string {
	return string(e)
}

func (e *VideoCommentSource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoCommentSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoCommentSource", str)
	}
	return nil
}

func (e VideoCommentSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the state of a video comment.
type VideoCommentState string

const (
	// The comment is published.
	VideoCommentStatePublished VideoCommentState = "PUBLISHED"
	// The comment was manually unpublished by a mod or the channel owner.
	VideoCommentStateUnpublished VideoCommentState = "UNPUBLISHED"
	// The comment was automatically flagged for review (AutoMod).
	VideoCommentStatePendingReview VideoCommentState = "PENDING_REVIEW"
	// The comment is possibly spam and has to be reviewed by a moderator.
	VideoCommentStatePendingReviewSpam VideoCommentState = "PENDING_REVIEW_SPAM"
	// The comment has been soft-deleted.
	VideoCommentStateDeleted VideoCommentState = "DELETED"
)

var AllVideoCommentState = []VideoCommentState{
	VideoCommentStatePublished,
	VideoCommentStateUnpublished,
	VideoCommentStatePendingReview,
	VideoCommentStatePendingReviewSpam,
	VideoCommentStateDeleted,
}

func (e VideoCommentState) IsValid() bool {
	switch e {
	case VideoCommentStatePublished, VideoCommentStateUnpublished, VideoCommentStatePendingReview, VideoCommentStatePendingReviewSpam, VideoCommentStateDeleted:
		return true
	}
	return false
}

func (e VideoCommentState) String() string {
	return string(e)
}

func (e *VideoCommentState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoCommentState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoCommentState", str)
	}
	return nil
}

func (e VideoCommentState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// These request types allow the client to request the backend to do
// some analysis and suggest markers that are relevant.
type VideoMomentRequestType string

const (
	// Moments most likely to be highlighted. Shown to creators.
	VideoMomentRequestTypeHighlighterSuggestions VideoMomentRequestType = "HIGHLIGHTER_SUGGESTIONS"
	// Chapter markers shown in the video to viewers.
	VideoMomentRequestTypeVideoChapterMarkers VideoMomentRequestType = "VIDEO_CHAPTER_MARKERS"
)

var AllVideoMomentRequestType = []VideoMomentRequestType{
	VideoMomentRequestTypeHighlighterSuggestions,
	VideoMomentRequestTypeVideoChapterMarkers,
}

func (e VideoMomentRequestType) IsValid() bool {
	switch e {
	case VideoMomentRequestTypeHighlighterSuggestions, VideoMomentRequestTypeVideoChapterMarkers:
		return true
	}
	return false
}

func (e VideoMomentRequestType) String() string {
	return string(e)
}

func (e *VideoMomentRequestType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoMomentRequestType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoMomentRequestType", str)
	}
	return nil
}

func (e VideoMomentRequestType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Marker types present in momentum.
type VideoMomentType string

const (
	// Creator/editor selected moment.
	VideoMomentTypeStreamMarker VideoMomentType = "STREAM_MARKER"
	// GAME_CHANGE is when the streamer changes the game during their stream.
	VideoMomentTypeGameChange VideoMomentType = "GAME_CHANGE"
	// Hearthstone video content analysis markers.
	VideoMomentTypeHearthstoneVca VideoMomentType = "HEARTHSTONE_VCA"
	// Overwatch video content analysis markers.
	VideoMomentTypeOverwatchVca VideoMomentType = "OVERWATCH_VCA"
	// PUBG video content analysis markers.
	VideoMomentTypePubgVca VideoMomentType = "PUBG_VCA"
	// VCA generic VCA analysis markers.
	VideoMomentTypeVca VideoMomentType = "VCA"
)

var AllVideoMomentType = []VideoMomentType{
	VideoMomentTypeStreamMarker,
	VideoMomentTypeGameChange,
	VideoMomentTypeHearthstoneVca,
	VideoMomentTypeOverwatchVca,
	VideoMomentTypePubgVca,
	VideoMomentTypeVca,
}

func (e VideoMomentType) IsValid() bool {
	switch e {
	case VideoMomentTypeStreamMarker, VideoMomentTypeGameChange, VideoMomentTypeHearthstoneVca, VideoMomentTypeOverwatchVca, VideoMomentTypePubgVca, VideoMomentTypeVca:
		return true
	}
	return false
}

func (e VideoMomentType) String() string {
	return string(e)
}

func (e *VideoMomentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoMomentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoMomentType", str)
	}
	return nil
}

func (e VideoMomentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VideoPrivacyScope string

const (
	// The video is only viewable by the owner.
	VideoPrivacyScopePrivate VideoPrivacyScope = "PRIVATE"
	// The video is listed in search and anyone can view the video.
	VideoPrivacyScopePublic VideoPrivacyScope = "PUBLIC"
)

var AllVideoPrivacyScope = []VideoPrivacyScope{
	VideoPrivacyScopePrivate,
	VideoPrivacyScopePublic,
}

func (e VideoPrivacyScope) IsValid() bool {
	switch e {
	case VideoPrivacyScopePrivate, VideoPrivacyScopePublic:
		return true
	}
	return false
}

func (e VideoPrivacyScope) String() string {
	return string(e)
}

func (e *VideoPrivacyScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoPrivacyScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoPrivacyScope", str)
	}
	return nil
}

func (e VideoPrivacyScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of item returned in the video shelf.
type VideoShelfType string

const (
	// Broadcasts sorted by recency.
	VideoShelfTypeLatestBroadcasts VideoShelfType = "LATEST_BROADCASTS"
	// Non broadcasts sorted by recency.
	VideoShelfTypeLatestNonBroadcasts VideoShelfType = "LATEST_NON_BROADCASTS"
	// Clips created within 30 days sorted by views.
	VideoShelfTypeTopClips VideoShelfType = "TOP_CLIPS"
	// Videos under 30 minutes sorted by recency.
	VideoShelfTypeShortVideos VideoShelfType = "SHORT_VIDEOS"
	// Videos over 30 minutes sorted by recency.
	VideoShelfTypeLongVideos VideoShelfType = "LONG_VIDEOS"
	// Videos marked with a specified game sorted by recency.
	VideoShelfTypeGame VideoShelfType = "GAME"
	// Videos from a specified collection.
	VideoShelfTypeCollection VideoShelfType = "COLLECTION"
	// All videos.
	VideoShelfTypeAllVideos VideoShelfType = "ALL_VIDEOS"
)

var AllVideoShelfType = []VideoShelfType{
	VideoShelfTypeLatestBroadcasts,
	VideoShelfTypeLatestNonBroadcasts,
	VideoShelfTypeTopClips,
	VideoShelfTypeShortVideos,
	VideoShelfTypeLongVideos,
	VideoShelfTypeGame,
	VideoShelfTypeCollection,
	VideoShelfTypeAllVideos,
}

func (e VideoShelfType) IsValid() bool {
	switch e {
	case VideoShelfTypeLatestBroadcasts, VideoShelfTypeLatestNonBroadcasts, VideoShelfTypeTopClips, VideoShelfTypeShortVideos, VideoShelfTypeLongVideos, VideoShelfTypeGame, VideoShelfTypeCollection, VideoShelfTypeAllVideos:
		return true
	}
	return false
}

func (e VideoShelfType) String() string {
	return string(e)
}

func (e *VideoShelfType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoShelfType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoShelfType", str)
	}
	return nil
}

func (e VideoShelfType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible sort orders for lists of videos.
type VideoSort string

const (
	// Sort the videos descending by time (publishedAt if available or createdAt).
	VideoSortTime VideoSort = "TIME"
	// Sort the videos descending by views.
	VideoSortViews VideoSort = "VIEWS"
)

var AllVideoSort = []VideoSort{
	VideoSortTime,
	VideoSortViews,
}

func (e VideoSort) IsValid() bool {
	switch e {
	case VideoSortTime, VideoSortViews:
		return true
	}
	return false
}

func (e VideoSort) String() string {
	return string(e)
}

func (e *VideoSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoSort", str)
	}
	return nil
}

func (e VideoSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VideoStatus string

const (
	// The video is being recorded from a live broadcast.
	VideoStatusRecording VideoStatus = "RECORDING"
	// The video needs to be processed.
	VideoStatusUnprocessed VideoStatus = "UNPROCESSED"
	// The upload job is ready to begin.
	VideoStatusCreated VideoStatus = "CREATED"
	// The video is being uploaded.
	VideoStatusUploading VideoStatus = "UPLOADING"
	// The video is being transcoded.
	VideoStatusPendingTranscode VideoStatus = "PENDING_TRANSCODE"
	// Something went wrong.
	VideoStatusFailed VideoStatus = "FAILED"
	// The video is ready to watch.
	VideoStatusRecorded VideoStatus = "RECORDED"
)

var AllVideoStatus = []VideoStatus{
	VideoStatusRecording,
	VideoStatusUnprocessed,
	VideoStatusCreated,
	VideoStatusUploading,
	VideoStatusPendingTranscode,
	VideoStatusFailed,
	VideoStatusRecorded,
}

func (e VideoStatus) IsValid() bool {
	switch e {
	case VideoStatusRecording, VideoStatusUnprocessed, VideoStatusCreated, VideoStatusUploading, VideoStatusPendingTranscode, VideoStatusFailed, VideoStatusRecorded:
		return true
	}
	return false
}

func (e VideoStatus) String() string {
	return string(e)
}

func (e *VideoStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoStatus", str)
	}
	return nil
}

func (e VideoStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes what type of content this originated from.
// NOTE: There is already an enum named BroadcastType which should have been named VideoBroadcastType.
type VideoType string

const (
	// The video type is live.
	VideoTypeLive VideoType = "LIVE"
	// The video is a vod.
	VideoTypeVod VideoType = "VOD"
)

var AllVideoType = []VideoType{
	VideoTypeLive,
	VideoTypeVod,
}

func (e VideoType) IsValid() bool {
	switch e {
	case VideoTypeLive, VideoTypeVod:
		return true
	}
	return false
}

func (e VideoType) String() string {
	return string(e)
}

func (e *VideoType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoType", str)
	}
	return nil
}

func (e VideoType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The user's shared availability while online.
// A value of ONLINE (typically called invisibility) additionally means that the user's activity will not be shared
// regardless of the isSharingActivity setting.
// NOTE: Should have been named UserOnlineVisibility.
type Visibility string

const (
	VisibilityOnline  Visibility = "ONLINE"
	VisibilityAway    Visibility = "AWAY"
	VisibilityBusy    Visibility = "BUSY"
	VisibilityOffline Visibility = "OFFLINE"
)

var AllVisibility = []Visibility{
	VisibilityOnline,
	VisibilityAway,
	VisibilityBusy,
	VisibilityOffline,
}

func (e Visibility) IsValid() bool {
	switch e {
	case VisibilityOnline, VisibilityAway, VisibilityBusy, VisibilityOffline:
		return true
	}
	return false
}

func (e Visibility) String() string {
	return string(e)
}

func (e *Visibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Visibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Visibility", str)
	}
	return nil
}

func (e Visibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A visibility type for the user.
type VisibilityInput string

const (
	// An ONLINE visibility (default) will cause the user's availability to be inherited from their sessions -- Online if
	// they have at least one non-idle session, Away if they have only idle sessions, or Offline if they have no sessions.
	VisibilityInputOnline VisibilityInput = "ONLINE"
	// An AWAY visibility will cause the user to appear as Away if they have any sessions, regardless of idleness, or
	// Offline if they have no sessions.
	VisibilityInputAway VisibilityInput = "AWAY"
	// A BUSY visibility will cause the user to appear as Busy if they have any sessions, regardless of idleness, or
	// Offline if they have no sessions.
	VisibilityInputBusy VisibilityInput = "BUSY"
	// An OFFLINE visibility (also called "invisible") will cause the user to appear as Offline always. It will also
	// implicitly turn off activity sharing.
	VisibilityInputOffline VisibilityInput = "OFFLINE"
)

var AllVisibilityInput = []VisibilityInput{
	VisibilityInputOnline,
	VisibilityInputAway,
	VisibilityInputBusy,
	VisibilityInputOffline,
}

func (e VisibilityInput) IsValid() bool {
	switch e {
	case VisibilityInputOnline, VisibilityInputAway, VisibilityInputBusy, VisibilityInputOffline:
		return true
	}
	return false
}

func (e VisibilityInput) String() string {
	return string(e)
}

func (e *VisibilityInput) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VisibilityInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VisibilityInput", str)
	}
	return nil
}

func (e VisibilityInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Vote in poll error code.
type VoteInAdPollErrorCode string

const (
	// User tried to vote in a poll that doesn't exist i.e. there is no poll running at all).
	VoteInAdPollErrorCodePollNotFound VoteInAdPollErrorCode = "POLL_NOT_FOUND"
	// User tried to vote in a poll that is not active.
	VoteInAdPollErrorCodePollNotActive VoteInAdPollErrorCode = "POLL_NOT_ACTIVE"
	// Request has a vote ID that is in progress or has already been submitted.
	VoteInAdPollErrorCodeVoteIDConflict VoteInAdPollErrorCode = "VOTE_ID_CONFLICT"
	// Voter is trying to vote more times than the maximum number of times that the poll allows.
	VoteInAdPollErrorCodeMaxVoteLimitError VoteInAdPollErrorCode = "MAX_VOTE_LIMIT_ERROR"
	// User is trying to vote for another choice in a poll that only allows one choice.
	VoteInAdPollErrorCodeMultiChoiceVoteForbidden VoteInAdPollErrorCode = "MULTI_CHOICE_VOTE_FORBIDDEN"
	// Request is for a choice ID that invalid.
	VoteInAdPollErrorCodeInvalidChoiceID VoteInAdPollErrorCode = "INVALID_CHOICE_ID"
	// An unknown error occurred.
	VoteInAdPollErrorCodeUnknown VoteInAdPollErrorCode = "UNKNOWN"
)

var AllVoteInAdPollErrorCode = []VoteInAdPollErrorCode{
	VoteInAdPollErrorCodePollNotFound,
	VoteInAdPollErrorCodePollNotActive,
	VoteInAdPollErrorCodeVoteIDConflict,
	VoteInAdPollErrorCodeMaxVoteLimitError,
	VoteInAdPollErrorCodeMultiChoiceVoteForbidden,
	VoteInAdPollErrorCodeInvalidChoiceID,
	VoteInAdPollErrorCodeUnknown,
}

func (e VoteInAdPollErrorCode) IsValid() bool {
	switch e {
	case VoteInAdPollErrorCodePollNotFound, VoteInAdPollErrorCodePollNotActive, VoteInAdPollErrorCodeVoteIDConflict, VoteInAdPollErrorCodeMaxVoteLimitError, VoteInAdPollErrorCodeMultiChoiceVoteForbidden, VoteInAdPollErrorCodeInvalidChoiceID, VoteInAdPollErrorCodeUnknown:
		return true
	}
	return false
}

func (e VoteInAdPollErrorCode) String() string {
	return string(e)
}

func (e *VoteInAdPollErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteInAdPollErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteInAdPollErrorCode", str)
	}
	return nil
}

func (e VoteInAdPollErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Vote in poll error code.
type VoteInPollErrorCode string

const (
	// User tried to vote in a poll that doesn't exist i.e. there is no poll running at all).
	VoteInPollErrorCodePollNotFound VoteInPollErrorCode = "POLL_NOT_FOUND"
	// User tried to vote in a poll that is not active.
	VoteInPollErrorCodePollNotActive VoteInPollErrorCode = "POLL_NOT_ACTIVE"
	// Request has a vote ID that is in progress or has already been submitted.
	VoteInPollErrorCodeVoteIDConflict VoteInPollErrorCode = "VOTE_ID_CONFLICT"
	// User is trying to vote for another choice in a poll that only allows one choice.
	VoteInPollErrorCodeMultiChoiceVoteForbidden VoteInPollErrorCode = "MULTI_CHOICE_VOTE_FORBIDDEN"
	// Request is for a channel ID that is invalid (e.g. banned channel, channel doesn't exist).
	VoteInPollErrorCodeInvalidChannelID VoteInPollErrorCode = "INVALID_CHANNEL_ID"
	// Request is for a choice index that is invalid (e.g. there are 3 choices and the request is for index 10).
	VoteInPollErrorCodeInvalidChoiceIndex VoteInPollErrorCode = "INVALID_CHOICE_INDEX"
	// Request is for a choice ID that invalid.
	VoteInPollErrorCodeInvalidChoiceID VoteInPollErrorCode = "INVALID_CHOICE_ID"
	// Request is for an invalid bits amount (e.g. -100 bits, or request is not for a multiple of the Bits cost).
	VoteInPollErrorCodeInvalidBitsAmount VoteInPollErrorCode = "INVALID_BITS_AMOUNT"
	// Request is for an invalid Community Points amount (e.g. -100 Points, or request is not for a multiple of the Points cost).
	VoteInPollErrorCodeInvalidCommunityPointsAmount VoteInPollErrorCode = "INVALID_COMMUNITY_POINTS_AMOUNT"
	// User's bits balance is too low to perform request (e.g. they only have 10 bits and they request to spend 100).
	VoteInPollErrorCodeInsufficientBitsBalance VoteInPollErrorCode = "INSUFFICIENT_BITS_BALANCE"
	// Users's Community Points balance is too low to perform request (e.g. they only have 10 points and they request to spend 100).
	VoteInPollErrorCodeInsufficientCommunityPointsBalance VoteInPollErrorCode = "INSUFFICIENT_COMMUNITY_POINTS_BALANCE"
	// User has already used their base votes, so in order to continue voting, they must use tokens (bits or channel points).
	VoteInPollErrorCodeTokensRequired VoteInPollErrorCode = "TOKENS_REQUIRED"
	// User is not allowed to vote in poll (e.g. they're banned in the channel).
	VoteInPollErrorCodeUserForbidden VoteInPollErrorCode = "USER_FORBIDDEN"
	// User is not allowed to vote in their own poll with bits.
	VoteInPollErrorCodeSelfBitsVoteNotAllowed VoteInPollErrorCode = "SELF_BITS_VOTE_NOT_ALLOWED"
	// User cannot vote because they have hit a per-user or per-poll rate limit. The user can try again later.
	VoteInPollErrorCodeRateLimited VoteInPollErrorCode = "RATE_LIMITED"
	// An unknown error occurred.
	VoteInPollErrorCodeUnknown VoteInPollErrorCode = "UNKNOWN"
)

var AllVoteInPollErrorCode = []VoteInPollErrorCode{
	VoteInPollErrorCodePollNotFound,
	VoteInPollErrorCodePollNotActive,
	VoteInPollErrorCodeVoteIDConflict,
	VoteInPollErrorCodeMultiChoiceVoteForbidden,
	VoteInPollErrorCodeInvalidChannelID,
	VoteInPollErrorCodeInvalidChoiceIndex,
	VoteInPollErrorCodeInvalidChoiceID,
	VoteInPollErrorCodeInvalidBitsAmount,
	VoteInPollErrorCodeInvalidCommunityPointsAmount,
	VoteInPollErrorCodeInsufficientBitsBalance,
	VoteInPollErrorCodeInsufficientCommunityPointsBalance,
	VoteInPollErrorCodeTokensRequired,
	VoteInPollErrorCodeUserForbidden,
	VoteInPollErrorCodeSelfBitsVoteNotAllowed,
	VoteInPollErrorCodeRateLimited,
	VoteInPollErrorCodeUnknown,
}

func (e VoteInPollErrorCode) IsValid() bool {
	switch e {
	case VoteInPollErrorCodePollNotFound, VoteInPollErrorCodePollNotActive, VoteInPollErrorCodeVoteIDConflict, VoteInPollErrorCodeMultiChoiceVoteForbidden, VoteInPollErrorCodeInvalidChannelID, VoteInPollErrorCodeInvalidChoiceIndex, VoteInPollErrorCodeInvalidChoiceID, VoteInPollErrorCodeInvalidBitsAmount, VoteInPollErrorCodeInvalidCommunityPointsAmount, VoteInPollErrorCodeInsufficientBitsBalance, VoteInPollErrorCodeInsufficientCommunityPointsBalance, VoteInPollErrorCodeTokensRequired, VoteInPollErrorCodeUserForbidden, VoteInPollErrorCodeSelfBitsVoteNotAllowed, VoteInPollErrorCodeRateLimited, VoteInPollErrorCodeUnknown:
		return true
	}
	return false
}

func (e VoteInPollErrorCode) String() string {
	return string(e)
}

func (e *VoteInPollErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteInPollErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteInPollErrorCode", str)
	}
	return nil
}

func (e VoteInPollErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// User's can have different wallet types based on legal and accounting
// requirements.
type WalletType string

const (
	// Only supports loading from FIAT currencies from gift card providers.
	WalletTypeGiftCard WalletType = "GIFT_CARD"
)

var AllWalletType = []WalletType{
	WalletTypeGiftCard,
}

func (e WalletType) IsValid() bool {
	switch e {
	case WalletTypeGiftCard:
		return true
	}
	return false
}

func (e WalletType) String() string {
	return string(e)
}

func (e *WalletType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WalletType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WalletType", str)
	}
	return nil
}

func (e WalletType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible restrictions for a user trying to host Watch Parties.
type WatchPartiesRestriction string

const (
	// A user cannot host Watch Parties in their current region.
	WatchPartiesRestrictionRegionNotSupported WatchPartiesRestriction = "REGION_NOT_SUPPORTED"
	// Unknown restriction.
	WatchPartiesRestrictionUnknown WatchPartiesRestriction = "UNKNOWN"
)

var AllWatchPartiesRestriction = []WatchPartiesRestriction{
	WatchPartiesRestrictionRegionNotSupported,
	WatchPartiesRestrictionUnknown,
}

func (e WatchPartiesRestriction) IsValid() bool {
	switch e {
	case WatchPartiesRestrictionRegionNotSupported, WatchPartiesRestrictionUnknown:
		return true
	}
	return false
}

func (e WatchPartiesRestriction) String() string {
	return string(e)
}

func (e *WatchPartiesRestriction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WatchPartiesRestriction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WatchPartiesRestriction", str)
	}
	return nil
}

func (e WatchPartiesRestriction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Restrictions on a piece of content.
type WatchPartyContentRestriction string

const (
	// Default type.
	WatchPartyContentRestrictionUnknown WatchPartyContentRestriction = "UNKNOWN"
	// Content is viewable by majority regions.
	WatchPartyContentRestrictionBroadAvailability WatchPartyContentRestriction = "BROAD_AVAILABILITY"
	// Content is viewable in a select number of regions.
	WatchPartyContentRestrictionLimitedAvailability WatchPartyContentRestriction = "LIMITED_AVAILABILITY"
)

var AllWatchPartyContentRestriction = []WatchPartyContentRestriction{
	WatchPartyContentRestrictionUnknown,
	WatchPartyContentRestrictionBroadAvailability,
	WatchPartyContentRestrictionLimitedAvailability,
}

func (e WatchPartyContentRestriction) IsValid() bool {
	switch e {
	case WatchPartyContentRestrictionUnknown, WatchPartyContentRestrictionBroadAvailability, WatchPartyContentRestrictionLimitedAvailability:
		return true
	}
	return false
}

func (e WatchPartyContentRestriction) String() string {
	return string(e)
}

func (e *WatchPartyContentRestriction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WatchPartyContentRestriction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WatchPartyContentRestriction", str)
	}
	return nil
}

func (e WatchPartyContentRestriction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for user errors.
type WatchPartyErrorCode string

const (
	// Used for invalid requests.
	WatchPartyErrorCodeBadRequest WatchPartyErrorCode = "BAD_REQUEST"
	// Used when the access token is expired.
	WatchPartyErrorCodeForbidden WatchPartyErrorCode = "FORBIDDEN"
	// Used when the user's request is throttled.
	WatchPartyErrorCodeRequestThrottled WatchPartyErrorCode = "REQUEST_THROTTLED"
	// Used when the user is geo restricted.
	WatchPartyErrorCodeGeoRestricted WatchPartyErrorCode = "GEO_RESTRICTED"
	// Used when the error is unknown.
	WatchPartyErrorCodeUnknown WatchPartyErrorCode = "UNKNOWN"
)

var AllWatchPartyErrorCode = []WatchPartyErrorCode{
	WatchPartyErrorCodeBadRequest,
	WatchPartyErrorCodeForbidden,
	WatchPartyErrorCodeRequestThrottled,
	WatchPartyErrorCodeGeoRestricted,
	WatchPartyErrorCodeUnknown,
}

func (e WatchPartyErrorCode) IsValid() bool {
	switch e {
	case WatchPartyErrorCodeBadRequest, WatchPartyErrorCodeForbidden, WatchPartyErrorCodeRequestThrottled, WatchPartyErrorCodeGeoRestricted, WatchPartyErrorCodeUnknown:
		return true
	}
	return false
}

func (e WatchPartyErrorCode) String() string {
	return string(e)
}

func (e *WatchPartyErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WatchPartyErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WatchPartyErrorCode", str)
	}
	return nil
}

func (e WatchPartyErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Content types for Prime Video.
type WatchPartyItemType string

const (
	// Default type.
	WatchPartyItemTypeUnknown WatchPartyItemType = "UNKNOWN"
	// A leaf node episode in a series/season.
	WatchPartyItemTypeEpisode WatchPartyItemType = "EPISODE"
	// A leaf node movie.
	WatchPartyItemTypeMovie WatchPartyItemType = "MOVIE"
	// Usually a collection of episodes.
	WatchPartyItemTypeSeason WatchPartyItemType = "SEASON"
	// Usually a collection of seasons.
	WatchPartyItemTypeSeries WatchPartyItemType = "SERIES"
)

var AllWatchPartyItemType = []WatchPartyItemType{
	WatchPartyItemTypeUnknown,
	WatchPartyItemTypeEpisode,
	WatchPartyItemTypeMovie,
	WatchPartyItemTypeSeason,
	WatchPartyItemTypeSeries,
}

func (e WatchPartyItemType) IsValid() bool {
	switch e {
	case WatchPartyItemTypeUnknown, WatchPartyItemTypeEpisode, WatchPartyItemTypeMovie, WatchPartyItemTypeSeason, WatchPartyItemTypeSeries:
		return true
	}
	return false
}

func (e WatchPartyItemType) String() string {
	return string(e)
}

func (e *WatchPartyItemType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WatchPartyItemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WatchPartyItemType", str)
	}
	return nil
}

func (e WatchPartyItemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enum for state.
type WatchPartyState string

const (
	// Default value.
	WatchPartyStateUnknown WatchPartyState = "UNKNOWN"
	// Pre-play countdown.
	WatchPartyStateHypeIn WatchPartyState = "HYPE_IN"
	// In progress, video playback.
	WatchPartyStateInProgress WatchPartyState = "IN_PROGRESS"
	// Offline.
	WatchPartyStateOffline WatchPartyState = "OFFLINE"
)

var AllWatchPartyState = []WatchPartyState{
	WatchPartyStateUnknown,
	WatchPartyStateHypeIn,
	WatchPartyStateInProgress,
	WatchPartyStateOffline,
}

func (e WatchPartyState) IsValid() bool {
	switch e {
	case WatchPartyStateUnknown, WatchPartyStateHypeIn, WatchPartyStateInProgress, WatchPartyStateOffline:
		return true
	}
	return false
}

func (e WatchPartyState) String() string {
	return string(e)
}

func (e *WatchPartyState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WatchPartyState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WatchPartyState", str)
	}
	return nil
}

func (e WatchPartyState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of the permissions for one user to Whisper another.
type WhisperPermissionType string

const (
	// The sender is allowed to Whisper the recipient.
	WhisperPermissionTypePermitted WhisperPermissionType = "PERMITTED"
	// The sender is not allowed to Whisper the recipient.
	WhisperPermissionTypeNotPermitted WhisperPermissionType = "NOT_PERMITTED"
	// Any sender is able to Whisper the recipient.
	WhisperPermissionTypeNotRestricted WhisperPermissionType = "NOT_RESTRICTED"
	// The sender is temporarily allowed to Whisper the recipient.
	WhisperPermissionTypeTemporary WhisperPermissionType = "TEMPORARY"
)

var AllWhisperPermissionType = []WhisperPermissionType{
	WhisperPermissionTypePermitted,
	WhisperPermissionTypeNotPermitted,
	WhisperPermissionTypeNotRestricted,
	WhisperPermissionTypeTemporary,
}

func (e WhisperPermissionType) IsValid() bool {
	switch e {
	case WhisperPermissionTypePermitted, WhisperPermissionTypeNotPermitted, WhisperPermissionTypeNotRestricted, WhisperPermissionTypeTemporary:
		return true
	}
	return false
}

func (e WhisperPermissionType) String() string {
	return string(e)
}

func (e *WhisperPermissionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WhisperPermissionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WhisperPermissionType", str)
	}
	return nil
}

func (e WhisperPermissionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WhisperSpamLikelihood string

const (
	WhisperSpamLikelihoodLow    WhisperSpamLikelihood = "LOW"
	WhisperSpamLikelihoodMedium WhisperSpamLikelihood = "MEDIUM"
	WhisperSpamLikelihoodHigh   WhisperSpamLikelihood = "HIGH"
)

var AllWhisperSpamLikelihood = []WhisperSpamLikelihood{
	WhisperSpamLikelihoodLow,
	WhisperSpamLikelihoodMedium,
	WhisperSpamLikelihoodHigh,
}

func (e WhisperSpamLikelihood) IsValid() bool {
	switch e {
	case WhisperSpamLikelihoodLow, WhisperSpamLikelihoodMedium, WhisperSpamLikelihoodHigh:
		return true
	}
	return false
}

func (e WhisperSpamLikelihood) String() string {
	return string(e)
}

func (e *WhisperSpamLikelihood) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WhisperSpamLikelihood(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WhisperSpamLikelihood", str)
	}
	return nil
}

func (e WhisperSpamLikelihood) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
